/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 12);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.2.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( ">tbody", elem )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with computed style
	var valueIsBorderBox,
		styles = getStyles( elem ),
		val = curCSS( elem, name, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test( val ) ) {
		return val;
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = isBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ name ] );

	// Fall back to offsetWidth/Height when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	if ( val === "auto" ) {
		val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var doc, docElem, rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		doc = elem.ownerDocument;
		docElem = doc.documentElement;
		win = doc.defaultView;

		return {
			top: rect.top + win.pageYOffset - docElem.clientTop,
			left: rect.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( jQuery.isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
		return jQuery;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Materialize v0.98.2 (http://materializecss.com)
 * Copyright 2014-2015 Materialize
 * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)
 */
// Check for jQuery.
if (typeof jQuery === 'undefined') {
  var jQuery;
  // Check if require is a defined function.
  if (true) {
    jQuery = $ = __webpack_require__(0);
    // Else use the dollar sign alias.
  } else {
    jQuery = $;
  }
}
; /*
  * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
  *
  * Uses the built in easing capabilities added In jQuery 1.1
  * to offer multiple easing options
  *
  * TERMS OF USE - jQuery Easing
  *
  * Open source under the BSD License.
  *
  * Copyright  2008 George McGinley Smith
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this list of
  * conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice, this list
  * of conditions and the following disclaimer in the documentation and/or other materials
  * provided with the distribution.
  *
  * Neither the name of the author nor the names of contributors may be used to endorse
  * or promote products derived from this software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */

// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing['jswing'] = jQuery.easing['swing'];

jQuery.extend(jQuery.easing, {
  def: 'easeOutQuad',
  swing: function swing(x, t, b, c, d) {
    //alert(jQuery.easing.default);
    return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
  },
  easeInQuad: function easeInQuad(x, t, b, c, d) {
    return c * (t /= d) * t + b;
  },
  easeOutQuad: function easeOutQuad(x, t, b, c, d) {
    return -c * (t /= d) * (t - 2) + b;
  },
  easeInOutQuad: function easeInOutQuad(x, t, b, c, d) {
    if ((t /= d / 2) < 1) return c / 2 * t * t + b;
    return -c / 2 * (--t * (t - 2) - 1) + b;
  },
  easeInCubic: function easeInCubic(x, t, b, c, d) {
    return c * (t /= d) * t * t + b;
  },
  easeOutCubic: function easeOutCubic(x, t, b, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  },
  easeInOutCubic: function easeInOutCubic(x, t, b, c, d) {
    if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;
    return c / 2 * ((t -= 2) * t * t + 2) + b;
  },
  easeInQuart: function easeInQuart(x, t, b, c, d) {
    return c * (t /= d) * t * t * t + b;
  },
  easeOutQuart: function easeOutQuart(x, t, b, c, d) {
    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
  },
  easeInOutQuart: function easeInOutQuart(x, t, b, c, d) {
    if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;
    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
  },
  easeInQuint: function easeInQuint(x, t, b, c, d) {
    return c * (t /= d) * t * t * t * t + b;
  },
  easeOutQuint: function easeOutQuint(x, t, b, c, d) {
    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
  },
  easeInOutQuint: function easeInOutQuint(x, t, b, c, d) {
    if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b;
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  },
  easeInSine: function easeInSine(x, t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
  },
  easeOutSine: function easeOutSine(x, t, b, c, d) {
    return c * Math.sin(t / d * (Math.PI / 2)) + b;
  },
  easeInOutSine: function easeInOutSine(x, t, b, c, d) {
    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
  },
  easeInExpo: function easeInExpo(x, t, b, c, d) {
    return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
  },
  easeOutExpo: function easeOutExpo(x, t, b, c, d) {
    return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
  },
  easeInOutExpo: function easeInOutExpo(x, t, b, c, d) {
    if (t == 0) return b;
    if (t == d) return b + c;
    if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
  },
  easeInCirc: function easeInCirc(x, t, b, c, d) {
    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
  },
  easeOutCirc: function easeOutCirc(x, t, b, c, d) {
    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
  },
  easeInOutCirc: function easeInOutCirc(x, t, b, c, d) {
    if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
  },
  easeInElastic: function easeInElastic(x, t, b, c, d) {
    var s = 1.70158;var p = 0;var a = c;
    if (t == 0) return b;if ((t /= d) == 1) return b + c;if (!p) p = d * .3;
    if (a < Math.abs(c)) {
      a = c;var s = p / 4;
    } else var s = p / (2 * Math.PI) * Math.asin(c / a);
    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
  },
  easeOutElastic: function easeOutElastic(x, t, b, c, d) {
    var s = 1.70158;var p = 0;var a = c;
    if (t == 0) return b;if ((t /= d) == 1) return b + c;if (!p) p = d * .3;
    if (a < Math.abs(c)) {
      a = c;var s = p / 4;
    } else var s = p / (2 * Math.PI) * Math.asin(c / a);
    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
  },
  easeInOutElastic: function easeInOutElastic(x, t, b, c, d) {
    var s = 1.70158;var p = 0;var a = c;
    if (t == 0) return b;if ((t /= d / 2) == 2) return b + c;if (!p) p = d * (.3 * 1.5);
    if (a < Math.abs(c)) {
      a = c;var s = p / 4;
    } else var s = p / (2 * Math.PI) * Math.asin(c / a);
    if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
  },
  easeInBack: function easeInBack(x, t, b, c, d, s) {
    if (s == undefined) s = 1.70158;
    return c * (t /= d) * t * ((s + 1) * t - s) + b;
  },
  easeOutBack: function easeOutBack(x, t, b, c, d, s) {
    if (s == undefined) s = 1.70158;
    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  },
  easeInOutBack: function easeInOutBack(x, t, b, c, d, s) {
    if (s == undefined) s = 1.70158;
    if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
    return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
  },
  easeInBounce: function easeInBounce(x, t, b, c, d) {
    return c - jQuery.easing.easeOutBounce(x, d - t, 0, c, d) + b;
  },
  easeOutBounce: function easeOutBounce(x, t, b, c, d) {
    if ((t /= d) < 1 / 2.75) {
      return c * (7.5625 * t * t) + b;
    } else if (t < 2 / 2.75) {
      return c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b;
    } else if (t < 2.5 / 2.75) {
      return c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b;
    } else {
      return c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b;
    }
  },
  easeInOutBounce: function easeInOutBounce(x, t, b, c, d) {
    if (t < d / 2) return jQuery.easing.easeInBounce(x, t * 2, 0, c, d) * .5 + b;
    return jQuery.easing.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;
  }
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright  2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */; // Custom Easing
jQuery.extend(jQuery.easing, {
  easeInOutMaterial: function easeInOutMaterial(x, t, b, c, d) {
    if ((t /= d / 2) < 1) return c / 2 * t * t + b;
    return c / 4 * ((t -= 2) * t * t + 2) + b;
  }
});; /*! VelocityJS.org (1.2.3). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */
/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */
/*! Note that this has been modified by Materialize to confirm that Velocity is not already being imported. */
jQuery.Velocity ? console.log("Velocity is already loaded. You may be needlessly importing Velocity again; note that Materialize includes Velocity.") : (!function (e) {
  function t(e) {
    var t = e.length,
        a = r.type(e);return "function" === a || r.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === a || 0 === t || "number" == typeof t && t > 0 && t - 1 in e;
  }if (!e.jQuery) {
    var r = function r(e, t) {
      return new r.fn.init(e, t);
    };r.isWindow = function (e) {
      return null != e && e == e.window;
    }, r.type = function (e) {
      return null == e ? e + "" : "object" == (typeof e === 'undefined' ? 'undefined' : _typeof(e)) || "function" == typeof e ? n[i.call(e)] || "object" : typeof e === 'undefined' ? 'undefined' : _typeof(e);
    }, r.isArray = Array.isArray || function (e) {
      return "array" === r.type(e);
    }, r.isPlainObject = function (e) {
      var t;if (!e || "object" !== r.type(e) || e.nodeType || r.isWindow(e)) return !1;try {
        if (e.constructor && !o.call(e, "constructor") && !o.call(e.constructor.prototype, "isPrototypeOf")) return !1;
      } catch (a) {
        return !1;
      }for (t in e) {}return void 0 === t || o.call(e, t);
    }, r.each = function (e, r, a) {
      var n,
          o = 0,
          i = e.length,
          s = t(e);if (a) {
        if (s) for (; i > o && (n = r.apply(e[o], a), n !== !1); o++) {} else for (o in e) {
          if (n = r.apply(e[o], a), n === !1) break;
        }
      } else if (s) for (; i > o && (n = r.call(e[o], o, e[o]), n !== !1); o++) {} else for (o in e) {
        if (n = r.call(e[o], o, e[o]), n === !1) break;
      }return e;
    }, r.data = function (e, t, n) {
      if (void 0 === n) {
        var o = e[r.expando],
            i = o && a[o];if (void 0 === t) return i;if (i && t in i) return i[t];
      } else if (void 0 !== t) {
        var o = e[r.expando] || (e[r.expando] = ++r.uuid);return a[o] = a[o] || {}, a[o][t] = n, n;
      }
    }, r.removeData = function (e, t) {
      var n = e[r.expando],
          o = n && a[n];o && r.each(t, function (e, t) {
        delete o[t];
      });
    }, r.extend = function () {
      var e,
          t,
          a,
          n,
          o,
          i,
          s = arguments[0] || {},
          l = 1,
          u = arguments.length,
          c = !1;for ("boolean" == typeof s && (c = s, s = arguments[l] || {}, l++), "object" != (typeof s === 'undefined' ? 'undefined' : _typeof(s)) && "function" !== r.type(s) && (s = {}), l === u && (s = this, l--); u > l; l++) {
        if (null != (o = arguments[l])) for (n in o) {
          e = s[n], a = o[n], s !== a && (c && a && (r.isPlainObject(a) || (t = r.isArray(a))) ? (t ? (t = !1, i = e && r.isArray(e) ? e : []) : i = e && r.isPlainObject(e) ? e : {}, s[n] = r.extend(c, i, a)) : void 0 !== a && (s[n] = a));
        }
      }return s;
    }, r.queue = function (e, a, n) {
      function o(e, r) {
        var a = r || [];return null != e && (t(Object(e)) ? !function (e, t) {
          for (var r = +t.length, a = 0, n = e.length; r > a;) {
            e[n++] = t[a++];
          }if (r !== r) for (; void 0 !== t[a];) {
            e[n++] = t[a++];
          }return e.length = n, e;
        }(a, "string" == typeof e ? [e] : e) : [].push.call(a, e)), a;
      }if (e) {
        a = (a || "fx") + "queue";var i = r.data(e, a);return n ? (!i || r.isArray(n) ? i = r.data(e, a, o(n)) : i.push(n), i) : i || [];
      }
    }, r.dequeue = function (e, t) {
      r.each(e.nodeType ? [e] : e, function (e, a) {
        t = t || "fx";var n = r.queue(a, t),
            o = n.shift();"inprogress" === o && (o = n.shift()), o && ("fx" === t && n.unshift("inprogress"), o.call(a, function () {
          r.dequeue(a, t);
        }));
      });
    }, r.fn = r.prototype = { init: function init(e) {
        if (e.nodeType) return this[0] = e, this;throw new Error("Not a DOM node.");
      }, offset: function offset() {
        var t = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : { top: 0, left: 0 };return { top: t.top + (e.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0), left: t.left + (e.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0) };
      }, position: function position() {
        function e() {
          for (var e = this.offsetParent || document; e && "html" === !e.nodeType.toLowerCase && "static" === e.style.position;) {
            e = e.offsetParent;
          }return e || document;
        }var t = this[0],
            e = e.apply(t),
            a = this.offset(),
            n = /^(?:body|html)$/i.test(e.nodeName) ? { top: 0, left: 0 } : r(e).offset();return a.top -= parseFloat(t.style.marginTop) || 0, a.left -= parseFloat(t.style.marginLeft) || 0, e.style && (n.top += parseFloat(e.style.borderTopWidth) || 0, n.left += parseFloat(e.style.borderLeftWidth) || 0), { top: a.top - n.top, left: a.left - n.left };
      } };var a = {};r.expando = "velocity" + new Date().getTime(), r.uuid = 0;for (var n = {}, o = n.hasOwnProperty, i = n.toString, s = "Boolean Number String Function Array Date RegExp Object Error".split(" "), l = 0; l < s.length; l++) {
      n["[object " + s[l] + "]"] = s[l].toLowerCase();
    }r.fn.init.prototype = r.fn, e.Velocity = { Utilities: r };
  }
}(window), function (e) {
  "object" == ( false ? 'undefined' : _typeof(module)) && "object" == _typeof(module.exports) ? module.exports = e() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : e();
}(function () {
  return function (e, t, r, a) {
    function n(e) {
      for (var t = -1, r = e ? e.length : 0, a = []; ++t < r;) {
        var n = e[t];n && a.push(n);
      }return a;
    }function o(e) {
      return m.isWrapped(e) ? e = [].slice.call(e) : m.isNode(e) && (e = [e]), e;
    }function i(e) {
      var t = f.data(e, "velocity");return null === t ? a : t;
    }function s(e) {
      return function (t) {
        return Math.round(t * e) * (1 / e);
      };
    }function l(e, r, a, n) {
      function o(e, t) {
        return 1 - 3 * t + 3 * e;
      }function i(e, t) {
        return 3 * t - 6 * e;
      }function s(e) {
        return 3 * e;
      }function l(e, t, r) {
        return ((o(t, r) * e + i(t, r)) * e + s(t)) * e;
      }function u(e, t, r) {
        return 3 * o(t, r) * e * e + 2 * i(t, r) * e + s(t);
      }function c(t, r) {
        for (var n = 0; m > n; ++n) {
          var o = u(r, e, a);if (0 === o) return r;var i = l(r, e, a) - t;r -= i / o;
        }return r;
      }function p() {
        for (var t = 0; b > t; ++t) {
          w[t] = l(t * x, e, a);
        }
      }function f(t, r, n) {
        var o,
            i,
            s = 0;do {
          i = r + (n - r) / 2, o = l(i, e, a) - t, o > 0 ? n = i : r = i;
        } while (Math.abs(o) > h && ++s < v);return i;
      }function d(t) {
        for (var r = 0, n = 1, o = b - 1; n != o && w[n] <= t; ++n) {
          r += x;
        }--n;var i = (t - w[n]) / (w[n + 1] - w[n]),
            s = r + i * x,
            l = u(s, e, a);return l >= y ? c(t, s) : 0 == l ? s : f(t, r, r + x);
      }function g() {
        V = !0, (e != r || a != n) && p();
      }var m = 4,
          y = .001,
          h = 1e-7,
          v = 10,
          b = 11,
          x = 1 / (b - 1),
          S = "Float32Array" in t;if (4 !== arguments.length) return !1;for (var P = 0; 4 > P; ++P) {
        if ("number" != typeof arguments[P] || isNaN(arguments[P]) || !isFinite(arguments[P])) return !1;
      }e = Math.min(e, 1), a = Math.min(a, 1), e = Math.max(e, 0), a = Math.max(a, 0);var w = S ? new Float32Array(b) : new Array(b),
          V = !1,
          C = function C(t) {
        return V || g(), e === r && a === n ? t : 0 === t ? 0 : 1 === t ? 1 : l(d(t), r, n);
      };C.getControlPoints = function () {
        return [{ x: e, y: r }, { x: a, y: n }];
      };var T = "generateBezier(" + [e, r, a, n] + ")";return C.toString = function () {
        return T;
      }, C;
    }function u(e, t) {
      var r = e;return m.isString(e) ? b.Easings[e] || (r = !1) : r = m.isArray(e) && 1 === e.length ? s.apply(null, e) : m.isArray(e) && 2 === e.length ? x.apply(null, e.concat([t])) : m.isArray(e) && 4 === e.length ? l.apply(null, e) : !1, r === !1 && (r = b.Easings[b.defaults.easing] ? b.defaults.easing : v), r;
    }function c(e) {
      if (e) {
        var t = new Date().getTime(),
            r = b.State.calls.length;r > 1e4 && (b.State.calls = n(b.State.calls));for (var o = 0; r > o; o++) {
          if (b.State.calls[o]) {
            var s = b.State.calls[o],
                l = s[0],
                u = s[2],
                d = s[3],
                g = !!d,
                y = null;d || (d = b.State.calls[o][3] = t - 16);for (var h = Math.min((t - d) / u.duration, 1), v = 0, x = l.length; x > v; v++) {
              var P = l[v],
                  V = P.element;if (i(V)) {
                var C = !1;if (u.display !== a && null !== u.display && "none" !== u.display) {
                  if ("flex" === u.display) {
                    var T = ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex"];f.each(T, function (e, t) {
                      S.setPropertyValue(V, "display", t);
                    });
                  }S.setPropertyValue(V, "display", u.display);
                }u.visibility !== a && "hidden" !== u.visibility && S.setPropertyValue(V, "visibility", u.visibility);for (var k in P) {
                  if ("element" !== k) {
                    var A,
                        F = P[k],
                        j = m.isString(F.easing) ? b.Easings[F.easing] : F.easing;if (1 === h) A = F.endValue;else {
                      var E = F.endValue - F.startValue;if (A = F.startValue + E * j(h, u, E), !g && A === F.currentValue) continue;
                    }if (F.currentValue = A, "tween" === k) y = A;else {
                      if (S.Hooks.registered[k]) {
                        var H = S.Hooks.getRoot(k),
                            N = i(V).rootPropertyValueCache[H];N && (F.rootPropertyValue = N);
                      }var L = S.setPropertyValue(V, k, F.currentValue + (0 === parseFloat(A) ? "" : F.unitType), F.rootPropertyValue, F.scrollData);S.Hooks.registered[k] && (i(V).rootPropertyValueCache[H] = S.Normalizations.registered[H] ? S.Normalizations.registered[H]("extract", null, L[1]) : L[1]), "transform" === L[0] && (C = !0);
                    }
                  }
                }u.mobileHA && i(V).transformCache.translate3d === a && (i(V).transformCache.translate3d = "(0px, 0px, 0px)", C = !0), C && S.flushTransformCache(V);
              }
            }u.display !== a && "none" !== u.display && (b.State.calls[o][2].display = !1), u.visibility !== a && "hidden" !== u.visibility && (b.State.calls[o][2].visibility = !1), u.progress && u.progress.call(s[1], s[1], h, Math.max(0, d + u.duration - t), d, y), 1 === h && p(o);
          }
        }
      }b.State.isTicking && w(c);
    }function p(e, t) {
      if (!b.State.calls[e]) return !1;for (var r = b.State.calls[e][0], n = b.State.calls[e][1], o = b.State.calls[e][2], s = b.State.calls[e][4], l = !1, u = 0, c = r.length; c > u; u++) {
        var p = r[u].element;if (t || o.loop || ("none" === o.display && S.setPropertyValue(p, "display", o.display), "hidden" === o.visibility && S.setPropertyValue(p, "visibility", o.visibility)), o.loop !== !0 && (f.queue(p)[1] === a || !/\.velocityQueueEntryFlag/i.test(f.queue(p)[1])) && i(p)) {
          i(p).isAnimating = !1, i(p).rootPropertyValueCache = {};var d = !1;f.each(S.Lists.transforms3D, function (e, t) {
            var r = /^scale/.test(t) ? 1 : 0,
                n = i(p).transformCache[t];i(p).transformCache[t] !== a && new RegExp("^\\(" + r + "[^.]").test(n) && (d = !0, delete i(p).transformCache[t]);
          }), o.mobileHA && (d = !0, delete i(p).transformCache.translate3d), d && S.flushTransformCache(p), S.Values.removeClass(p, "velocity-animating");
        }if (!t && o.complete && !o.loop && u === c - 1) try {
          o.complete.call(n, n);
        } catch (g) {
          setTimeout(function () {
            throw g;
          }, 1);
        }s && o.loop !== !0 && s(n), i(p) && o.loop === !0 && !t && (f.each(i(p).tweensContainer, function (e, t) {
          /^rotate/.test(e) && 360 === parseFloat(t.endValue) && (t.endValue = 0, t.startValue = 360), /^backgroundPosition/.test(e) && 100 === parseFloat(t.endValue) && "%" === t.unitType && (t.endValue = 0, t.startValue = 100);
        }), b(p, "reverse", { loop: !0, delay: o.delay })), o.queue !== !1 && f.dequeue(p, o.queue);
      }b.State.calls[e] = !1;for (var m = 0, y = b.State.calls.length; y > m; m++) {
        if (b.State.calls[m] !== !1) {
          l = !0;break;
        }
      }l === !1 && (b.State.isTicking = !1, delete b.State.calls, b.State.calls = []);
    }var f,
        d = function () {
      if (r.documentMode) return r.documentMode;for (var e = 7; e > 4; e--) {
        var t = r.createElement("div");if (t.innerHTML = "<!--[if IE " + e + "]><span></span><![endif]-->", t.getElementsByTagName("span").length) return t = null, e;
      }return a;
    }(),
        g = function () {
      var e = 0;return t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || function (t) {
        var r,
            a = new Date().getTime();return r = Math.max(0, 16 - (a - e)), e = a + r, setTimeout(function () {
          t(a + r);
        }, r);
      };
    }(),
        m = { isString: function isString(e) {
        return "string" == typeof e;
      }, isArray: Array.isArray || function (e) {
        return "[object Array]" === Object.prototype.toString.call(e);
      }, isFunction: function isFunction(e) {
        return "[object Function]" === Object.prototype.toString.call(e);
      }, isNode: function isNode(e) {
        return e && e.nodeType;
      }, isNodeList: function isNodeList(e) {
        return "object" == (typeof e === 'undefined' ? 'undefined' : _typeof(e)) && /^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(e)) && e.length !== a && (0 === e.length || "object" == _typeof(e[0]) && e[0].nodeType > 0);
      }, isWrapped: function isWrapped(e) {
        return e && (e.jquery || t.Zepto && t.Zepto.zepto.isZ(e));
      }, isSVG: function isSVG(e) {
        return t.SVGElement && e instanceof t.SVGElement;
      }, isEmptyObject: function isEmptyObject(e) {
        for (var t in e) {
          return !1;
        }return !0;
      } },
        y = !1;if (e.fn && e.fn.jquery ? (f = e, y = !0) : f = t.Velocity.Utilities, 8 >= d && !y) throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");if (7 >= d) return void (jQuery.fn.velocity = jQuery.fn.animate);var h = 400,
        v = "swing",
        b = { State: { isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent), isAndroid: /Android/i.test(navigator.userAgent), isGingerbread: /Android 2\.3\.[3-7]/i.test(navigator.userAgent), isChrome: t.chrome, isFirefox: /Firefox/i.test(navigator.userAgent), prefixElement: r.createElement("div"), prefixMatches: {}, scrollAnchor: null, scrollPropertyLeft: null, scrollPropertyTop: null, isTicking: !1, calls: [] }, CSS: {}, Utilities: f, Redirects: {}, Easings: {}, Promise: t.Promise, defaults: { queue: "", duration: h, easing: v, begin: a, complete: a, progress: a, display: a, visibility: a, loop: !1, delay: !1, mobileHA: !0, _cacheValues: !0 }, init: function init(e) {
        f.data(e, "velocity", { isSVG: m.isSVG(e), isAnimating: !1, computedStyle: null, tweensContainer: null, rootPropertyValueCache: {}, transformCache: {} });
      }, hook: null, mock: !1, version: { major: 1, minor: 2, patch: 2 }, debug: !1 };t.pageYOffset !== a ? (b.State.scrollAnchor = t, b.State.scrollPropertyLeft = "pageXOffset", b.State.scrollPropertyTop = "pageYOffset") : (b.State.scrollAnchor = r.documentElement || r.body.parentNode || r.body, b.State.scrollPropertyLeft = "scrollLeft", b.State.scrollPropertyTop = "scrollTop");var x = function () {
      function e(e) {
        return -e.tension * e.x - e.friction * e.v;
      }function t(t, r, a) {
        var n = { x: t.x + a.dx * r, v: t.v + a.dv * r, tension: t.tension, friction: t.friction };return { dx: n.v, dv: e(n) };
      }function r(r, a) {
        var n = { dx: r.v, dv: e(r) },
            o = t(r, .5 * a, n),
            i = t(r, .5 * a, o),
            s = t(r, a, i),
            l = 1 / 6 * (n.dx + 2 * (o.dx + i.dx) + s.dx),
            u = 1 / 6 * (n.dv + 2 * (o.dv + i.dv) + s.dv);return r.x = r.x + l * a, r.v = r.v + u * a, r;
      }return function a(e, t, n) {
        var o,
            i,
            s,
            l = { x: -1, v: 0, tension: null, friction: null },
            u = [0],
            c = 0,
            p = 1e-4,
            f = .016;for (e = parseFloat(e) || 500, t = parseFloat(t) || 20, n = n || null, l.tension = e, l.friction = t, o = null !== n, o ? (c = a(e, t), i = c / n * f) : i = f; s = r(s || l, i), u.push(1 + s.x), c += 16, Math.abs(s.x) > p && Math.abs(s.v) > p;) {}return o ? function (e) {
          return u[e * (u.length - 1) | 0];
        } : c;
      };
    }();b.Easings = { linear: function linear(e) {
        return e;
      }, swing: function swing(e) {
        return .5 - Math.cos(e * Math.PI) / 2;
      }, spring: function spring(e) {
        return 1 - Math.cos(4.5 * e * Math.PI) * Math.exp(6 * -e);
      } }, f.each([["ease", [.25, .1, .25, 1]], ["ease-in", [.42, 0, 1, 1]], ["ease-out", [0, 0, .58, 1]], ["ease-in-out", [.42, 0, .58, 1]], ["easeInSine", [.47, 0, .745, .715]], ["easeOutSine", [.39, .575, .565, 1]], ["easeInOutSine", [.445, .05, .55, .95]], ["easeInQuad", [.55, .085, .68, .53]], ["easeOutQuad", [.25, .46, .45, .94]], ["easeInOutQuad", [.455, .03, .515, .955]], ["easeInCubic", [.55, .055, .675, .19]], ["easeOutCubic", [.215, .61, .355, 1]], ["easeInOutCubic", [.645, .045, .355, 1]], ["easeInQuart", [.895, .03, .685, .22]], ["easeOutQuart", [.165, .84, .44, 1]], ["easeInOutQuart", [.77, 0, .175, 1]], ["easeInQuint", [.755, .05, .855, .06]], ["easeOutQuint", [.23, 1, .32, 1]], ["easeInOutQuint", [.86, 0, .07, 1]], ["easeInExpo", [.95, .05, .795, .035]], ["easeOutExpo", [.19, 1, .22, 1]], ["easeInOutExpo", [1, 0, 0, 1]], ["easeInCirc", [.6, .04, .98, .335]], ["easeOutCirc", [.075, .82, .165, 1]], ["easeInOutCirc", [.785, .135, .15, .86]]], function (e, t) {
      b.Easings[t[0]] = l.apply(null, t[1]);
    });var S = b.CSS = { RegEx: { isHex: /^#([A-f\d]{3}){1,2}$/i, valueUnwrap: /^[A-z]+\((.*)\)$/i, wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/, valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi }, Lists: { colors: ["fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor"], transformsBase: ["translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ"], transforms3D: ["transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY"] }, Hooks: { templates: { textShadow: ["Color X Y Blur", "black 0px 0px 0px"], boxShadow: ["Color X Y Blur Spread", "black 0px 0px 0px 0px"], clip: ["Top Right Bottom Left", "0px 0px 0px 0px"], backgroundPosition: ["X Y", "0% 0%"], transformOrigin: ["X Y Z", "50% 50% 0px"], perspectiveOrigin: ["X Y", "50% 50%"] }, registered: {}, register: function register() {
          for (var e = 0; e < S.Lists.colors.length; e++) {
            var t = "color" === S.Lists.colors[e] ? "0 0 0 1" : "255 255 255 1";S.Hooks.templates[S.Lists.colors[e]] = ["Red Green Blue Alpha", t];
          }var r, a, n;if (d) for (r in S.Hooks.templates) {
            a = S.Hooks.templates[r], n = a[0].split(" ");var o = a[1].match(S.RegEx.valueSplit);"Color" === n[0] && (n.push(n.shift()), o.push(o.shift()), S.Hooks.templates[r] = [n.join(" "), o.join(" ")]);
          }for (r in S.Hooks.templates) {
            a = S.Hooks.templates[r], n = a[0].split(" ");for (var e in n) {
              var i = r + n[e],
                  s = e;S.Hooks.registered[i] = [r, s];
            }
          }
        }, getRoot: function getRoot(e) {
          var t = S.Hooks.registered[e];return t ? t[0] : e;
        }, cleanRootPropertyValue: function cleanRootPropertyValue(e, t) {
          return S.RegEx.valueUnwrap.test(t) && (t = t.match(S.RegEx.valueUnwrap)[1]), S.Values.isCSSNullValue(t) && (t = S.Hooks.templates[e][1]), t;
        }, extractValue: function extractValue(e, t) {
          var r = S.Hooks.registered[e];if (r) {
            var a = r[0],
                n = r[1];return t = S.Hooks.cleanRootPropertyValue(a, t), t.toString().match(S.RegEx.valueSplit)[n];
          }return t;
        }, injectValue: function injectValue(e, t, r) {
          var a = S.Hooks.registered[e];if (a) {
            var n,
                o,
                i = a[0],
                s = a[1];return r = S.Hooks.cleanRootPropertyValue(i, r), n = r.toString().match(S.RegEx.valueSplit), n[s] = t, o = n.join(" ");
          }return r;
        } }, Normalizations: { registered: { clip: function clip(e, t, r) {
            switch (e) {case "name":
                return "clip";case "extract":
                var a;return S.RegEx.wrappedValueAlreadyExtracted.test(r) ? a = r : (a = r.toString().match(S.RegEx.valueUnwrap), a = a ? a[1].replace(/,(\s+)?/g, " ") : r), a;case "inject":
                return "rect(" + r + ")";}
          }, blur: function blur(e, t, r) {
            switch (e) {case "name":
                return b.State.isFirefox ? "filter" : "-webkit-filter";case "extract":
                var a = parseFloat(r);if (!a && 0 !== a) {
                  var n = r.toString().match(/blur\(([0-9]+[A-z]+)\)/i);a = n ? n[1] : 0;
                }return a;case "inject":
                return parseFloat(r) ? "blur(" + r + ")" : "none";}
          }, opacity: function opacity(e, t, r) {
            if (8 >= d) switch (e) {case "name":
                return "filter";case "extract":
                var a = r.toString().match(/alpha\(opacity=(.*)\)/i);return r = a ? a[1] / 100 : 1;case "inject":
                return t.style.zoom = 1, parseFloat(r) >= 1 ? "" : "alpha(opacity=" + parseInt(100 * parseFloat(r), 10) + ")";} else switch (e) {case "name":
                return "opacity";case "extract":
                return r;case "inject":
                return r;}
          } }, register: function register() {
          9 >= d || b.State.isGingerbread || (S.Lists.transformsBase = S.Lists.transformsBase.concat(S.Lists.transforms3D));for (var e = 0; e < S.Lists.transformsBase.length; e++) {
            !function () {
              var t = S.Lists.transformsBase[e];S.Normalizations.registered[t] = function (e, r, n) {
                switch (e) {case "name":
                    return "transform";case "extract":
                    return i(r) === a || i(r).transformCache[t] === a ? /^scale/i.test(t) ? 1 : 0 : i(r).transformCache[t].replace(/[()]/g, "");case "inject":
                    var o = !1;switch (t.substr(0, t.length - 1)) {case "translate":
                        o = !/(%|px|em|rem|vw|vh|\d)$/i.test(n);break;case "scal":case "scale":
                        b.State.isAndroid && i(r).transformCache[t] === a && 1 > n && (n = 1), o = !/(\d)$/i.test(n);break;case "skew":
                        o = !/(deg|\d)$/i.test(n);break;case "rotate":
                        o = !/(deg|\d)$/i.test(n);}return o || (i(r).transformCache[t] = "(" + n + ")"), i(r).transformCache[t];}
              };
            }();
          }for (var e = 0; e < S.Lists.colors.length; e++) {
            !function () {
              var t = S.Lists.colors[e];S.Normalizations.registered[t] = function (e, r, n) {
                switch (e) {case "name":
                    return t;case "extract":
                    var o;if (S.RegEx.wrappedValueAlreadyExtracted.test(n)) o = n;else {
                      var i,
                          s = { black: "rgb(0, 0, 0)", blue: "rgb(0, 0, 255)", gray: "rgb(128, 128, 128)", green: "rgb(0, 128, 0)", red: "rgb(255, 0, 0)", white: "rgb(255, 255, 255)" };/^[A-z]+$/i.test(n) ? i = s[n] !== a ? s[n] : s.black : S.RegEx.isHex.test(n) ? i = "rgb(" + S.Values.hexToRgb(n).join(" ") + ")" : /^rgba?\(/i.test(n) || (i = s.black), o = (i || n).toString().match(S.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ");
                    }return 8 >= d || 3 !== o.split(" ").length || (o += " 1"), o;case "inject":
                    return 8 >= d ? 4 === n.split(" ").length && (n = n.split(/\s+/).slice(0, 3).join(" ")) : 3 === n.split(" ").length && (n += " 1"), (8 >= d ? "rgb" : "rgba") + "(" + n.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")";}
              };
            }();
          }
        } }, Names: { camelCase: function camelCase(e) {
          return e.replace(/-(\w)/g, function (e, t) {
            return t.toUpperCase();
          });
        }, SVGAttribute: function SVGAttribute(e) {
          var t = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";return (d || b.State.isAndroid && !b.State.isChrome) && (t += "|transform"), new RegExp("^(" + t + ")$", "i").test(e);
        }, prefixCheck: function prefixCheck(e) {
          if (b.State.prefixMatches[e]) return [b.State.prefixMatches[e], !0];for (var t = ["", "Webkit", "Moz", "ms", "O"], r = 0, a = t.length; a > r; r++) {
            var n;if (n = 0 === r ? e : t[r] + e.replace(/^\w/, function (e) {
              return e.toUpperCase();
            }), m.isString(b.State.prefixElement.style[n])) return b.State.prefixMatches[e] = n, [n, !0];
          }return [e, !1];
        } }, Values: { hexToRgb: function hexToRgb(e) {
          var t,
              r = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
              a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;return e = e.replace(r, function (e, t, r, a) {
            return t + t + r + r + a + a;
          }), t = a.exec(e), t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] : [0, 0, 0];
        }, isCSSNullValue: function isCSSNullValue(e) {
          return 0 == e || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(e);
        }, getUnitType: function getUnitType(e) {
          return (/^(rotate|skew)/i.test(e) ? "deg" : /(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e) ? "" : "px"
          );
        }, getDisplayType: function getDisplayType(e) {
          var t = e && e.tagName.toString().toLowerCase();return (/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t) ? "inline" : /^(li)$/i.test(t) ? "list-item" : /^(tr)$/i.test(t) ? "table-row" : /^(table)$/i.test(t) ? "table" : /^(tbody)$/i.test(t) ? "table-row-group" : "block"
          );
        }, addClass: function addClass(e, t) {
          e.classList ? e.classList.add(t) : e.className += (e.className.length ? " " : "") + t;
        }, removeClass: function removeClass(e, t) {
          e.classList ? e.classList.remove(t) : e.className = e.className.toString().replace(new RegExp("(^|\\s)" + t.split(" ").join("|") + "(\\s|$)", "gi"), " ");
        } }, getPropertyValue: function getPropertyValue(e, r, n, o) {
        function s(e, r) {
          function n() {
            u && S.setPropertyValue(e, "display", "none");
          }var l = 0;if (8 >= d) l = f.css(e, r);else {
            var u = !1;if (/^(width|height)$/.test(r) && 0 === S.getPropertyValue(e, "display") && (u = !0, S.setPropertyValue(e, "display", S.Values.getDisplayType(e))), !o) {
              if ("height" === r && "border-box" !== S.getPropertyValue(e, "boxSizing").toString().toLowerCase()) {
                var c = e.offsetHeight - (parseFloat(S.getPropertyValue(e, "borderTopWidth")) || 0) - (parseFloat(S.getPropertyValue(e, "borderBottomWidth")) || 0) - (parseFloat(S.getPropertyValue(e, "paddingTop")) || 0) - (parseFloat(S.getPropertyValue(e, "paddingBottom")) || 0);return n(), c;
              }if ("width" === r && "border-box" !== S.getPropertyValue(e, "boxSizing").toString().toLowerCase()) {
                var p = e.offsetWidth - (parseFloat(S.getPropertyValue(e, "borderLeftWidth")) || 0) - (parseFloat(S.getPropertyValue(e, "borderRightWidth")) || 0) - (parseFloat(S.getPropertyValue(e, "paddingLeft")) || 0) - (parseFloat(S.getPropertyValue(e, "paddingRight")) || 0);return n(), p;
              }
            }var g;g = i(e) === a ? t.getComputedStyle(e, null) : i(e).computedStyle ? i(e).computedStyle : i(e).computedStyle = t.getComputedStyle(e, null), "borderColor" === r && (r = "borderTopColor"), l = 9 === d && "filter" === r ? g.getPropertyValue(r) : g[r], ("" === l || null === l) && (l = e.style[r]), n();
          }if ("auto" === l && /^(top|right|bottom|left)$/i.test(r)) {
            var m = s(e, "position");("fixed" === m || "absolute" === m && /top|left/i.test(r)) && (l = f(e).position()[r] + "px");
          }return l;
        }var l;if (S.Hooks.registered[r]) {
          var u = r,
              c = S.Hooks.getRoot(u);n === a && (n = S.getPropertyValue(e, S.Names.prefixCheck(c)[0])), S.Normalizations.registered[c] && (n = S.Normalizations.registered[c]("extract", e, n)), l = S.Hooks.extractValue(u, n);
        } else if (S.Normalizations.registered[r]) {
          var p, g;p = S.Normalizations.registered[r]("name", e), "transform" !== p && (g = s(e, S.Names.prefixCheck(p)[0]), S.Values.isCSSNullValue(g) && S.Hooks.templates[r] && (g = S.Hooks.templates[r][1])), l = S.Normalizations.registered[r]("extract", e, g);
        }if (!/^[\d-]/.test(l)) if (i(e) && i(e).isSVG && S.Names.SVGAttribute(r)) {
          if (/^(height|width)$/i.test(r)) try {
            l = e.getBBox()[r];
          } catch (m) {
            l = 0;
          } else l = e.getAttribute(r);
        } else l = s(e, S.Names.prefixCheck(r)[0]);return S.Values.isCSSNullValue(l) && (l = 0), b.debug >= 2 && console.log("Get " + r + ": " + l), l;
      }, setPropertyValue: function setPropertyValue(e, r, a, n, o) {
        var s = r;if ("scroll" === r) o.container ? o.container["scroll" + o.direction] = a : "Left" === o.direction ? t.scrollTo(a, o.alternateValue) : t.scrollTo(o.alternateValue, a);else if (S.Normalizations.registered[r] && "transform" === S.Normalizations.registered[r]("name", e)) S.Normalizations.registered[r]("inject", e, a), s = "transform", a = i(e).transformCache[r];else {
          if (S.Hooks.registered[r]) {
            var l = r,
                u = S.Hooks.getRoot(r);n = n || S.getPropertyValue(e, u), a = S.Hooks.injectValue(l, a, n), r = u;
          }if (S.Normalizations.registered[r] && (a = S.Normalizations.registered[r]("inject", e, a), r = S.Normalizations.registered[r]("name", e)), s = S.Names.prefixCheck(r)[0], 8 >= d) try {
            e.style[s] = a;
          } catch (c) {
            b.debug && console.log("Browser does not support [" + a + "] for [" + s + "]");
          } else i(e) && i(e).isSVG && S.Names.SVGAttribute(r) ? e.setAttribute(r, a) : e.style[s] = a;b.debug >= 2 && console.log("Set " + r + " (" + s + "): " + a);
        }return [s, a];
      }, flushTransformCache: function flushTransformCache(e) {
        function t(t) {
          return parseFloat(S.getPropertyValue(e, t));
        }var r = "";if ((d || b.State.isAndroid && !b.State.isChrome) && i(e).isSVG) {
          var a = { translate: [t("translateX"), t("translateY")], skewX: [t("skewX")], skewY: [t("skewY")], scale: 1 !== t("scale") ? [t("scale"), t("scale")] : [t("scaleX"), t("scaleY")], rotate: [t("rotateZ"), 0, 0] };f.each(i(e).transformCache, function (e) {
            /^translate/i.test(e) ? e = "translate" : /^scale/i.test(e) ? e = "scale" : /^rotate/i.test(e) && (e = "rotate"), a[e] && (r += e + "(" + a[e].join(" ") + ") ", delete a[e]);
          });
        } else {
          var n, o;f.each(i(e).transformCache, function (t) {
            return n = i(e).transformCache[t], "transformPerspective" === t ? (o = n, !0) : (9 === d && "rotateZ" === t && (t = "rotate"), void (r += t + n + " "));
          }), o && (r = "perspective" + o + " " + r);
        }S.setPropertyValue(e, "transform", r);
      } };S.Hooks.register(), S.Normalizations.register(), b.hook = function (e, t, r) {
      var n = a;return e = o(e), f.each(e, function (e, o) {
        if (i(o) === a && b.init(o), r === a) n === a && (n = b.CSS.getPropertyValue(o, t));else {
          var s = b.CSS.setPropertyValue(o, t, r);"transform" === s[0] && b.CSS.flushTransformCache(o), n = s;
        }
      }), n;
    };var P = function P() {
      function e() {
        return s ? k.promise || null : l;
      }function n() {
        function e(e) {
          function p(e, t) {
            var r = a,
                n = a,
                i = a;return m.isArray(e) ? (r = e[0], !m.isArray(e[1]) && /^[\d-]/.test(e[1]) || m.isFunction(e[1]) || S.RegEx.isHex.test(e[1]) ? i = e[1] : (m.isString(e[1]) && !S.RegEx.isHex.test(e[1]) || m.isArray(e[1])) && (n = t ? e[1] : u(e[1], s.duration), e[2] !== a && (i = e[2]))) : r = e, t || (n = n || s.easing), m.isFunction(r) && (r = r.call(o, V, w)), m.isFunction(i) && (i = i.call(o, V, w)), [r || 0, n, i];
          }function d(e, t) {
            var r, a;return a = (t || "0").toString().toLowerCase().replace(/[%A-z]+$/, function (e) {
              return r = e, "";
            }), r || (r = S.Values.getUnitType(e)), [a, r];
          }function h() {
            var e = { myParent: o.parentNode || r.body, position: S.getPropertyValue(o, "position"), fontSize: S.getPropertyValue(o, "fontSize") },
                a = e.position === L.lastPosition && e.myParent === L.lastParent,
                n = e.fontSize === L.lastFontSize;L.lastParent = e.myParent, L.lastPosition = e.position, L.lastFontSize = e.fontSize;var s = 100,
                l = {};if (n && a) l.emToPx = L.lastEmToPx, l.percentToPxWidth = L.lastPercentToPxWidth, l.percentToPxHeight = L.lastPercentToPxHeight;else {
              var u = i(o).isSVG ? r.createElementNS("http://www.w3.org/2000/svg", "rect") : r.createElement("div");b.init(u), e.myParent.appendChild(u), f.each(["overflow", "overflowX", "overflowY"], function (e, t) {
                b.CSS.setPropertyValue(u, t, "hidden");
              }), b.CSS.setPropertyValue(u, "position", e.position), b.CSS.setPropertyValue(u, "fontSize", e.fontSize), b.CSS.setPropertyValue(u, "boxSizing", "content-box"), f.each(["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height"], function (e, t) {
                b.CSS.setPropertyValue(u, t, s + "%");
              }), b.CSS.setPropertyValue(u, "paddingLeft", s + "em"), l.percentToPxWidth = L.lastPercentToPxWidth = (parseFloat(S.getPropertyValue(u, "width", null, !0)) || 1) / s, l.percentToPxHeight = L.lastPercentToPxHeight = (parseFloat(S.getPropertyValue(u, "height", null, !0)) || 1) / s, l.emToPx = L.lastEmToPx = (parseFloat(S.getPropertyValue(u, "paddingLeft")) || 1) / s, e.myParent.removeChild(u);
            }return null === L.remToPx && (L.remToPx = parseFloat(S.getPropertyValue(r.body, "fontSize")) || 16), null === L.vwToPx && (L.vwToPx = parseFloat(t.innerWidth) / 100, L.vhToPx = parseFloat(t.innerHeight) / 100), l.remToPx = L.remToPx, l.vwToPx = L.vwToPx, l.vhToPx = L.vhToPx, b.debug >= 1 && console.log("Unit ratios: " + JSON.stringify(l), o), l;
          }if (s.begin && 0 === V) try {
            s.begin.call(g, g);
          } catch (x) {
            setTimeout(function () {
              throw x;
            }, 1);
          }if ("scroll" === A) {
            var P,
                C,
                T,
                F = /^x$/i.test(s.axis) ? "Left" : "Top",
                j = parseFloat(s.offset) || 0;s.container ? m.isWrapped(s.container) || m.isNode(s.container) ? (s.container = s.container[0] || s.container, P = s.container["scroll" + F], T = P + f(o).position()[F.toLowerCase()] + j) : s.container = null : (P = b.State.scrollAnchor[b.State["scrollProperty" + F]], C = b.State.scrollAnchor[b.State["scrollProperty" + ("Left" === F ? "Top" : "Left")]], T = f(o).offset()[F.toLowerCase()] + j), l = { scroll: { rootPropertyValue: !1, startValue: P, currentValue: P, endValue: T, unitType: "", easing: s.easing, scrollData: { container: s.container, direction: F, alternateValue: C } }, element: o }, b.debug && console.log("tweensContainer (scroll): ", l.scroll, o);
          } else if ("reverse" === A) {
            if (!i(o).tweensContainer) return void f.dequeue(o, s.queue);"none" === i(o).opts.display && (i(o).opts.display = "auto"), "hidden" === i(o).opts.visibility && (i(o).opts.visibility = "visible"), i(o).opts.loop = !1, i(o).opts.begin = null, i(o).opts.complete = null, v.easing || delete s.easing, v.duration || delete s.duration, s = f.extend({}, i(o).opts, s);var E = f.extend(!0, {}, i(o).tweensContainer);for (var H in E) {
              if ("element" !== H) {
                var N = E[H].startValue;E[H].startValue = E[H].currentValue = E[H].endValue, E[H].endValue = N, m.isEmptyObject(v) || (E[H].easing = s.easing), b.debug && console.log("reverse tweensContainer (" + H + "): " + JSON.stringify(E[H]), o);
              }
            }l = E;
          } else if ("start" === A) {
            var E;i(o).tweensContainer && i(o).isAnimating === !0 && (E = i(o).tweensContainer), f.each(y, function (e, t) {
              if (RegExp("^" + S.Lists.colors.join("$|^") + "$").test(e)) {
                var r = p(t, !0),
                    n = r[0],
                    o = r[1],
                    i = r[2];if (S.RegEx.isHex.test(n)) {
                  for (var s = ["Red", "Green", "Blue"], l = S.Values.hexToRgb(n), u = i ? S.Values.hexToRgb(i) : a, c = 0; c < s.length; c++) {
                    var f = [l[c]];o && f.push(o), u !== a && f.push(u[c]), y[e + s[c]] = f;
                  }delete y[e];
                }
              }
            });for (var z in y) {
              var O = p(y[z]),
                  q = O[0],
                  $ = O[1],
                  M = O[2];z = S.Names.camelCase(z);var I = S.Hooks.getRoot(z),
                  B = !1;if (i(o).isSVG || "tween" === I || S.Names.prefixCheck(I)[1] !== !1 || S.Normalizations.registered[I] !== a) {
                (s.display !== a && null !== s.display && "none" !== s.display || s.visibility !== a && "hidden" !== s.visibility) && /opacity|filter/.test(z) && !M && 0 !== q && (M = 0), s._cacheValues && E && E[z] ? (M === a && (M = E[z].endValue + E[z].unitType), B = i(o).rootPropertyValueCache[I]) : S.Hooks.registered[z] ? M === a ? (B = S.getPropertyValue(o, I), M = S.getPropertyValue(o, z, B)) : B = S.Hooks.templates[I][1] : M === a && (M = S.getPropertyValue(o, z));var W,
                    G,
                    Y,
                    D = !1;if (W = d(z, M), M = W[0], Y = W[1], W = d(z, q), q = W[0].replace(/^([+-\/*])=/, function (e, t) {
                  return D = t, "";
                }), G = W[1], M = parseFloat(M) || 0, q = parseFloat(q) || 0, "%" === G && (/^(fontSize|lineHeight)$/.test(z) ? (q /= 100, G = "em") : /^scale/.test(z) ? (q /= 100, G = "") : /(Red|Green|Blue)$/i.test(z) && (q = q / 100 * 255, G = "")), /[\/*]/.test(D)) G = Y;else if (Y !== G && 0 !== M) if (0 === q) G = Y;else {
                  n = n || h();var Q = /margin|padding|left|right|width|text|word|letter/i.test(z) || /X$/.test(z) || "x" === z ? "x" : "y";switch (Y) {case "%":
                      M *= "x" === Q ? n.percentToPxWidth : n.percentToPxHeight;break;case "px":
                      break;default:
                      M *= n[Y + "ToPx"];}switch (G) {case "%":
                      M *= 1 / ("x" === Q ? n.percentToPxWidth : n.percentToPxHeight);break;case "px":
                      break;default:
                      M *= 1 / n[G + "ToPx"];}
                }switch (D) {case "+":
                    q = M + q;break;case "-":
                    q = M - q;break;case "*":
                    q = M * q;break;case "/":
                    q = M / q;}l[z] = { rootPropertyValue: B, startValue: M, currentValue: M, endValue: q, unitType: G, easing: $ }, b.debug && console.log("tweensContainer (" + z + "): " + JSON.stringify(l[z]), o);
              } else b.debug && console.log("Skipping [" + I + "] due to a lack of browser support.");
            }l.element = o;
          }l.element && (S.Values.addClass(o, "velocity-animating"), R.push(l), "" === s.queue && (i(o).tweensContainer = l, i(o).opts = s), i(o).isAnimating = !0, V === w - 1 ? (b.State.calls.push([R, g, s, null, k.resolver]), b.State.isTicking === !1 && (b.State.isTicking = !0, c())) : V++);
        }var n,
            o = this,
            s = f.extend({}, b.defaults, v),
            l = {};switch (i(o) === a && b.init(o), parseFloat(s.delay) && s.queue !== !1 && f.queue(o, s.queue, function (e) {
          b.velocityQueueEntryFlag = !0, i(o).delayTimer = { setTimeout: setTimeout(e, parseFloat(s.delay)), next: e };
        }), s.duration.toString().toLowerCase()) {case "fast":
            s.duration = 200;break;case "normal":
            s.duration = h;break;case "slow":
            s.duration = 600;break;default:
            s.duration = parseFloat(s.duration) || 1;}b.mock !== !1 && (b.mock === !0 ? s.duration = s.delay = 1 : (s.duration *= parseFloat(b.mock) || 1, s.delay *= parseFloat(b.mock) || 1)), s.easing = u(s.easing, s.duration), s.begin && !m.isFunction(s.begin) && (s.begin = null), s.progress && !m.isFunction(s.progress) && (s.progress = null), s.complete && !m.isFunction(s.complete) && (s.complete = null), s.display !== a && null !== s.display && (s.display = s.display.toString().toLowerCase(), "auto" === s.display && (s.display = b.CSS.Values.getDisplayType(o))), s.visibility !== a && null !== s.visibility && (s.visibility = s.visibility.toString().toLowerCase()), s.mobileHA = s.mobileHA && b.State.isMobile && !b.State.isGingerbread, s.queue === !1 ? s.delay ? setTimeout(e, s.delay) : e() : f.queue(o, s.queue, function (t, r) {
          return r === !0 ? (k.promise && k.resolver(g), !0) : (b.velocityQueueEntryFlag = !0, void e(t));
        }), "" !== s.queue && "fx" !== s.queue || "inprogress" === f.queue(o)[0] || f.dequeue(o);
      }var s,
          l,
          d,
          g,
          y,
          v,
          x = arguments[0] && (arguments[0].p || f.isPlainObject(arguments[0].properties) && !arguments[0].properties.names || m.isString(arguments[0].properties));if (m.isWrapped(this) ? (s = !1, d = 0, g = this, l = this) : (s = !0, d = 1, g = x ? arguments[0].elements || arguments[0].e : arguments[0]), g = o(g)) {
        x ? (y = arguments[0].properties || arguments[0].p, v = arguments[0].options || arguments[0].o) : (y = arguments[d], v = arguments[d + 1]);var w = g.length,
            V = 0;if (!/^(stop|finish)$/i.test(y) && !f.isPlainObject(v)) {
          var C = d + 1;v = {};for (var T = C; T < arguments.length; T++) {
            m.isArray(arguments[T]) || !/^(fast|normal|slow)$/i.test(arguments[T]) && !/^\d/.test(arguments[T]) ? m.isString(arguments[T]) || m.isArray(arguments[T]) ? v.easing = arguments[T] : m.isFunction(arguments[T]) && (v.complete = arguments[T]) : v.duration = arguments[T];
          }
        }var k = { promise: null, resolver: null, rejecter: null };s && b.Promise && (k.promise = new b.Promise(function (e, t) {
          k.resolver = e, k.rejecter = t;
        }));var A;switch (y) {case "scroll":
            A = "scroll";break;case "reverse":
            A = "reverse";break;case "finish":case "stop":
            f.each(g, function (e, t) {
              i(t) && i(t).delayTimer && (clearTimeout(i(t).delayTimer.setTimeout), i(t).delayTimer.next && i(t).delayTimer.next(), delete i(t).delayTimer);
            });var F = [];return f.each(b.State.calls, function (e, t) {
              t && f.each(t[1], function (r, n) {
                var o = v === a ? "" : v;return o === !0 || t[2].queue === o || v === a && t[2].queue === !1 ? void f.each(g, function (r, a) {
                  a === n && ((v === !0 || m.isString(v)) && (f.each(f.queue(a, m.isString(v) ? v : ""), function (e, t) {
                    m.isFunction(t) && t(null, !0);
                  }), f.queue(a, m.isString(v) ? v : "", [])), "stop" === y ? (i(a) && i(a).tweensContainer && o !== !1 && f.each(i(a).tweensContainer, function (e, t) {
                    t.endValue = t.currentValue;
                  }), F.push(e)) : "finish" === y && (t[2].duration = 1));
                }) : !0;
              });
            }), "stop" === y && (f.each(F, function (e, t) {
              p(t, !0);
            }), k.promise && k.resolver(g)), e();default:
            if (!f.isPlainObject(y) || m.isEmptyObject(y)) {
              if (m.isString(y) && b.Redirects[y]) {
                var j = f.extend({}, v),
                    E = j.duration,
                    H = j.delay || 0;return j.backwards === !0 && (g = f.extend(!0, [], g).reverse()), f.each(g, function (e, t) {
                  parseFloat(j.stagger) ? j.delay = H + parseFloat(j.stagger) * e : m.isFunction(j.stagger) && (j.delay = H + j.stagger.call(t, e, w)), j.drag && (j.duration = parseFloat(E) || (/^(callout|transition)/.test(y) ? 1e3 : h), j.duration = Math.max(j.duration * (j.backwards ? 1 - e / w : (e + 1) / w), .75 * j.duration, 200)), b.Redirects[y].call(t, t, j || {}, e, w, g, k.promise ? k : a);
                }), e();
              }var N = "Velocity: First argument (" + y + ") was not a property map, a known action, or a registered redirect. Aborting.";return k.promise ? k.rejecter(new Error(N)) : console.log(N), e();
            }A = "start";}var L = { lastParent: null, lastPosition: null, lastFontSize: null, lastPercentToPxWidth: null, lastPercentToPxHeight: null, lastEmToPx: null, remToPx: null, vwToPx: null, vhToPx: null },
            R = [];f.each(g, function (e, t) {
          m.isNode(t) && n.call(t);
        });var z,
            j = f.extend({}, b.defaults, v);if (j.loop = parseInt(j.loop), z = 2 * j.loop - 1, j.loop) for (var O = 0; z > O; O++) {
          var q = { delay: j.delay, progress: j.progress };O === z - 1 && (q.display = j.display, q.visibility = j.visibility, q.complete = j.complete), P(g, "reverse", q);
        }return e();
      }
    };b = f.extend(P, b), b.animate = P;var w = t.requestAnimationFrame || g;return b.State.isMobile || r.hidden === a || r.addEventListener("visibilitychange", function () {
      r.hidden ? (w = function w(e) {
        return setTimeout(function () {
          e(!0);
        }, 16);
      }, c()) : w = t.requestAnimationFrame || g;
    }), e.Velocity = b, e !== t && (e.fn.velocity = P, e.fn.velocity.defaults = b.defaults), f.each(["Down", "Up"], function (e, t) {
      b.Redirects["slide" + t] = function (e, r, n, o, i, s) {
        var l = f.extend({}, r),
            u = l.begin,
            c = l.complete,
            p = { height: "", marginTop: "", marginBottom: "", paddingTop: "", paddingBottom: "" },
            d = {};l.display === a && (l.display = "Down" === t ? "inline" === b.CSS.Values.getDisplayType(e) ? "inline-block" : "block" : "none"), l.begin = function () {
          u && u.call(i, i);for (var r in p) {
            d[r] = e.style[r];var a = b.CSS.getPropertyValue(e, r);p[r] = "Down" === t ? [a, 0] : [0, a];
          }d.overflow = e.style.overflow, e.style.overflow = "hidden";
        }, l.complete = function () {
          for (var t in d) {
            e.style[t] = d[t];
          }c && c.call(i, i), s && s.resolver(i);
        }, b(e, p, l);
      };
    }), f.each(["In", "Out"], function (e, t) {
      b.Redirects["fade" + t] = function (e, r, n, o, i, s) {
        var l = f.extend({}, r),
            u = { opacity: "In" === t ? 1 : 0 },
            c = l.complete;l.complete = n !== o - 1 ? l.begin = null : function () {
          c && c.call(i, i), s && s.resolver(i);
        }, l.display === a && (l.display = "In" === t ? "auto" : "none"), b(this, u, l);
      };
    }), b;
  }(window.jQuery || window.Zepto || window, window, document);
}));
;!function (a, b, c, d) {
  "use strict";
  function k(a, b, c) {
    return setTimeout(q(a, c), b);
  }function l(a, b, c) {
    return Array.isArray(a) ? (m(a, c[b], c), !0) : !1;
  }function m(a, b, c) {
    var e;if (a) if (a.forEach) a.forEach(b, c);else if (a.length !== d) for (e = 0; e < a.length;) {
      b.call(c, a[e], e, a), e++;
    } else for (e in a) {
      a.hasOwnProperty(e) && b.call(c, a[e], e, a);
    }
  }function n(a, b, c) {
    for (var e = Object.keys(b), f = 0; f < e.length;) {
      (!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++;
    }return a;
  }function o(a, b) {
    return n(a, b, !0);
  }function p(a, b, c) {
    var e,
        d = b.prototype;e = a.prototype = Object.create(d), e.constructor = a, e._super = d, c && n(e, c);
  }function q(a, b) {
    return function () {
      return a.apply(b, arguments);
    };
  }function r(a, b) {
    return (typeof a === 'undefined' ? 'undefined' : _typeof(a)) == g ? a.apply(b ? b[0] || d : d, b) : a;
  }function s(a, b) {
    return a === d ? b : a;
  }function t(a, b, c) {
    m(x(b), function (b) {
      a.addEventListener(b, c, !1);
    });
  }function u(a, b, c) {
    m(x(b), function (b) {
      a.removeEventListener(b, c, !1);
    });
  }function v(a, b) {
    for (; a;) {
      if (a == b) return !0;a = a.parentNode;
    }return !1;
  }function w(a, b) {
    return a.indexOf(b) > -1;
  }function x(a) {
    return a.trim().split(/\s+/g);
  }function y(a, b, c) {
    if (a.indexOf && !c) return a.indexOf(b);for (var d = 0; d < a.length;) {
      if (c && a[d][c] == b || !c && a[d] === b) return d;d++;
    }return -1;
  }function z(a) {
    return Array.prototype.slice.call(a, 0);
  }function A(a, b, c) {
    for (var d = [], e = [], f = 0; f < a.length;) {
      var g = b ? a[f][b] : a[f];y(e, g) < 0 && d.push(a[f]), e[f] = g, f++;
    }return c && (d = b ? d.sort(function (a, c) {
      return a[b] > c[b];
    }) : d.sort()), d;
  }function B(a, b) {
    for (var c, f, g = b[0].toUpperCase() + b.slice(1), h = 0; h < e.length;) {
      if (c = e[h], f = c ? c + g : b, f in a) return f;h++;
    }return d;
  }function D() {
    return C++;
  }function E(a) {
    var b = a.ownerDocument;return b.defaultView || b.parentWindow;
  }function ab(a, b) {
    var c = this;this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) {
      r(a.options.enable, [a]) && c.handler(b);
    }, this.init();
  }function bb(a) {
    var b,
        c = a.options.inputClass;return b = c ? c : H ? wb : I ? Eb : G ? Gb : rb, new b(a, cb);
  }function cb(a, b, c) {
    var d = c.pointers.length,
        e = c.changedPointers.length,
        f = b & O && 0 === d - e,
        g = b & (Q | R) && 0 === d - e;c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, db(a, c), a.emit("hammer.input", c), a.recognize(c), a.session.prevInput = c;
  }function db(a, b) {
    var c = a.session,
        d = b.pointers,
        e = d.length;c.firstInput || (c.firstInput = gb(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = gb(b) : 1 === e && (c.firstMultiple = !1);var f = c.firstInput,
        g = c.firstMultiple,
        h = g ? g.center : f.center,
        i = b.center = hb(d);b.timeStamp = j(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = lb(h, i), b.distance = kb(h, i), eb(c, b), b.offsetDirection = jb(b.deltaX, b.deltaY), b.scale = g ? nb(g.pointers, d) : 1, b.rotation = g ? mb(g.pointers, d) : 0, fb(c, b);var k = a.element;v(b.srcEvent.target, k) && (k = b.srcEvent.target), b.target = k;
  }function eb(a, b) {
    var c = b.center,
        d = a.offsetDelta || {},
        e = a.prevDelta || {},
        f = a.prevInput || {};(b.eventType === O || f.eventType === Q) && (e = a.prevDelta = { x: f.deltaX || 0, y: f.deltaY || 0 }, d = a.offsetDelta = { x: c.x, y: c.y }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y);
  }function fb(a, b) {
    var f,
        g,
        h,
        j,
        c = a.lastInterval || b,
        e = b.timeStamp - c.timeStamp;if (b.eventType != R && (e > N || c.velocity === d)) {
      var k = c.deltaX - b.deltaX,
          l = c.deltaY - b.deltaY,
          m = ib(e, k, l);g = m.x, h = m.y, f = i(m.x) > i(m.y) ? m.x : m.y, j = jb(k, l), a.lastInterval = b;
    } else f = c.velocity, g = c.velocityX, h = c.velocityY, j = c.direction;b.velocity = f, b.velocityX = g, b.velocityY = h, b.direction = j;
  }function gb(a) {
    for (var b = [], c = 0; c < a.pointers.length;) {
      b[c] = { clientX: h(a.pointers[c].clientX), clientY: h(a.pointers[c].clientY) }, c++;
    }return { timeStamp: j(), pointers: b, center: hb(b), deltaX: a.deltaX, deltaY: a.deltaY };
  }function hb(a) {
    var b = a.length;if (1 === b) return { x: h(a[0].clientX), y: h(a[0].clientY) };for (var c = 0, d = 0, e = 0; b > e;) {
      c += a[e].clientX, d += a[e].clientY, e++;
    }return { x: h(c / b), y: h(d / b) };
  }function ib(a, b, c) {
    return { x: b / a || 0, y: c / a || 0 };
  }function jb(a, b) {
    return a === b ? S : i(a) >= i(b) ? a > 0 ? T : U : b > 0 ? V : W;
  }function kb(a, b, c) {
    c || (c = $);var d = b[c[0]] - a[c[0]],
        e = b[c[1]] - a[c[1]];return Math.sqrt(d * d + e * e);
  }function lb(a, b, c) {
    c || (c = $);var d = b[c[0]] - a[c[0]],
        e = b[c[1]] - a[c[1]];return 180 * Math.atan2(e, d) / Math.PI;
  }function mb(a, b) {
    return lb(b[1], b[0], _) - lb(a[1], a[0], _);
  }function nb(a, b) {
    return kb(b[0], b[1], _) / kb(a[0], a[1], _);
  }function rb() {
    this.evEl = pb, this.evWin = qb, this.allow = !0, this.pressed = !1, ab.apply(this, arguments);
  }function wb() {
    this.evEl = ub, this.evWin = vb, ab.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
  }function Ab() {
    this.evTarget = yb, this.evWin = zb, this.started = !1, ab.apply(this, arguments);
  }function Bb(a, b) {
    var c = z(a.touches),
        d = z(a.changedTouches);return b & (Q | R) && (c = A(c.concat(d), "identifier", !0)), [c, d];
  }function Eb() {
    this.evTarget = Db, this.targetIds = {}, ab.apply(this, arguments);
  }function Fb(a, b) {
    var c = z(a.touches),
        d = this.targetIds;if (b & (O | P) && 1 === c.length) return d[c[0].identifier] = !0, [c, c];var e,
        f,
        g = z(a.changedTouches),
        h = [],
        i = this.target;if (f = c.filter(function (a) {
      return v(a.target, i);
    }), b === O) for (e = 0; e < f.length;) {
      d[f[e].identifier] = !0, e++;
    }for (e = 0; e < g.length;) {
      d[g[e].identifier] && h.push(g[e]), b & (Q | R) && delete d[g[e].identifier], e++;
    }return h.length ? [A(f.concat(h), "identifier", !0), h] : void 0;
  }function Gb() {
    ab.apply(this, arguments);var a = q(this.handler, this);this.touch = new Eb(this.manager, a), this.mouse = new rb(this.manager, a);
  }function Pb(a, b) {
    this.manager = a, this.set(b);
  }function Qb(a) {
    if (w(a, Mb)) return Mb;var b = w(a, Nb),
        c = w(a, Ob);return b && c ? Nb + " " + Ob : b || c ? b ? Nb : Ob : w(a, Lb) ? Lb : Kb;
  }function Yb(a) {
    this.id = D(), this.manager = null, this.options = o(a || {}, this.defaults), this.options.enable = s(this.options.enable, !0), this.state = Rb, this.simultaneous = {}, this.requireFail = [];
  }function Zb(a) {
    return a & Wb ? "cancel" : a & Ub ? "end" : a & Tb ? "move" : a & Sb ? "start" : "";
  }function $b(a) {
    return a == W ? "down" : a == V ? "up" : a == T ? "left" : a == U ? "right" : "";
  }function _b(a, b) {
    var c = b.manager;return c ? c.get(a) : a;
  }function ac() {
    Yb.apply(this, arguments);
  }function bc() {
    ac.apply(this, arguments), this.pX = null, this.pY = null;
  }function cc() {
    ac.apply(this, arguments);
  }function dc() {
    Yb.apply(this, arguments), this._timer = null, this._input = null;
  }function ec() {
    ac.apply(this, arguments);
  }function fc() {
    ac.apply(this, arguments);
  }function gc() {
    Yb.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
  }function hc(a, b) {
    return b = b || {}, b.recognizers = s(b.recognizers, hc.defaults.preset), new kc(a, b);
  }function kc(a, b) {
    b = b || {}, this.options = o(b, hc.defaults), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.element = a, this.input = bb(this), this.touchAction = new Pb(this, this.options.touchAction), lc(this, !0), m(b.recognizers, function (a) {
      var b = this.add(new a[0](a[1]));a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3]);
    }, this);
  }function lc(a, b) {
    var c = a.element;m(a.options.cssProps, function (a, d) {
      c.style[B(c.style, d)] = b ? a : "";
    });
  }function mc(a, c) {
    var d = b.createEvent("Event");d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d);
  }var e = ["", "webkit", "moz", "MS", "ms", "o"],
      f = b.createElement("div"),
      g = "function",
      h = Math.round,
      i = Math.abs,
      j = Date.now,
      C = 1,
      F = /mobile|tablet|ip(ad|hone|od)|android/i,
      G = "ontouchstart" in a,
      H = B(a, "PointerEvent") !== d,
      I = G && F.test(navigator.userAgent),
      J = "touch",
      K = "pen",
      L = "mouse",
      M = "kinect",
      N = 25,
      O = 1,
      P = 2,
      Q = 4,
      R = 8,
      S = 1,
      T = 2,
      U = 4,
      V = 8,
      W = 16,
      X = T | U,
      Y = V | W,
      Z = X | Y,
      $ = ["x", "y"],
      _ = ["clientX", "clientY"];ab.prototype = { handler: function handler() {}, init: function init() {
      this.evEl && t(this.element, this.evEl, this.domHandler), this.evTarget && t(this.target, this.evTarget, this.domHandler), this.evWin && t(E(this.element), this.evWin, this.domHandler);
    }, destroy: function destroy() {
      this.evEl && u(this.element, this.evEl, this.domHandler), this.evTarget && u(this.target, this.evTarget, this.domHandler), this.evWin && u(E(this.element), this.evWin, this.domHandler);
    } };var ob = { mousedown: O, mousemove: P, mouseup: Q },
      pb = "mousedown",
      qb = "mousemove mouseup";p(rb, ab, { handler: function handler(a) {
      var b = ob[a.type];b & O && 0 === a.button && (this.pressed = !0), b & P && 1 !== a.which && (b = Q), this.pressed && this.allow && (b & Q && (this.pressed = !1), this.callback(this.manager, b, { pointers: [a], changedPointers: [a], pointerType: L, srcEvent: a }));
    } });var sb = { pointerdown: O, pointermove: P, pointerup: Q, pointercancel: R, pointerout: R },
      tb = { 2: J, 3: K, 4: L, 5: M },
      ub = "pointerdown",
      vb = "pointermove pointerup pointercancel";a.MSPointerEvent && (ub = "MSPointerDown", vb = "MSPointerMove MSPointerUp MSPointerCancel"), p(wb, ab, { handler: function handler(a) {
      var b = this.store,
          c = !1,
          d = a.type.toLowerCase().replace("ms", ""),
          e = sb[d],
          f = tb[a.pointerType] || a.pointerType,
          g = f == J,
          h = y(b, a.pointerId, "pointerId");e & O && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Q | R) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, { pointers: b, changedPointers: [a], pointerType: f, srcEvent: a }), c && b.splice(h, 1));
    } });var xb = { touchstart: O, touchmove: P, touchend: Q, touchcancel: R },
      yb = "touchstart",
      zb = "touchstart touchmove touchend touchcancel";p(Ab, ab, { handler: function handler(a) {
      var b = xb[a.type];if (b === O && (this.started = !0), this.started) {
        var c = Bb.call(this, a, b);b & (Q | R) && 0 === c[0].length - c[1].length && (this.started = !1), this.callback(this.manager, b, { pointers: c[0], changedPointers: c[1], pointerType: J, srcEvent: a });
      }
    } });var Cb = { touchstart: O, touchmove: P, touchend: Q, touchcancel: R },
      Db = "touchstart touchmove touchend touchcancel";p(Eb, ab, { handler: function handler(a) {
      var b = Cb[a.type],
          c = Fb.call(this, a, b);c && this.callback(this.manager, b, { pointers: c[0], changedPointers: c[1], pointerType: J, srcEvent: a });
    } }), p(Gb, ab, { handler: function handler(a, b, c) {
      var d = c.pointerType == J,
          e = c.pointerType == L;if (d) this.mouse.allow = !1;else if (e && !this.mouse.allow) return;b & (Q | R) && (this.mouse.allow = !0), this.callback(a, b, c);
    }, destroy: function destroy() {
      this.touch.destroy(), this.mouse.destroy();
    } });var Hb = B(f.style, "touchAction"),
      Ib = Hb !== d,
      Jb = "compute",
      Kb = "auto",
      Lb = "manipulation",
      Mb = "none",
      Nb = "pan-x",
      Ob = "pan-y";Pb.prototype = { set: function set(a) {
      a == Jb && (a = this.compute()), Ib && (this.manager.element.style[Hb] = a), this.actions = a.toLowerCase().trim();
    }, update: function update() {
      this.set(this.manager.options.touchAction);
    }, compute: function compute() {
      var a = [];return m(this.manager.recognizers, function (b) {
        r(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()));
      }), Qb(a.join(" "));
    }, preventDefaults: function preventDefaults(a) {
      if (!Ib) {
        var b = a.srcEvent,
            c = a.offsetDirection;if (this.manager.session.prevented) return b.preventDefault(), void 0;var d = this.actions,
            e = w(d, Mb),
            f = w(d, Ob),
            g = w(d, Nb);return e || f && c & X || g && c & Y ? this.preventSrc(b) : void 0;
      }
    }, preventSrc: function preventSrc(a) {
      this.manager.session.prevented = !0, a.preventDefault();
    } };var Rb = 1,
      Sb = 2,
      Tb = 4,
      Ub = 8,
      Vb = Ub,
      Wb = 16,
      Xb = 32;Yb.prototype = { defaults: {}, set: function set(a) {
      return n(this.options, a), this.manager && this.manager.touchAction.update(), this;
    }, recognizeWith: function recognizeWith(a) {
      if (l(a, "recognizeWith", this)) return this;var b = this.simultaneous;return a = _b(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this;
    }, dropRecognizeWith: function dropRecognizeWith(a) {
      return l(a, "dropRecognizeWith", this) ? this : (a = _b(a, this), delete this.simultaneous[a.id], this);
    }, requireFailure: function requireFailure(a) {
      if (l(a, "requireFailure", this)) return this;var b = this.requireFail;return a = _b(a, this), -1 === y(b, a) && (b.push(a), a.requireFailure(this)), this;
    }, dropRequireFailure: function dropRequireFailure(a) {
      if (l(a, "dropRequireFailure", this)) return this;a = _b(a, this);var b = y(this.requireFail, a);return b > -1 && this.requireFail.splice(b, 1), this;
    }, hasRequireFailures: function hasRequireFailures() {
      return this.requireFail.length > 0;
    }, canRecognizeWith: function canRecognizeWith(a) {
      return !!this.simultaneous[a.id];
    }, emit: function emit(a) {
      function d(d) {
        b.manager.emit(b.options.event + (d ? Zb(c) : ""), a);
      }var b = this,
          c = this.state;Ub > c && d(!0), d(), c >= Ub && d(!0);
    }, tryEmit: function tryEmit(a) {
      return this.canEmit() ? this.emit(a) : (this.state = Xb, void 0);
    }, canEmit: function canEmit() {
      for (var a = 0; a < this.requireFail.length;) {
        if (!(this.requireFail[a].state & (Xb | Rb))) return !1;a++;
      }return !0;
    }, recognize: function recognize(a) {
      var b = n({}, a);return r(this.options.enable, [this, b]) ? (this.state & (Vb | Wb | Xb) && (this.state = Rb), this.state = this.process(b), this.state & (Sb | Tb | Ub | Wb) && this.tryEmit(b), void 0) : (this.reset(), this.state = Xb, void 0);
    }, process: function process() {}, getTouchAction: function getTouchAction() {}, reset: function reset() {} }, p(ac, Yb, { defaults: { pointers: 1 }, attrTest: function attrTest(a) {
      var b = this.options.pointers;return 0 === b || a.pointers.length === b;
    }, process: function process(a) {
      var b = this.state,
          c = a.eventType,
          d = b & (Sb | Tb),
          e = this.attrTest(a);return d && (c & R || !e) ? b | Wb : d || e ? c & Q ? b | Ub : b & Sb ? b | Tb : Sb : Xb;
    } }), p(bc, ac, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: Z }, getTouchAction: function getTouchAction() {
      var a = this.options.direction,
          b = [];return a & X && b.push(Ob), a & Y && b.push(Nb), b;
    }, directionTest: function directionTest(a) {
      var b = this.options,
          c = !0,
          d = a.distance,
          e = a.direction,
          f = a.deltaX,
          g = a.deltaY;return e & b.direction || (b.direction & X ? (e = 0 === f ? S : 0 > f ? T : U, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? S : 0 > g ? V : W, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction;
    }, attrTest: function attrTest(a) {
      return ac.prototype.attrTest.call(this, a) && (this.state & Sb || !(this.state & Sb) && this.directionTest(a));
    }, emit: function emit(a) {
      this.pX = a.deltaX, this.pY = a.deltaY;var b = $b(a.direction);b && this.manager.emit(this.options.event + b, a), this._super.emit.call(this, a);
    } }), p(cc, ac, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function getTouchAction() {
      return [Mb];
    }, attrTest: function attrTest(a) {
      return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & Sb);
    }, emit: function emit(a) {
      if (this._super.emit.call(this, a), 1 !== a.scale) {
        var b = a.scale < 1 ? "in" : "out";this.manager.emit(this.options.event + b, a);
      }
    } }), p(dc, Yb, { defaults: { event: "press", pointers: 1, time: 500, threshold: 5 }, getTouchAction: function getTouchAction() {
      return [Kb];
    }, process: function process(a) {
      var b = this.options,
          c = a.pointers.length === b.pointers,
          d = a.distance < b.threshold,
          e = a.deltaTime > b.time;if (this._input = a, !d || !c || a.eventType & (Q | R) && !e) this.reset();else if (a.eventType & O) this.reset(), this._timer = k(function () {
        this.state = Vb, this.tryEmit();
      }, b.time, this);else if (a.eventType & Q) return Vb;return Xb;
    }, reset: function reset() {
      clearTimeout(this._timer);
    }, emit: function emit(a) {
      this.state === Vb && (a && a.eventType & Q ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = j(), this.manager.emit(this.options.event, this._input)));
    } }), p(ec, ac, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function getTouchAction() {
      return [Mb];
    }, attrTest: function attrTest(a) {
      return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & Sb);
    } }), p(fc, ac, { defaults: { event: "swipe", threshold: 10, velocity: .65, direction: X | Y, pointers: 1 }, getTouchAction: function getTouchAction() {
      return bc.prototype.getTouchAction.call(this);
    }, attrTest: function attrTest(a) {
      var c,
          b = this.options.direction;return b & (X | Y) ? c = a.velocity : b & X ? c = a.velocityX : b & Y && (c = a.velocityY), this._super.attrTest.call(this, a) && b & a.direction && a.distance > this.options.threshold && i(c) > this.options.velocity && a.eventType & Q;
    }, emit: function emit(a) {
      var b = $b(a.direction);b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a);
    } }), p(gc, Yb, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 2, posThreshold: 10 }, getTouchAction: function getTouchAction() {
      return [Lb];
    }, process: function process(a) {
      var b = this.options,
          c = a.pointers.length === b.pointers,
          d = a.distance < b.threshold,
          e = a.deltaTime < b.time;if (this.reset(), a.eventType & O && 0 === this.count) return this.failTimeout();if (d && e && c) {
        if (a.eventType != Q) return this.failTimeout();var f = this.pTime ? a.timeStamp - this.pTime < b.interval : !0,
            g = !this.pCenter || kb(this.pCenter, a.center) < b.posThreshold;this.pTime = a.timeStamp, this.pCenter = a.center, g && f ? this.count += 1 : this.count = 1, this._input = a;var h = this.count % b.taps;if (0 === h) return this.hasRequireFailures() ? (this._timer = k(function () {
          this.state = Vb, this.tryEmit();
        }, b.interval, this), Sb) : Vb;
      }return Xb;
    }, failTimeout: function failTimeout() {
      return this._timer = k(function () {
        this.state = Xb;
      }, this.options.interval, this), Xb;
    }, reset: function reset() {
      clearTimeout(this._timer);
    }, emit: function emit() {
      this.state == Vb && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
    } }), hc.VERSION = "2.0.4", hc.defaults = { domEvents: !1, touchAction: Jb, enable: !0, inputTarget: null, inputClass: null, preset: [[ec, { enable: !1 }], [cc, { enable: !1 }, ["rotate"]], [fc, { direction: X }], [bc, { direction: X }, ["swipe"]], [gc], [gc, { event: "doubletap", taps: 2 }, ["tap"]], [dc]], cssProps: { userSelect: "default", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } };var ic = 1,
      jc = 2;kc.prototype = { set: function set(a) {
      return n(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this;
    }, stop: function stop(a) {
      this.session.stopped = a ? jc : ic;
    }, recognize: function recognize(a) {
      var b = this.session;if (!b.stopped) {
        this.touchAction.preventDefaults(a);var c,
            d = this.recognizers,
            e = b.curRecognizer;(!e || e && e.state & Vb) && (e = b.curRecognizer = null);for (var f = 0; f < d.length;) {
          c = d[f], b.stopped === jc || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (Sb | Tb | Ub) && (e = b.curRecognizer = c), f++;
        }
      }
    }, get: function get(a) {
      if (a instanceof Yb) return a;for (var b = this.recognizers, c = 0; c < b.length; c++) {
        if (b[c].options.event == a) return b[c];
      }return null;
    }, add: function add(a) {
      if (l(a, "add", this)) return this;var b = this.get(a.options.event);return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a;
    }, remove: function remove(a) {
      if (l(a, "remove", this)) return this;var b = this.recognizers;return a = this.get(a), b.splice(y(b, a), 1), this.touchAction.update(), this;
    }, on: function on(a, b) {
      var c = this.handlers;return m(x(a), function (a) {
        c[a] = c[a] || [], c[a].push(b);
      }), this;
    }, off: function off(a, b) {
      var c = this.handlers;return m(x(a), function (a) {
        b ? c[a].splice(y(c[a], b), 1) : delete c[a];
      }), this;
    }, emit: function emit(a, b) {
      this.options.domEvents && mc(a, b);var c = this.handlers[a] && this.handlers[a].slice();if (c && c.length) {
        b.type = a, b.preventDefault = function () {
          b.srcEvent.preventDefault();
        };for (var d = 0; d < c.length;) {
          c[d](b), d++;
        }
      }
    }, destroy: function destroy() {
      this.element && lc(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
    } }, n(hc, { INPUT_START: O, INPUT_MOVE: P, INPUT_END: Q, INPUT_CANCEL: R, STATE_POSSIBLE: Rb, STATE_BEGAN: Sb, STATE_CHANGED: Tb, STATE_ENDED: Ub, STATE_RECOGNIZED: Vb, STATE_CANCELLED: Wb, STATE_FAILED: Xb, DIRECTION_NONE: S, DIRECTION_LEFT: T, DIRECTION_RIGHT: U, DIRECTION_UP: V, DIRECTION_DOWN: W, DIRECTION_HORIZONTAL: X, DIRECTION_VERTICAL: Y, DIRECTION_ALL: Z, Manager: kc, Input: ab, TouchAction: Pb, TouchInput: Eb, MouseInput: rb, PointerEventInput: wb, TouchMouseInput: Gb, SingleTouchInput: Ab, Recognizer: Yb, AttrRecognizer: ac, Tap: gc, Pan: bc, Swipe: fc, Pinch: cc, Rotate: ec, Press: dc, on: t, off: u, each: m, merge: o, extend: n, inherit: p, bindFn: q, prefixed: B }), ( false ? 'undefined' : _typeof(__webpack_require__(3))) == g && __webpack_require__(4) ? !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    return hc;
  }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "undefined" != typeof module && module.exports ? module.exports = hc : a[c] = hc;
}(window, document, "Hammer");;(function (factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    factory(require('jquery'), require('hammerjs'));
  } else {
    factory(jQuery, Hammer);
  }
})(function ($, Hammer) {
  function hammerify(el, options) {
    var $el = $(el);
    if (!$el.data("hammer")) {
      $el.data("hammer", new Hammer($el[0], options));
    }
  }

  $.fn.hammer = function (options) {
    return this.each(function () {
      hammerify(this, options);
    });
  };

  // extend the emit method to also trigger jQuery events
  Hammer.Manager.prototype.emit = function (originalEmit) {
    return function (type, data) {
      originalEmit.call(this, type, data);
      $(this.element).trigger({
        type: type,
        gesture: data
      });
    };
  }(Hammer.Manager.prototype.emit);
});
; // Required for Meteor package, the use of window prevents export by Meteor
(function (window) {
  if (window.Package) {
    Materialize = {};
  } else {
    window.Materialize = {};
  }
})(window);

/*
 * raf.js
 * https://github.com/ngryman/raf.js
 *
 * original requestAnimationFrame polyfill by Erik Mller
 * inspired from paul_irish gist and post
 *
 * Copyright (c) 2013 ngryman
 * Licensed under the MIT license.
 */
(function (window) {
  var lastTime = 0,
      vendors = ['webkit', 'moz'],
      requestAnimationFrame = window.requestAnimationFrame,
      cancelAnimationFrame = window.cancelAnimationFrame,
      i = vendors.length;

  // try to un-prefix existing raf
  while (--i >= 0 && !requestAnimationFrame) {
    requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
    cancelAnimationFrame = window[vendors[i] + 'CancelRequestAnimationFrame'];
  }

  // polyfill with setTimeout fallback
  // heavily inspired from @darius gist mod: https://gist.github.com/paulirish/1579671#comment-837945
  if (!requestAnimationFrame || !cancelAnimationFrame) {
    requestAnimationFrame = function requestAnimationFrame(callback) {
      var now = +Date.now(),
          nextTime = Math.max(lastTime + 16, now);
      return setTimeout(function () {
        callback(lastTime = nextTime);
      }, nextTime - now);
    };

    cancelAnimationFrame = clearTimeout;
  }

  // export to window
  window.requestAnimationFrame = requestAnimationFrame;
  window.cancelAnimationFrame = cancelAnimationFrame;
})(window);

/**
 * Generate approximated selector string for a jQuery object
 * @param {jQuery} obj  jQuery object to be parsed
 * @returns {string}
 */
Materialize.objectSelectorString = function (obj) {
  var tagStr = obj.prop('tagName') || '';
  var idStr = obj.attr('id') || '';
  var classStr = obj.attr('class') || '';
  return (tagStr + idStr + classStr).replace(/\s/g, '');
};

// Unique Random ID
Materialize.guid = function () {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  }
  return function () {
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
  };
}();

/**
 * Escapes hash from special characters
 * @param {string} hash  String returned from this.hash
 * @returns {string}
 */
Materialize.escapeHash = function (hash) {
  return hash.replace(/(:|\.|\[|\]|,|=)/g, "\\$1");
};

Materialize.elementOrParentIsFixed = function (element) {
  var $element = $(element);
  var $checkElements = $element.add($element.parents());
  var isFixed = false;
  $checkElements.each(function () {
    if ($(this).css("position") === "fixed") {
      isFixed = true;
      return false;
    }
  });
  return isFixed;
};

/**
 * Get time in ms
 * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
 * @type {function}
 * @return {number}
 */
var getTime = Date.now || function () {
  return new Date().getTime();
};

/**
 * Returns a function, that, when invoked, will only be triggered at most once
 * during a given window of time. Normally, the throttled function will run
 * as much as it can, without ever going more than once per `wait` duration;
 * but if you'd like to disable the execution on the leading edge, pass
 * `{leading: false}`. To disable execution on the trailing edge, ditto.
 * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
 * @param {function} func
 * @param {number} wait
 * @param {Object=} options
 * @returns {Function}
 */
Materialize.throttle = function (func, wait, options) {
  var context, args, result;
  var timeout = null;
  var previous = 0;
  options || (options = {});
  var later = function later() {
    previous = options.leading === false ? 0 : getTime();
    timeout = null;
    result = func.apply(context, args);
    context = args = null;
  };
  return function () {
    var now = getTime();
    if (!previous && options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0) {
      clearTimeout(timeout);
      timeout = null;
      previous = now;
      result = func.apply(context, args);
      context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
};

// Velocity has conflicts when loaded with jQuery, this will check for it
// First, check if in noConflict mode
var Vel;
if (jQuery) {
  Vel = jQuery.Velocity;
} else if ($) {
  Vel = $.Velocity;
} else {
  Vel = Velocity;
}
;(function ($) {
  $.fn.collapsible = function (options, methodParam) {
    var defaults = {
      accordion: undefined,
      onOpen: undefined,
      onClose: undefined
    };

    var methodName = options;
    options = $.extend(defaults, options);

    return this.each(function () {

      var $this = $(this);

      var $panel_headers = $(this).find('> li > .collapsible-header');

      var collapsible_type = $this.data("collapsible");

      /****************
      Helper Functions
      ****************/

      // Accordion Open
      function accordionOpen(object) {
        $panel_headers = $this.find('> li > .collapsible-header');
        if (object.hasClass('active')) {
          object.parent().addClass('active');
        } else {
          object.parent().removeClass('active');
        }
        if (object.parent().hasClass('active')) {
          object.siblings('.collapsible-body').stop(true, false).slideDown({ duration: 350, easing: "easeOutQuart", queue: false, complete: function complete() {
              $(this).css('height', '');
            } });
        } else {
          object.siblings('.collapsible-body').stop(true, false).slideUp({ duration: 350, easing: "easeOutQuart", queue: false, complete: function complete() {
              $(this).css('height', '');
            } });
        }

        $panel_headers.not(object).removeClass('active').parent().removeClass('active');

        // Close previously open accordion elements.
        $panel_headers.not(object).parent().children('.collapsible-body').stop(true, false).each(function () {
          if ($(this).is(':visible')) {
            $(this).slideUp({
              duration: 350,
              easing: "easeOutQuart",
              queue: false,
              complete: function complete() {
                $(this).css('height', '');
                execCallbacks($(this).siblings('.collapsible-header'));
              }
            });
          }
        });
      }

      // Expandable Open
      function expandableOpen(object) {
        if (object.hasClass('active')) {
          object.parent().addClass('active');
        } else {
          object.parent().removeClass('active');
        }
        if (object.parent().hasClass('active')) {
          object.siblings('.collapsible-body').stop(true, false).slideDown({ duration: 350, easing: "easeOutQuart", queue: false, complete: function complete() {
              $(this).css('height', '');
            } });
        } else {
          object.siblings('.collapsible-body').stop(true, false).slideUp({ duration: 350, easing: "easeOutQuart", queue: false, complete: function complete() {
              $(this).css('height', '');
            } });
        }
      }

      // Open collapsible. object: .collapsible-header
      function collapsibleOpen(object, noToggle) {
        if (!noToggle) {
          object.toggleClass('active');
        }

        if (options.accordion || collapsible_type === "accordion" || collapsible_type === undefined) {
          // Handle Accordion
          accordionOpen(object);
        } else {
          // Handle Expandables
          expandableOpen(object);
        }

        execCallbacks(object);
      }

      // Handle callbacks
      function execCallbacks(object) {
        if (object.hasClass('active')) {
          if (typeof options.onOpen === "function") {
            options.onOpen.call(this, object.parent());
          }
        } else {
          if (typeof options.onClose === "function") {
            options.onClose.call(this, object.parent());
          }
        }
      }

      /**
       * Check if object is children of panel header
       * @param  {Object}  object Jquery object
       * @return {Boolean} true if it is children
       */
      function isChildrenOfPanelHeader(object) {

        var panelHeader = getPanelHeader(object);

        return panelHeader.length > 0;
      }

      /**
       * Get panel header from a children element
       * @param  {Object} object Jquery object
       * @return {Object} panel header object
       */
      function getPanelHeader(object) {

        return object.closest('li > .collapsible-header');
      }

      // Turn off any existing event handlers
      function removeEventHandlers() {
        $this.off('click.collapse', '> li > .collapsible-header');
      }

      /*****  End Helper Functions  *****/

      // Methods
      if (methodName === 'destroy') {
        removeEventHandlers();
        return;
      } else if (methodParam >= 0 && methodParam < $panel_headers.length) {
        var $curr_header = $panel_headers.eq(methodParam);
        if ($curr_header.length && (methodName === 'open' || methodName === 'close' && $curr_header.hasClass('active'))) {
          collapsibleOpen($curr_header);
        }
        return;
      }

      removeEventHandlers();

      // Add click handler to only direct collapsible header children
      $this.on('click.collapse', '> li > .collapsible-header', function (e) {
        var element = $(e.target);

        if (isChildrenOfPanelHeader(element)) {
          element = getPanelHeader(element);
        }

        collapsibleOpen(element);
      });

      // Open first active
      if (options.accordion || collapsible_type === "accordion" || collapsible_type === undefined) {
        // Handle Accordion
        collapsibleOpen($panel_headers.filter('.active').first(), true);
      } else {
        // Handle Expandables
        $panel_headers.filter('.active').each(function () {
          collapsibleOpen($(this), true);
        });
      }
    });
  };

  $(document).ready(function () {
    $('.collapsible').collapsible();
  });
})(jQuery);;(function ($) {

  // Add posibility to scroll to selected option
  // usefull for select for example
  $.fn.scrollTo = function (elem) {
    $(this).scrollTop($(this).scrollTop() - $(this).offset().top + $(elem).offset().top);
    return this;
  };

  $.fn.dropdown = function (options) {
    var defaults = {
      inDuration: 300,
      outDuration: 225,
      constrainWidth: true, // Constrains width of dropdown to the activator
      hover: false,
      gutter: 0, // Spacing from edge
      belowOrigin: false,
      alignment: 'left',
      stopPropagation: false
    };

    // Open dropdown.
    if (options === "open") {
      this.each(function () {
        $(this).trigger('open');
      });
      return false;
    }

    // Close dropdown.
    if (options === "close") {
      this.each(function () {
        $(this).trigger('close');
      });
      return false;
    }

    this.each(function () {
      var origin = $(this);
      var curr_options = $.extend({}, defaults, options);
      var isFocused = false;

      // Dropdown menu
      var activates = $("#" + origin.attr('data-activates'));

      function updateOptions() {
        if (origin.data('induration') !== undefined) curr_options.inDuration = origin.data('induration');
        if (origin.data('outduration') !== undefined) curr_options.outDuration = origin.data('outduration');
        if (origin.data('constrainwidth') !== undefined) curr_options.constrainWidth = origin.data('constrainwidth');
        if (origin.data('hover') !== undefined) curr_options.hover = origin.data('hover');
        if (origin.data('gutter') !== undefined) curr_options.gutter = origin.data('gutter');
        if (origin.data('beloworigin') !== undefined) curr_options.belowOrigin = origin.data('beloworigin');
        if (origin.data('alignment') !== undefined) curr_options.alignment = origin.data('alignment');
        if (origin.data('stoppropagation') !== undefined) curr_options.stopPropagation = origin.data('stoppropagation');
      }

      updateOptions();

      // Attach dropdown to its activator
      origin.after(activates);

      /*
        Helper function to position and resize dropdown.
        Used in hover and click handler.
      */
      function placeDropdown(eventType) {
        // Check for simultaneous focus and click events.
        if (eventType === 'focus') {
          isFocused = true;
        }

        // Check html data attributes
        updateOptions();

        // Set Dropdown state
        activates.addClass('active');
        origin.addClass('active');

        // Constrain width
        if (curr_options.constrainWidth === true) {
          activates.css('width', origin.outerWidth());
        } else {
          activates.css('white-space', 'nowrap');
        }

        // Offscreen detection
        var windowHeight = window.innerHeight;
        var originHeight = origin.innerHeight();
        var offsetLeft = origin.offset().left;
        var offsetTop = origin.offset().top - $(window).scrollTop();
        var currAlignment = curr_options.alignment;
        var gutterSpacing = 0;
        var leftPosition = 0;

        // Below Origin
        var verticalOffset = 0;
        if (curr_options.belowOrigin === true) {
          verticalOffset = originHeight;
        }

        // Check for scrolling positioned container.
        var scrollYOffset = 0;
        var scrollXOffset = 0;
        var wrapper = origin.parent();
        if (!wrapper.is('body')) {
          if (wrapper[0].scrollHeight > wrapper[0].clientHeight) {
            scrollYOffset = wrapper[0].scrollTop;
          }
          if (wrapper[0].scrollWidth > wrapper[0].clientWidth) {
            scrollXOffset = wrapper[0].scrollLeft;
          }
        }

        if (offsetLeft + activates.innerWidth() > $(window).width()) {
          // Dropdown goes past screen on right, force right alignment
          currAlignment = 'right';
        } else if (offsetLeft - activates.innerWidth() + origin.innerWidth() < 0) {
          // Dropdown goes past screen on left, force left alignment
          currAlignment = 'left';
        }
        // Vertical bottom offscreen detection
        if (offsetTop + activates.innerHeight() > windowHeight) {
          // If going upwards still goes offscreen, just crop height of dropdown.
          if (offsetTop + originHeight - activates.innerHeight() < 0) {
            var adjustedHeight = windowHeight - offsetTop - verticalOffset;
            activates.css('max-height', adjustedHeight);
          } else {
            // Flow upwards.
            if (!verticalOffset) {
              verticalOffset += originHeight;
            }
            verticalOffset -= activates.innerHeight();
          }
        }

        // Handle edge alignment
        if (currAlignment === 'left') {
          gutterSpacing = curr_options.gutter;
          leftPosition = origin.position().left + gutterSpacing;
        } else if (currAlignment === 'right') {
          var offsetRight = origin.position().left + origin.outerWidth() - activates.outerWidth();
          gutterSpacing = -curr_options.gutter;
          leftPosition = offsetRight + gutterSpacing;
        }

        // Position dropdown
        activates.css({
          position: 'absolute',
          top: origin.position().top + verticalOffset + scrollYOffset,
          left: leftPosition + scrollXOffset
        });

        // Show dropdown
        activates.stop(true, true).css('opacity', 0).slideDown({
          queue: false,
          duration: curr_options.inDuration,
          easing: 'easeOutCubic',
          complete: function complete() {
            $(this).css('height', '');
          }
        }).animate({ opacity: 1 }, { queue: false, duration: curr_options.inDuration, easing: 'easeOutSine' });

        // Add click close handler to document
        setTimeout(function () {
          $(document).bind('click.' + activates.attr('id'), function (e) {
            hideDropdown();
            $(document).unbind('click.' + activates.attr('id'));
          });
        }, 0);
      }

      function hideDropdown() {
        // Check for simultaneous focus and click events.
        isFocused = false;
        activates.fadeOut(curr_options.outDuration);
        activates.removeClass('active');
        origin.removeClass('active');
        $(document).unbind('click.' + activates.attr('id'));
        setTimeout(function () {
          activates.css('max-height', '');
        }, curr_options.outDuration);
      }

      // Hover
      if (curr_options.hover) {
        var open = false;
        origin.unbind('click.' + origin.attr('id'));
        // Hover handler to show dropdown
        origin.on('mouseenter', function (e) {
          // Mouse over
          if (open === false) {
            placeDropdown();
            open = true;
          }
        });
        origin.on('mouseleave', function (e) {
          // If hover on origin then to something other than dropdown content, then close
          var toEl = e.toElement || e.relatedTarget; // added browser compatibility for target element
          if (!$(toEl).closest('.dropdown-content').is(activates)) {
            activates.stop(true, true);
            hideDropdown();
            open = false;
          }
        });

        activates.on('mouseleave', function (e) {
          // Mouse out
          var toEl = e.toElement || e.relatedTarget;
          if (!$(toEl).closest('.dropdown-button').is(origin)) {
            activates.stop(true, true);
            hideDropdown();
            open = false;
          }
        });

        // Click
      } else {
        // Click handler to show dropdown
        origin.unbind('click.' + origin.attr('id'));
        origin.bind('click.' + origin.attr('id'), function (e) {
          if (!isFocused) {
            if (origin[0] == e.currentTarget && !origin.hasClass('active') && $(e.target).closest('.dropdown-content').length === 0) {
              e.preventDefault(); // Prevents button click from moving window
              if (curr_options.stopPropagation) {
                e.stopPropagation();
              }
              placeDropdown('click');
            }
            // If origin is clicked and menu is open, close menu
            else if (origin.hasClass('active')) {
                hideDropdown();
                $(document).unbind('click.' + activates.attr('id'));
              }
          }
        });
      } // End else

      // Listen to open and close event - useful for select component
      origin.on('open', function (e, eventType) {
        placeDropdown(eventType);
      });
      origin.on('close', hideDropdown);
    });
  }; // End dropdown plugin

  $(document).ready(function () {
    $('.dropdown-button').dropdown();
  });
})(jQuery);
;(function ($) {
  var _stack = 0,
      _lastID = 0,
      _generateID = function _generateID() {
    _lastID++;
    return 'materialize-modal-overlay-' + _lastID;
  };

  var methods = {
    init: function init(options) {
      var defaults = {
        opacity: 0.5,
        inDuration: 350,
        outDuration: 250,
        ready: undefined,
        complete: undefined,
        dismissible: true,
        startingTop: '4%',
        endingTop: '10%'
      };

      // Override defaults
      options = $.extend(defaults, options);

      return this.each(function () {
        var $modal = $(this);
        var modal_id = $(this).attr("id") || '#' + $(this).data('target');

        var closeModal = function closeModal() {
          var overlayID = $modal.data('overlay-id');
          var $overlay = $('#' + overlayID);
          $modal.removeClass('open');

          // Enable scrolling
          $('body').css({
            overflow: '',
            width: ''
          });

          $modal.find('.modal-close').off('click.close');
          $(document).off('keyup.modal' + overlayID);

          $overlay.velocity({ opacity: 0 }, { duration: options.outDuration, queue: false, ease: "easeOutQuart" });

          // Define Bottom Sheet animation
          var exitVelocityOptions = {
            duration: options.outDuration,
            queue: false,
            ease: "easeOutCubic",
            // Handle modal ready callback
            complete: function complete() {
              $(this).css({ display: "none" });

              // Call complete callback
              if (typeof options.complete === "function") {
                options.complete.call(this, $modal);
              }
              $overlay.remove();
              _stack--;
            }
          };
          if ($modal.hasClass('bottom-sheet')) {
            $modal.velocity({ bottom: "-100%", opacity: 0 }, exitVelocityOptions);
          } else {
            $modal.velocity({ top: options.startingTop, opacity: 0, scaleX: 0.7 }, exitVelocityOptions);
          }
        };

        var openModal = function openModal($trigger) {
          var $body = $('body');
          var oldWidth = $body.innerWidth();
          $body.css('overflow', 'hidden');
          $body.width(oldWidth);

          if ($modal.hasClass('open')) {
            return;
          }

          var overlayID = _generateID();
          var $overlay = $('<div class="modal-overlay"></div>');
          lStack = ++_stack;

          // Store a reference of the overlay
          $overlay.attr('id', overlayID).css('z-index', 1000 + lStack * 2);
          $modal.data('overlay-id', overlayID).css('z-index', 1000 + lStack * 2 + 1);
          $modal.addClass('open');

          $("body").append($overlay);

          if (options.dismissible) {
            $overlay.click(function () {
              closeModal();
            });
            // Return on ESC
            $(document).on('keyup.modal' + overlayID, function (e) {
              if (e.keyCode === 27) {
                // ESC key
                closeModal();
              }
            });
          }

          $modal.find(".modal-close").on('click.close', function (e) {
            closeModal();
          });

          $overlay.css({ display: "block", opacity: 0 });

          $modal.css({
            display: "block",
            opacity: 0
          });

          $overlay.velocity({ opacity: options.opacity }, { duration: options.inDuration, queue: false, ease: "easeOutCubic" });
          $modal.data('associated-overlay', $overlay[0]);

          // Define Bottom Sheet animation
          var enterVelocityOptions = {
            duration: options.inDuration,
            queue: false,
            ease: "easeOutCubic",
            // Handle modal ready callback
            complete: function complete() {
              if (typeof options.ready === "function") {
                options.ready.call(this, $modal, $trigger);
              }
            }
          };
          if ($modal.hasClass('bottom-sheet')) {
            $modal.velocity({ bottom: "0", opacity: 1 }, enterVelocityOptions);
          } else {
            $.Velocity.hook($modal, "scaleX", 0.7);
            $modal.css({ top: options.startingTop });
            $modal.velocity({ top: options.endingTop, opacity: 1, scaleX: '1' }, enterVelocityOptions);
          }
        };

        // Reset handlers
        $(document).off('click.modalTrigger', 'a[href="#' + modal_id + '"], [data-target="' + modal_id + '"]');
        $(this).off('openModal');
        $(this).off('closeModal');

        // Close Handlers
        $(document).on('click.modalTrigger', 'a[href="#' + modal_id + '"], [data-target="' + modal_id + '"]', function (e) {
          options.startingTop = ($(this).offset().top - $(window).scrollTop()) / 1.15;
          openModal($(this));
          e.preventDefault();
        }); // done set on click

        $(this).on('openModal', function () {
          var modal_id = $(this).attr("href") || '#' + $(this).data('target');
          openModal();
        });

        $(this).on('closeModal', function () {
          closeModal();
        });
      }); // done return
    },
    open: function open() {
      $(this).trigger('openModal');
    },
    close: function close() {
      $(this).trigger('closeModal');
    }
  };

  $.fn.modal = function (methodOrOptions) {
    if (methods[methodOrOptions]) {
      return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if ((typeof methodOrOptions === 'undefined' ? 'undefined' : _typeof(methodOrOptions)) === 'object' || !methodOrOptions) {
      // Default to "init"
      return methods.init.apply(this, arguments);
    } else {
      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.modal');
    }
  };
})(jQuery);
;(function ($) {

  $.fn.materialbox = function () {

    return this.each(function () {

      if ($(this).hasClass('initialized')) {
        return;
      }

      $(this).addClass('initialized');

      var overlayActive = false;
      var doneAnimating = true;
      var inDuration = 275;
      var outDuration = 200;
      var origin = $(this);
      var placeholder = $('<div></div>').addClass('material-placeholder');
      var originalWidth = 0;
      var originalHeight = 0;
      var ancestorsChanged;
      var ancestor;
      var originInlineStyles = origin.attr('style');
      origin.wrap(placeholder);

      origin.on('click', function () {
        var placeholder = origin.parent('.material-placeholder');
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;
        var originalWidth = origin.width();
        var originalHeight = origin.height();

        // If already modal, return to original
        if (doneAnimating === false) {
          returnToOriginal();
          return false;
        } else if (overlayActive && doneAnimating === true) {
          returnToOriginal();
          return false;
        }

        // Set states
        doneAnimating = false;
        origin.addClass('active');
        overlayActive = true;

        // Set positioning for placeholder
        placeholder.css({
          width: placeholder[0].getBoundingClientRect().width,
          height: placeholder[0].getBoundingClientRect().height,
          position: 'relative',
          top: 0,
          left: 0
        });

        // Find ancestor with overflow: hidden; and remove it
        ancestorsChanged = undefined;
        ancestor = placeholder[0].parentNode;
        var count = 0;
        while (ancestor !== null && !$(ancestor).is(document)) {
          var curr = $(ancestor);
          if (curr.css('overflow') !== 'visible') {
            curr.css('overflow', 'visible');
            if (ancestorsChanged === undefined) {
              ancestorsChanged = curr;
            } else {
              ancestorsChanged = ancestorsChanged.add(curr);
            }
          }
          ancestor = ancestor.parentNode;
        }

        // Set css on origin
        origin.css({
          position: 'absolute',
          'z-index': 1000,
          'will-change': 'left, top, width, height'
        }).data('width', originalWidth).data('height', originalHeight);

        // Add overlay
        var overlay = $('<div id="materialbox-overlay"></div>').css({
          opacity: 0
        }).click(function () {
          if (doneAnimating === true) returnToOriginal();
        });

        // Put before in origin image to preserve z-index layering.
        origin.before(overlay);

        // Set dimensions if needed
        var overlayOffset = overlay[0].getBoundingClientRect();
        overlay.css({
          width: windowWidth,
          height: windowHeight,
          left: -1 * overlayOffset.left,
          top: -1 * overlayOffset.top
        });

        // Animate Overlay
        overlay.velocity({ opacity: 1 }, { duration: inDuration, queue: false, easing: 'easeOutQuad' });

        // Add and animate caption if it exists
        if (origin.data('caption') !== "") {
          var $photo_caption = $('<div class="materialbox-caption"></div>');
          $photo_caption.text(origin.data('caption'));
          $('body').append($photo_caption);
          $photo_caption.css({ "display": "inline" });
          $photo_caption.velocity({ opacity: 1 }, { duration: inDuration, queue: false, easing: 'easeOutQuad' });
        }

        // Resize Image
        var ratio = 0;
        var widthPercent = originalWidth / windowWidth;
        var heightPercent = originalHeight / windowHeight;
        var newWidth = 0;
        var newHeight = 0;

        if (widthPercent > heightPercent) {
          ratio = originalHeight / originalWidth;
          newWidth = windowWidth * 0.9;
          newHeight = windowWidth * 0.9 * ratio;
        } else {
          ratio = originalWidth / originalHeight;
          newWidth = windowHeight * 0.9 * ratio;
          newHeight = windowHeight * 0.9;
        }

        // Animate image + set z-index
        if (origin.hasClass('responsive-img')) {
          origin.velocity({ 'max-width': newWidth, 'width': originalWidth }, { duration: 0, queue: false,
            complete: function complete() {
              origin.css({ left: 0, top: 0 }).velocity({
                height: newHeight,
                width: newWidth,
                left: $(document).scrollLeft() + windowWidth / 2 - origin.parent('.material-placeholder').offset().left - newWidth / 2,
                top: $(document).scrollTop() + windowHeight / 2 - origin.parent('.material-placeholder').offset().top - newHeight / 2
              }, {
                duration: inDuration,
                queue: false,
                easing: 'easeOutQuad',
                complete: function complete() {
                  doneAnimating = true;
                }
              });
            } // End Complete
          }); // End Velocity
        } else {
          origin.css('left', 0).css('top', 0).velocity({
            height: newHeight,
            width: newWidth,
            left: $(document).scrollLeft() + windowWidth / 2 - origin.parent('.material-placeholder').offset().left - newWidth / 2,
            top: $(document).scrollTop() + windowHeight / 2 - origin.parent('.material-placeholder').offset().top - newHeight / 2
          }, {
            duration: inDuration,
            queue: false,
            easing: 'easeOutQuad',
            complete: function complete() {
              doneAnimating = true;
            }
          }); // End Velocity
        }
      }); // End origin on click


      // Return on scroll
      $(window).scroll(function () {
        if (overlayActive) {
          returnToOriginal();
        }
      });

      // Return on ESC
      $(document).keyup(function (e) {

        if (e.keyCode === 27 && doneAnimating === true) {
          // ESC key
          if (overlayActive) {
            returnToOriginal();
          }
        }
      });

      // This function returns the modaled image to the original spot
      function returnToOriginal() {

        doneAnimating = false;

        var placeholder = origin.parent('.material-placeholder');
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;
        var originalWidth = origin.data('width');
        var originalHeight = origin.data('height');

        origin.velocity("stop", true);
        $('#materialbox-overlay').velocity("stop", true);
        $('.materialbox-caption').velocity("stop", true);

        $('#materialbox-overlay').velocity({ opacity: 0 }, {
          duration: outDuration, // Delay prevents animation overlapping
          queue: false, easing: 'easeOutQuad',
          complete: function complete() {
            // Remove Overlay
            overlayActive = false;
            $(this).remove();
          }
        });

        // Resize Image
        origin.velocity({
          width: originalWidth,
          height: originalHeight,
          left: 0,
          top: 0
        }, {
          duration: outDuration,
          queue: false, easing: 'easeOutQuad',
          complete: function complete() {
            placeholder.css({
              height: '',
              width: '',
              position: '',
              top: '',
              left: ''
            });

            origin.removeAttr('style');
            origin.attr('style', originInlineStyles);

            // Remove class
            origin.removeClass('active');
            doneAnimating = true;

            // Remove overflow overrides on ancestors
            if (ancestorsChanged) {
              ancestorsChanged.css('overflow', '');
            }
          }
        });

        // Remove Caption + reset css settings on image
        $('.materialbox-caption').velocity({ opacity: 0 }, {
          duration: outDuration, // Delay prevents animation overlapping
          queue: false, easing: 'easeOutQuad',
          complete: function complete() {
            $(this).remove();
          }
        });
      }
    });
  };

  $(document).ready(function () {
    $('.materialboxed').materialbox();
  });
})(jQuery);
;(function ($) {

  $.fn.parallax = function () {
    var window_width = $(window).width();
    // Parallax Scripts
    return this.each(function (i) {
      var $this = $(this);
      $this.addClass('parallax');

      function updateParallax(initial) {
        var container_height;
        if (window_width < 601) {
          container_height = $this.height() > 0 ? $this.height() : $this.children("img").height();
        } else {
          container_height = $this.height() > 0 ? $this.height() : 500;
        }
        var $img = $this.children("img").first();
        var img_height = $img.height();
        var parallax_dist = img_height - container_height;
        var bottom = $this.offset().top + container_height;
        var top = $this.offset().top;
        var scrollTop = $(window).scrollTop();
        var windowHeight = window.innerHeight;
        var windowBottom = scrollTop + windowHeight;
        var percentScrolled = (windowBottom - top) / (container_height + windowHeight);
        var parallax = Math.round(parallax_dist * percentScrolled);

        if (initial) {
          $img.css('display', 'block');
        }
        if (bottom > scrollTop && top < scrollTop + windowHeight) {
          $img.css('transform', "translate3D(-50%," + parallax + "px, 0)");
        }
      }

      // Wait for image load
      $this.children("img").one("load", function () {
        updateParallax(true);
      }).each(function () {
        if (this.complete) $(this).trigger("load");
      });

      $(window).scroll(function () {
        window_width = $(window).width();
        updateParallax(false);
      });

      $(window).resize(function () {
        window_width = $(window).width();
        updateParallax(false);
      });
    });
  };
})(jQuery);
;(function ($) {

  var methods = {
    init: function init(options) {
      var defaults = {
        onShow: null,
        swipeable: false,
        responsiveThreshold: Infinity // breakpoint for swipeable
      };
      options = $.extend(defaults, options);
      var namespace = Materialize.objectSelectorString($(this));

      return this.each(function (i) {

        var uniqueNamespace = namespace + i;

        // For each set of tabs, we want to keep track of
        // which tab is active and its associated content
        var $this = $(this),
            window_width = $(window).width();

        var $active,
            $content,
            $links = $this.find('li.tab a'),
            $tabs_width = $this.width(),
            $tabs_content = $(),
            $tabs_wrapper,
            $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length,
            $indicator,
            index = prev_index = 0,
            clicked = false,
            clickedTimeout,
            transition = 300;

        // Finds right attribute for indicator based on active tab.
        // el: jQuery Object
        var calcRightPos = function calcRightPos(el) {
          return Math.ceil($tabs_width - el.position().left - el.outerWidth() - $this.scrollLeft());
        };

        // Finds left attribute for indicator based on active tab.
        // el: jQuery Object
        var calcLeftPos = function calcLeftPos(el) {
          return Math.floor(el.position().left + $this.scrollLeft());
        };

        // Animates Indicator to active tab.
        // prev_index: Number
        var animateIndicator = function animateIndicator(prev_index) {
          if (index - prev_index >= 0) {
            $indicator.velocity({ "right": calcRightPos($active) }, { duration: transition, queue: false, easing: 'easeOutQuad' });
            $indicator.velocity({ "left": calcLeftPos($active) }, { duration: transition, queue: false, easing: 'easeOutQuad', delay: 90 });
          } else {
            $indicator.velocity({ "left": calcLeftPos($active) }, { duration: transition, queue: false, easing: 'easeOutQuad' });
            $indicator.velocity({ "right": calcRightPos($active) }, { duration: transition, queue: false, easing: 'easeOutQuad', delay: 90 });
          }
        };

        // Change swipeable according to responsive threshold
        if (options.swipeable) {
          if (window_width > options.responsiveThreshold) {
            options.swipeable = false;
          }
        }

        // If the location.hash matches one of the links, use that as the active tab.
        $active = $($links.filter('[href="' + location.hash + '"]'));

        // If no match is found, use the first link or any with class 'active' as the initial active tab.
        if ($active.length === 0) {
          $active = $(this).find('li.tab a.active').first();
        }
        if ($active.length === 0) {
          $active = $(this).find('li.tab a').first();
        }

        $active.addClass('active');
        index = $links.index($active);
        if (index < 0) {
          index = 0;
        }

        if ($active[0] !== undefined) {
          $content = $($active[0].hash);
          $content.addClass('active');
        }

        // append indicator then set indicator width to tab width
        if (!$this.find('.indicator').length) {
          $this.append('<div class="indicator"></div>');
        }
        $indicator = $this.find('.indicator');

        // we make sure that the indicator is at the end of the tabs
        $this.append($indicator);

        if ($this.is(":visible")) {
          // $indicator.css({"right": $tabs_width - ((index + 1) * $tab_width)});
          // $indicator.css({"left": index * $tab_width});
          setTimeout(function () {
            $indicator.css({ "right": calcRightPos($active) });
            $indicator.css({ "left": calcLeftPos($active) });
          }, 0);
        }
        $(window).off('resize.tabs-' + uniqueNamespace).on('resize.tabs-' + uniqueNamespace, function () {
          $tabs_width = $this.width();
          $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;
          if (index < 0) {
            index = 0;
          }
          if ($tab_width !== 0 && $tabs_width !== 0) {
            $indicator.css({ "right": calcRightPos($active) });
            $indicator.css({ "left": calcLeftPos($active) });
          }
        });

        // Initialize Tabs Content.
        if (options.swipeable) {
          // TODO: Duplicate calls with swipeable? handle multiple div wrapping.
          $links.each(function () {
            var $curr_content = $(Materialize.escapeHash(this.hash));
            $curr_content.addClass('carousel-item');
            $tabs_content = $tabs_content.add($curr_content);
          });
          $tabs_wrapper = $tabs_content.wrapAll('<div class="tabs-content carousel"></div>');
          $tabs_content.css('display', '');
          $('.tabs-content.carousel').carousel({
            fullWidth: true,
            noWrap: true,
            onCycleTo: function onCycleTo(item) {
              if (!clicked) {
                var prev_index = index;
                index = $tabs_wrapper.index(item);
                $active = $links.eq(index);
                animateIndicator(prev_index);
              }
            }
          });
        } else {
          // Hide the remaining content
          $links.not($active).each(function () {
            $(Materialize.escapeHash(this.hash)).hide();
          });
        }

        // Bind the click event handler
        $this.off('click.tabs').on('click.tabs', 'a', function (e) {
          if ($(this).parent().hasClass('disabled')) {
            e.preventDefault();
            return;
          }

          // Act as regular link if target attribute is specified.
          if (!!$(this).attr("target")) {
            return;
          }

          clicked = true;
          $tabs_width = $this.width();
          $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;

          // Make the old tab inactive.
          $active.removeClass('active');
          var $oldContent = $content;

          // Update the variables with the new link and content
          $active = $(this);
          $content = $(Materialize.escapeHash(this.hash));
          $links = $this.find('li.tab a');
          var activeRect = $active.position();

          // Make the tab active.
          $active.addClass('active');
          prev_index = index;
          index = $links.index($(this));
          if (index < 0) {
            index = 0;
          }
          // Change url to current tab
          // window.location.hash = $active.attr('href');

          // Swap content
          if (options.swipeable) {
            if ($tabs_content.length) {
              $tabs_content.carousel('set', index);
            }
          } else {
            if ($content !== undefined) {
              $content.show();
              $content.addClass('active');
              if (typeof options.onShow === "function") {
                options.onShow.call(this, $content);
              }
            }

            if ($oldContent !== undefined && !$oldContent.is($content)) {
              $oldContent.hide();
              $oldContent.removeClass('active');
            }
          }

          // Reset clicked state
          clickedTimeout = setTimeout(function () {
            clicked = false;
          }, transition);

          // Update indicator
          animateIndicator(prev_index);

          // Prevent the anchor's default click action
          e.preventDefault();
        });
      });
    },
    select_tab: function select_tab(id) {
      this.find('a[href="#' + id + '"]').trigger('click');
    }
  };

  $.fn.tabs = function (methodOrOptions) {
    if (methods[methodOrOptions]) {
      return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if ((typeof methodOrOptions === 'undefined' ? 'undefined' : _typeof(methodOrOptions)) === 'object' || !methodOrOptions) {
      // Default to "init"
      return methods.init.apply(this, arguments);
    } else {
      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.tabs');
    }
  };

  $(document).ready(function () {
    $('ul.tabs').tabs();
  });
})(jQuery);
;(function ($) {
  $.fn.tooltip = function (options) {
    var timeout = null,
        margin = 5;

    // Defaults
    var defaults = {
      delay: 350,
      tooltip: '',
      position: 'bottom',
      html: false
    };

    // Remove tooltip from the activator
    if (options === "remove") {
      this.each(function () {
        $('#' + $(this).attr('data-tooltip-id')).remove();
        $(this).off('mouseenter.tooltip mouseleave.tooltip');
      });
      return false;
    }

    options = $.extend(defaults, options);

    return this.each(function () {
      var tooltipId = Materialize.guid();
      var origin = $(this);

      // Destroy old tooltip
      if (origin.attr('data-tooltip-id')) {
        $('#' + origin.attr('data-tooltip-id')).remove();
      }

      origin.attr('data-tooltip-id', tooltipId);

      // Get attributes.
      var allowHtml, tooltipDelay, tooltipPosition, tooltipText, tooltipEl, backdrop;
      var setAttributes = function setAttributes() {
        allowHtml = origin.attr('data-html') ? origin.attr('data-html') === 'true' : options.html;
        tooltipDelay = origin.attr('data-delay');
        tooltipDelay = tooltipDelay === undefined || tooltipDelay === '' ? options.delay : tooltipDelay;
        tooltipPosition = origin.attr('data-position');
        tooltipPosition = tooltipPosition === undefined || tooltipPosition === '' ? options.position : tooltipPosition;
        tooltipText = origin.attr('data-tooltip');
        tooltipText = tooltipText === undefined || tooltipText === '' ? options.tooltip : tooltipText;
      };
      setAttributes();

      var renderTooltipEl = function renderTooltipEl() {
        var tooltip = $('<div class="material-tooltip"></div>');

        // Create Text span
        if (allowHtml) {
          tooltipText = $('<span></span>').html(tooltipText);
        } else {
          tooltipText = $('<span></span>').text(tooltipText);
        }

        // Create tooltip
        tooltip.append(tooltipText).appendTo($('body')).attr('id', tooltipId);

        // Create backdrop
        backdrop = $('<div class="backdrop"></div>');
        backdrop.appendTo(tooltip);
        return tooltip;
      };
      tooltipEl = renderTooltipEl();

      // Destroy previously binded events
      origin.off('mouseenter.tooltip mouseleave.tooltip');
      // Mouse In
      var started = false,
          timeoutRef;
      origin.on({ 'mouseenter.tooltip': function mouseenterTooltip(e) {
          var showTooltip = function showTooltip() {
            setAttributes();
            started = true;
            tooltipEl.velocity('stop');
            backdrop.velocity('stop');
            tooltipEl.css({ visibility: 'visible', left: '0px', top: '0px' });

            // Tooltip positioning
            var originWidth = origin.outerWidth();
            var originHeight = origin.outerHeight();
            var tooltipHeight = tooltipEl.outerHeight();
            var tooltipWidth = tooltipEl.outerWidth();
            var tooltipVerticalMovement = '0px';
            var tooltipHorizontalMovement = '0px';
            var backdropOffsetWidth = backdrop[0].offsetWidth;
            var backdropOffsetHeight = backdrop[0].offsetHeight;
            var scaleXFactor = 8;
            var scaleYFactor = 8;
            var scaleFactor = 0;
            var targetTop, targetLeft, newCoordinates;

            if (tooltipPosition === "top") {
              // Top Position
              targetTop = origin.offset().top - tooltipHeight - margin;
              targetLeft = origin.offset().left + originWidth / 2 - tooltipWidth / 2;
              newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
              tooltipVerticalMovement = '-10px';
              backdrop.css({
                bottom: 0,
                left: 0,
                borderRadius: '14px 14px 0 0',
                transformOrigin: '50% 100%',
                marginTop: tooltipHeight,
                marginLeft: tooltipWidth / 2 - backdropOffsetWidth / 2
              });
            }
            // Left Position
            else if (tooltipPosition === "left") {
                targetTop = origin.offset().top + originHeight / 2 - tooltipHeight / 2;
                targetLeft = origin.offset().left - tooltipWidth - margin;
                newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);

                tooltipHorizontalMovement = '-10px';
                backdrop.css({
                  top: '-7px',
                  right: 0,
                  width: '14px',
                  height: '14px',
                  borderRadius: '14px 0 0 14px',
                  transformOrigin: '95% 50%',
                  marginTop: tooltipHeight / 2,
                  marginLeft: tooltipWidth
                });
              }
              // Right Position
              else if (tooltipPosition === "right") {
                  targetTop = origin.offset().top + originHeight / 2 - tooltipHeight / 2;
                  targetLeft = origin.offset().left + originWidth + margin;
                  newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);

                  tooltipHorizontalMovement = '+10px';
                  backdrop.css({
                    top: '-7px',
                    left: 0,
                    width: '14px',
                    height: '14px',
                    borderRadius: '0 14px 14px 0',
                    transformOrigin: '5% 50%',
                    marginTop: tooltipHeight / 2,
                    marginLeft: '0px'
                  });
                } else {
                  // Bottom Position
                  targetTop = origin.offset().top + origin.outerHeight() + margin;
                  targetLeft = origin.offset().left + originWidth / 2 - tooltipWidth / 2;
                  newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
                  tooltipVerticalMovement = '+10px';
                  backdrop.css({
                    top: 0,
                    left: 0,
                    marginLeft: tooltipWidth / 2 - backdropOffsetWidth / 2
                  });
                }

            // Set tooptip css placement
            tooltipEl.css({
              top: newCoordinates.y,
              left: newCoordinates.x
            });

            // Calculate Scale to fill
            scaleXFactor = Math.SQRT2 * tooltipWidth / parseInt(backdropOffsetWidth);
            scaleYFactor = Math.SQRT2 * tooltipHeight / parseInt(backdropOffsetHeight);
            scaleFactor = Math.max(scaleXFactor, scaleYFactor);

            tooltipEl.velocity({ translateY: tooltipVerticalMovement, translateX: tooltipHorizontalMovement }, { duration: 350, queue: false }).velocity({ opacity: 1 }, { duration: 300, delay: 50, queue: false });
            backdrop.css({ visibility: 'visible' }).velocity({ opacity: 1 }, { duration: 55, delay: 0, queue: false }).velocity({ scaleX: scaleFactor, scaleY: scaleFactor }, { duration: 300, delay: 0, queue: false, easing: 'easeInOutQuad' });
          };

          timeoutRef = setTimeout(showTooltip, tooltipDelay); // End Interval

          // Mouse Out
        },
        'mouseleave.tooltip': function mouseleaveTooltip() {
          // Reset State
          started = false;
          clearTimeout(timeoutRef);

          // Animate back
          setTimeout(function () {
            if (started !== true) {
              tooltipEl.velocity({
                opacity: 0, translateY: 0, translateX: 0 }, { duration: 225, queue: false });
              backdrop.velocity({ opacity: 0, scaleX: 1, scaleY: 1 }, {
                duration: 225,
                queue: false,
                complete: function complete() {
                  backdrop.css({ visibility: 'hidden' });
                  tooltipEl.css({ visibility: 'hidden' });
                  started = false;
                }
              });
            }
          }, 225);
        }
      });
    });
  };

  var repositionWithinScreen = function repositionWithinScreen(x, y, width, height) {
    var newX = x;
    var newY = y;

    if (newX < 0) {
      newX = 4;
    } else if (newX + width > window.innerWidth) {
      newX -= newX + width - window.innerWidth;
    }

    if (newY < 0) {
      newY = 4;
    } else if (newY + height > window.innerHeight + $(window).scrollTop) {
      newY -= newY + height - window.innerHeight;
    }

    return { x: newX, y: newY };
  };

  $(document).ready(function () {
    $('.tooltipped').tooltip();
  });
})(jQuery);
; /*!
  * Waves v0.6.4
  * http://fian.my.id/Waves
  *
  * Copyright 2014 Alfiana E. Sibuea and other contributors
  * Released under the MIT license
  * https://github.com/fians/Waves/blob/master/LICENSE
  */

;(function (window) {
  'use strict';

  var Waves = Waves || {};
  var $$ = document.querySelectorAll.bind(document);

  // Find exact position of element
  function isWindow(obj) {
    return obj !== null && obj === obj.window;
  }

  function getWindow(elem) {
    return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }

  function offset(elem) {
    var docElem,
        win,
        box = { top: 0, left: 0 },
        doc = elem && elem.ownerDocument;

    docElem = doc.documentElement;

    if (_typeof(elem.getBoundingClientRect) !== ( true ? 'undefined' : _typeof(undefined))) {
      box = elem.getBoundingClientRect();
    }
    win = getWindow(doc);
    return {
      top: box.top + win.pageYOffset - docElem.clientTop,
      left: box.left + win.pageXOffset - docElem.clientLeft
    };
  }

  function convertStyle(obj) {
    var style = '';

    for (var a in obj) {
      if (obj.hasOwnProperty(a)) {
        style += a + ':' + obj[a] + ';';
      }
    }

    return style;
  }

  var Effect = {

    // Effect delay
    duration: 750,

    show: function show(e, element) {

      // Disable right click
      if (e.button === 2) {
        return false;
      }

      var el = element || this;

      // Create ripple
      var ripple = document.createElement('div');
      ripple.className = 'waves-ripple';
      el.appendChild(ripple);

      // Get click coordinate and element witdh
      var pos = offset(el);
      var relativeY = e.pageY - pos.top;
      var relativeX = e.pageX - pos.left;
      var scale = 'scale(' + el.clientWidth / 100 * 10 + ')';

      // Support for touch devices
      if ('touches' in e) {
        relativeY = e.touches[0].pageY - pos.top;
        relativeX = e.touches[0].pageX - pos.left;
      }

      // Attach data to element
      ripple.setAttribute('data-hold', Date.now());
      ripple.setAttribute('data-scale', scale);
      ripple.setAttribute('data-x', relativeX);
      ripple.setAttribute('data-y', relativeY);

      // Set ripple position
      var rippleStyle = {
        'top': relativeY + 'px',
        'left': relativeX + 'px'
      };

      ripple.className = ripple.className + ' waves-notransition';
      ripple.setAttribute('style', convertStyle(rippleStyle));
      ripple.className = ripple.className.replace('waves-notransition', '');

      // Scale the ripple
      rippleStyle['-webkit-transform'] = scale;
      rippleStyle['-moz-transform'] = scale;
      rippleStyle['-ms-transform'] = scale;
      rippleStyle['-o-transform'] = scale;
      rippleStyle.transform = scale;
      rippleStyle.opacity = '1';

      rippleStyle['-webkit-transition-duration'] = Effect.duration + 'ms';
      rippleStyle['-moz-transition-duration'] = Effect.duration + 'ms';
      rippleStyle['-o-transition-duration'] = Effect.duration + 'ms';
      rippleStyle['transition-duration'] = Effect.duration + 'ms';

      rippleStyle['-webkit-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
      rippleStyle['-moz-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
      rippleStyle['-o-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
      rippleStyle['transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';

      ripple.setAttribute('style', convertStyle(rippleStyle));
    },

    hide: function hide(e) {
      TouchHandler.touchup(e);

      var el = this;
      var width = el.clientWidth * 1.4;

      // Get first ripple
      var ripple = null;
      var ripples = el.getElementsByClassName('waves-ripple');
      if (ripples.length > 0) {
        ripple = ripples[ripples.length - 1];
      } else {
        return false;
      }

      var relativeX = ripple.getAttribute('data-x');
      var relativeY = ripple.getAttribute('data-y');
      var scale = ripple.getAttribute('data-scale');

      // Get delay beetween mousedown and mouse leave
      var diff = Date.now() - Number(ripple.getAttribute('data-hold'));
      var delay = 350 - diff;

      if (delay < 0) {
        delay = 0;
      }

      // Fade out ripple after delay
      setTimeout(function () {
        var style = {
          'top': relativeY + 'px',
          'left': relativeX + 'px',
          'opacity': '0',

          // Duration
          '-webkit-transition-duration': Effect.duration + 'ms',
          '-moz-transition-duration': Effect.duration + 'ms',
          '-o-transition-duration': Effect.duration + 'ms',
          'transition-duration': Effect.duration + 'ms',
          '-webkit-transform': scale,
          '-moz-transform': scale,
          '-ms-transform': scale,
          '-o-transform': scale,
          'transform': scale
        };

        ripple.setAttribute('style', convertStyle(style));

        setTimeout(function () {
          try {
            el.removeChild(ripple);
          } catch (e) {
            return false;
          }
        }, Effect.duration);
      }, delay);
    },

    // Little hack to make <input> can perform waves effect
    wrapInput: function wrapInput(elements) {
      for (var a = 0; a < elements.length; a++) {
        var el = elements[a];

        if (el.tagName.toLowerCase() === 'input') {
          var parent = el.parentNode;

          // If input already have parent just pass through
          if (parent.tagName.toLowerCase() === 'i' && parent.className.indexOf('waves-effect') !== -1) {
            continue;
          }

          // Put element class and style to the specified parent
          var wrapper = document.createElement('i');
          wrapper.className = el.className + ' waves-input-wrapper';

          var elementStyle = el.getAttribute('style');

          if (!elementStyle) {
            elementStyle = '';
          }

          wrapper.setAttribute('style', elementStyle);

          el.className = 'waves-button-input';
          el.removeAttribute('style');

          // Put element as child
          parent.replaceChild(wrapper, el);
          wrapper.appendChild(el);
        }
      }
    }
  };

  /**
   * Disable mousedown event for 500ms during and after touch
   */
  var TouchHandler = {
    /* uses an integer rather than bool so there's no issues with
     * needing to clear timeouts if another touch event occurred
     * within the 500ms. Cannot mouseup between touchstart and
     * touchend, nor in the 500ms after touchend. */
    touches: 0,
    allowEvent: function allowEvent(e) {
      var allow = true;

      if (e.type === 'touchstart') {
        TouchHandler.touches += 1; //push
      } else if (e.type === 'touchend' || e.type === 'touchcancel') {
        setTimeout(function () {
          if (TouchHandler.touches > 0) {
            TouchHandler.touches -= 1; //pop after 500ms
          }
        }, 500);
      } else if (e.type === 'mousedown' && TouchHandler.touches > 0) {
        allow = false;
      }

      return allow;
    },
    touchup: function touchup(e) {
      TouchHandler.allowEvent(e);
    }
  };

  /**
   * Delegated click handler for .waves-effect element.
   * returns null when .waves-effect element not in "click tree"
   */
  function getWavesEffectElement(e) {
    if (TouchHandler.allowEvent(e) === false) {
      return null;
    }

    var element = null;
    var target = e.target || e.srcElement;

    while (target.parentElement !== null) {
      if (!(target instanceof SVGElement) && target.className.indexOf('waves-effect') !== -1) {
        element = target;
        break;
      } else if (target.classList.contains('waves-effect')) {
        element = target;
        break;
      }
      target = target.parentElement;
    }

    return element;
  }

  /**
   * Bubble the click and show effect if .waves-effect elem was found
   */
  function showEffect(e) {
    var element = getWavesEffectElement(e);

    if (element !== null) {
      Effect.show(e, element);

      if ('ontouchstart' in window) {
        element.addEventListener('touchend', Effect.hide, false);
        element.addEventListener('touchcancel', Effect.hide, false);
      }

      element.addEventListener('mouseup', Effect.hide, false);
      element.addEventListener('mouseleave', Effect.hide, false);
    }
  }

  Waves.displayEffect = function (options) {
    options = options || {};

    if ('duration' in options) {
      Effect.duration = options.duration;
    }

    //Wrap input inside <i> tag
    Effect.wrapInput($$('.waves-effect'));

    if ('ontouchstart' in window) {
      document.body.addEventListener('touchstart', showEffect, false);
    }

    document.body.addEventListener('mousedown', showEffect, false);
  };

  /**
   * Attach Waves to an input element (or any element which doesn't
   * bubble mouseup/mousedown events).
   *   Intended to be used with dynamically loaded forms/inputs, or
   * where the user doesn't want a delegated click handler.
   */
  Waves.attach = function (element) {
    //FUTURE: automatically add waves classes and allow users
    // to specify them with an options param? Eg. light/classic/button
    if (element.tagName.toLowerCase() === 'input') {
      Effect.wrapInput([element]);
      element = element.parentElement;
    }

    if ('ontouchstart' in window) {
      element.addEventListener('touchstart', showEffect, false);
    }

    element.addEventListener('mousedown', showEffect, false);
  };

  window.Waves = Waves;

  document.addEventListener('DOMContentLoaded', function () {
    Waves.displayEffect();
  }, false);
})(window);
;Materialize.toast = function (message, displayLength, className, completeCallback) {
  className = className || "";

  var container = document.getElementById('toast-container');

  // Create toast container if it does not exist
  if (container === null) {
    // create notification container
    container = document.createElement('div');
    container.id = 'toast-container';
    document.body.appendChild(container);
  }

  // Select and append toast
  var newToast = createToast(message);

  // only append toast if message is not undefined
  if (message) {
    container.appendChild(newToast);
  }

  newToast.style.opacity = 0;

  // Animate toast in
  Vel(newToast, { translateY: '-35px', opacity: 1 }, { duration: 300,
    easing: 'easeOutCubic',
    queue: false });

  // Allows timer to be pause while being panned
  var timeLeft = displayLength;
  var counterInterval;
  if (timeLeft != null) {
    counterInterval = setInterval(function () {
      if (newToast.parentNode === null) window.clearInterval(counterInterval);

      // If toast is not being dragged, decrease its time remaining
      if (!newToast.classList.contains('panning')) {
        timeLeft -= 20;
      }

      if (timeLeft <= 0) {
        // Animate toast out
        Vel(newToast, { "opacity": 0, marginTop: '-40px' }, { duration: 375,
          easing: 'easeOutExpo',
          queue: false,
          complete: function complete() {
            // Call the optional callback
            if (typeof completeCallback === "function") completeCallback();
            // Remove toast after it times out
            this[0].parentNode.removeChild(this[0]);
          }
        });
        window.clearInterval(counterInterval);
      }
    }, 20);
  }

  function createToast(html) {

    // Create toast
    var toast = document.createElement('div');
    toast.classList.add('toast');
    if (className) {
      var classes = className.split(' ');

      for (var i = 0, count = classes.length; i < count; i++) {
        toast.classList.add(classes[i]);
      }
    }
    // If type of parameter is HTML Element
    if ((typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === "object" ? html instanceof HTMLElement : html && (typeof html === 'undefined' ? 'undefined' : _typeof(html)) === "object" && html !== null && html.nodeType === 1 && typeof html.nodeName === "string") {
      toast.appendChild(html);
    } else if (html instanceof jQuery) {
      // Check if it is jQuery object
      toast.appendChild(html[0]);
    } else {
      // Insert as text;
      toast.innerHTML = html;
    }
    // Bind hammer
    var hammerHandler = new Hammer(toast, { prevent_default: false });
    hammerHandler.on('pan', function (e) {
      var deltaX = e.deltaX;
      var activationDistance = 80;

      // Change toast state
      if (!toast.classList.contains('panning')) {
        toast.classList.add('panning');
      }

      var opacityPercent = 1 - Math.abs(deltaX / activationDistance);
      if (opacityPercent < 0) opacityPercent = 0;

      Vel(toast, { left: deltaX, opacity: opacityPercent }, { duration: 50, queue: false, easing: 'easeOutQuad' });
    });

    hammerHandler.on('panend', function (e) {
      var deltaX = e.deltaX;
      var activationDistance = 80;

      // If toast dragged past activation point
      if (Math.abs(deltaX) > activationDistance) {
        Vel(toast, { marginTop: '-40px' }, { duration: 375,
          easing: 'easeOutExpo',
          queue: false,
          complete: function complete() {
            if (typeof completeCallback === "function") {
              completeCallback();
            }
            toast.parentNode.removeChild(toast);
          }
        });
      } else {
        toast.classList.remove('panning');
        // Put toast back into original position
        Vel(toast, { left: 0, opacity: 1 }, { duration: 300,
          easing: 'easeOutExpo',
          queue: false
        });
      }
    });

    return toast;
  }
};
;(function ($) {

  var methods = {
    init: function init(options) {
      var defaults = {
        menuWidth: 300,
        edge: 'left',
        closeOnClick: false,
        draggable: true
      };
      options = $.extend(defaults, options);

      $(this).each(function () {
        var $this = $(this);
        var menuId = $this.attr('data-activates');
        var menu = $("#" + menuId);

        // Set to width
        if (options.menuWidth != 300) {
          menu.css('width', options.menuWidth);
        }

        // Add Touch Area
        var $dragTarget = $('.drag-target[data-sidenav="' + menuId + '"]');
        if (options.draggable) {
          // Regenerate dragTarget
          if ($dragTarget.length) {
            $dragTarget.remove();
          }

          $dragTarget = $('<div class="drag-target"></div>').attr('data-sidenav', menuId);
          $('body').append($dragTarget);
        } else {
          $dragTarget = $();
        }

        if (options.edge == 'left') {
          menu.css('transform', 'translateX(-100%)');
          $dragTarget.css({ 'left': 0 }); // Add Touch Area
        } else {
          menu.addClass('right-aligned') // Change text-alignment to right
          .css('transform', 'translateX(100%)');
          $dragTarget.css({ 'right': 0 }); // Add Touch Area
        }

        // If fixed sidenav, bring menu out
        if (menu.hasClass('fixed')) {
          if (window.innerWidth > 992) {
            menu.css('transform', 'translateX(0)');
          }
        }

        // Window resize to reset on large screens fixed
        if (menu.hasClass('fixed')) {
          $(window).resize(function () {
            if (window.innerWidth > 992) {
              // Close menu if window is resized bigger than 992 and user has fixed sidenav
              if ($('#sidenav-overlay').length !== 0 && menuOut) {
                removeMenu(true);
              } else {
                // menu.removeAttr('style');
                menu.css('transform', 'translateX(0%)');
                // menu.css('width', options.menuWidth);
              }
            } else if (menuOut === false) {
              if (options.edge === 'left') {
                menu.css('transform', 'translateX(-100%)');
              } else {
                menu.css('transform', 'translateX(100%)');
              }
            }
          });
        }

        // if closeOnClick, then add close event for all a tags in side sideNav
        if (options.closeOnClick === true) {
          menu.on("click.itemclick", "a:not(.collapsible-header)", function () {
            removeMenu();
          });
        }

        var removeMenu = function removeMenu(restoreNav) {
          panning = false;
          menuOut = false;
          // Reenable scrolling
          $('body').css({
            overflow: '',
            width: ''
          });

          $('#sidenav-overlay').velocity({ opacity: 0 }, { duration: 200,
            queue: false, easing: 'easeOutQuad',
            complete: function complete() {
              $(this).remove();
            } });
          if (options.edge === 'left') {
            // Reset phantom div
            $dragTarget.css({ width: '', right: '', left: '0' });
            menu.velocity({ 'translateX': '-100%' }, { duration: 200,
              queue: false,
              easing: 'easeOutCubic',
              complete: function complete() {
                if (restoreNav === true) {
                  // Restore Fixed sidenav
                  menu.removeAttr('style');
                  menu.css('width', options.menuWidth);
                }
              }

            });
          } else {
            // Reset phantom div
            $dragTarget.css({ width: '', right: '0', left: '' });
            menu.velocity({ 'translateX': '100%' }, { duration: 200,
              queue: false,
              easing: 'easeOutCubic',
              complete: function complete() {
                if (restoreNav === true) {
                  // Restore Fixed sidenav
                  menu.removeAttr('style');
                  menu.css('width', options.menuWidth);
                }
              }
            });
          }
        };

        // Touch Event
        var panning = false;
        var menuOut = false;

        if (options.draggable) {
          $dragTarget.on('click', function () {
            if (menuOut) {
              removeMenu();
            }
          });

          $dragTarget.hammer({
            prevent_default: false
          }).bind('pan', function (e) {

            if (e.gesture.pointerType == "touch") {

              var direction = e.gesture.direction;
              var x = e.gesture.center.x;
              var y = e.gesture.center.y;
              var velocityX = e.gesture.velocityX;

              // Disable Scrolling
              var $body = $('body');
              var $overlay = $('#sidenav-overlay');
              var oldWidth = $body.innerWidth();
              $body.css('overflow', 'hidden');
              $body.width(oldWidth);

              // If overlay does not exist, create one and if it is clicked, close menu
              if ($overlay.length === 0) {
                $overlay = $('<div id="sidenav-overlay"></div>');
                $overlay.css('opacity', 0).click(function () {
                  removeMenu();
                });
                $('body').append($overlay);
              }

              // Keep within boundaries
              if (options.edge === 'left') {
                if (x > options.menuWidth) {
                  x = options.menuWidth;
                } else if (x < 0) {
                  x = 0;
                }
              }

              if (options.edge === 'left') {
                // Left Direction
                if (x < options.menuWidth / 2) {
                  menuOut = false;
                }
                // Right Direction
                else if (x >= options.menuWidth / 2) {
                    menuOut = true;
                  }
                menu.css('transform', 'translateX(' + (x - options.menuWidth) + 'px)');
              } else {
                // Left Direction
                if (x < window.innerWidth - options.menuWidth / 2) {
                  menuOut = true;
                }
                // Right Direction
                else if (x >= window.innerWidth - options.menuWidth / 2) {
                    menuOut = false;
                  }
                var rightPos = x - options.menuWidth / 2;
                if (rightPos < 0) {
                  rightPos = 0;
                }

                menu.css('transform', 'translateX(' + rightPos + 'px)');
              }

              // Percentage overlay
              var overlayPerc;
              if (options.edge === 'left') {
                overlayPerc = x / options.menuWidth;
                $overlay.velocity({ opacity: overlayPerc }, { duration: 10, queue: false, easing: 'easeOutQuad' });
              } else {
                overlayPerc = Math.abs((x - window.innerWidth) / options.menuWidth);
                $overlay.velocity({ opacity: overlayPerc }, { duration: 10, queue: false, easing: 'easeOutQuad' });
              }
            }
          }).bind('panend', function (e) {

            if (e.gesture.pointerType == "touch") {
              var $overlay = $('#sidenav-overlay');
              var velocityX = e.gesture.velocityX;
              var x = e.gesture.center.x;
              var leftPos = x - options.menuWidth;
              var rightPos = x - options.menuWidth / 2;
              if (leftPos > 0) {
                leftPos = 0;
              }
              if (rightPos < 0) {
                rightPos = 0;
              }
              panning = false;

              if (options.edge === 'left') {
                // If velocityX <= 0.3 then the user is flinging the menu closed so ignore menuOut
                if (menuOut && velocityX <= 0.3 || velocityX < -0.5) {
                  // Return menu to open
                  if (leftPos !== 0) {
                    menu.velocity({ 'translateX': [0, leftPos] }, { duration: 300, queue: false, easing: 'easeOutQuad' });
                  }

                  $overlay.velocity({ opacity: 1 }, { duration: 50, queue: false, easing: 'easeOutQuad' });
                  $dragTarget.css({ width: '50%', right: 0, left: '' });
                  menuOut = true;
                } else if (!menuOut || velocityX > 0.3) {
                  // Enable Scrolling
                  $('body').css({
                    overflow: '',
                    width: ''
                  });
                  // Slide menu closed
                  menu.velocity({ 'translateX': [-1 * options.menuWidth - 10, leftPos] }, { duration: 200, queue: false, easing: 'easeOutQuad' });
                  $overlay.velocity({ opacity: 0 }, { duration: 200, queue: false, easing: 'easeOutQuad',
                    complete: function complete() {
                      $(this).remove();
                    } });
                  $dragTarget.css({ width: '10px', right: '', left: 0 });
                }
              } else {
                if (menuOut && velocityX >= -0.3 || velocityX > 0.5) {
                  // Return menu to open
                  if (rightPos !== 0) {
                    menu.velocity({ 'translateX': [0, rightPos] }, { duration: 300, queue: false, easing: 'easeOutQuad' });
                  }

                  $overlay.velocity({ opacity: 1 }, { duration: 50, queue: false, easing: 'easeOutQuad' });
                  $dragTarget.css({ width: '50%', right: '', left: 0 });
                  menuOut = true;
                } else if (!menuOut || velocityX < -0.3) {
                  // Enable Scrolling
                  $('body').css({
                    overflow: '',
                    width: ''
                  });

                  // Slide menu closed
                  menu.velocity({ 'translateX': [options.menuWidth + 10, rightPos] }, { duration: 200, queue: false, easing: 'easeOutQuad' });
                  $overlay.velocity({ opacity: 0 }, { duration: 200, queue: false, easing: 'easeOutQuad',
                    complete: function complete() {
                      $(this).remove();
                    } });
                  $dragTarget.css({ width: '10px', right: 0, left: '' });
                }
              }
            }
          });
        }

        $this.off('click.sidenav').on('click.sidenav', function () {
          if (menuOut === true) {
            menuOut = false;
            panning = false;
            removeMenu();
          } else {

            // Disable Scrolling
            var $body = $('body');
            var $overlay = $('<div id="sidenav-overlay"></div>');
            var oldWidth = $body.innerWidth();
            $body.css('overflow', 'hidden');
            $body.width(oldWidth);

            // Push current drag target on top of DOM tree
            $('body').append($dragTarget);

            if (options.edge === 'left') {
              $dragTarget.css({ width: '50%', right: 0, left: '' });
              menu.velocity({ 'translateX': [0, -1 * options.menuWidth] }, { duration: 300, queue: false, easing: 'easeOutQuad' });
            } else {
              $dragTarget.css({ width: '50%', right: '', left: 0 });
              menu.velocity({ 'translateX': [0, options.menuWidth] }, { duration: 300, queue: false, easing: 'easeOutQuad' });
            }

            $overlay.css('opacity', 0).click(function () {
              menuOut = false;
              panning = false;
              removeMenu();
              $overlay.velocity({ opacity: 0 }, { duration: 300, queue: false, easing: 'easeOutQuad',
                complete: function complete() {
                  $(this).remove();
                } });
            });
            $('body').append($overlay);
            $overlay.velocity({ opacity: 1 }, { duration: 300, queue: false, easing: 'easeOutQuad',
              complete: function complete() {
                menuOut = true;
                panning = false;
              }
            });
          }

          return false;
        });
      });
    },
    destroy: function destroy() {
      var $overlay = $('#sidenav-overlay');
      var $dragTarget = $('.drag-target[data-sidenav="' + $(this).attr('data-activates') + '"]');
      $overlay.trigger('click');
      $dragTarget.remove();
      $(this).off('click');
      $overlay.remove();
    },
    show: function show() {
      this.trigger('click');
    },
    hide: function hide() {
      $('#sidenav-overlay').trigger('click');
    }
  };

  $.fn.sideNav = function (methodOrOptions) {
    if (methods[methodOrOptions]) {
      return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if ((typeof methodOrOptions === 'undefined' ? 'undefined' : _typeof(methodOrOptions)) === 'object' || !methodOrOptions) {
      // Default to "init"
      return methods.init.apply(this, arguments);
    } else {
      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.sideNav');
    }
  }; // Plugin end
})(jQuery);
; /**
  * Extend jquery with a scrollspy plugin.
  * This watches the window scroll and fires events when elements are scrolled into viewport.
  *
  * throttle() and getTime() taken from Underscore.js
  * https://github.com/jashkenas/underscore
  *
  * @author Copyright 2013 John Smart
  * @license https://raw.github.com/thesmart/jquery-scrollspy/master/LICENSE
  * @see https://github.com/thesmart
  * @version 0.1.2
  */
(function ($) {

  var jWindow = $(window);
  var elements = [];
  var elementsInView = [];
  var isSpying = false;
  var ticks = 0;
  var unique_id = 1;
  var offset = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0

    /**
     * Find elements that are within the boundary
     * @param {number} top
     * @param {number} right
     * @param {number} bottom
     * @param {number} left
     * @return {jQuery}		A collection of elements
     */
  };function findElements(top, right, bottom, left) {
    var hits = $();
    $.each(elements, function (i, element) {
      if (element.height() > 0) {
        var elTop = element.offset().top,
            elLeft = element.offset().left,
            elRight = elLeft + element.width(),
            elBottom = elTop + element.height();

        var isIntersect = !(elLeft > right || elRight < left || elTop > bottom || elBottom < top);

        if (isIntersect) {
          hits.push(element);
        }
      }
    });

    return hits;
  }

  /**
   * Called when the user scrolls the window
   */
  function onScroll(scrollOffset) {
    // unique tick id
    ++ticks;

    // viewport rectangle
    var top = jWindow.scrollTop(),
        left = jWindow.scrollLeft(),
        right = left + jWindow.width(),
        bottom = top + jWindow.height();

    // determine which elements are in view
    var intersections = findElements(top + offset.top + scrollOffset || 200, right + offset.right, bottom + offset.bottom, left + offset.left);
    $.each(intersections, function (i, element) {

      var lastTick = element.data('scrollSpy:ticks');
      if (typeof lastTick != 'number') {
        // entered into view
        element.triggerHandler('scrollSpy:enter');
      }

      // update tick id
      element.data('scrollSpy:ticks', ticks);
    });

    // determine which elements are no longer in view
    $.each(elementsInView, function (i, element) {
      var lastTick = element.data('scrollSpy:ticks');
      if (typeof lastTick == 'number' && lastTick !== ticks) {
        // exited from view
        element.triggerHandler('scrollSpy:exit');
        element.data('scrollSpy:ticks', null);
      }
    });

    // remember elements in view for next tick
    elementsInView = intersections;
  }

  /**
   * Called when window is resized
  */
  function onWinSize() {
    jWindow.trigger('scrollSpy:winSize');
  }

  /**
   * Enables ScrollSpy using a selector
   * @param {jQuery|string} selector  The elements collection, or a selector
   * @param {Object=} options	Optional.
         throttle : number -> scrollspy throttling. Default: 100 ms
         offsetTop : number -> offset from top. Default: 0
         offsetRight : number -> offset from right. Default: 0
         offsetBottom : number -> offset from bottom. Default: 0
         offsetLeft : number -> offset from left. Default: 0
   * @returns {jQuery}
   */
  $.scrollSpy = function (selector, options) {
    var defaults = {
      throttle: 100,
      scrollOffset: 200 // offset - 200 allows elements near bottom of page to scroll
    };
    options = $.extend(defaults, options);

    var visible = [];
    selector = $(selector);
    selector.each(function (i, element) {
      elements.push($(element));
      $(element).data("scrollSpy:id", i);
      // Smooth scroll to section
      $('a[href="#' + $(element).attr('id') + '"]').click(function (e) {
        e.preventDefault();
        var offset = $(Materialize.escapeHash(this.hash)).offset().top + 1;
        $('html, body').animate({ scrollTop: offset - options.scrollOffset }, { duration: 400, queue: false, easing: 'easeOutCubic' });
      });
    });

    offset.top = options.offsetTop || 0;
    offset.right = options.offsetRight || 0;
    offset.bottom = options.offsetBottom || 0;
    offset.left = options.offsetLeft || 0;

    var throttledScroll = Materialize.throttle(function () {
      onScroll(options.scrollOffset);
    }, options.throttle || 100);
    var readyScroll = function readyScroll() {
      $(document).ready(throttledScroll);
    };

    if (!isSpying) {
      jWindow.on('scroll', readyScroll);
      jWindow.on('resize', readyScroll);
      isSpying = true;
    }

    // perform a scan once, after current execution context, and after dom is ready
    setTimeout(readyScroll, 0);

    selector.on('scrollSpy:enter', function () {
      visible = $.grep(visible, function (value) {
        return value.height() != 0;
      });

      var $this = $(this);

      if (visible[0]) {
        $('a[href="#' + visible[0].attr('id') + '"]').removeClass('active');
        if ($this.data('scrollSpy:id') < visible[0].data('scrollSpy:id')) {
          visible.unshift($(this));
        } else {
          visible.push($(this));
        }
      } else {
        visible.push($(this));
      }

      $('a[href="#' + visible[0].attr('id') + '"]').addClass('active');
    });
    selector.on('scrollSpy:exit', function () {
      visible = $.grep(visible, function (value) {
        return value.height() != 0;
      });

      if (visible[0]) {
        $('a[href="#' + visible[0].attr('id') + '"]').removeClass('active');
        var $this = $(this);
        visible = $.grep(visible, function (value) {
          return value.attr('id') != $this.attr('id');
        });
        if (visible[0]) {
          // Check if empty
          $('a[href="#' + visible[0].attr('id') + '"]').addClass('active');
        }
      }
    });

    return selector;
  };

  /**
   * Listen for window resize events
   * @param {Object=} options						Optional. Set { throttle: number } to change throttling. Default: 100 ms
   * @returns {jQuery}		$(window)
   */
  $.winSizeSpy = function (options) {
    $.winSizeSpy = function () {
      return jWindow;
    }; // lock from multiple calls
    options = options || {
      throttle: 100
    };
    return jWindow.on('resize', Materialize.throttle(onWinSize, options.throttle || 100));
  };

  /**
   * Enables ScrollSpy on a collection of elements
   * e.g. $('.scrollSpy').scrollSpy()
   * @param {Object=} options	Optional.
  										throttle : number -> scrollspy throttling. Default: 100 ms
  										offsetTop : number -> offset from top. Default: 0
  										offsetRight : number -> offset from right. Default: 0
  										offsetBottom : number -> offset from bottom. Default: 0
  										offsetLeft : number -> offset from left. Default: 0
   * @returns {jQuery}
   */
  $.fn.scrollSpy = function (options) {
    return $.scrollSpy($(this), options);
  };
})(jQuery);
;(function ($) {
  $(document).ready(function () {

    // Function to update labels of text fields
    Materialize.updateTextFields = function () {
      var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea';
      $(input_selector).each(function (index, element) {
        var $this = $(this);
        if ($(element).val().length > 0 || element.autofocus || $this.attr('placeholder') !== undefined) {
          $this.siblings('label').addClass('active');
        } else if ($(element)[0].validity) {
          $this.siblings('label').toggleClass('active', $(element)[0].validity.badInput === true);
        } else {
          $this.siblings('label').removeClass('active');
        }
      });
    };

    // Text based inputs
    var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea';

    // Add active if form auto complete
    $(document).on('change', input_selector, function () {
      if ($(this).val().length !== 0 || $(this).attr('placeholder') !== undefined) {
        $(this).siblings('label').addClass('active');
      }
      validate_field($(this));
    });

    // Add active if input element has been pre-populated on document ready
    $(document).ready(function () {
      Materialize.updateTextFields();
    });

    // HTML DOM FORM RESET handling
    $(document).on('reset', function (e) {
      var formReset = $(e.target);
      if (formReset.is('form')) {
        formReset.find(input_selector).removeClass('valid').removeClass('invalid');
        formReset.find(input_selector).each(function () {
          if ($(this).attr('value') === '') {
            $(this).siblings('label').removeClass('active');
          }
        });

        // Reset select
        formReset.find('select.initialized').each(function () {
          var reset_text = formReset.find('option[selected]').text();
          formReset.siblings('input.select-dropdown').val(reset_text);
        });
      }
    });

    // Add active when element has focus
    $(document).on('focus', input_selector, function () {
      $(this).siblings('label, .prefix').addClass('active');
    });

    $(document).on('blur', input_selector, function () {
      var $inputElement = $(this);
      var selector = ".prefix";

      if ($inputElement.val().length === 0 && $inputElement[0].validity.badInput !== true && $inputElement.attr('placeholder') === undefined) {
        selector += ", label";
      }

      $inputElement.siblings(selector).removeClass('active');

      validate_field($inputElement);
    });

    window.validate_field = function (object) {
      var hasLength = object.attr('data-length') !== undefined;
      var lenAttr = parseInt(object.attr('data-length'));
      var len = object.val().length;

      if (object.val().length === 0 && object[0].validity.badInput === false) {
        if (object.hasClass('validate')) {
          object.removeClass('valid');
          object.removeClass('invalid');
        }
      } else {
        if (object.hasClass('validate')) {
          // Check for character counter attributes
          if (object.is(':valid') && hasLength && len <= lenAttr || object.is(':valid') && !hasLength) {
            object.removeClass('invalid');
            object.addClass('valid');
          } else {
            object.removeClass('valid');
            object.addClass('invalid');
          }
        }
      }
    };

    // Radio and Checkbox focus class
    var radio_checkbox = 'input[type=radio], input[type=checkbox]';
    $(document).on('keyup.radio', radio_checkbox, function (e) {
      // TAB, check if tabbing to radio or checkbox.
      if (e.which === 9) {
        $(this).addClass('tabbed');
        var $this = $(this);
        $this.one('blur', function (e) {

          $(this).removeClass('tabbed');
        });
        return;
      }
    });

    // Textarea Auto Resize
    var hiddenDiv = $('.hiddendiv').first();
    if (!hiddenDiv.length) {
      hiddenDiv = $('<div class="hiddendiv common"></div>');
      $('body').append(hiddenDiv);
    }
    var text_area_selector = '.materialize-textarea';

    function textareaAutoResize($textarea) {
      // Set font properties of hiddenDiv

      var fontFamily = $textarea.css('font-family');
      var fontSize = $textarea.css('font-size');
      var lineHeight = $textarea.css('line-height');

      if (fontSize) {
        hiddenDiv.css('font-size', fontSize);
      }
      if (fontFamily) {
        hiddenDiv.css('font-family', fontFamily);
      }
      if (lineHeight) {
        hiddenDiv.css('line-height', lineHeight);
      }

      if ($textarea.attr('wrap') === "off") {
        hiddenDiv.css('overflow-wrap', "normal").css('white-space', "pre");
      }

      hiddenDiv.text($textarea.val() + '\n');
      var content = hiddenDiv.html().replace(/\n/g, '<br>');
      hiddenDiv.html(content);

      // When textarea is hidden, width goes crazy.
      // Approximate with half of window size

      if ($textarea.is(':visible')) {
        hiddenDiv.css('width', $textarea.width());
      } else {
        hiddenDiv.css('width', $(window).width() / 2);
      }

      /**
       * Resize if the new height is greater than the
       * original height of the textarea
       */
      if ($textarea.data("original-height") <= hiddenDiv.height()) {
        $textarea.css('height', hiddenDiv.height());
      } else if ($textarea.val().length < $textarea.data("previous-length")) {
        /**
         * In case the new height is less than original height, it
         * means the textarea has less text than before
         * So we set the height to the original one
         */
        $textarea.css('height', $textarea.data("original-height"));
      }
      $textarea.data("previous-length", $textarea.val().length);
    }

    $(text_area_selector).each(function () {
      var $textarea = $(this);
      /**
       * Instead of resizing textarea on document load,
       * store the original height and the original length
       */
      $textarea.data("original-height", $textarea.height());
      $textarea.data("previous-length", $textarea.val().length);
    });

    $('body').on('keyup keydown autoresize', text_area_selector, function () {
      textareaAutoResize($(this));
    });

    // File Input Path
    $(document).on('change', '.file-field input[type="file"]', function () {
      var file_field = $(this).closest('.file-field');
      var path_input = file_field.find('input.file-path');
      var files = $(this)[0].files;
      var file_names = [];
      for (var i = 0; i < files.length; i++) {
        file_names.push(files[i].name);
      }
      path_input.val(file_names.join(", "));
      path_input.trigger('change');
    });

    /****************
    *  Range Input  *
    ****************/

    var range_type = 'input[type=range]';
    var range_mousedown = false;
    var left;

    $(range_type).each(function () {
      var thumb = $('<span class="thumb"><span class="value"></span></span>');
      $(this).after(thumb);
    });

    var showRangeBubble = function showRangeBubble(thumb) {
      var paddingLeft = parseInt(thumb.parent().css('padding-left'));
      var marginLeft = -7 + paddingLeft + 'px';
      thumb.velocity({ height: "30px", width: "30px", top: "-30px", marginLeft: marginLeft }, { duration: 300, easing: 'easeOutExpo' });
    };

    var calcRangeOffset = function calcRangeOffset(range) {
      var width = range.width() - 15;
      var max = parseFloat(range.attr('max'));
      var min = parseFloat(range.attr('min'));
      var percent = (parseFloat(range.val()) - min) / (max - min);
      return percent * width;
    };

    var range_wrapper = '.range-field';
    $(document).on('change', range_type, function (e) {
      var thumb = $(this).siblings('.thumb');
      thumb.find('.value').html($(this).val());

      if (!thumb.hasClass('active')) {
        showRangeBubble(thumb);
      }

      var offsetLeft = calcRangeOffset($(this));
      thumb.addClass('active').css('left', offsetLeft);
    });

    $(document).on('mousedown touchstart', range_type, function (e) {
      var thumb = $(this).siblings('.thumb');

      // If thumb indicator does not exist yet, create it
      if (thumb.length <= 0) {
        thumb = $('<span class="thumb"><span class="value"></span></span>');
        $(this).after(thumb);
      }

      // Set indicator value
      thumb.find('.value').html($(this).val());

      range_mousedown = true;
      $(this).addClass('active');

      if (!thumb.hasClass('active')) {
        showRangeBubble(thumb);
      }

      if (e.type !== 'input') {
        var offsetLeft = calcRangeOffset($(this));
        thumb.addClass('active').css('left', offsetLeft);
      }
    });

    $(document).on('mouseup touchend', range_wrapper, function () {
      range_mousedown = false;
      $(this).removeClass('active');
    });

    $(document).on('input mousemove touchmove', range_wrapper, function (e) {
      var thumb = $(this).children('.thumb');
      var left;
      var input = $(this).find(range_type);

      if (range_mousedown) {
        if (!thumb.hasClass('active')) {
          showRangeBubble(thumb);
        }

        var offsetLeft = calcRangeOffset(input);
        thumb.addClass('active').css('left', offsetLeft);
        thumb.find('.value').html(thumb.siblings(range_type).val());
      }
    });

    $(document).on('mouseout touchleave', range_wrapper, function () {
      if (!range_mousedown) {

        var thumb = $(this).children('.thumb');
        var paddingLeft = parseInt($(this).css('padding-left'));
        var marginLeft = 7 + paddingLeft + 'px';

        if (thumb.hasClass('active')) {
          thumb.velocity({ height: '0', width: '0', top: '10px', marginLeft: marginLeft }, { duration: 100 });
        }
        thumb.removeClass('active');
      }
    });

    /**************************
     * Auto complete plugin  *
     *************************/
    $.fn.autocomplete = function (options) {
      // Defaults
      var defaults = {
        data: {},
        limit: Infinity,
        onAutocomplete: null,
        minLength: 1
      };

      options = $.extend(defaults, options);

      return this.each(function () {
        var $input = $(this);
        var data = options.data,
            count = 0,
            activeIndex = -1,
            oldVal,
            $inputDiv = $input.closest('.input-field'); // Div to append on

        // Check if data isn't empty
        if (!$.isEmptyObject(data)) {
          var $autocomplete = $('<ul class="autocomplete-content dropdown-content"></ul>');
          var $oldAutocomplete;

          // Append autocomplete element.
          // Prevent double structure init.
          if ($inputDiv.length) {
            $oldAutocomplete = $inputDiv.children('.autocomplete-content.dropdown-content').first();
            if (!$oldAutocomplete.length) {
              $inputDiv.append($autocomplete); // Set ul in body
            }
          } else {
            $oldAutocomplete = $input.next('.autocomplete-content.dropdown-content');
            if (!$oldAutocomplete.length) {
              $input.after($autocomplete);
            }
          }
          if ($oldAutocomplete.length) {
            $autocomplete = $oldAutocomplete;
          }

          // Highlight partial match.
          var highlight = function highlight(string, $el) {
            var img = $el.find('img');
            var matchStart = $el.text().toLowerCase().indexOf("" + string.toLowerCase() + ""),
                matchEnd = matchStart + string.length - 1,
                beforeMatch = $el.text().slice(0, matchStart),
                matchText = $el.text().slice(matchStart, matchEnd + 1),
                afterMatch = $el.text().slice(matchEnd + 1);
            $el.html("<span>" + beforeMatch + "<span class='highlight'>" + matchText + "</span>" + afterMatch + "</span>");
            if (img.length) {
              $el.prepend(img);
            }
          };

          // Reset current element position
          var resetCurrentElement = function resetCurrentElement() {
            activeIndex = -1;
            $autocomplete.find('.active').removeClass('active');
          };

          // Remove autocomplete elements
          var removeAutocomplete = function removeAutocomplete() {
            $autocomplete.empty();
            resetCurrentElement();
            oldVal = undefined;
          };

          $input.off('blur.autocomplete').on('blur.autocomplete', function () {
            removeAutocomplete();
          });

          // Perform search
          $input.off('keyup.autocomplete focus.autocomplete').on('keyup.autocomplete focus.autocomplete', function (e) {
            // Reset count.
            count = 0;
            var val = $input.val().toLowerCase();

            // Don't capture enter or arrow key usage.
            if (e.which === 13 || e.which === 38 || e.which === 40) {
              return;
            }

            // Check if the input isn't empty
            if (oldVal !== val) {
              removeAutocomplete();

              if (val.length >= options.minLength) {
                for (var key in data) {
                  if (data.hasOwnProperty(key) && key.toLowerCase().indexOf(val) !== -1 && key.toLowerCase() !== val) {
                    // Break if past limit
                    if (count >= options.limit) {
                      break;
                    }

                    var autocompleteOption = $('<li></li>');
                    if (!!data[key]) {
                      autocompleteOption.append('<img src="' + data[key] + '" class="right circle"><span>' + key + '</span>');
                    } else {
                      autocompleteOption.append('<span>' + key + '</span>');
                    }

                    $autocomplete.append(autocompleteOption);
                    highlight(val, autocompleteOption);
                    count++;
                  }
                }
              }
            }

            // Update oldVal
            oldVal = val;
          });

          $input.off('keydown.autocomplete').on('keydown.autocomplete', function (e) {
            // Arrow keys and enter key usage
            var keyCode = e.which,
                liElement,
                numItems = $autocomplete.children('li').length,
                $active = $autocomplete.children('.active').first();

            // select element on Enter
            if (keyCode === 13 && activeIndex >= 0) {
              liElement = $autocomplete.children('li').eq(activeIndex);
              if (liElement.length) {
                liElement.trigger('mousedown.autocomplete');
                e.preventDefault();
              }
              return;
            }

            // Capture up and down key
            if (keyCode === 38 || keyCode === 40) {
              e.preventDefault();

              if (keyCode === 38 && activeIndex > 0) {
                activeIndex--;
              }

              if (keyCode === 40 && activeIndex < numItems - 1) {
                activeIndex++;
              }

              $active.removeClass('active');
              if (activeIndex >= 0) {
                $autocomplete.children('li').eq(activeIndex).addClass('active');
              }
            }
          });

          // Set input value
          $autocomplete.on('mousedown.autocomplete touchstart.autocomplete', 'li', function () {
            var text = $(this).text().trim();
            $input.val(text);
            $input.trigger('change');
            removeAutocomplete();

            // Handle onAutocomplete callback.
            if (typeof options.onAutocomplete === "function") {
              options.onAutocomplete.call(this, text);
            }
          });
        }
      });
    };
  }); // End of $(document).ready

  /*******************
   *  Select Plugin  *
   ******************/
  $.fn.material_select = function (callback) {
    $(this).each(function () {
      var $select = $(this);

      if ($select.hasClass('browser-default')) {
        return; // Continue to next (return false breaks out of entire loop)
      }

      var multiple = $select.attr('multiple') ? true : false,
          lastID = $select.data('select-id'); // Tear down structure if Select needs to be rebuilt

      if (lastID) {
        $select.parent().find('span.caret').remove();
        $select.parent().find('input').remove();

        $select.unwrap();
        $('ul#select-options-' + lastID).remove();
      }

      // If destroying the select, remove the selelct-id and reset it to it's uninitialized state.
      if (callback === 'destroy') {
        $select.data('select-id', null).removeClass('initialized');
        return;
      }

      var uniqueID = Materialize.guid();
      $select.data('select-id', uniqueID);
      var wrapper = $('<div class="select-wrapper"></div>');
      wrapper.addClass($select.attr('class'));
      var options = $('<ul id="select-options-' + uniqueID + '" class="dropdown-content select-dropdown ' + (multiple ? 'multiple-select-dropdown' : '') + '"></ul>'),
          selectChildren = $select.children('option, optgroup'),
          valuesSelected = [],
          optionsHover = false;

      var label = $select.find('option:selected').html() || $select.find('option:first').html() || "";

      // Function that renders and appends the option taking into
      // account type and possible image icon.
      var appendOptionWithIcon = function appendOptionWithIcon(select, option, type) {
        // Add disabled attr if disabled
        var disabledClass = option.is(':disabled') ? 'disabled ' : '';
        var optgroupClass = type === 'optgroup-option' ? 'optgroup-option ' : '';
        var multipleCheckbox = multiple ? '<input type="checkbox"' + disabledClass + '/><label></label>' : '';

        // add icons
        var icon_url = option.data('icon');
        var classes = option.attr('class');
        if (!!icon_url) {
          var classString = '';
          if (!!classes) classString = ' class="' + classes + '"';

          // Check for multiple type.
          options.append($('<li class="' + disabledClass + optgroupClass + '"><img alt="" src="' + icon_url + '"' + classString + '><span>' + multipleCheckbox + option.html() + '</span></li>'));
          return true;
        }

        // Check for multiple type.
        options.append($('<li class="' + disabledClass + optgroupClass + '"><span>' + multipleCheckbox + option.html() + '</span></li>'));
      };

      /* Create dropdown structure. */
      if (selectChildren.length) {
        selectChildren.each(function () {
          if ($(this).is('option')) {
            // Direct descendant option.
            if (multiple) {
              appendOptionWithIcon($select, $(this), 'multiple');
            } else {
              appendOptionWithIcon($select, $(this));
            }
          } else if ($(this).is('optgroup')) {
            // Optgroup.
            var selectOptions = $(this).children('option');
            options.append($('<li class="optgroup"><span>' + $(this).attr('label') + '</span></li>'));

            selectOptions.each(function () {
              appendOptionWithIcon($select, $(this), 'optgroup-option');
            });
          }
        });
      }

      options.find('li:not(.optgroup)').each(function (i) {
        $(this).click(function (e) {
          // Check if option element is disabled
          if (!$(this).hasClass('disabled') && !$(this).hasClass('optgroup')) {
            var selected = true;

            if (multiple) {
              $('input[type="checkbox"]', this).prop('checked', function (i, v) {
                return !v;
              });
              selected = toggleEntryFromArray(valuesSelected, i, $select);
              $newSelect.trigger('focus');
            } else {
              options.find('li').removeClass('active');
              $(this).toggleClass('active');
              $newSelect.val($(this).text());
            }

            activateOption(options, $(this));
            $select.find('option').eq(i).prop('selected', selected);
            // Trigger onchange() event
            $select.trigger('change');
            if (typeof callback !== 'undefined') callback();
          }

          e.stopPropagation();
        });
      });

      // Wrap Elements
      $select.wrap(wrapper);
      // Add Select Display Element
      var dropdownIcon = $('<span class="caret">&#9660;</span>');
      if ($select.is(':disabled')) dropdownIcon.addClass('disabled');

      // escape double quotes
      var sanitizedLabelHtml = label.replace(/"/g, '&quot;');

      var $newSelect = $('<input type="text" class="select-dropdown" readonly="true" ' + ($select.is(':disabled') ? 'disabled' : '') + ' data-activates="select-options-' + uniqueID + '" value="' + sanitizedLabelHtml + '"/>');
      $select.before($newSelect);
      $newSelect.before(dropdownIcon);

      $newSelect.after(options);
      // Check if section element is disabled
      if (!$select.is(':disabled')) {
        $newSelect.dropdown({ 'hover': false });
      }

      // Copy tabindex
      if ($select.attr('tabindex')) {
        $($newSelect[0]).attr('tabindex', $select.attr('tabindex'));
      }

      $select.addClass('initialized');

      $newSelect.on({
        'focus': function focus() {
          if ($('ul.select-dropdown').not(options[0]).is(':visible')) {
            $('input.select-dropdown').trigger('close');
          }
          if (!options.is(':visible')) {
            $(this).trigger('open', ['focus']);
            var label = $(this).val();
            if (multiple && label.indexOf(',') >= 0) {
              label = label.split(',')[0];
            }

            var selectedOption = options.find('li').filter(function () {
              return $(this).text().toLowerCase() === label.toLowerCase();
            })[0];
            activateOption(options, selectedOption, true);
          }
        },
        'click': function click(e) {
          e.stopPropagation();
        }
      });

      $newSelect.on('blur', function () {
        if (!multiple) {
          $(this).trigger('close');
        }
        options.find('li.selected').removeClass('selected');
      });

      options.hover(function () {
        optionsHover = true;
      }, function () {
        optionsHover = false;
      });

      $(window).on({
        'click': function click() {
          multiple && (optionsHover || $newSelect.trigger('close'));
        }
      });

      // Add initial multiple selections.
      if (multiple) {
        $select.find("option:selected:not(:disabled)").each(function () {
          var index = $(this).index();

          toggleEntryFromArray(valuesSelected, index, $select);
          options.find("li").eq(index).find(":checkbox").prop("checked", true);
        });
      }

      /**
       * Make option as selected and scroll to selected position
       * @param {jQuery} collection  Select options jQuery element
       * @param {Element} newOption  element of the new option
       * @param {Boolean} firstActivation  If on first activation of select
       */
      var activateOption = function activateOption(collection, newOption, firstActivation) {
        if (newOption) {
          collection.find('li.selected').removeClass('selected');
          var option = $(newOption);
          option.addClass('selected');
          if (!multiple || !!firstActivation) {
            options.scrollTo(option);
          }
        }
      };

      // Allow user to search by typing
      // this array is cleared after 1 second
      var filterQuery = [],
          onKeyDown = function onKeyDown(e) {
        // TAB - switch to another input
        if (e.which == 9) {
          $newSelect.trigger('close');
          return;
        }

        // ARROW DOWN WHEN SELECT IS CLOSED - open select options
        if (e.which == 40 && !options.is(':visible')) {
          $newSelect.trigger('open');
          return;
        }

        // ENTER WHEN SELECT IS CLOSED - submit form
        if (e.which == 13 && !options.is(':visible')) {
          return;
        }

        e.preventDefault();

        // CASE WHEN USER TYPE LETTERS
        var letter = String.fromCharCode(e.which).toLowerCase(),
            nonLetters = [9, 13, 27, 38, 40];
        if (letter && nonLetters.indexOf(e.which) === -1) {
          filterQuery.push(letter);

          var string = filterQuery.join(''),
              newOption = options.find('li').filter(function () {
            return $(this).text().toLowerCase().indexOf(string) === 0;
          })[0];

          if (newOption) {
            activateOption(options, newOption);
          }
        }

        // ENTER - select option and close when select options are opened
        if (e.which == 13) {
          var activeOption = options.find('li.selected:not(.disabled)')[0];
          if (activeOption) {
            $(activeOption).trigger('click');
            if (!multiple) {
              $newSelect.trigger('close');
            }
          }
        }

        // ARROW DOWN - move to next not disabled option
        if (e.which == 40) {
          if (options.find('li.selected').length) {
            newOption = options.find('li.selected').next('li:not(.disabled)')[0];
          } else {
            newOption = options.find('li:not(.disabled)')[0];
          }
          activateOption(options, newOption);
        }

        // ESC - close options
        if (e.which == 27) {
          $newSelect.trigger('close');
        }

        // ARROW UP - move to previous not disabled option
        if (e.which == 38) {
          newOption = options.find('li.selected').prev('li:not(.disabled)')[0];
          if (newOption) activateOption(options, newOption);
        }

        // Automaticaly clean filter query so user can search again by starting letters
        setTimeout(function () {
          filterQuery = [];
        }, 1000);
      };

      $newSelect.on('keydown', onKeyDown);
    });

    function toggleEntryFromArray(entriesArray, entryIndex, select) {
      var index = entriesArray.indexOf(entryIndex),
          notAdded = index === -1;

      if (notAdded) {
        entriesArray.push(entryIndex);
      } else {
        entriesArray.splice(index, 1);
      }

      select.siblings('ul.dropdown-content').find('li:not(.optgroup)').eq(entryIndex).toggleClass('active');

      // use notAdded instead of true (to detect if the option is selected or not)
      select.find('option').eq(entryIndex).prop('selected', notAdded);
      setValueToInput(entriesArray, select);

      return notAdded;
    }

    function setValueToInput(entriesArray, select) {
      var value = '';

      for (var i = 0, count = entriesArray.length; i < count; i++) {
        var text = select.find('option').eq(entriesArray[i]).text();

        i === 0 ? value += text : value += ', ' + text;
      }

      if (value === '') {
        value = select.find('option:disabled').eq(0).text();
      }

      select.siblings('input.select-dropdown').val(value);
    }
  };
})(jQuery);
;(function ($) {

  var methods = {

    init: function init(options) {
      var defaults = {
        indicators: true,
        height: 400,
        transition: 500,
        interval: 6000
      };
      options = $.extend(defaults, options);

      return this.each(function () {

        // For each slider, we want to keep track of
        // which slide is active and its associated content
        var $this = $(this);
        var $slider = $this.find('ul.slides').first();
        var $slides = $slider.find('> li');
        var $active_index = $slider.find('.active').index();
        var $active, $indicators, $interval;
        if ($active_index != -1) {
          $active = $slides.eq($active_index);
        }

        // Transitions the caption depending on alignment
        function captionTransition(caption, duration) {
          if (caption.hasClass("center-align")) {
            caption.velocity({ opacity: 0, translateY: -100 }, { duration: duration, queue: false });
          } else if (caption.hasClass("right-align")) {
            caption.velocity({ opacity: 0, translateX: 100 }, { duration: duration, queue: false });
          } else if (caption.hasClass("left-align")) {
            caption.velocity({ opacity: 0, translateX: -100 }, { duration: duration, queue: false });
          }
        }

        // This function will transition the slide to any index of the next slide
        function moveToSlide(index) {
          // Wrap around indices.
          if (index >= $slides.length) index = 0;else if (index < 0) index = $slides.length - 1;

          $active_index = $slider.find('.active').index();

          // Only do if index changes
          if ($active_index != index) {
            $active = $slides.eq($active_index);
            $caption = $active.find('.caption');

            $active.removeClass('active');
            $active.velocity({ opacity: 0 }, { duration: options.transition, queue: false, easing: 'easeOutQuad',
              complete: function complete() {
                $slides.not('.active').velocity({ opacity: 0, translateX: 0, translateY: 0 }, { duration: 0, queue: false });
              } });
            captionTransition($caption, options.transition);

            // Update indicators
            if (options.indicators) {
              $indicators.eq($active_index).removeClass('active');
            }

            $slides.eq(index).velocity({ opacity: 1 }, { duration: options.transition, queue: false, easing: 'easeOutQuad' });
            $slides.eq(index).find('.caption').velocity({ opacity: 1, translateX: 0, translateY: 0 }, { duration: options.transition, delay: options.transition, queue: false, easing: 'easeOutQuad' });
            $slides.eq(index).addClass('active');

            // Update indicators
            if (options.indicators) {
              $indicators.eq(index).addClass('active');
            }
          }
        }

        // Set height of slider
        // If fullscreen, do nothing
        if (!$this.hasClass('fullscreen')) {
          if (options.indicators) {
            // Add height if indicators are present
            $this.height(options.height + 40);
          } else {
            $this.height(options.height);
          }
          $slider.height(options.height);
        }

        // Set initial positions of captions
        $slides.find('.caption').each(function () {
          captionTransition($(this), 0);
        });

        // Move img src into background-image
        $slides.find('img').each(function () {
          var placeholderBase64 = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
          if ($(this).attr('src') !== placeholderBase64) {
            $(this).css('background-image', 'url(' + $(this).attr('src') + ')');
            $(this).attr('src', placeholderBase64);
          }
        });

        // dynamically add indicators
        if (options.indicators) {
          $indicators = $('<ul class="indicators"></ul>');
          $slides.each(function (index) {
            var $indicator = $('<li class="indicator-item"></li>');

            // Handle clicks on indicators
            $indicator.click(function () {
              var $parent = $slider.parent();
              var curr_index = $parent.find($(this)).index();
              moveToSlide(curr_index);

              // reset interval
              clearInterval($interval);
              $interval = setInterval(function () {
                $active_index = $slider.find('.active').index();
                if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
                else $active_index += 1;

                moveToSlide($active_index);
              }, options.transition + options.interval);
            });
            $indicators.append($indicator);
          });
          $this.append($indicators);
          $indicators = $this.find('ul.indicators').find('li.indicator-item');
        }

        if ($active) {
          $active.show();
        } else {
          $slides.first().addClass('active').velocity({ opacity: 1 }, { duration: options.transition, queue: false, easing: 'easeOutQuad' });

          $active_index = 0;
          $active = $slides.eq($active_index);

          // Update indicators
          if (options.indicators) {
            $indicators.eq($active_index).addClass('active');
          }
        }

        // Adjust height to current slide
        $active.find('img').each(function () {
          $active.find('.caption').velocity({ opacity: 1, translateX: 0, translateY: 0 }, { duration: options.transition, queue: false, easing: 'easeOutQuad' });
        });

        // auto scroll
        $interval = setInterval(function () {
          $active_index = $slider.find('.active').index();
          moveToSlide($active_index + 1);
        }, options.transition + options.interval);

        // HammerJS, Swipe navigation

        // Touch Event
        var panning = false;
        var swipeLeft = false;
        var swipeRight = false;

        $this.hammer({
          prevent_default: false
        }).bind('pan', function (e) {
          if (e.gesture.pointerType === "touch") {

            // reset interval
            clearInterval($interval);

            var direction = e.gesture.direction;
            var x = e.gesture.deltaX;
            var velocityX = e.gesture.velocityX;
            var velocityY = e.gesture.velocityY;

            $curr_slide = $slider.find('.active');
            if (Math.abs(velocityX) > Math.abs(velocityY)) {
              $curr_slide.velocity({ translateX: x
              }, { duration: 50, queue: false, easing: 'easeOutQuad' });
            }

            // Swipe Left
            if (direction === 4 && (x > $this.innerWidth() / 2 || velocityX < -0.65)) {
              swipeRight = true;
            }
            // Swipe Right
            else if (direction === 2 && (x < -1 * $this.innerWidth() / 2 || velocityX > 0.65)) {
                swipeLeft = true;
              }

            // Make Slide Behind active slide visible
            var next_slide;
            if (swipeLeft) {
              next_slide = $curr_slide.next();
              if (next_slide.length === 0) {
                next_slide = $slides.first();
              }
              next_slide.velocity({ opacity: 1
              }, { duration: 300, queue: false, easing: 'easeOutQuad' });
            }
            if (swipeRight) {
              next_slide = $curr_slide.prev();
              if (next_slide.length === 0) {
                next_slide = $slides.last();
              }
              next_slide.velocity({ opacity: 1
              }, { duration: 300, queue: false, easing: 'easeOutQuad' });
            }
          }
        }).bind('panend', function (e) {
          if (e.gesture.pointerType === "touch") {

            $curr_slide = $slider.find('.active');
            panning = false;
            curr_index = $slider.find('.active').index();

            if (!swipeRight && !swipeLeft || $slides.length <= 1) {
              // Return to original spot
              $curr_slide.velocity({ translateX: 0
              }, { duration: 300, queue: false, easing: 'easeOutQuad' });
            } else if (swipeLeft) {
              moveToSlide(curr_index + 1);
              $curr_slide.velocity({ translateX: -1 * $this.innerWidth() }, { duration: 300, queue: false, easing: 'easeOutQuad',
                complete: function complete() {
                  $curr_slide.velocity({ opacity: 0, translateX: 0 }, { duration: 0, queue: false });
                } });
            } else if (swipeRight) {
              moveToSlide(curr_index - 1);
              $curr_slide.velocity({ translateX: $this.innerWidth() }, { duration: 300, queue: false, easing: 'easeOutQuad',
                complete: function complete() {
                  $curr_slide.velocity({ opacity: 0, translateX: 0 }, { duration: 0, queue: false });
                } });
            }
            swipeLeft = false;
            swipeRight = false;

            // Restart interval
            clearInterval($interval);
            $interval = setInterval(function () {
              $active_index = $slider.find('.active').index();
              if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
              else $active_index += 1;

              moveToSlide($active_index);
            }, options.transition + options.interval);
          }
        });

        $this.on('sliderPause', function () {
          clearInterval($interval);
        });

        $this.on('sliderStart', function () {
          clearInterval($interval);
          $interval = setInterval(function () {
            $active_index = $slider.find('.active').index();
            if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
            else $active_index += 1;

            moveToSlide($active_index);
          }, options.transition + options.interval);
        });

        $this.on('sliderNext', function () {
          $active_index = $slider.find('.active').index();
          moveToSlide($active_index + 1);
        });

        $this.on('sliderPrev', function () {
          $active_index = $slider.find('.active').index();
          moveToSlide($active_index - 1);
        });
      });
    },
    pause: function pause() {
      $(this).trigger('sliderPause');
    },
    start: function start() {
      $(this).trigger('sliderStart');
    },
    next: function next() {
      $(this).trigger('sliderNext');
    },
    prev: function prev() {
      $(this).trigger('sliderPrev');
    }
  };

  $.fn.slider = function (methodOrOptions) {
    if (methods[methodOrOptions]) {
      return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if ((typeof methodOrOptions === 'undefined' ? 'undefined' : _typeof(methodOrOptions)) === 'object' || !methodOrOptions) {
      // Default to "init"
      return methods.init.apply(this, arguments);
    } else {
      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.tooltip');
    }
  }; // Plugin end
})(jQuery);
;(function ($) {
  $(document).ready(function () {

    $(document).on('click.card', '.card', function (e) {
      if ($(this).find('> .card-reveal').length) {
        if ($(e.target).is($('.card-reveal .card-title')) || $(e.target).is($('.card-reveal .card-title i'))) {
          // Make Reveal animate down and display none
          $(this).find('.card-reveal').velocity({ translateY: 0 }, {
            duration: 225,
            queue: false,
            easing: 'easeInOutQuad',
            complete: function complete() {
              $(this).css({ display: 'none' });
            }
          });
        } else if ($(e.target).is($('.card .activator')) || $(e.target).is($('.card .activator i'))) {
          $(e.target).closest('.card').css('overflow', 'hidden');
          $(this).find('.card-reveal').css({ display: 'block' }).velocity("stop", false).velocity({ translateY: '-100%' }, { duration: 300, queue: false, easing: 'easeInOutQuad' });
        }
      }
    });
  });
})(jQuery);;(function ($) {
  var materialChipsDefaults = {
    data: [],
    placeholder: '',
    secondaryPlaceholder: '',
    autocompleteOptions: {}
  };

  $(document).ready(function () {
    // Handle removal of static chips.
    $(document).on('click', '.chip .close', function (e) {
      var $chips = $(this).closest('.chips');
      if ($chips.attr('data-initialized')) {
        return;
      }
      $(this).closest('.chip').remove();
    });
  });

  $.fn.material_chip = function (options) {
    var self = this;
    this.$el = $(this);
    this.$document = $(document);
    this.SELS = {
      CHIPS: '.chips',
      CHIP: '.chip',
      INPUT: 'input',
      DELETE: '.material-icons',
      SELECTED_CHIP: '.selected'
    };

    if ('data' === options) {
      return this.$el.data('chips');
    }

    var curr_options = $.extend({}, materialChipsDefaults, options);
    self.hasAutocomplete = !$.isEmptyObject(curr_options.autocompleteOptions.data);

    // Initialize
    this.init = function () {
      var i = 0;
      var chips;
      self.$el.each(function () {
        var $chips = $(this);
        var chipId = Materialize.guid();
        self.chipId = chipId;

        if (!curr_options.data || !(curr_options.data instanceof Array)) {
          curr_options.data = [];
        }
        $chips.data('chips', curr_options.data);
        $chips.attr('data-index', i);
        $chips.attr('data-initialized', true);

        if (!$chips.hasClass(self.SELS.CHIPS)) {
          $chips.addClass('chips');
        }

        self.chips($chips, chipId);
        i++;
      });
    };

    this.handleEvents = function () {
      var SELS = self.SELS;

      self.$document.off('click.chips-focus', SELS.CHIPS).on('click.chips-focus', SELS.CHIPS, function (e) {
        $(e.target).find(SELS.INPUT).focus();
      });

      self.$document.off('click.chips-select', SELS.CHIP).on('click.chips-select', SELS.CHIP, function (e) {
        var $chip = $(e.target);
        if ($chip.length) {
          var wasSelected = $chip.hasClass('selected');
          var $chips = $chip.closest(SELS.CHIPS);
          $(SELS.CHIP).removeClass('selected');

          if (!wasSelected) {
            self.selectChip($chip.index(), $chips);
          }
        }
      });

      self.$document.off('keydown.chips').on('keydown.chips', function (e) {
        if ($(e.target).is('input, textarea')) {
          return;
        }

        // delete
        var $chip = self.$document.find(SELS.CHIP + SELS.SELECTED_CHIP);
        var $chips = $chip.closest(SELS.CHIPS);
        var length = $chip.siblings(SELS.CHIP).length;
        var index;

        if (!$chip.length) {
          return;
        }

        if (e.which === 8 || e.which === 46) {
          e.preventDefault();

          index = $chip.index();
          self.deleteChip(index, $chips);

          var selectIndex = null;
          if (index + 1 < length) {
            selectIndex = index;
          } else if (index === length || index + 1 === length) {
            selectIndex = length - 1;
          }

          if (selectIndex < 0) selectIndex = null;

          if (null !== selectIndex) {
            self.selectChip(selectIndex, $chips);
          }
          if (!length) $chips.find('input').focus();

          // left
        } else if (e.which === 37) {
          index = $chip.index() - 1;
          if (index < 0) {
            return;
          }
          $(SELS.CHIP).removeClass('selected');
          self.selectChip(index, $chips);

          // right
        } else if (e.which === 39) {
          index = $chip.index() + 1;
          $(SELS.CHIP).removeClass('selected');
          if (index > length) {
            $chips.find('input').focus();
            return;
          }
          self.selectChip(index, $chips);
        }
      });

      self.$document.off('focusin.chips', SELS.CHIPS + ' ' + SELS.INPUT).on('focusin.chips', SELS.CHIPS + ' ' + SELS.INPUT, function (e) {
        var $currChips = $(e.target).closest(SELS.CHIPS);
        $currChips.addClass('focus');
        $currChips.siblings('label, .prefix').addClass('active');
        $(SELS.CHIP).removeClass('selected');
      });

      self.$document.off('focusout.chips', SELS.CHIPS + ' ' + SELS.INPUT).on('focusout.chips', SELS.CHIPS + ' ' + SELS.INPUT, function (e) {
        var $currChips = $(e.target).closest(SELS.CHIPS);
        $currChips.removeClass('focus');

        // Remove active if empty
        if (!$currChips.data('chips').length) {
          $currChips.siblings('label').removeClass('active');
        }
        $currChips.siblings('.prefix').removeClass('active');
      });

      self.$document.off('keydown.chips-add', SELS.CHIPS + ' ' + SELS.INPUT).on('keydown.chips-add', SELS.CHIPS + ' ' + SELS.INPUT, function (e) {
        var $target = $(e.target);
        var $chips = $target.closest(SELS.CHIPS);
        var chipsLength = $chips.children(SELS.CHIP).length;

        // enter
        if (13 === e.which) {
          // Override enter if autocompleting.
          if (self.hasAutocomplete && $chips.find('.autocomplete-content.dropdown-content').length && $chips.find('.autocomplete-content.dropdown-content').children().length) {
            return;
          }

          e.preventDefault();
          self.addChip({ tag: $target.val() }, $chips);
          $target.val('');
          return;
        }

        // delete or left
        if ((8 === e.keyCode || 37 === e.keyCode) && '' === $target.val() && chipsLength) {
          e.preventDefault();
          self.selectChip(chipsLength - 1, $chips);
          $target.blur();
          return;
        }
      });

      // Click on delete icon in chip.
      self.$document.off('click.chips-delete', SELS.CHIPS + ' ' + SELS.DELETE).on('click.chips-delete', SELS.CHIPS + ' ' + SELS.DELETE, function (e) {
        var $target = $(e.target);
        var $chips = $target.closest(SELS.CHIPS);
        var $chip = $target.closest(SELS.CHIP);
        e.stopPropagation();
        self.deleteChip($chip.index(), $chips);
        $chips.find('input').focus();
      });
    };

    this.chips = function ($chips, chipId) {
      $chips.empty();
      $chips.data('chips').forEach(function (elem) {
        $chips.append(self.renderChip(elem));
      });
      $chips.append($('<input id="' + chipId + '" class="input" placeholder="">'));
      self.setPlaceholder($chips);

      // Set for attribute for label
      var label = $chips.next('label');
      if (label.length) {
        label.attr('for', chipId);

        if ($chips.data('chips').length) {
          label.addClass('active');
        }
      }

      // Setup autocomplete if needed.
      var input = $('#' + chipId);
      if (self.hasAutocomplete) {
        curr_options.autocompleteOptions.onAutocomplete = function (val) {
          self.addChip({ tag: val }, $chips);
          input.val('');
          input.focus();
        };
        input.autocomplete(curr_options.autocompleteOptions);
      }
    };

    /**
     * Render chip jQuery element.
     * @param {Object} elem
     * @return {jQuery}
     */
    this.renderChip = function (elem) {
      if (!elem.tag) return;

      var $renderedChip = $('<div class="chip"></div>');
      $renderedChip.text(elem.tag);
      $renderedChip.append($('<i class="material-icons close">close</i>'));
      return $renderedChip;
    };

    this.setPlaceholder = function ($chips) {
      if ($chips.data('chips').length && curr_options.placeholder) {
        $chips.find('input').prop('placeholder', curr_options.placeholder);
      } else if (!$chips.data('chips').length && curr_options.secondaryPlaceholder) {
        $chips.find('input').prop('placeholder', curr_options.secondaryPlaceholder);
      }
    };

    this.isValid = function ($chips, elem) {
      var chips = $chips.data('chips');
      var exists = false;
      for (var i = 0; i < chips.length; i++) {
        if (chips[i].tag === elem.tag) {
          exists = true;
          return;
        }
      }
      return '' !== elem.tag && !exists;
    };

    this.addChip = function (elem, $chips) {
      if (!self.isValid($chips, elem)) {
        return;
      }
      var $renderedChip = self.renderChip(elem);
      var newData = [];
      var oldData = $chips.data('chips');
      for (var i = 0; i < oldData.length; i++) {
        newData.push(oldData[i]);
      }
      newData.push(elem);

      $chips.data('chips', newData);
      $renderedChip.insertBefore($chips.find('input'));
      $chips.trigger('chip.add', elem);
      self.setPlaceholder($chips);
    };

    this.deleteChip = function (chipIndex, $chips) {
      var chip = $chips.data('chips')[chipIndex];
      $chips.find('.chip').eq(chipIndex).remove();

      var newData = [];
      var oldData = $chips.data('chips');
      for (var i = 0; i < oldData.length; i++) {
        if (i !== chipIndex) {
          newData.push(oldData[i]);
        }
      }

      $chips.data('chips', newData);
      $chips.trigger('chip.delete', chip);
      self.setPlaceholder($chips);
    };

    this.selectChip = function (chipIndex, $chips) {
      var $chip = $chips.find('.chip').eq(chipIndex);
      if ($chip && false === $chip.hasClass('selected')) {
        $chip.addClass('selected');
        $chips.trigger('chip.select', $chips.data('chips')[chipIndex]);
      }
    };

    this.getChipsElement = function (index, $chips) {
      return $chips.eq(index);
    };

    // init
    this.init();

    this.handleEvents();
  };
})(jQuery);
;(function ($) {
  $.fn.pushpin = function (options) {
    // Defaults
    var defaults = {
      top: 0,
      bottom: Infinity,
      offset: 0
    };

    // Remove pushpin event and classes
    if (options === "remove") {
      this.each(function () {
        if (id = $(this).data('pushpin-id')) {
          $(window).off('scroll.' + id);
          $(this).removeData('pushpin-id').removeClass('pin-top pinned pin-bottom').removeAttr('style');
        }
      });
      return false;
    }

    options = $.extend(defaults, options);

    $index = 0;
    return this.each(function () {
      var $uniqueId = Materialize.guid(),
          $this = $(this),
          $original_offset = $(this).offset().top;

      function removePinClasses(object) {
        object.removeClass('pin-top');
        object.removeClass('pinned');
        object.removeClass('pin-bottom');
      }

      function updateElements(objects, scrolled) {
        objects.each(function () {
          // Add position fixed (because its between top and bottom)
          if (options.top <= scrolled && options.bottom >= scrolled && !$(this).hasClass('pinned')) {
            removePinClasses($(this));
            $(this).css('top', options.offset);
            $(this).addClass('pinned');
          }

          // Add pin-top (when scrolled position is above top)
          if (scrolled < options.top && !$(this).hasClass('pin-top')) {
            removePinClasses($(this));
            $(this).css('top', 0);
            $(this).addClass('pin-top');
          }

          // Add pin-bottom (when scrolled position is below bottom)
          if (scrolled > options.bottom && !$(this).hasClass('pin-bottom')) {
            removePinClasses($(this));
            $(this).addClass('pin-bottom');
            $(this).css('top', options.bottom - $original_offset);
          }
        });
      }

      $(this).data('pushpin-id', $uniqueId);
      updateElements($this, $(window).scrollTop());
      $(window).on('scroll.' + $uniqueId, function () {
        var $scrolled = $(window).scrollTop() + options.offset;
        updateElements($this, $scrolled);
      });
    });
  };
})(jQuery);;(function ($) {
  $(document).ready(function () {

    // jQuery reverse
    $.fn.reverse = [].reverse;

    // Hover behaviour: make sure this doesn't work on .click-to-toggle FABs!
    $(document).on('mouseenter.fixedActionBtn', '.fixed-action-btn:not(.click-to-toggle):not(.toolbar)', function (e) {
      var $this = $(this);
      openFABMenu($this);
    });
    $(document).on('mouseleave.fixedActionBtn', '.fixed-action-btn:not(.click-to-toggle):not(.toolbar)', function (e) {
      var $this = $(this);
      closeFABMenu($this);
    });

    // Toggle-on-click behaviour.
    $(document).on('click.fabClickToggle', '.fixed-action-btn.click-to-toggle > a', function (e) {
      var $this = $(this);
      var $menu = $this.parent();
      if ($menu.hasClass('active')) {
        closeFABMenu($menu);
      } else {
        openFABMenu($menu);
      }
    });

    // Toolbar transition behaviour.
    $(document).on('click.fabToolbar', '.fixed-action-btn.toolbar > a', function (e) {
      var $this = $(this);
      var $menu = $this.parent();
      FABtoToolbar($menu);
    });
  });

  $.fn.extend({
    openFAB: function openFAB() {
      openFABMenu($(this));
    },
    closeFAB: function closeFAB() {
      closeFABMenu($(this));
    },
    openToolbar: function openToolbar() {
      FABtoToolbar($(this));
    },
    closeToolbar: function closeToolbar() {
      toolbarToFAB($(this));
    }
  });

  var openFABMenu = function openFABMenu(btn) {
    var $this = btn;
    if ($this.hasClass('active') === false) {

      // Get direction option
      var horizontal = $this.hasClass('horizontal');
      var offsetY, offsetX;

      if (horizontal === true) {
        offsetX = 40;
      } else {
        offsetY = 40;
      }

      $this.addClass('active');
      $this.find('ul .btn-floating').velocity({ scaleY: ".4", scaleX: ".4", translateY: offsetY + 'px', translateX: offsetX + 'px' }, { duration: 0 });

      var time = 0;
      $this.find('ul .btn-floating').reverse().each(function () {
        $(this).velocity({ opacity: "1", scaleX: "1", scaleY: "1", translateY: "0", translateX: '0' }, { duration: 80, delay: time });
        time += 40;
      });
    }
  };

  var closeFABMenu = function closeFABMenu(btn) {
    var $this = btn;
    // Get direction option
    var horizontal = $this.hasClass('horizontal');
    var offsetY, offsetX;

    if (horizontal === true) {
      offsetX = 40;
    } else {
      offsetY = 40;
    }

    $this.removeClass('active');
    var time = 0;
    $this.find('ul .btn-floating').velocity("stop", true);
    $this.find('ul .btn-floating').velocity({ opacity: "0", scaleX: ".4", scaleY: ".4", translateY: offsetY + 'px', translateX: offsetX + 'px' }, { duration: 80 });
  };

  /**
   * Transform FAB into toolbar
   * @param  {Object}  object jQuery object
   */
  var FABtoToolbar = function FABtoToolbar(btn) {
    if (btn.attr('data-open') === "true") {
      return;
    }

    var offsetX, offsetY, scaleFactor;
    var windowWidth = window.innerWidth;
    var windowHeight = window.innerHeight;
    var btnRect = btn[0].getBoundingClientRect();
    var anchor = btn.find('> a').first();
    var menu = btn.find('> ul').first();
    var backdrop = $('<div class="fab-backdrop"></div>');
    var fabColor = anchor.css('background-color');
    anchor.append(backdrop);

    offsetX = btnRect.left - windowWidth / 2 + btnRect.width / 2;
    offsetY = windowHeight - btnRect.bottom;
    scaleFactor = windowWidth / backdrop.width();
    btn.attr('data-origin-bottom', btnRect.bottom);
    btn.attr('data-origin-left', btnRect.left);
    btn.attr('data-origin-width', btnRect.width);

    // Set initial state
    btn.addClass('active');
    btn.attr('data-open', true);
    btn.css({
      'text-align': 'center',
      width: '100%',
      bottom: 0,
      left: 0,
      transform: 'translateX(' + offsetX + 'px)',
      transition: 'none'
    });
    anchor.css({
      transform: 'translateY(' + -offsetY + 'px)',
      transition: 'none'
    });
    backdrop.css({
      'background-color': fabColor
    });

    setTimeout(function () {
      btn.css({
        transform: '',
        transition: 'transform .2s cubic-bezier(0.550, 0.085, 0.680, 0.530), background-color 0s linear .2s'
      });
      anchor.css({
        overflow: 'visible',
        transform: '',
        transition: 'transform .2s'
      });

      setTimeout(function () {
        btn.css({
          overflow: 'hidden',
          'background-color': fabColor
        });
        backdrop.css({
          transform: 'scale(' + scaleFactor + ')',
          transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'
        });
        menu.find('> li > a').css({
          opacity: 1
        });

        // Scroll to close.
        $(window).on('scroll.fabToolbarClose', function () {
          toolbarToFAB(btn);
          $(window).off('scroll.fabToolbarClose');
          $(document).off('click.fabToolbarClose');
        });

        $(document).on('click.fabToolbarClose', function (e) {
          if (!$(e.target).closest(menu).length) {
            toolbarToFAB(btn);
            $(window).off('scroll.fabToolbarClose');
            $(document).off('click.fabToolbarClose');
          }
        });
      }, 100);
    }, 0);
  };

  /**
   * Transform toolbar back into FAB
   * @param  {Object}  object jQuery object
   */
  var toolbarToFAB = function toolbarToFAB(btn) {
    if (btn.attr('data-open') !== "true") {
      return;
    }

    var offsetX, offsetY, scaleFactor;
    var windowWidth = window.innerWidth;
    var windowHeight = window.innerHeight;
    var btnWidth = btn.attr('data-origin-width');
    var btnBottom = btn.attr('data-origin-bottom');
    var btnLeft = btn.attr('data-origin-left');
    var anchor = btn.find('> .btn-floating').first();
    var menu = btn.find('> ul').first();
    var backdrop = btn.find('.fab-backdrop');
    var fabColor = anchor.css('background-color');

    offsetX = btnLeft - windowWidth / 2 + btnWidth / 2;
    offsetY = windowHeight - btnBottom;
    scaleFactor = windowWidth / backdrop.width();

    // Hide backdrop
    btn.removeClass('active');
    btn.attr('data-open', false);
    btn.css({
      'background-color': 'transparent',
      transition: 'none'
    });
    anchor.css({
      transition: 'none'
    });
    backdrop.css({
      transform: 'scale(0)',
      'background-color': fabColor
    });
    menu.find('> li > a').css({
      opacity: ''
    });

    setTimeout(function () {
      backdrop.remove();

      // Set initial state.
      btn.css({
        'text-align': '',
        width: '',
        bottom: '',
        left: '',
        overflow: '',
        'background-color': '',
        transform: 'translate3d(' + -offsetX + 'px,0,0)'
      });
      anchor.css({
        overflow: '',
        transform: 'translate3d(0,' + offsetY + 'px,0)'
      });

      setTimeout(function () {
        btn.css({
          transform: 'translate3d(0,0,0)',
          transition: 'transform .2s'
        });
        anchor.css({
          transform: 'translate3d(0,0,0)',
          transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'
        });
      }, 20);
    }, 200);
  };
})(jQuery);
;(function ($) {
  // Image transition function
  Materialize.fadeInImage = function (selectorOrEl) {
    var element;
    if (typeof selectorOrEl === 'string') {
      element = $(selectorOrEl);
    } else if ((typeof selectorOrEl === 'undefined' ? 'undefined' : _typeof(selectorOrEl)) === 'object') {
      element = selectorOrEl;
    } else {
      return;
    }
    element.css({ opacity: 0 });
    $(element).velocity({ opacity: 1 }, {
      duration: 650,
      queue: false,
      easing: 'easeOutSine'
    });
    $(element).velocity({ opacity: 1 }, {
      duration: 1300,
      queue: false,
      easing: 'swing',
      step: function step(now, fx) {
        fx.start = 100;
        var grayscale_setting = now / 100;
        var brightness_setting = 150 - (100 - now) / 1.75;

        if (brightness_setting < 100) {
          brightness_setting = 100;
        }
        if (now >= 0) {
          $(this).css({
            "-webkit-filter": "grayscale(" + grayscale_setting + ")" + "brightness(" + brightness_setting + "%)",
            "filter": "grayscale(" + grayscale_setting + ")" + "brightness(" + brightness_setting + "%)"
          });
        }
      }
    });
  };

  // Horizontal staggered list
  Materialize.showStaggeredList = function (selectorOrEl) {
    var element;
    if (typeof selectorOrEl === 'string') {
      element = $(selectorOrEl);
    } else if ((typeof selectorOrEl === 'undefined' ? 'undefined' : _typeof(selectorOrEl)) === 'object') {
      element = selectorOrEl;
    } else {
      return;
    }
    var time = 0;
    element.find('li').velocity({ translateX: "-100px" }, { duration: 0 });

    element.find('li').each(function () {
      $(this).velocity({ opacity: "1", translateX: "0" }, { duration: 800, delay: time, easing: [60, 10] });
      time += 120;
    });
  };

  $(document).ready(function () {
    // Hardcoded .staggered-list scrollFire
    // var staggeredListOptions = [];
    // $('ul.staggered-list').each(function (i) {

    //   var label = 'scrollFire-' + i;
    //   $(this).addClass(label);
    //   staggeredListOptions.push(
    //     {selector: 'ul.staggered-list.' + label,
    //      offset: 200,
    //      callback: 'showStaggeredList("ul.staggered-list.' + label + '")'});
    // });
    // scrollFire(staggeredListOptions);

    // HammerJS, Swipe navigation

    // Touch Event
    var swipeLeft = false;
    var swipeRight = false;

    // Dismissible Collections
    $('.dismissable').each(function () {
      $(this).hammer({
        prevent_default: false
      }).bind('pan', function (e) {
        if (e.gesture.pointerType === "touch") {
          var $this = $(this);
          var direction = e.gesture.direction;
          var x = e.gesture.deltaX;
          var velocityX = e.gesture.velocityX;

          $this.velocity({ translateX: x
          }, { duration: 50, queue: false, easing: 'easeOutQuad' });

          // Swipe Left
          if (direction === 4 && (x > $this.innerWidth() / 2 || velocityX < -0.75)) {
            swipeLeft = true;
          }

          // Swipe Right
          if (direction === 2 && (x < -1 * $this.innerWidth() / 2 || velocityX > 0.75)) {
            swipeRight = true;
          }
        }
      }).bind('panend', function (e) {
        // Reset if collection is moved back into original position
        if (Math.abs(e.gesture.deltaX) < $(this).innerWidth() / 2) {
          swipeRight = false;
          swipeLeft = false;
        }

        if (e.gesture.pointerType === "touch") {
          var $this = $(this);
          if (swipeLeft || swipeRight) {
            var fullWidth;
            if (swipeLeft) {
              fullWidth = $this.innerWidth();
            } else {
              fullWidth = -1 * $this.innerWidth();
            }

            $this.velocity({ translateX: fullWidth
            }, { duration: 100, queue: false, easing: 'easeOutQuad', complete: function complete() {
                $this.css('border', 'none');
                $this.velocity({ height: 0, padding: 0
                }, { duration: 200, queue: false, easing: 'easeOutQuad', complete: function complete() {
                    $this.remove();
                  }
                });
              }
            });
          } else {
            $this.velocity({ translateX: 0
            }, { duration: 100, queue: false, easing: 'easeOutQuad' });
          }
          swipeLeft = false;
          swipeRight = false;
        }
      });
    });

    // time = 0
    // // Vertical Staggered list
    // $('ul.staggered-list.vertical li').velocity(
    //     { translateY: "100px"},
    //     { duration: 0 });

    // $('ul.staggered-list.vertical li').each(function() {
    //   $(this).velocity(
    //     { opacity: "1", translateY: "0"},
    //     { duration: 800, delay: time, easing: [60, 25] });
    //   time += 120;
    // });

    // // Fade in and Scale
    // $('.fade-in.scale').velocity(
    //     { scaleX: .4, scaleY: .4, translateX: -600},
    //     { duration: 0});
    // $('.fade-in').each(function() {
    //   $(this).velocity(
    //     { opacity: "1", scaleX: 1, scaleY: 1, translateX: 0},
    //     { duration: 800, easing: [60, 10] });
    // });
  });
})(jQuery);
;(function ($) {

  var scrollFireEventsHandled = false;

  // Input: Array of JSON objects {selector, offset, callback}
  Materialize.scrollFire = function (options) {
    var onScroll = function onScroll() {
      var windowScroll = window.pageYOffset + window.innerHeight;

      for (var i = 0; i < options.length; i++) {
        // Get options from each line
        var value = options[i];
        var selector = value.selector,
            offset = value.offset,
            callback = value.callback;

        var currentElement = document.querySelector(selector);
        if (currentElement !== null) {
          var elementOffset = currentElement.getBoundingClientRect().top + window.pageYOffset;

          if (windowScroll > elementOffset + offset) {
            if (value.done !== true) {
              if (typeof callback === 'function') {
                callback.call(this, currentElement);
              } else if (typeof callback === 'string') {
                var callbackFunc = new Function(callback);
                callbackFunc(currentElement);
              }
              value.done = true;
            }
          }
        }
      }
    };

    var throttledScroll = Materialize.throttle(function () {
      onScroll();
    }, options.throttle || 100);

    if (!scrollFireEventsHandled) {
      window.addEventListener("scroll", throttledScroll);
      window.addEventListener("resize", throttledScroll);
      scrollFireEventsHandled = true;
    }

    // perform a scan once, after current execution context, and after dom is ready
    setTimeout(throttledScroll, 0);
  };
})(jQuery);
; /*!
  * pickadate.js v3.5.0, 2014/04/13
  * By Amsul, http://amsul.ca
  * Hosted on http://amsul.github.io/pickadate.js
  * Licensed under MIT
  */

(function (factory) {

  // AMD.
  if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_LOCAL_MODULE_0__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));

  // Node.js/browserify.
  else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object') module.exports = factory(require('jquery'));

    // Browser globals.
    else this.Picker = factory(jQuery);
})(function ($) {

  var $window = $(window);
  var $document = $(document);
  var $html = $(document.documentElement);

  /**
   * The picker constructor that creates a blank picker.
   */
  function PickerConstructor(ELEMENT, NAME, COMPONENT, OPTIONS) {

    // If theres no element, return the picker constructor.
    if (!ELEMENT) return PickerConstructor;

    var IS_DEFAULT_THEME = false,


    // The state of the picker.
    STATE = {
      id: ELEMENT.id || 'P' + Math.abs(~~(Math.random() * new Date()))
    },


    // Merge the defaults and options passed.
    SETTINGS = COMPONENT ? $.extend(true, {}, COMPONENT.defaults, OPTIONS) : OPTIONS || {},


    // Merge the default classes with the settings classes.
    CLASSES = $.extend({}, PickerConstructor.klasses(), SETTINGS.klass),


    // The element node wrapper into a jQuery object.
    $ELEMENT = $(ELEMENT),


    // Pseudo picker constructor.
    PickerInstance = function PickerInstance() {
      return this.start();
    },


    // The picker prototype.
    P = PickerInstance.prototype = {

      constructor: PickerInstance,

      $node: $ELEMENT,

      /**
       * Initialize everything
       */
      start: function start() {

        // If its already started, do nothing.
        if (STATE && STATE.start) return P;

        // Update the picker states.
        STATE.methods = {};
        STATE.start = true;
        STATE.open = false;
        STATE.type = ELEMENT.type;

        // Confirm focus state, convert into text input to remove UA stylings,
        // and set as readonly to prevent keyboard popup.
        ELEMENT.autofocus = ELEMENT == getActiveElement();
        ELEMENT.readOnly = !SETTINGS.editable;
        ELEMENT.id = ELEMENT.id || STATE.id;
        if (ELEMENT.type != 'text') {
          ELEMENT.type = 'text';
        }

        // Create a new picker component with the settings.
        P.component = new COMPONENT(P, SETTINGS);

        // Create the picker root with a holder and then prepare it.
        P.$root = $(PickerConstructor._.node('div', createWrappedComponent(), CLASSES.picker, 'id="' + ELEMENT.id + '_root" tabindex="0"'));
        prepareElementRoot();

        // If theres a format for the hidden input element, create the element.
        if (SETTINGS.formatSubmit) {
          prepareElementHidden();
        }

        // Prepare the input element.
        prepareElement();

        // Insert the root as specified in the settings.
        if (SETTINGS.container) $(SETTINGS.container).append(P.$root);else $ELEMENT.after(P.$root);

        // Bind the default component and settings events.
        P.on({
          start: P.component.onStart,
          render: P.component.onRender,
          stop: P.component.onStop,
          open: P.component.onOpen,
          close: P.component.onClose,
          set: P.component.onSet
        }).on({
          start: SETTINGS.onStart,
          render: SETTINGS.onRender,
          stop: SETTINGS.onStop,
          open: SETTINGS.onOpen,
          close: SETTINGS.onClose,
          set: SETTINGS.onSet
        });

        // Once were all set, check the theme in use.
        IS_DEFAULT_THEME = isUsingDefaultTheme(P.$root.children()[0]);

        // If the element has autofocus, open the picker.
        if (ELEMENT.autofocus) {
          P.open();
        }

        // Trigger queued the start and render events.
        return P.trigger('start').trigger('render');
      }, //start


      /**
       * Render a new picker
       */
      render: function render(entireComponent) {

        // Insert a new component holder in the root or box.
        if (entireComponent) P.$root.html(createWrappedComponent());else P.$root.find('.' + CLASSES.box).html(P.component.nodes(STATE.open));

        // Trigger the queued render events.
        return P.trigger('render');
      }, //render


      /**
       * Destroy everything
       */
      stop: function stop() {

        // If its already stopped, do nothing.
        if (!STATE.start) return P;

        // Then close the picker.
        P.close();

        // Remove the hidden field.
        if (P._hidden) {
          P._hidden.parentNode.removeChild(P._hidden);
        }

        // Remove the root.
        P.$root.remove();

        // Remove the input class, remove the stored data, and unbind
        // the events (after a tick for IE - see `P.close`).
        $ELEMENT.removeClass(CLASSES.input).removeData(NAME);
        setTimeout(function () {
          $ELEMENT.off('.' + STATE.id);
        }, 0);

        // Restore the element state
        ELEMENT.type = STATE.type;
        ELEMENT.readOnly = false;

        // Trigger the queued stop events.
        P.trigger('stop');

        // Reset the picker states.
        STATE.methods = {};
        STATE.start = false;

        return P;
      }, //stop


      /**
       * Open up the picker
       */
      open: function open(dontGiveFocus) {

        // If its already open, do nothing.
        if (STATE.open) return P;

        // Add the active class.
        $ELEMENT.addClass(CLASSES.active);
        aria(ELEMENT, 'expanded', true);

        // * A Firefox bug, when `html` has `overflow:hidden`, results in
        //   killing transitions :(. So add the opened state on the next tick.
        //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289
        setTimeout(function () {

          // Add the opened class to the picker root.
          P.$root.addClass(CLASSES.opened);
          aria(P.$root[0], 'hidden', false);
        }, 0);

        // If we have to give focus, bind the element and doc events.
        if (dontGiveFocus !== false) {

          // Set it as open.
          STATE.open = true;

          // Prevent the page from scrolling.
          if (IS_DEFAULT_THEME) {
            $html.css('overflow', 'hidden').css('padding-right', '+=' + getScrollbarWidth());
          }

          // Pass focus to the root elements jQuery object.
          // * Workaround for iOS8 to bring the pickers root into view.
          P.$root.eq(0).focus();

          // Bind the document events.
          $document.on('click.' + STATE.id + ' focusin.' + STATE.id, function (event) {

            var target = event.target;

            // If the target of the event is not the element, close the picker picker.
            // * Dont worry about clicks or focusins on the root because those dont bubble up.
            //   Also, for Firefox, a click on an `option` element bubbles up directly
            //   to the doc. So make sure the target wasn't the doc.
            // * In Firefox stopPropagation() doesnt prevent right-click events from bubbling,
            //   which causes the picker to unexpectedly close when right-clicking it. So make
            //   sure the event wasnt a right-click.
            if (target != ELEMENT && target != document && event.which != 3) {

              // If the target was the holder that covers the screen,
              // keep the element focused to maintain tabindex.
              P.close(target === P.$root.children()[0]);
            }
          }).on('keydown.' + STATE.id, function (event) {

            var
            // Get the keycode.
            keycode = event.keyCode,


            // Translate that to a selection change.
            keycodeToMove = P.component.key[keycode],


            // Grab the target.
            target = event.target;

            // On escape, close the picker and give focus.
            if (keycode == 27) {
              P.close(true);
            }

            // Check if there is a key movement or enter keypress on the element.
            else if (target == P.$root[0] && (keycodeToMove || keycode == 13)) {

                // Prevent the default action to stop page movement.
                event.preventDefault();

                // Trigger the key movement action.
                if (keycodeToMove) {
                  PickerConstructor._.trigger(P.component.key.go, P, [PickerConstructor._.trigger(keycodeToMove)]);
                }

                // On enter, if the highlighted item isnt disabled, set the value and close.
                else if (!P.$root.find('.' + CLASSES.highlighted).hasClass(CLASSES.disabled)) {
                    P.set('select', P.component.item.highlight).close();
                  }
              }

              // If the target is within the root and enter is pressed,
              // prevent the default action and trigger a click on the target instead.
              else if ($.contains(P.$root[0], target) && keycode == 13) {
                  event.preventDefault();
                  target.click();
                }
          });
        }

        // Trigger the queued open events.
        return P.trigger('open');
      }, //open


      /**
       * Close the picker
       */
      close: function close(giveFocus) {

        // If we need to give focus, do it before changing states.
        if (giveFocus) {
          // ....ah yes! It wouldve been incomplete without a crazy workaround for IE :|
          // The focus is triggered *after* the close has completed - causing it
          // to open again. So unbind and rebind the event at the next tick.
          P.$root.off('focus.toOpen').eq(0).focus();
          setTimeout(function () {
            P.$root.on('focus.toOpen', handleFocusToOpenEvent);
          }, 0);
        }

        // Remove the active class.
        $ELEMENT.removeClass(CLASSES.active);
        aria(ELEMENT, 'expanded', false);

        // * A Firefox bug, when `html` has `overflow:hidden`, results in
        //   killing transitions :(. So remove the opened state on the next tick.
        //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289
        setTimeout(function () {

          // Remove the opened and focused class from the picker root.
          P.$root.removeClass(CLASSES.opened + ' ' + CLASSES.focused);
          aria(P.$root[0], 'hidden', true);
        }, 0);

        // If its already closed, do nothing more.
        if (!STATE.open) return P;

        // Set it as closed.
        STATE.open = false;

        // Allow the page to scroll.
        if (IS_DEFAULT_THEME) {
          $html.css('overflow', '').css('padding-right', '-=' + getScrollbarWidth());
        }

        // Unbind the document events.
        $document.off('.' + STATE.id);

        // Trigger the queued close events.
        return P.trigger('close');
      }, //close


      /**
       * Clear the values
       */
      clear: function clear(options) {
        return P.set('clear', null, options);
      }, //clear


      /**
       * Set something
       */
      set: function set(thing, value, options) {

        var thingItem,
            thingValue,
            thingIsObject = $.isPlainObject(thing),
            thingObject = thingIsObject ? thing : {};

        // Make sure we have usable options.
        options = thingIsObject && $.isPlainObject(value) ? value : options || {};

        if (thing) {

          // If the thing isnt an object, make it one.
          if (!thingIsObject) {
            thingObject[thing] = value;
          }

          // Go through the things of items to set.
          for (thingItem in thingObject) {

            // Grab the value of the thing.
            thingValue = thingObject[thingItem];

            // First, if the item exists and theres a value, set it.
            if (thingItem in P.component.item) {
              if (thingValue === undefined) thingValue = null;
              P.component.set(thingItem, thingValue, options);
            }

            // Then, check to update the element value and broadcast a change.
            if (thingItem == 'select' || thingItem == 'clear') {
              $ELEMENT.val(thingItem == 'clear' ? '' : P.get(thingItem, SETTINGS.format)).trigger('change');
            }
          }

          // Render a new picker.
          P.render();
        }

        // When the method isnt muted, trigger queued set events and pass the `thingObject`.
        return options.muted ? P : P.trigger('set', thingObject);
      }, //set


      /**
       * Get something
       */
      get: function get(thing, format) {

        // Make sure theres something to get.
        thing = thing || 'value';

        // If a picker state exists, return that.
        if (STATE[thing] != null) {
          return STATE[thing];
        }

        // Return the submission value, if that.
        if (thing == 'valueSubmit') {
          if (P._hidden) {
            return P._hidden.value;
          }
          thing = 'value';
        }

        // Return the value, if that.
        if (thing == 'value') {
          return ELEMENT.value;
        }

        // Check if a component item exists, return that.
        if (thing in P.component.item) {
          if (typeof format == 'string') {
            var thingValue = P.component.get(thing);
            return thingValue ? PickerConstructor._.trigger(P.component.formats.toString, P.component, [format, thingValue]) : '';
          }
          return P.component.get(thing);
        }
      }, //get


      /**
       * Bind events on the things.
       */
      on: function on(thing, method, internal) {

        var thingName,
            thingMethod,
            thingIsObject = $.isPlainObject(thing),
            thingObject = thingIsObject ? thing : {};

        if (thing) {

          // If the thing isnt an object, make it one.
          if (!thingIsObject) {
            thingObject[thing] = method;
          }

          // Go through the things to bind to.
          for (thingName in thingObject) {

            // Grab the method of the thing.
            thingMethod = thingObject[thingName];

            // If it was an internal binding, prefix it.
            if (internal) {
              thingName = '_' + thingName;
            }

            // Make sure the thing methods collection exists.
            STATE.methods[thingName] = STATE.methods[thingName] || [];

            // Add the method to the relative method collection.
            STATE.methods[thingName].push(thingMethod);
          }
        }

        return P;
      }, //on


      /**
       * Unbind events on the things.
       */
      off: function off() {
        var i,
            thingName,
            names = arguments;
        for (i = 0, namesCount = names.length; i < namesCount; i += 1) {
          thingName = names[i];
          if (thingName in STATE.methods) {
            delete STATE.methods[thingName];
          }
        }
        return P;
      },

      /**
       * Fire off method events.
       */
      trigger: function trigger(name, data) {
        var _trigger = function _trigger(name) {
          var methodList = STATE.methods[name];
          if (methodList) {
            methodList.map(function (method) {
              PickerConstructor._.trigger(method, P, [data]);
            });
          }
        };
        _trigger('_' + name);
        _trigger(name);
        return P;
      } //trigger
      //PickerInstance.prototype


      /**
       * Wrap the picker holder components together.
       */
    };function createWrappedComponent() {

      // Create a picker wrapper holder
      return PickerConstructor._.node('div',

      // Create a picker wrapper node
      PickerConstructor._.node('div',

      // Create a picker frame
      PickerConstructor._.node('div',

      // Create a picker box node
      PickerConstructor._.node('div',

      // Create the components nodes.
      P.component.nodes(STATE.open),

      // The picker box class
      CLASSES.box),

      // Picker wrap class
      CLASSES.wrap),

      // Picker frame class
      CLASSES.frame),

      // Picker holder class
      CLASSES.holder); //endreturn
    } //createWrappedComponent


    /**
     * Prepare the input element with all bindings.
     */
    function prepareElement() {

      $ELEMENT.

      // Store the picker data by component name.
      data(NAME, P).

      // Add the input class name.
      addClass(CLASSES.input).

      // Remove the tabindex.
      attr('tabindex', -1).

      // If theres a `data-value`, update the value of the element.
      val($ELEMENT.data('value') ? P.get('select', SETTINGS.format) : ELEMENT.value);

      // Only bind keydown events if the element isnt editable.
      if (!SETTINGS.editable) {

        $ELEMENT.

        // On focus/click, focus onto the root to open it up.
        on('focus.' + STATE.id + ' click.' + STATE.id, function (event) {
          event.preventDefault();
          P.$root.eq(0).focus();
        }).

        // Handle keyboard event based on the picker being opened or not.
        on('keydown.' + STATE.id, handleKeydownEvent);
      }

      // Update the aria attributes.
      aria(ELEMENT, {
        haspopup: true,
        expanded: false,
        readonly: false,
        owns: ELEMENT.id + '_root'
      });
    }

    /**
     * Prepare the root picker element with all bindings.
     */
    function prepareElementRoot() {

      P.$root.on({

        // For iOS8.
        keydown: handleKeydownEvent,

        // When something within the root is focused, stop from bubbling
        // to the doc and remove the focused state from the root.
        focusin: function focusin(event) {
          P.$root.removeClass(CLASSES.focused);
          event.stopPropagation();
        },

        // When something within the root holder is clicked, stop it
        // from bubbling to the doc.
        'mousedown click': function mousedownClick(event) {

          var target = event.target;

          // Make sure the target isnt the root holder so it can bubble up.
          if (target != P.$root.children()[0]) {

            event.stopPropagation();

            // * For mousedown events, cancel the default action in order to
            //   prevent cases where focus is shifted onto external elements
            //   when using things like jQuery mobile or MagnificPopup (ref: #249 & #120).
            //   Also, for Firefox, dont prevent action on the `option` element.
            if (event.type == 'mousedown' && !$(target).is('input, select, textarea, button, option')) {

              event.preventDefault();

              // Re-focus onto the root so that users can click away
              // from elements focused within the picker.
              P.$root.eq(0).focus();
            }
          }
        }
      }).

      // Add/remove the target class on focus and blur.
      on({
        focus: function focus() {
          $ELEMENT.addClass(CLASSES.target);
        },
        blur: function blur() {
          $ELEMENT.removeClass(CLASSES.target);
        }
      }).

      // Open the picker and adjust the root focused state
      on('focus.toOpen', handleFocusToOpenEvent).

      // If theres a click on an actionable element, carry out the actions.
      on('click', '[data-pick], [data-nav], [data-clear], [data-close]', function () {

        var $target = $(this),
            targetData = $target.data(),
            targetDisabled = $target.hasClass(CLASSES.navDisabled) || $target.hasClass(CLASSES.disabled),


        // * For IE, non-focusable elements can be active elements as well
        //   (http://stackoverflow.com/a/2684561).
        activeElement = getActiveElement();
        activeElement = activeElement && (activeElement.type || activeElement.href);

        // If its disabled or nothing inside is actively focused, re-focus the element.
        if (targetDisabled || activeElement && !$.contains(P.$root[0], activeElement)) {
          P.$root.eq(0).focus();
        }

        // If something is superficially changed, update the `highlight` based on the `nav`.
        if (!targetDisabled && targetData.nav) {
          P.set('highlight', P.component.item.highlight, { nav: targetData.nav });
        }

        // If something is picked, set `select` then close with focus.
        else if (!targetDisabled && 'pick' in targetData) {
            P.set('select', targetData.pick);
          }

          // If a clear button is pressed, empty the values and close with focus.
          else if (targetData.clear) {
              P.clear().close(true);
            } else if (targetData.close) {
              P.close(true);
            }
      }); //P.$root

      aria(P.$root[0], 'hidden', true);
    }

    /**
     * Prepare the hidden input element along with all bindings.
     */
    function prepareElementHidden() {

      var name;

      if (SETTINGS.hiddenName === true) {
        name = ELEMENT.name;
        ELEMENT.name = '';
      } else {
        name = [typeof SETTINGS.hiddenPrefix == 'string' ? SETTINGS.hiddenPrefix : '', typeof SETTINGS.hiddenSuffix == 'string' ? SETTINGS.hiddenSuffix : '_submit'];
        name = name[0] + ELEMENT.name + name[1];
      }

      P._hidden = $('<input ' + 'type=hidden ' +

      // Create the name using the original inputs with a prefix and suffix.
      'name="' + name + '"' + (

      // If the element has a value, set the hidden value as well.
      $ELEMENT.data('value') || ELEMENT.value ? ' value="' + P.get('select', SETTINGS.formatSubmit) + '"' : '') + '>')[0];

      $ELEMENT.

      // If the value changes, update the hidden input with the correct format.
      on('change.' + STATE.id, function () {
        P._hidden.value = ELEMENT.value ? P.get('select', SETTINGS.formatSubmit) : '';
      });

      // Insert the hidden input as specified in the settings.
      if (SETTINGS.container) $(SETTINGS.container).append(P._hidden);else $ELEMENT.after(P._hidden);
    }

    // For iOS8.
    function handleKeydownEvent(event) {

      var keycode = event.keyCode,


      // Check if one of the delete keys was pressed.
      isKeycodeDelete = /^(8|46)$/.test(keycode);

      // For some reason IE clears the input value on escape.
      if (keycode == 27) {
        P.close();
        return false;
      }

      // Check if `space` or `delete` was pressed or the picker is closed with a key movement.
      if (keycode == 32 || isKeycodeDelete || !STATE.open && P.component.key[keycode]) {

        // Prevent it from moving the page and bubbling to doc.
        event.preventDefault();
        event.stopPropagation();

        // If `delete` was pressed, clear the values and close the picker.
        // Otherwise open the picker.
        if (isKeycodeDelete) {
          P.clear().close();
        } else {
          P.open();
        }
      }
    }

    // Separated for IE
    function handleFocusToOpenEvent(event) {

      // Stop the event from propagating to the doc.
      event.stopPropagation();

      // If its a focus event, add the focused class to the root.
      if (event.type == 'focus') {
        P.$root.addClass(CLASSES.focused);
      }

      // And then finally open the picker.
      P.open();
    }

    // Return a new picker instance.
    return new PickerInstance();
  } //PickerConstructor


  /**
   * The default classes and prefix to use for the HTML classes.
   */
  PickerConstructor.klasses = function (prefix) {
    prefix = prefix || 'picker';
    return {

      picker: prefix,
      opened: prefix + '--opened',
      focused: prefix + '--focused',

      input: prefix + '__input',
      active: prefix + '__input--active',
      target: prefix + '__input--target',

      holder: prefix + '__holder',

      frame: prefix + '__frame',
      wrap: prefix + '__wrap',

      box: prefix + '__box'
    };
  }; //PickerConstructor.klasses


  /**
   * Check if the default theme is being used.
   */
  function isUsingDefaultTheme(element) {

    var theme,
        prop = 'position';

    // For IE.
    if (element.currentStyle) {
      theme = element.currentStyle[prop];
    }

    // For normal browsers.
    else if (window.getComputedStyle) {
        theme = getComputedStyle(element)[prop];
      }

    return theme == 'fixed';
  }

  /**
   * Get the width of the browsers scrollbar.
   * Taken from: https://github.com/VodkaBears/Remodal/blob/master/src/jquery.remodal.js
   */
  function getScrollbarWidth() {

    if ($html.height() <= $window.height()) {
      return 0;
    }

    var $outer = $('<div style="visibility:hidden;width:100px" />').appendTo('body');

    // Get the width without scrollbars.
    var widthWithoutScroll = $outer[0].offsetWidth;

    // Force adding scrollbars.
    $outer.css('overflow', 'scroll');

    // Add the inner div.
    var $inner = $('<div style="width:100%" />').appendTo($outer);

    // Get the width with scrollbars.
    var widthWithScroll = $inner[0].offsetWidth;

    // Remove the divs.
    $outer.remove();

    // Return the difference between the widths.
    return widthWithoutScroll - widthWithScroll;
  }

  /**
   * PickerConstructor helper methods.
   */
  PickerConstructor._ = {

    /**
     * Create a group of nodes. Expects:
     * `
        {
            min:    {Integer},
            max:    {Integer},
            i:      {Integer},
            node:   {String},
            item:   {Function}
        }
     * `
     */
    group: function group(groupObject) {

      var
      // Scope for the looped object
      loopObjectScope,


      // Create the nodes list
      nodesList = '',


      // The counter starts from the `min`
      counter = PickerConstructor._.trigger(groupObject.min, groupObject);

      // Loop from the `min` to `max`, incrementing by `i`
      for (; counter <= PickerConstructor._.trigger(groupObject.max, groupObject, [counter]); counter += groupObject.i) {

        // Trigger the `item` function within scope of the object
        loopObjectScope = PickerConstructor._.trigger(groupObject.item, groupObject, [counter]);

        // Splice the subgroup and create nodes out of the sub nodes
        nodesList += PickerConstructor._.node(groupObject.node, loopObjectScope[0], // the node
        loopObjectScope[1], // the classes
        loopObjectScope[2] // the attributes
        );
      }

      // Return the list of nodes
      return nodesList;
    }, //group


    /**
     * Create a dom node string
     */
    node: function node(wrapper, item, klass, attribute) {

      // If the item is false-y, just return an empty string
      if (!item) return '';

      // If the item is an array, do a join
      item = $.isArray(item) ? item.join('') : item;

      // Check for the class
      klass = klass ? ' class="' + klass + '"' : '';

      // Check for any attributes
      attribute = attribute ? ' ' + attribute : '';

      // Return the wrapped item
      return '<' + wrapper + klass + attribute + '>' + item + '</' + wrapper + '>';
    }, //node


    /**
     * Lead numbers below 10 with a zero.
     */
    lead: function lead(number) {
      return (number < 10 ? '0' : '') + number;
    },

    /**
     * Trigger a function otherwise return the value.
     */
    trigger: function trigger(callback, scope, args) {
      return typeof callback == 'function' ? callback.apply(scope, args || []) : callback;
    },

    /**
     * If the second character is a digit, length is 2 otherwise 1.
     */
    digits: function digits(string) {
      return (/\d/.test(string[1]) ? 2 : 1
      );
    },

    /**
     * Tell if something is a date object.
     */
    isDate: function isDate(value) {
      return {}.toString.call(value).indexOf('Date') > -1 && this.isInteger(value.getDate());
    },

    /**
     * Tell if something is an integer.
     */
    isInteger: function isInteger(value) {
      return {}.toString.call(value).indexOf('Number') > -1 && value % 1 === 0;
    },

    /**
     * Create ARIA attribute strings.
     */
    ariaAttr: ariaAttr //PickerConstructor._


    /**
     * Extend the picker with a component and defaults.
     */
  };PickerConstructor.extend = function (name, Component) {

    // Extend jQuery.
    $.fn[name] = function (options, action) {

      // Grab the component data.
      var componentData = this.data(name);

      // If the picker is requested, return the data object.
      if (options == 'picker') {
        return componentData;
      }

      // If the component data exists and `options` is a string, carry out the action.
      if (componentData && typeof options == 'string') {
        return PickerConstructor._.trigger(componentData[options], componentData, [action]);
      }

      // Otherwise go through each matched element and if the component
      // doesnt exist, create a new picker using `this` element
      // and merging the defaults and options with a deep copy.
      return this.each(function () {
        var $this = $(this);
        if (!$this.data(name)) {
          new PickerConstructor(this, name, Component, options);
        }
      });
    };

    // Set the defaults.
    $.fn[name].defaults = Component.defaults;
  }; //PickerConstructor.extend


  function aria(element, attribute, value) {
    if ($.isPlainObject(attribute)) {
      for (var key in attribute) {
        ariaSet(element, key, attribute[key]);
      }
    } else {
      ariaSet(element, attribute, value);
    }
  }
  function ariaSet(element, attribute, value) {
    element.setAttribute((attribute == 'role' ? '' : 'aria-') + attribute, value);
  }
  function ariaAttr(attribute, data) {
    if (!$.isPlainObject(attribute)) {
      attribute = { attribute: data };
    }
    data = '';
    for (var key in attribute) {
      var attr = (key == 'role' ? '' : 'aria-') + key,
          attrVal = attribute[key];
      data += attrVal == null ? '' : attr + '="' + attribute[key] + '"';
    }
    return data;
  }

  // IE8 bug throws an error for activeElements within iframes.
  function getActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  // Expose the picker constructor.
  return PickerConstructor;
});

; /*!
  * Date picker for pickadate.js v3.5.0
  * http://amsul.github.io/pickadate.js/date.htm
  */

(function (factory) {

  // AMD.
  if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__, __webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

  // Node.js/browserify.
  else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object') module.exports = factory(require('./picker.js'), require('jquery'));

    // Browser globals.
    else factory(Picker, jQuery);
})(function (Picker, $) {

  /**
   * Globals and constants
   */
  var DAYS_IN_WEEK = 7,
      WEEKS_IN_CALENDAR = 6,
      _ = Picker._;

  /**
   * The date picker constructor
   */
  function DatePicker(picker, settings) {

    var calendar = this,
        element = picker.$node[0],
        elementValue = element.value,
        elementDataValue = picker.$node.data('value'),
        valueString = elementDataValue || elementValue,
        formatString = elementDataValue ? settings.formatSubmit : settings.format,
        isRTL = function isRTL() {

      return element.currentStyle ?

      // For IE.
      element.currentStyle.direction == 'rtl' :

      // For normal browsers.
      getComputedStyle(picker.$root[0]).direction == 'rtl';
    };

    calendar.settings = settings;
    calendar.$node = picker.$node;

    // The queue of methods that will be used to build item objects.
    calendar.queue = {
      min: 'measure create',
      max: 'measure create',
      now: 'now create',
      select: 'parse create validate',
      highlight: 'parse navigate create validate',
      view: 'parse create validate viewset',
      disable: 'deactivate',
      enable: 'activate'

      // The component's item object.
    };calendar.item = {};

    calendar.item.clear = null;
    calendar.item.disable = (settings.disable || []).slice(0);
    calendar.item.enable = -function (collectionDisabled) {
      return collectionDisabled[0] === true ? collectionDisabled.shift() : -1;
    }(calendar.item.disable);

    calendar.set('min', settings.min).set('max', settings.max).set('now');

    // When theres a value, set the `select`, which in turn
    // also sets the `highlight` and `view`.
    if (valueString) {
      calendar.set('select', valueString, { format: formatString });
    }

    // If theres no value, default to highlighting today.
    else {
        calendar.set('select', null).set('highlight', calendar.item.now);
      }

    // The keycode to movement mapping.
    calendar.key = {
      40: 7, // Down
      38: -7, // Up
      39: function _() {
        return isRTL() ? -1 : 1;
      }, // Right
      37: function _() {
        return isRTL() ? 1 : -1;
      }, // Left
      go: function go(timeChange) {
        var highlightedObject = calendar.item.highlight,
            targetDate = new Date(highlightedObject.year, highlightedObject.month, highlightedObject.date + timeChange);
        calendar.set('highlight', targetDate, { interval: timeChange });
        this.render();
      }

      // Bind some picker events.
    };picker.on('render', function () {
      picker.$root.find('.' + settings.klass.selectMonth).on('change', function () {
        var value = this.value;
        if (value) {
          picker.set('highlight', [picker.get('view').year, value, picker.get('highlight').date]);
          picker.$root.find('.' + settings.klass.selectMonth).trigger('focus');
        }
      });
      picker.$root.find('.' + settings.klass.selectYear).on('change', function () {
        var value = this.value;
        if (value) {
          picker.set('highlight', [value, picker.get('view').month, picker.get('highlight').date]);
          picker.$root.find('.' + settings.klass.selectYear).trigger('focus');
        }
      });
    }, 1).on('open', function () {
      var includeToday = '';
      if (calendar.disabled(calendar.get('now'))) {
        includeToday = ':not(.' + settings.klass.buttonToday + ')';
      }
      picker.$root.find('button' + includeToday + ', select').attr('disabled', false);
    }, 1).on('close', function () {
      picker.$root.find('button, select').attr('disabled', true);
    }, 1);
  } //DatePicker


  /**
   * Set a datepicker item object.
   */
  DatePicker.prototype.set = function (type, value, options) {

    var calendar = this,
        calendarItem = calendar.item;

    // If the value is `null` just set it immediately.
    if (value === null) {
      if (type == 'clear') type = 'select';
      calendarItem[type] = value;
      return calendar;
    }

    // Otherwise go through the queue of methods, and invoke the functions.
    // Update this as the time unit, and set the final value as this item.
    // * In the case of `enable`, keep the queue but set `disable` instead.
    //   And in the case of `flip`, keep the queue but set `enable` instead.
    calendarItem[type == 'enable' ? 'disable' : type == 'flip' ? 'enable' : type] = calendar.queue[type].split(' ').map(function (method) {
      value = calendar[method](type, value, options);
      return value;
    }).pop();

    // Check if we need to cascade through more updates.
    if (type == 'select') {
      calendar.set('highlight', calendarItem.select, options);
    } else if (type == 'highlight') {
      calendar.set('view', calendarItem.highlight, options);
    } else if (type.match(/^(flip|min|max|disable|enable)$/)) {
      if (calendarItem.select && calendar.disabled(calendarItem.select)) {
        calendar.set('select', calendarItem.select, options);
      }
      if (calendarItem.highlight && calendar.disabled(calendarItem.highlight)) {
        calendar.set('highlight', calendarItem.highlight, options);
      }
    }

    return calendar;
  }; //DatePicker.prototype.set


  /**
   * Get a datepicker item object.
   */
  DatePicker.prototype.get = function (type) {
    return this.item[type];
  }; //DatePicker.prototype.get


  /**
   * Create a picker date object.
   */
  DatePicker.prototype.create = function (type, value, options) {

    var isInfiniteValue,
        calendar = this;

    // If theres no value, use the type as the value.
    value = value === undefined ? type : value;

    // If its infinity, update the value.
    if (value == -Infinity || value == Infinity) {
      isInfiniteValue = value;
    }

    // If its an object, use the native date object.
    else if ($.isPlainObject(value) && _.isInteger(value.pick)) {
        value = value.obj;
      }

      // If its an array, convert it into a date and make sure
      // that its a valid date  otherwise default to today.
      else if ($.isArray(value)) {
          value = new Date(value[0], value[1], value[2]);
          value = _.isDate(value) ? value : calendar.create().obj;
        }

        // If its a number or date object, make a normalized date.
        else if (_.isInteger(value) || _.isDate(value)) {
            value = calendar.normalize(new Date(value), options);
          }

          // If its a literal true or any other case, set it to now.
          else /*if ( value === true )*/{
              value = calendar.now(type, value, options);
            }

    // Return the compiled object.
    return {
      year: isInfiniteValue || value.getFullYear(),
      month: isInfiniteValue || value.getMonth(),
      date: isInfiniteValue || value.getDate(),
      day: isInfiniteValue || value.getDay(),
      obj: isInfiniteValue || value,
      pick: isInfiniteValue || value.getTime()
    };
  }; //DatePicker.prototype.create


  /**
   * Create a range limit object using an array, date object,
   * literal true, or integer relative to another time.
   */
  DatePicker.prototype.createRange = function (from, to) {

    var calendar = this,
        createDate = function createDate(date) {
      if (date === true || $.isArray(date) || _.isDate(date)) {
        return calendar.create(date);
      }
      return date;
    };

    // Create objects if possible.
    if (!_.isInteger(from)) {
      from = createDate(from);
    }
    if (!_.isInteger(to)) {
      to = createDate(to);
    }

    // Create relative dates.
    if (_.isInteger(from) && $.isPlainObject(to)) {
      from = [to.year, to.month, to.date + from];
    } else if (_.isInteger(to) && $.isPlainObject(from)) {
      to = [from.year, from.month, from.date + to];
    }

    return {
      from: createDate(from),
      to: createDate(to)
    };
  }; //DatePicker.prototype.createRange


  /**
   * Check if a date unit falls within a date range object.
   */
  DatePicker.prototype.withinRange = function (range, dateUnit) {
    range = this.createRange(range.from, range.to);
    return dateUnit.pick >= range.from.pick && dateUnit.pick <= range.to.pick;
  };

  /**
   * Check if two date range objects overlap.
   */
  DatePicker.prototype.overlapRanges = function (one, two) {

    var calendar = this;

    // Convert the ranges into comparable dates.
    one = calendar.createRange(one.from, one.to);
    two = calendar.createRange(two.from, two.to);

    return calendar.withinRange(one, two.from) || calendar.withinRange(one, two.to) || calendar.withinRange(two, one.from) || calendar.withinRange(two, one.to);
  };

  /**
   * Get the date today.
   */
  DatePicker.prototype.now = function (type, value, options) {
    value = new Date();
    if (options && options.rel) {
      value.setDate(value.getDate() + options.rel);
    }
    return this.normalize(value, options);
  };

  /**
   * Navigate to next/prev month.
   */
  DatePicker.prototype.navigate = function (type, value, options) {

    var targetDateObject,
        targetYear,
        targetMonth,
        targetDate,
        isTargetArray = $.isArray(value),
        isTargetObject = $.isPlainObject(value),
        viewsetObject = this.item.view; /*,
                                        safety = 100*/

    if (isTargetArray || isTargetObject) {

      if (isTargetObject) {
        targetYear = value.year;
        targetMonth = value.month;
        targetDate = value.date;
      } else {
        targetYear = +value[0];
        targetMonth = +value[1];
        targetDate = +value[2];
      }

      // If were navigating months but the view is in a different
      // month, navigate to the views year and month.
      if (options && options.nav && viewsetObject && viewsetObject.month !== targetMonth) {
        targetYear = viewsetObject.year;
        targetMonth = viewsetObject.month;
      }

      // Figure out the expected target year and month.
      targetDateObject = new Date(targetYear, targetMonth + (options && options.nav ? options.nav : 0), 1);
      targetYear = targetDateObject.getFullYear();
      targetMonth = targetDateObject.getMonth();

      // If the month were going to doesnt have enough days,
      // keep decreasing the date until we reach the months last date.
      while ( /*safety &&*/new Date(targetYear, targetMonth, targetDate).getMonth() !== targetMonth) {
        targetDate -= 1;
        /*safety -= 1
        if ( !safety ) {
            throw 'Fell into an infinite loop while navigating to ' + new Date( targetYear, targetMonth, targetDate ) + '.'
        }*/
      }

      value = [targetYear, targetMonth, targetDate];
    }

    return value;
  }; //DatePicker.prototype.navigate


  /**
   * Normalize a date by setting the hours to midnight.
   */
  DatePicker.prototype.normalize = function (value /*, options*/) {
    value.setHours(0, 0, 0, 0);
    return value;
  };

  /**
   * Measure the range of dates.
   */
  DatePicker.prototype.measure = function (type, value /*, options*/) {

    var calendar = this;

    // If its anything false-y, remove the limits.
    if (!value) {
      value = type == 'min' ? -Infinity : Infinity;
    }

    // If its a string, parse it.
    else if (typeof value == 'string') {
        value = calendar.parse(type, value);
      }

      // If it's an integer, get a date relative to today.
      else if (_.isInteger(value)) {
          value = calendar.now(type, value, { rel: value });
        }

    return value;
  }; ///DatePicker.prototype.measure


  /**
   * Create a viewset object based on navigation.
   */
  DatePicker.prototype.viewset = function (type, dateObject /*, options*/) {
    return this.create([dateObject.year, dateObject.month, 1]);
  };

  /**
   * Validate a date as enabled and shift if needed.
   */
  DatePicker.prototype.validate = function (type, dateObject, options) {

    var calendar = this,


    // Keep a reference to the original date.
    originalDateObject = dateObject,


    // Make sure we have an interval.
    interval = options && options.interval ? options.interval : 1,


    // Check if the calendar enabled dates are inverted.
    isFlippedBase = calendar.item.enable === -1,


    // Check if we have any enabled dates after/before now.
    hasEnabledBeforeTarget,
        hasEnabledAfterTarget,


    // The min & max limits.
    minLimitObject = calendar.item.min,
        maxLimitObject = calendar.item.max,


    // Check if weve reached the limit during shifting.
    reachedMin,
        reachedMax,


    // Check if the calendar is inverted and at least one weekday is enabled.
    hasEnabledWeekdays = isFlippedBase && calendar.item.disable.filter(function (value) {

      // If theres a date, check where it is relative to the target.
      if ($.isArray(value)) {
        var dateTime = calendar.create(value).pick;
        if (dateTime < dateObject.pick) hasEnabledBeforeTarget = true;else if (dateTime > dateObject.pick) hasEnabledAfterTarget = true;
      }

      // Return only integers for enabled weekdays.
      return _.isInteger(value);
    }).length; /*,
               safety = 100*/

    // Cases to validate for:
    // [1] Not inverted and date disabled.
    // [2] Inverted and some dates enabled.
    // [3] Not inverted and out of range.
    //
    // Cases to **not** validate for:
    //  Navigating months.
    //  Not inverted and date enabled.
    //  Inverted and all dates disabled.
    //  ..and anything else.
    if (!options || !options.nav) if (
    /* 1 */!isFlippedBase && calendar.disabled(dateObject) ||
    /* 2 */isFlippedBase && calendar.disabled(dateObject) && (hasEnabledWeekdays || hasEnabledBeforeTarget || hasEnabledAfterTarget) ||
    /* 3 */!isFlippedBase && (dateObject.pick <= minLimitObject.pick || dateObject.pick >= maxLimitObject.pick)) {

      // When inverted, flip the direction if there arent any enabled weekdays
      // and there are no enabled dates in the direction of the interval.
      if (isFlippedBase && !hasEnabledWeekdays && (!hasEnabledAfterTarget && interval > 0 || !hasEnabledBeforeTarget && interval < 0)) {
        interval *= -1;
      }

      // Keep looping until we reach an enabled date.
      while ( /*safety &&*/calendar.disabled(dateObject)) {

        /*safety -= 1
        if ( !safety ) {
            throw 'Fell into an infinite loop while validating ' + dateObject.obj + '.'
        }*/

        // If weve looped into the next/prev month with a large interval, return to the original date and flatten the interval.
        if (Math.abs(interval) > 1 && (dateObject.month < originalDateObject.month || dateObject.month > originalDateObject.month)) {
          dateObject = originalDateObject;
          interval = interval > 0 ? 1 : -1;
        }

        // If weve reached the min/max limit, reverse the direction, flatten the interval and set it to the limit.
        if (dateObject.pick <= minLimitObject.pick) {
          reachedMin = true;
          interval = 1;
          dateObject = calendar.create([minLimitObject.year, minLimitObject.month, minLimitObject.date + (dateObject.pick === minLimitObject.pick ? 0 : -1)]);
        } else if (dateObject.pick >= maxLimitObject.pick) {
          reachedMax = true;
          interval = -1;
          dateObject = calendar.create([maxLimitObject.year, maxLimitObject.month, maxLimitObject.date + (dateObject.pick === maxLimitObject.pick ? 0 : 1)]);
        }

        // If weve reached both limits, just break out of the loop.
        if (reachedMin && reachedMax) {
          break;
        }

        // Finally, create the shifted date using the interval and keep looping.
        dateObject = calendar.create([dateObject.year, dateObject.month, dateObject.date + interval]);
      }
    } //endif


    // Return the date object settled on.
    return dateObject;
  }; //DatePicker.prototype.validate


  /**
   * Check if a date is disabled.
   */
  DatePicker.prototype.disabled = function (dateToVerify) {

    var calendar = this,


    // Filter through the disabled dates to check if this is one.
    isDisabledMatch = calendar.item.disable.filter(function (dateToDisable) {

      // If the date is a number, match the weekday with 0index and `firstDay` check.
      if (_.isInteger(dateToDisable)) {
        return dateToVerify.day === (calendar.settings.firstDay ? dateToDisable : dateToDisable - 1) % 7;
      }

      // If its an array or a native JS date, create and match the exact date.
      if ($.isArray(dateToDisable) || _.isDate(dateToDisable)) {
        return dateToVerify.pick === calendar.create(dateToDisable).pick;
      }

      // If its an object, match a date within the from and to range.
      if ($.isPlainObject(dateToDisable)) {
        return calendar.withinRange(dateToDisable, dateToVerify);
      }
    });

    // If this date matches a disabled date, confirm its not inverted.
    isDisabledMatch = isDisabledMatch.length && !isDisabledMatch.filter(function (dateToDisable) {
      return $.isArray(dateToDisable) && dateToDisable[3] == 'inverted' || $.isPlainObject(dateToDisable) && dateToDisable.inverted;
    }).length;

    // Check the calendar enabled flag and respectively flip the
    // disabled state. Then also check if its beyond the min/max limits.
    return calendar.item.enable === -1 ? !isDisabledMatch : isDisabledMatch || dateToVerify.pick < calendar.item.min.pick || dateToVerify.pick > calendar.item.max.pick;
  }; //DatePicker.prototype.disabled


  /**
   * Parse a string into a usable type.
   */
  DatePicker.prototype.parse = function (type, value, options) {

    var calendar = this,
        parsingObject = {};

    // If its already parsed, were good.
    if (!value || typeof value != 'string') {
      return value;
    }

    // We need a `.format` to parse the value with.
    if (!(options && options.format)) {
      options = options || {};
      options.format = calendar.settings.format;
    }

    // Convert the format into an array and then map through it.
    calendar.formats.toArray(options.format).map(function (label) {

      var
      // Grab the formatting label.
      formattingLabel = calendar.formats[label],


      // The format length is from the formatting label function or the
      // label length without the escaping exclamation (!) mark.
      formatLength = formattingLabel ? _.trigger(formattingLabel, calendar, [value, parsingObject]) : label.replace(/^!/, '').length;

      // If there's a format label, split the value up to the format length.
      // Then add it to the parsing object with appropriate label.
      if (formattingLabel) {
        parsingObject[label] = value.substr(0, formatLength);
      }

      // Update the value as the substring from format length to end.
      value = value.substr(formatLength);
    });

    // Compensate for month 0index.
    return [parsingObject.yyyy || parsingObject.yy, +(parsingObject.mm || parsingObject.m) - 1, parsingObject.dd || parsingObject.d];
  }; //DatePicker.prototype.parse


  /**
   * Various formats to display the object in.
   */
  DatePicker.prototype.formats = function () {

    // Return the length of the first word in a collection.
    function getWordLengthFromCollection(string, collection, dateObject) {

      // Grab the first word from the string.
      var word = string.match(/\w+/)[0];

      // If there's no month index, add it to the date object
      if (!dateObject.mm && !dateObject.m) {
        dateObject.m = collection.indexOf(word) + 1;
      }

      // Return the length of the word.
      return word.length;
    }

    // Get the length of the first word in a string.
    function getFirstWordLength(string) {
      return string.match(/\w+/)[0].length;
    }

    return {

      d: function d(string, dateObject) {

        // If there's string, then get the digits length.
        // Otherwise return the selected date.
        return string ? _.digits(string) : dateObject.date;
      },
      dd: function dd(string, dateObject) {

        // If there's a string, then the length is always 2.
        // Otherwise return the selected date with a leading zero.
        return string ? 2 : _.lead(dateObject.date);
      },
      ddd: function ddd(string, dateObject) {

        // If there's a string, then get the length of the first word.
        // Otherwise return the short selected weekday.
        return string ? getFirstWordLength(string) : this.settings.weekdaysShort[dateObject.day];
      },
      dddd: function dddd(string, dateObject) {

        // If there's a string, then get the length of the first word.
        // Otherwise return the full selected weekday.
        return string ? getFirstWordLength(string) : this.settings.weekdaysFull[dateObject.day];
      },
      m: function m(string, dateObject) {

        // If there's a string, then get the length of the digits
        // Otherwise return the selected month with 0index compensation.
        return string ? _.digits(string) : dateObject.month + 1;
      },
      mm: function mm(string, dateObject) {

        // If there's a string, then the length is always 2.
        // Otherwise return the selected month with 0index and leading zero.
        return string ? 2 : _.lead(dateObject.month + 1);
      },
      mmm: function mmm(string, dateObject) {

        var collection = this.settings.monthsShort;

        // If there's a string, get length of the relevant month from the short
        // months collection. Otherwise return the selected month from that collection.
        return string ? getWordLengthFromCollection(string, collection, dateObject) : collection[dateObject.month];
      },
      mmmm: function mmmm(string, dateObject) {

        var collection = this.settings.monthsFull;

        // If there's a string, get length of the relevant month from the full
        // months collection. Otherwise return the selected month from that collection.
        return string ? getWordLengthFromCollection(string, collection, dateObject) : collection[dateObject.month];
      },
      yy: function yy(string, dateObject) {

        // If there's a string, then the length is always 2.
        // Otherwise return the selected year by slicing out the first 2 digits.
        return string ? 2 : ('' + dateObject.year).slice(2);
      },
      yyyy: function yyyy(string, dateObject) {

        // If there's a string, then the length is always 4.
        // Otherwise return the selected year.
        return string ? 4 : dateObject.year;
      },

      // Create an array by splitting the formatting string passed.
      toArray: function toArray(formatString) {
        return formatString.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);
      },

      // Format an object into a string using the formatting options.
      toString: function toString(formatString, itemObject) {
        var calendar = this;
        return calendar.formats.toArray(formatString).map(function (label) {
          return _.trigger(calendar.formats[label], calendar, [0, itemObject]) || label.replace(/^!/, '');
        }).join('');
      }
    };
  }(); //DatePicker.prototype.formats


  /**
   * Check if two date units are the exact.
   */
  DatePicker.prototype.isDateExact = function (one, two) {

    var calendar = this;

    // When were working with weekdays, do a direct comparison.
    if (_.isInteger(one) && _.isInteger(two) || typeof one == 'boolean' && typeof two == 'boolean') {
      return one === two;
    }

    // When were working with date representations, compare the pick value.
    if ((_.isDate(one) || $.isArray(one)) && (_.isDate(two) || $.isArray(two))) {
      return calendar.create(one).pick === calendar.create(two).pick;
    }

    // When were working with range objects, compare the from and to.
    if ($.isPlainObject(one) && $.isPlainObject(two)) {
      return calendar.isDateExact(one.from, two.from) && calendar.isDateExact(one.to, two.to);
    }

    return false;
  };

  /**
   * Check if two date units overlap.
   */
  DatePicker.prototype.isDateOverlap = function (one, two) {

    var calendar = this,
        firstDay = calendar.settings.firstDay ? 1 : 0;

    // When were working with a weekday index, compare the days.
    if (_.isInteger(one) && (_.isDate(two) || $.isArray(two))) {
      one = one % 7 + firstDay;
      return one === calendar.create(two).day + 1;
    }
    if (_.isInteger(two) && (_.isDate(one) || $.isArray(one))) {
      two = two % 7 + firstDay;
      return two === calendar.create(one).day + 1;
    }

    // When were working with range objects, check if the ranges overlap.
    if ($.isPlainObject(one) && $.isPlainObject(two)) {
      return calendar.overlapRanges(one, two);
    }

    return false;
  };

  /**
   * Flip the enabled state.
   */
  DatePicker.prototype.flipEnable = function (val) {
    var itemObject = this.item;
    itemObject.enable = val || (itemObject.enable == -1 ? 1 : -1);
  };

  /**
   * Mark a collection of dates as disabled.
   */
  DatePicker.prototype.deactivate = function (type, datesToDisable) {

    var calendar = this,
        disabledItems = calendar.item.disable.slice(0);

    // If were flipping, thats all we need to do.
    if (datesToDisable == 'flip') {
      calendar.flipEnable();
    } else if (datesToDisable === false) {
      calendar.flipEnable(1);
      disabledItems = [];
    } else if (datesToDisable === true) {
      calendar.flipEnable(-1);
      disabledItems = [];
    }

    // Otherwise go through the dates to disable.
    else {

        datesToDisable.map(function (unitToDisable) {

          var matchFound;

          // When we have disabled items, check for matches.
          // If something is matched, immediately break out.
          for (var index = 0; index < disabledItems.length; index += 1) {
            if (calendar.isDateExact(unitToDisable, disabledItems[index])) {
              matchFound = true;
              break;
            }
          }

          // If nothing was found, add the validated unit to the collection.
          if (!matchFound) {
            if (_.isInteger(unitToDisable) || _.isDate(unitToDisable) || $.isArray(unitToDisable) || $.isPlainObject(unitToDisable) && unitToDisable.from && unitToDisable.to) {
              disabledItems.push(unitToDisable);
            }
          }
        });
      }

    // Return the updated collection.
    return disabledItems;
  }; //DatePicker.prototype.deactivate


  /**
   * Mark a collection of dates as enabled.
   */
  DatePicker.prototype.activate = function (type, datesToEnable) {

    var calendar = this,
        disabledItems = calendar.item.disable,
        disabledItemsCount = disabledItems.length;

    // If were flipping, thats all we need to do.
    if (datesToEnable == 'flip') {
      calendar.flipEnable();
    } else if (datesToEnable === true) {
      calendar.flipEnable(1);
      disabledItems = [];
    } else if (datesToEnable === false) {
      calendar.flipEnable(-1);
      disabledItems = [];
    }

    // Otherwise go through the disabled dates.
    else {

        datesToEnable.map(function (unitToEnable) {

          var matchFound, disabledUnit, index, isExactRange;

          // Go through the disabled items and try to find a match.
          for (index = 0; index < disabledItemsCount; index += 1) {

            disabledUnit = disabledItems[index];

            // When an exact match is found, remove it from the collection.
            if (calendar.isDateExact(disabledUnit, unitToEnable)) {
              matchFound = disabledItems[index] = null;
              isExactRange = true;
              break;
            }

            // When an overlapped match is found, add the inverted state to it.
            else if (calendar.isDateOverlap(disabledUnit, unitToEnable)) {
                if ($.isPlainObject(unitToEnable)) {
                  unitToEnable.inverted = true;
                  matchFound = unitToEnable;
                } else if ($.isArray(unitToEnable)) {
                  matchFound = unitToEnable;
                  if (!matchFound[3]) matchFound.push('inverted');
                } else if (_.isDate(unitToEnable)) {
                  matchFound = [unitToEnable.getFullYear(), unitToEnable.getMonth(), unitToEnable.getDate(), 'inverted'];
                }
                break;
              }
          }

          // If a match was found, remove a previous duplicate entry.
          if (matchFound) for (index = 0; index < disabledItemsCount; index += 1) {
            if (calendar.isDateExact(disabledItems[index], unitToEnable)) {
              disabledItems[index] = null;
              break;
            }
          }

          // In the event that were dealing with an exact range of dates,
          // make sure there are no inverted dates because of it.
          if (isExactRange) for (index = 0; index < disabledItemsCount; index += 1) {
            if (calendar.isDateOverlap(disabledItems[index], unitToEnable)) {
              disabledItems[index] = null;
              break;
            }
          }

          // If something is still matched, add it into the collection.
          if (matchFound) {
            disabledItems.push(matchFound);
          }
        });
      }

    // Return the updated collection.
    return disabledItems.filter(function (val) {
      return val != null;
    });
  }; //DatePicker.prototype.activate


  /**
   * Create a string for the nodes in the picker.
   */
  DatePicker.prototype.nodes = function (isOpen) {

    var calendar = this,
        settings = calendar.settings,
        calendarItem = calendar.item,
        nowObject = calendarItem.now,
        selectedObject = calendarItem.select,
        highlightedObject = calendarItem.highlight,
        viewsetObject = calendarItem.view,
        disabledCollection = calendarItem.disable,
        minLimitObject = calendarItem.min,
        maxLimitObject = calendarItem.max,


    // Create the calendar table head using a copy of weekday labels collection.
    // * We do a copy so we don't mutate the original array.
    tableHead = function (collection, fullCollection) {

      // If the first day should be Monday, move Sunday to the end.
      if (settings.firstDay) {
        collection.push(collection.shift());
        fullCollection.push(fullCollection.shift());
      }

      // Create and return the table head group.
      return _.node('thead', _.node('tr', _.group({
        min: 0,
        max: DAYS_IN_WEEK - 1,
        i: 1,
        node: 'th',
        item: function item(counter) {
          return [collection[counter], settings.klass.weekdays, 'scope=col title="' + fullCollection[counter] + '"'];
        }
      }))); //endreturn

      // Materialize modified
    }((settings.showWeekdaysFull ? settings.weekdaysFull : settings.weekdaysLetter).slice(0), settings.weekdaysFull.slice(0)),
        //tableHead


    // Create the nav for next/prev month.
    createMonthNav = function createMonthNav(next) {

      // Otherwise, return the created month tag.
      return _.node('div', ' ', settings.klass['nav' + (next ? 'Next' : 'Prev')] + (

      // If the focused month is outside the range, disabled the button.
      next && viewsetObject.year >= maxLimitObject.year && viewsetObject.month >= maxLimitObject.month || !next && viewsetObject.year <= minLimitObject.year && viewsetObject.month <= minLimitObject.month ? ' ' + settings.klass.navDisabled : ''), 'data-nav=' + (next || -1) + ' ' + _.ariaAttr({
        role: 'button',
        controls: calendar.$node[0].id + '_table'
      }) + ' ' + 'title="' + (next ? settings.labelMonthNext : settings.labelMonthPrev) + '"'); //endreturn
    },
        //createMonthNav


    // Create the month label.
    //Materialize modified
    createMonthLabel = function createMonthLabel(override) {

      var monthsCollection = settings.showMonthsShort ? settings.monthsShort : settings.monthsFull;

      // Materialize modified
      if (override == "short_months") {
        monthsCollection = settings.monthsShort;
      }

      // If there are months to select, add a dropdown menu.
      if (settings.selectMonths && override == undefined) {

        return _.node('select', _.group({
          min: 0,
          max: 11,
          i: 1,
          node: 'option',
          item: function item(loopedMonth) {

            return [

            // The looped month and no classes.
            monthsCollection[loopedMonth], 0,

            // Set the value and selected index.
            'value=' + loopedMonth + (viewsetObject.month == loopedMonth ? ' selected' : '') + (viewsetObject.year == minLimitObject.year && loopedMonth < minLimitObject.month || viewsetObject.year == maxLimitObject.year && loopedMonth > maxLimitObject.month ? ' disabled' : '')];
          }
        }), settings.klass.selectMonth + ' browser-default', (isOpen ? '' : 'disabled') + ' ' + _.ariaAttr({ controls: calendar.$node[0].id + '_table' }) + ' ' + 'title="' + settings.labelMonthSelect + '"');
      }

      // Materialize modified
      if (override == "short_months") if (selectedObject != null) return _.node('div', monthsCollection[selectedObject.month]);else return _.node('div', monthsCollection[viewsetObject.month]);

      // If there's a need for a month selector
      return _.node('div', monthsCollection[viewsetObject.month], settings.klass.month);
    },
        //createMonthLabel


    // Create the year label.
    // Materialize modified
    createYearLabel = function createYearLabel(override) {

      var focusedYear = viewsetObject.year,


      // If years selector is set to a literal "true", set it to 5. Otherwise
      // divide in half to get half before and half after focused year.
      numberYears = settings.selectYears === true ? 5 : ~~(settings.selectYears / 2);

      // If there are years to select, add a dropdown menu.
      if (numberYears) {

        var minYear = minLimitObject.year,
            maxYear = maxLimitObject.year,
            lowestYear = focusedYear - numberYears,
            highestYear = focusedYear + numberYears;

        // If the min year is greater than the lowest year, increase the highest year
        // by the difference and set the lowest year to the min year.
        if (minYear > lowestYear) {
          highestYear += minYear - lowestYear;
          lowestYear = minYear;
        }

        // If the max year is less than the highest year, decrease the lowest year
        // by the lower of the two: available and needed years. Then set the
        // highest year to the max year.
        if (maxYear < highestYear) {

          var availableYears = lowestYear - minYear,
              neededYears = highestYear - maxYear;

          lowestYear -= availableYears > neededYears ? neededYears : availableYears;
          highestYear = maxYear;
        }

        if (settings.selectYears && override == undefined) {
          return _.node('select', _.group({
            min: lowestYear,
            max: highestYear,
            i: 1,
            node: 'option',
            item: function item(loopedYear) {
              return [

              // The looped year and no classes.
              loopedYear, 0,

              // Set the value and selected index.
              'value=' + loopedYear + (focusedYear == loopedYear ? ' selected' : '')];
            }
          }), settings.klass.selectYear + ' browser-default', (isOpen ? '' : 'disabled') + ' ' + _.ariaAttr({ controls: calendar.$node[0].id + '_table' }) + ' ' + 'title="' + settings.labelYearSelect + '"');
        }
      }

      // Materialize modified
      if (override == "raw") return _.node('div', focusedYear);

      // Otherwise just return the year focused
      return _.node('div', focusedYear, settings.klass.year);
    }; //createYearLabel


    // Materialize modified
    createDayLabel = function createDayLabel() {
      if (selectedObject != null) return _.node('div', selectedObject.date);else return _.node('div', nowObject.date);
    };
    createWeekdayLabel = function createWeekdayLabel() {
      var display_day;

      if (selectedObject != null) display_day = selectedObject.day;else display_day = nowObject.day;
      var weekday = settings.weekdaysFull[display_day];
      return weekday;
    };

    // Create and return the entire calendar.
    return _.node(
    // Date presentation View
    'div', _.node('div', createWeekdayLabel(), "picker__weekday-display") + _.node(
    // Div for short Month
    'div', createMonthLabel("short_months"), settings.klass.month_display) + _.node(
    // Div for Day
    'div', createDayLabel(), settings.klass.day_display) + _.node(
    // Div for Year
    'div', createYearLabel("raw"), settings.klass.year_display), settings.klass.date_display) +
    // Calendar container
    _.node('div', _.node('div', (settings.selectYears ? createMonthLabel() + createYearLabel() : createMonthLabel() + createYearLabel()) + createMonthNav() + createMonthNav(1), settings.klass.header) + _.node('table', tableHead + _.node('tbody', _.group({
      min: 0,
      max: WEEKS_IN_CALENDAR - 1,
      i: 1,
      node: 'tr',
      item: function item(rowCounter) {

        // If Monday is the first day and the month starts on Sunday, shift the date back a week.
        var shiftDateBy = settings.firstDay && calendar.create([viewsetObject.year, viewsetObject.month, 1]).day === 0 ? -7 : 0;

        return [_.group({
          min: DAYS_IN_WEEK * rowCounter - viewsetObject.day + shiftDateBy + 1, // Add 1 for weekday 0index
          max: function max() {
            return this.min + DAYS_IN_WEEK - 1;
          },
          i: 1,
          node: 'td',
          item: function item(targetDate) {

            // Convert the time date from a relative date to a target date.
            targetDate = calendar.create([viewsetObject.year, viewsetObject.month, targetDate + (settings.firstDay ? 1 : 0)]);

            var isSelected = selectedObject && selectedObject.pick == targetDate.pick,
                isHighlighted = highlightedObject && highlightedObject.pick == targetDate.pick,
                isDisabled = disabledCollection && calendar.disabled(targetDate) || targetDate.pick < minLimitObject.pick || targetDate.pick > maxLimitObject.pick,
                formattedDate = _.trigger(calendar.formats.toString, calendar, [settings.format, targetDate]);

            return [_.node('div', targetDate.date, function (klasses) {

              // Add the `infocus` or `outfocus` classes based on month in view.
              klasses.push(viewsetObject.month == targetDate.month ? settings.klass.infocus : settings.klass.outfocus);

              // Add the `today` class if needed.
              if (nowObject.pick == targetDate.pick) {
                klasses.push(settings.klass.now);
              }

              // Add the `selected` class if something's selected and the time matches.
              if (isSelected) {
                klasses.push(settings.klass.selected);
              }

              // Add the `highlighted` class if something's highlighted and the time matches.
              if (isHighlighted) {
                klasses.push(settings.klass.highlighted);
              }

              // Add the `disabled` class if something's disabled and the object matches.
              if (isDisabled) {
                klasses.push(settings.klass.disabled);
              }

              return klasses.join(' ');
            }([settings.klass.day]), 'data-pick=' + targetDate.pick + ' ' + _.ariaAttr({
              role: 'gridcell',
              label: formattedDate,
              selected: isSelected && calendar.$node.val() === formattedDate ? true : null,
              activedescendant: isHighlighted ? true : null,
              disabled: isDisabled ? true : null
            })), '', _.ariaAttr({ role: 'presentation' })]; //endreturn
          }
        })]; //endreturn
      }
    })), settings.klass.table, 'id="' + calendar.$node[0].id + '_table' + '" ' + _.ariaAttr({
      role: 'grid',
      controls: calendar.$node[0].id,
      readonly: true
    })), settings.klass.calendar_container) // end calendar

    +

    // * For Firefox forms to submit, make sure to set the buttons `type` attributes as button.
    _.node('div', _.node('button', settings.today, "btn-flat picker__today", 'type=button data-pick=' + nowObject.pick + (isOpen && !calendar.disabled(nowObject) ? '' : ' disabled') + ' ' + _.ariaAttr({ controls: calendar.$node[0].id })) + _.node('button', settings.clear, "btn-flat picker__clear", 'type=button data-clear=1' + (isOpen ? '' : ' disabled') + ' ' + _.ariaAttr({ controls: calendar.$node[0].id })) + _.node('button', settings.close, "btn-flat picker__close", 'type=button data-close=true ' + (isOpen ? '' : ' disabled') + ' ' + _.ariaAttr({ controls: calendar.$node[0].id })), settings.klass.footer); //endreturn
  }; //DatePicker.prototype.nodes


  /**
   * The date picker defaults.
   */
  DatePicker.defaults = function (prefix) {

    return {

      // The title label to use for the month nav buttons
      labelMonthNext: 'Next month',
      labelMonthPrev: 'Previous month',

      // The title label to use for the dropdown selectors
      labelMonthSelect: 'Select a month',
      labelYearSelect: 'Select a year',

      // Months and weekdays
      monthsFull: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
      monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      weekdaysFull: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],

      // Materialize modified
      weekdaysLetter: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],

      // Today and clear
      today: 'Today',
      clear: 'Clear',
      close: 'Close',

      // The format to show on the `input` element
      format: 'd mmmm, yyyy',

      // Classes
      klass: {

        table: prefix + 'table',

        header: prefix + 'header',

        // Materialize Added klasses
        date_display: prefix + 'date-display',
        day_display: prefix + 'day-display',
        month_display: prefix + 'month-display',
        year_display: prefix + 'year-display',
        calendar_container: prefix + 'calendar-container',
        // end


        navPrev: prefix + 'nav--prev',
        navNext: prefix + 'nav--next',
        navDisabled: prefix + 'nav--disabled',

        month: prefix + 'month',
        year: prefix + 'year',

        selectMonth: prefix + 'select--month',
        selectYear: prefix + 'select--year',

        weekdays: prefix + 'weekday',

        day: prefix + 'day',
        disabled: prefix + 'day--disabled',
        selected: prefix + 'day--selected',
        highlighted: prefix + 'day--highlighted',
        now: prefix + 'day--today',
        infocus: prefix + 'day--infocus',
        outfocus: prefix + 'day--outfocus',

        footer: prefix + 'footer',

        buttonClear: prefix + 'button--clear',
        buttonToday: prefix + 'button--today',
        buttonClose: prefix + 'button--close'
      }
    };
  }(Picker.klasses().picker + '__');

  /**
   * Extend the picker to add the date picker.
   */
  Picker.extend('pickadate', DatePicker);
});

;(function ($) {

  $.fn.characterCounter = function () {
    return this.each(function () {
      var $input = $(this);
      var $counterElement = $input.parent().find('span[class="character-counter"]');

      // character counter has already been added appended to the parent container
      if ($counterElement.length) {
        return;
      }

      var itHasLengthAttribute = $input.attr('data-length') !== undefined;

      if (itHasLengthAttribute) {
        $input.on('input', updateCounter);
        $input.on('focus', updateCounter);
        $input.on('blur', removeCounterElement);

        addCounterElement($input);
      }
    });
  };

  function updateCounter() {
    var maxLength = +$(this).attr('data-length'),
        actualLength = +$(this).val().length,
        isValidLength = actualLength <= maxLength;

    $(this).parent().find('span[class="character-counter"]').html(actualLength + '/' + maxLength);

    addInputStyle(isValidLength, $(this));
  }

  function addCounterElement($input) {
    var $counterElement = $input.parent().find('span[class="character-counter"]');

    if ($counterElement.length) {
      return;
    }

    $counterElement = $('<span/>').addClass('character-counter').css('float', 'right').css('font-size', '12px').css('height', 1);

    $input.parent().append($counterElement);
  }

  function removeCounterElement() {
    $(this).parent().find('span[class="character-counter"]').html('');
  }

  function addInputStyle(isValidLength, $input) {
    var inputHasInvalidClass = $input.hasClass('invalid');
    if (isValidLength && inputHasInvalidClass) {
      $input.removeClass('invalid');
    } else if (!isValidLength && !inputHasInvalidClass) {
      $input.removeClass('valid');
      $input.addClass('invalid');
    }
  }

  $(document).ready(function () {
    $('input, textarea').characterCounter();
  });
})(jQuery);
;(function ($) {

  var methods = {

    init: function init(options) {
      var defaults = {
        duration: 200, // ms
        dist: -100, // zoom scale TODO: make this more intuitive as an option
        shift: 0, // spacing for center image
        padding: 0, // Padding between non center items
        fullWidth: false, // Change to full width styles
        indicators: false, // Toggle indicators
        noWrap: false, // Don't wrap around and cycle through items.
        onCycleTo: null // Callback for when a new slide is cycled to.
      };
      options = $.extend(defaults, options);
      var namespace = Materialize.objectSelectorString($(this));

      return this.each(function (i) {

        var uniqueNamespace = namespace + i;
        var images, item_width, item_height, offset, center, pressed, dim, count, reference, referenceY, amplitude, target, velocity, scrolling, xform, frame, timestamp, ticker, dragged, vertical_dragged;
        var $indicators = $('<ul class="indicators"></ul>');
        var scrollingTimeout = null;

        // Initialize
        var view = $(this);
        var showIndicators = view.attr('data-indicators') || options.indicators;

        // Options
        var setCarouselHeight = function setCarouselHeight() {
          var firstImage = view.find('.carousel-item img').first();
          if (firstImage.length) {
            if (firstImage.prop('complete')) {
              view.css('height', firstImage.height());
            } else {
              firstImage.on('load', function () {
                view.css('height', $(this).height());
              });
            }
          } else {
            var imageHeight = view.find('.carousel-item').first().height();
            view.css('height', imageHeight);
          }
        };

        if (options.fullWidth) {
          options.dist = 0;
          setCarouselHeight();

          // Offset fixed items when indicators.
          if (showIndicators) {
            view.find('.carousel-fixed-item').addClass('with-indicators');
          }
        }

        // Don't double initialize.
        if (view.hasClass('initialized')) {
          // Recalculate variables
          $(window).trigger('resize');

          // Redraw carousel.
          $(this).trigger('carouselNext', [0.000001]);
          return true;
        }

        view.addClass('initialized');
        pressed = false;
        offset = target = 0;
        images = [];
        item_width = view.find('.carousel-item').first().innerWidth();
        item_height = view.find('.carousel-item').first().innerHeight();
        dim = item_width * 2 + options.padding;

        view.find('.carousel-item').each(function (i) {
          images.push($(this)[0]);
          if (showIndicators) {
            var $indicator = $('<li class="indicator-item"></li>');

            // Add active to first by default.
            if (i === 0) {
              $indicator.addClass('active');
            }

            // Handle clicks on indicators.
            $indicator.click(function (e) {
              e.stopPropagation();

              var index = $(this).index();
              cycleTo(index);
            });
            $indicators.append($indicator);
          }
        });

        if (showIndicators) {
          view.append($indicators);
        }
        count = images.length;

        function setupEvents() {
          if (typeof window.ontouchstart !== 'undefined') {
            view[0].addEventListener('touchstart', tap);
            view[0].addEventListener('touchmove', drag);
            view[0].addEventListener('touchend', release);
          }
          view[0].addEventListener('mousedown', tap);
          view[0].addEventListener('mousemove', drag);
          view[0].addEventListener('mouseup', release);
          view[0].addEventListener('mouseleave', release);
          view[0].addEventListener('click', click);
        }

        function xpos(e) {
          // touch event
          if (e.targetTouches && e.targetTouches.length >= 1) {
            return e.targetTouches[0].clientX;
          }

          // mouse event
          return e.clientX;
        }

        function ypos(e) {
          // touch event
          if (e.targetTouches && e.targetTouches.length >= 1) {
            return e.targetTouches[0].clientY;
          }

          // mouse event
          return e.clientY;
        }

        function wrap(x) {
          return x >= count ? x % count : x < 0 ? wrap(count + x % count) : x;
        }

        function scroll(x) {
          // Track scrolling state
          scrolling = true;
          if (!view.hasClass('scrolling')) {
            view.addClass('scrolling');
          }
          if (scrollingTimeout != null) {
            window.clearTimeout(scrollingTimeout);
          }
          scrollingTimeout = window.setTimeout(function () {
            scrolling = false;
            view.removeClass('scrolling');
          }, options.duration);

          // Start actual scroll
          var i, half, delta, dir, tween, el, alignment, xTranslation;
          var lastCenter = center;

          offset = typeof x === 'number' ? x : offset;
          center = Math.floor((offset + dim / 2) / dim);
          delta = offset - center * dim;
          dir = delta < 0 ? 1 : -1;
          tween = -dir * delta * 2 / dim;
          half = count >> 1;

          if (!options.fullWidth) {
            alignment = 'translateX(' + (view[0].clientWidth - item_width) / 2 + 'px) ';
            alignment += 'translateY(' + (view[0].clientHeight - item_height) / 2 + 'px)';
          } else {
            alignment = 'translateX(0)';
          }

          // Set indicator active
          if (showIndicators) {
            var diff = center % count;
            var activeIndicator = $indicators.find('.indicator-item.active');
            if (activeIndicator.index() !== diff) {
              activeIndicator.removeClass('active');
              $indicators.find('.indicator-item').eq(diff).addClass('active');
            }
          }

          // center
          // Don't show wrapped items.
          if (!options.noWrap || center >= 0 && center < count) {
            el = images[wrap(center)];

            // Add active class to center item.
            if (!$(el).hasClass('active')) {
              view.find('.carousel-item').removeClass('active');
              $(el).addClass('active');
            }
            el.style[xform] = alignment + ' translateX(' + -delta / 2 + 'px)' + ' translateX(' + dir * options.shift * tween * i + 'px)' + ' translateZ(' + options.dist * tween + 'px)';
            el.style.zIndex = 0;
            if (options.fullWidth) {
              tweenedOpacity = 1;
            } else {
              tweenedOpacity = 1 - 0.2 * tween;
            }
            el.style.opacity = tweenedOpacity;
            el.style.display = 'block';
          }

          for (i = 1; i <= half; ++i) {
            // right side
            if (options.fullWidth) {
              zTranslation = options.dist;
              tweenedOpacity = i === half && delta < 0 ? 1 - tween : 1;
            } else {
              zTranslation = options.dist * (i * 2 + tween * dir);
              tweenedOpacity = 1 - 0.2 * (i * 2 + tween * dir);
            }
            // Don't show wrapped items.
            if (!options.noWrap || center + i < count) {
              el = images[wrap(center + i)];
              el.style[xform] = alignment + ' translateX(' + (options.shift + (dim * i - delta) / 2) + 'px)' + ' translateZ(' + zTranslation + 'px)';
              el.style.zIndex = -i;
              el.style.opacity = tweenedOpacity;
              el.style.display = 'block';
            }

            // left side
            if (options.fullWidth) {
              zTranslation = options.dist;
              tweenedOpacity = i === half && delta > 0 ? 1 - tween : 1;
            } else {
              zTranslation = options.dist * (i * 2 - tween * dir);
              tweenedOpacity = 1 - 0.2 * (i * 2 - tween * dir);
            }
            // Don't show wrapped items.
            if (!options.noWrap || center - i >= 0) {
              el = images[wrap(center - i)];
              el.style[xform] = alignment + ' translateX(' + (-options.shift + (-dim * i - delta) / 2) + 'px)' + ' translateZ(' + zTranslation + 'px)';
              el.style.zIndex = -i;
              el.style.opacity = tweenedOpacity;
              el.style.display = 'block';
            }
          }

          // center
          // Don't show wrapped items.
          if (!options.noWrap || center >= 0 && center < count) {
            el = images[wrap(center)];
            el.style[xform] = alignment + ' translateX(' + -delta / 2 + 'px)' + ' translateX(' + dir * options.shift * tween + 'px)' + ' translateZ(' + options.dist * tween + 'px)';
            el.style.zIndex = 0;
            if (options.fullWidth) {
              tweenedOpacity = 1;
            } else {
              tweenedOpacity = 1 - 0.2 * tween;
            }
            el.style.opacity = tweenedOpacity;
            el.style.display = 'block';
          }

          // onCycleTo callback
          if (lastCenter !== center && typeof options.onCycleTo === "function") {
            var $curr_item = view.find('.carousel-item').eq(wrap(center));
            options.onCycleTo.call(this, $curr_item, dragged);
          }
        }

        function track() {
          var now, elapsed, delta, v;

          now = Date.now();
          elapsed = now - timestamp;
          timestamp = now;
          delta = offset - frame;
          frame = offset;

          v = 1000 * delta / (1 + elapsed);
          velocity = 0.8 * v + 0.2 * velocity;
        }

        function autoScroll() {
          var elapsed, delta;

          if (amplitude) {
            elapsed = Date.now() - timestamp;
            delta = amplitude * Math.exp(-elapsed / options.duration);
            if (delta > 2 || delta < -2) {
              scroll(target - delta);
              requestAnimationFrame(autoScroll);
            } else {
              scroll(target);
            }
          }
        }

        function click(e) {
          // Disable clicks if carousel was dragged.
          if (dragged) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          } else if (!options.fullWidth) {
            var clickedIndex = $(e.target).closest('.carousel-item').index();
            var diff = center % count - clickedIndex;

            // Disable clicks if carousel was shifted by click
            if (diff !== 0) {
              e.preventDefault();
              e.stopPropagation();
            }
            cycleTo(clickedIndex);
          }
        }

        function cycleTo(n) {
          var diff = center % count - n;

          // Account for wraparound.
          if (!options.noWrap) {
            if (diff < 0) {
              if (Math.abs(diff + count) < Math.abs(diff)) {
                diff += count;
              }
            } else if (diff > 0) {
              if (Math.abs(diff - count) < diff) {
                diff -= count;
              }
            }
          }

          // Call prev or next accordingly.
          if (diff < 0) {
            view.trigger('carouselNext', [Math.abs(diff)]);
          } else if (diff > 0) {
            view.trigger('carouselPrev', [diff]);
          }
        }

        function tap(e) {
          e.preventDefault();
          pressed = true;
          dragged = false;
          vertical_dragged = false;
          reference = xpos(e);
          referenceY = ypos(e);

          velocity = amplitude = 0;
          frame = offset;
          timestamp = Date.now();
          clearInterval(ticker);
          ticker = setInterval(track, 100);
        }

        function drag(e) {
          var x, delta, deltaY;
          if (pressed) {
            x = xpos(e);
            y = ypos(e);
            delta = reference - x;
            deltaY = Math.abs(referenceY - y);
            if (deltaY < 30 && !vertical_dragged) {
              // If vertical scrolling don't allow dragging.
              if (delta > 2 || delta < -2) {
                dragged = true;
                reference = x;
                scroll(offset + delta);
              }
            } else if (dragged) {
              // If dragging don't allow vertical scroll.
              e.preventDefault();
              e.stopPropagation();
              return false;
            } else {
              // Vertical scrolling.
              vertical_dragged = true;
            }
          }

          if (dragged) {
            // If dragging don't allow vertical scroll.
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }

        function release(e) {
          if (pressed) {
            pressed = false;
          } else {
            return;
          }

          clearInterval(ticker);
          target = offset;
          if (velocity > 10 || velocity < -10) {
            amplitude = 0.9 * velocity;
            target = offset + amplitude;
          }
          target = Math.round(target / dim) * dim;

          // No wrap of items.
          if (options.noWrap) {
            if (target >= dim * (count - 1)) {
              target = dim * (count - 1);
            } else if (target < 0) {
              target = 0;
            }
          }
          amplitude = target - offset;
          timestamp = Date.now();
          requestAnimationFrame(autoScroll);

          if (dragged) {
            e.preventDefault();
            e.stopPropagation();
          }
          return false;
        }

        xform = 'transform';
        ['webkit', 'Moz', 'O', 'ms'].every(function (prefix) {
          var e = prefix + 'Transform';
          if (typeof document.body.style[e] !== 'undefined') {
            xform = e;
            return false;
          }
          return true;
        });

        $(window).off('resize.carousel-' + uniqueNamespace).on('resize.carousel-' + uniqueNamespace, function () {
          if (options.fullWidth) {
            item_width = view.find('.carousel-item').first().innerWidth();
            item_height = view.find('.carousel-item').first().innerHeight();
            dim = item_width * 2 + options.padding;
            offset = center * 2 * item_width;
            target = offset;
          } else {
            scroll();
          }
        });

        setupEvents();
        scroll(offset);

        $(this).on('carouselNext', function (e, n) {
          if (n === undefined) {
            n = 1;
          }
          target = dim * Math.round(offset / dim) + dim * n;
          if (offset !== target) {
            amplitude = target - offset;
            timestamp = Date.now();
            requestAnimationFrame(autoScroll);
          }
        });

        $(this).on('carouselPrev', function (e, n) {
          if (n === undefined) {
            n = 1;
          }
          target = dim * Math.round(offset / dim) - dim * n;
          if (offset !== target) {
            amplitude = target - offset;
            timestamp = Date.now();
            requestAnimationFrame(autoScroll);
          }
        });

        $(this).on('carouselSet', function (e, n) {
          if (n === undefined) {
            n = 0;
          }
          cycleTo(n);
        });
      });
    },
    next: function next(n) {
      $(this).trigger('carouselNext', [n]);
    },
    prev: function prev(n) {
      $(this).trigger('carouselPrev', [n]);
    },
    set: function set(n) {
      $(this).trigger('carouselSet', [n]);
    }
  };

  $.fn.carousel = function (methodOrOptions) {
    if (methods[methodOrOptions]) {
      return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if ((typeof methodOrOptions === 'undefined' ? 'undefined' : _typeof(methodOrOptions)) === 'object' || !methodOrOptions) {
      // Default to "init"
      return methods.init.apply(this, arguments);
    } else {
      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.carousel');
    }
  }; // Plugin end
})(jQuery);;(function ($) {

  var methods = {
    init: function init(options) {
      return this.each(function () {
        var origin = $('#' + $(this).attr('data-activates'));
        var screen = $('body');

        // Creating tap target
        var tapTargetEl = $(this);
        var tapTargetWrapper = tapTargetEl.parent('.tap-target-wrapper');
        var tapTargetWave = tapTargetWrapper.find('.tap-target-wave');
        var tapTargetOriginEl = tapTargetWrapper.find('.tap-target-origin');
        var tapTargetContentEl = tapTargetEl.find('.tap-target-content');

        // Creating wrapper
        if (!tapTargetWrapper.length) {
          tapTargetWrapper = tapTargetEl.wrap($('<div class="tap-target-wrapper"></div>')).parent();
        }

        // Creating content
        if (!tapTargetContentEl.length) {
          tapTargetContentEl = $('<div class="tap-target-content"></div>');
          tapTargetEl.append(tapTargetContentEl);
        }

        // Creating foreground wave
        if (!tapTargetWave.length) {
          tapTargetWave = $('<div class="tap-target-wave"></div>');

          // Creating origin
          if (!tapTargetOriginEl.length) {
            tapTargetOriginEl = origin.clone(true, true);
            tapTargetOriginEl.addClass('tap-target-origin');
            tapTargetOriginEl.removeAttr('id');
            tapTargetOriginEl.removeAttr('style');
            tapTargetWave.append(tapTargetOriginEl);
          }

          tapTargetWrapper.append(tapTargetWave);
        }

        // Open
        var openTapTarget = function openTapTarget() {
          if (tapTargetWrapper.is('.open')) {
            return;
          }

          // Adding open class
          tapTargetWrapper.addClass('open');

          setTimeout(function () {
            tapTargetOriginEl.off('click.tapTarget').on('click.tapTarget', function (e) {
              closeTapTarget();
              tapTargetOriginEl.off('click.tapTarget');
            });

            $(document).off('click.tapTarget').on('click.tapTarget', function (e) {
              closeTapTarget();
              $(document).off('click.tapTarget');
            });

            var throttledCalc = Materialize.throttle(function () {
              calculateTapTarget();
            }, 200);
            $(window).off('resize.tapTarget').on('resize.tapTarget', throttledCalc);
          }, 0);
        };

        // Close
        var closeTapTarget = function closeTapTarget() {
          if (!tapTargetWrapper.is('.open')) {
            return;
          }

          tapTargetWrapper.removeClass('open');
          tapTargetOriginEl.off('click.tapTarget');
          $(document).off('click.tapTarget');
          $(window).off('resize.tapTarget');
        };

        // Pre calculate
        var calculateTapTarget = function calculateTapTarget() {
          // Element or parent is fixed position?
          var isFixed = origin.css('position') === 'fixed';
          if (!isFixed) {
            var parents = origin.parents();
            for (var i = 0; i < parents.length; i++) {
              isFixed = $(parents[i]).css('position') == 'fixed';
              if (isFixed) {
                break;
              }
            }
          }

          // Calculating origin
          var originWidth = origin.outerWidth();
          var originHeight = origin.outerHeight();
          var originTop = isFixed ? origin.offset().top - $(document).scrollTop() : origin.offset().top;
          var originLeft = isFixed ? origin.offset().left - $(document).scrollLeft() : origin.offset().left;

          // Calculating screen
          var windowWidth = $(window).width();
          var windowHeight = $(window).height();
          var centerX = windowWidth / 2;
          var centerY = windowHeight / 2;
          var isLeft = originLeft <= centerX;
          var isRight = originLeft > centerX;
          var isTop = originTop <= centerY;
          var isBottom = originTop > centerY;
          var isCenterX = originLeft >= windowWidth * 0.25 && originLeft <= windowWidth * 0.75;
          var isCenterY = originTop >= windowHeight * 0.25 && originTop <= windowHeight * 0.75;

          // Calculating tap target
          var tapTargetWidth = tapTargetEl.outerWidth();
          var tapTargetHeight = tapTargetEl.outerHeight();
          var tapTargetTop = originTop + originHeight / 2 - tapTargetHeight / 2;
          var tapTargetLeft = originLeft + originWidth / 2 - tapTargetWidth / 2;
          var tapTargetPosition = isFixed ? 'fixed' : 'absolute';

          // Calculating content
          var tapTargetTextWidth = isCenterX ? tapTargetWidth : tapTargetWidth / 2 + originWidth;
          var tapTargetTextHeight = tapTargetHeight / 2;
          var tapTargetTextTop = isTop ? tapTargetHeight / 2 : 0;
          var tapTargetTextBottom = 0;
          var tapTargetTextLeft = isLeft && !isCenterX ? tapTargetWidth / 2 - originWidth : 0;
          var tapTargetTextRight = 0;
          var tapTargetTextPadding = originWidth;
          var tapTargetTextAlign = isBottom ? 'bottom' : 'top';

          // Calculating wave
          var tapTargetWaveWidth = originWidth > originHeight ? originWidth * 2 : originWidth * 2;
          var tapTargetWaveHeight = tapTargetWaveWidth;
          var tapTargetWaveTop = tapTargetHeight / 2 - tapTargetWaveHeight / 2;
          var tapTargetWaveLeft = tapTargetWidth / 2 - tapTargetWaveWidth / 2;

          // Setting tap target
          var tapTargetWrapperCssObj = {};
          tapTargetWrapperCssObj.top = isTop ? tapTargetTop : '';
          tapTargetWrapperCssObj.right = isRight ? windowWidth - tapTargetLeft - tapTargetWidth : '';
          tapTargetWrapperCssObj.bottom = isBottom ? windowHeight - tapTargetTop - tapTargetHeight : '';
          tapTargetWrapperCssObj.left = isLeft ? tapTargetLeft : '';
          tapTargetWrapperCssObj.position = tapTargetPosition;
          tapTargetWrapper.css(tapTargetWrapperCssObj);

          // Setting content
          tapTargetContentEl.css({
            width: tapTargetTextWidth,
            height: tapTargetTextHeight,
            top: tapTargetTextTop,
            right: tapTargetTextRight,
            bottom: tapTargetTextBottom,
            left: tapTargetTextLeft,
            padding: tapTargetTextPadding,
            verticalAlign: tapTargetTextAlign
          });

          // Setting wave
          tapTargetWave.css({
            top: tapTargetWaveTop,
            left: tapTargetWaveLeft,
            width: tapTargetWaveWidth,
            height: tapTargetWaveHeight
          });
        };

        if (options == 'open') {
          calculateTapTarget();
          openTapTarget();
        }

        if (options == 'close') closeTapTarget();
      });
    },
    open: function open() {},
    close: function close() {}
  };

  $.fn.tapTarget = function (methodOrOptions) {
    if (methods[methodOrOptions] || (typeof methodOrOptions === 'undefined' ? 'undefined' : _typeof(methodOrOptions)) === 'object') return methods.init.apply(this, arguments);

    $.error('Method ' + methodOrOptions + ' does not exist on jQuery.tap-target');
  };
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)(module)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
        return Hammer;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var $ = window.jQuery = __webpack_require__(0);
__webpack_require__(10);
__webpack_require__(1);

$(document).ready(function () {
    $(".button-collapse").sideNav();
    $('#posts-table').DataTable();
    $('#projects-table').DataTable();
    $('#tags').material_chip({
        placeholder: 'Enter a tag',
        secondaryPlaceholder: '+Tag'
    });
});

/***/ }),
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! DataTables 1.10.15
 * 2008-2017 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.15
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net
 * @copyright   Copyright 2008-2017 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/

(function (factory) {
	"use strict";

	if (true) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
			return factory($, window, document);
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
		// CommonJS
		module.exports = function (root, $) {
			if (!root) {
				// CommonJS environments without a window global must pass a
				// root. This will give an error otherwise
				root = window;
			}

			if (!$) {
				$ = typeof window !== 'undefined' ? // jQuery's factory checks for a global window
				require('jquery') : require('jquery')(root);
			}

			return factory($, root, root.document);
		};
	} else {
		// Browser
		factory(jQuery, window, document);
	}
})(function ($, window, document, undefined) {
	"use strict";

	/**
  * DataTables is a plug-in for the jQuery Javascript library. It is a highly
  * flexible tool, based upon the foundations of progressive enhancement,
  * which will add advanced interaction controls to any HTML table. For a
  * full list of features please refer to
  * [DataTables.net](href="http://datatables.net).
  *
  * Note that the `DataTable` object is not a global variable but is aliased
  * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
  * be  accessed.
  *
  *  @class
  *  @param {object} [init={}] Configuration object for DataTables. Options
  *    are defined by {@link DataTable.defaults}
  *  @requires jQuery 1.7+
  *
  *  @example
  *    // Basic initialisation
  *    $(document).ready( function {
  *      $('#example').dataTable();
  *    } );
  *
  *  @example
  *    // Initialisation with configuration options - in this case, disable
  *    // pagination and sorting.
  *    $(document).ready( function {
  *      $('#example').dataTable( {
  *        "paginate": false,
  *        "sort": false
  *      } );
  *    } );
  */

	var DataTable = function DataTable(options) {
		/**
   * Perform a jQuery selector action on the table's TR elements (from the tbody) and
   * return the resulting jQuery object.
   *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
   *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
   *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
   *    criterion ("applied") or all TR elements (i.e. no filter).
   *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
   *    Can be either 'current', whereby the current sorting of the table is used, or
   *    'original' whereby the original order the data was read into the table is used.
   *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
   *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
   *    'current' and filter is 'applied', regardless of what they might be given as.
   *  @returns {object} jQuery object, filtered by the given selector.
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Highlight every second row
   *      oTable.$('tr:odd').css('backgroundColor', 'blue');
   *    } );
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Filter to rows with 'Webkit' in them, add a background colour and then
   *      // remove the filter, thus highlighting the 'Webkit' rows only.
   *      oTable.fnFilter('Webkit');
   *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
   *      oTable.fnFilter('');
   *    } );
   */
		this.$ = function (sSelector, oOpts) {
			return this.api(true).$(sSelector, oOpts);
		};

		/**
   * Almost identical to $ in operation, but in this case returns the data for the matched
   * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
   * rather than any descendants, so the data can be obtained for the row/cell. If matching
   * rows are found, the data returned is the original data array/object that was used to
   * create the row (or a generated array if from a DOM source).
   *
   * This method is often useful in-combination with $ where both functions are given the
   * same parameters and the array indexes will match identically.
   *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
   *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
   *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
   *    criterion ("applied") or all elements (i.e. no filter).
   *  @param {string} [oOpts.order=current] Order of the data in the processed array.
   *    Can be either 'current', whereby the current sorting of the table is used, or
   *    'original' whereby the original order the data was read into the table is used.
   *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
   *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
   *    'current' and filter is 'applied', regardless of what they might be given as.
   *  @returns {array} Data for the matched elements. If any elements, as a result of the
   *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
   *    entry in the array.
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Get the data from the first row in the table
   *      var data = oTable._('tr:first');
   *
   *      // Do something useful with the data
   *      alert( "First cell is: "+data[0] );
   *    } );
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Filter to 'Webkit' and get all data for
   *      oTable.fnFilter('Webkit');
   *      var data = oTable._('tr', {"search": "applied"});
   *
   *      // Do something with the data
   *      alert( data.length+" rows matched the search" );
   *    } );
   */
		this._ = function (sSelector, oOpts) {
			return this.api(true).rows(sSelector, oOpts).data();
		};

		/**
   * Create a DataTables Api instance, with the currently selected tables for
   * the Api's context.
   * @param {boolean} [traditional=false] Set the API instance's context to be
   *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
   *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
   *   or if all tables captured in the jQuery object should be used.
   * @return {DataTables.Api}
   */
		this.api = function (traditional) {
			return traditional ? new _Api2(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api2(this);
		};

		/**
   * Add a single new row or multiple rows of data to the table. Please note
   * that this is suitable for client-side processing only - if you are using
   * server-side processing (i.e. "bServerSide": true), then to add data, you
   * must add it to the data source, i.e. the server-side, through an Ajax call.
   *  @param {array|object} data The data to be added to the table. This can be:
   *    <ul>
   *      <li>1D array of data - add a single row with the data provided</li>
   *      <li>2D array of arrays - add multiple rows in a single call</li>
   *      <li>object - data object when using <i>mData</i></li>
   *      <li>array of objects - multiple data objects when using <i>mData</i></li>
   *    </ul>
   *  @param {bool} [redraw=true] redraw the table or not
   *  @returns {array} An array of integers, representing the list of indexes in
   *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
   *    the table.
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    // Global var for counter
   *    var giCount = 2;
   *
   *    $(document).ready(function() {
   *      $('#example').dataTable();
   *    } );
   *
   *    function fnClickAddRow() {
   *      $('#example').dataTable().fnAddData( [
   *        giCount+".1",
   *        giCount+".2",
   *        giCount+".3",
   *        giCount+".4" ]
   *      );
   *
   *      giCount++;
   *    }
   */
		this.fnAddData = function (data, redraw) {
			var api = this.api(true);

			/* Check if we want to add multiple rows or not */
			var rows = $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);

			if (redraw === undefined || redraw) {
				api.draw();
			}

			return rows.flatten().toArray();
		};

		/**
   * This function will make DataTables recalculate the column sizes, based on the data
   * contained in the table and the sizes applied to the columns (in the DOM, CSS or
   * through the sWidth parameter). This can be useful when the width of the table's
   * parent element changes (for example a window resize).
   *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable( {
   *        "sScrollY": "200px",
   *        "bPaginate": false
   *      } );
   *
   *      $(window).on('resize', function () {
   *        oTable.fnAdjustColumnSizing();
   *      } );
   *    } );
   */
		this.fnAdjustColumnSizing = function (bRedraw) {
			var api = this.api(true).columns.adjust();
			var settings = api.settings()[0];
			var scroll = settings.oScroll;

			if (bRedraw === undefined || bRedraw) {
				api.draw(false);
			} else if (scroll.sX !== "" || scroll.sY !== "") {
				/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
				_fnScrollDraw(settings);
			}
		};

		/**
   * Quickly and simply clear a table
   *  @param {bool} [bRedraw=true] redraw the table or not
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
   *      oTable.fnClearTable();
   *    } );
   */
		this.fnClearTable = function (bRedraw) {
			var api = this.api(true).clear();

			if (bRedraw === undefined || bRedraw) {
				api.draw();
			}
		};

		/**
   * The exact opposite of 'opening' a row, this function will close any rows which
   * are currently 'open'.
   *  @param {node} nTr the table row to 'close'
   *  @returns {int} 0 on success, or 1 if failed (can't find the row)
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable;
   *
   *      // 'open' an information row when a row is clicked on
   *      $('#example tbody tr').click( function () {
   *        if ( oTable.fnIsOpen(this) ) {
   *          oTable.fnClose( this );
   *        } else {
   *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
   *        }
   *      } );
   *
   *      oTable = $('#example').dataTable();
   *    } );
   */
		this.fnClose = function (nTr) {
			this.api(true).row(nTr).child.hide();
		};

		/**
   * Remove a row for the table
   *  @param {mixed} target The index of the row from aoData to be deleted, or
   *    the TR element you want to delete
   *  @param {function|null} [callBack] Callback function
   *  @param {bool} [redraw=true] Redraw the table or not
   *  @returns {array} The row that was deleted
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Immediately remove the first row
   *      oTable.fnDeleteRow( 0 );
   *    } );
   */
		this.fnDeleteRow = function (target, callback, redraw) {
			var api = this.api(true);
			var rows = api.rows(target);
			var settings = rows.settings()[0];
			var data = settings.aoData[rows[0][0]];

			rows.remove();

			if (callback) {
				callback.call(this, settings, data);
			}

			if (redraw === undefined || redraw) {
				api.draw();
			}

			return data;
		};

		/**
   * Restore the table to it's original state in the DOM by removing all of DataTables
   * enhancements, alterations to the DOM structure of the table and event listeners.
   *  @param {boolean} [remove=false] Completely remove the table from the DOM
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
   *      var oTable = $('#example').dataTable();
   *      oTable.fnDestroy();
   *    } );
   */
		this.fnDestroy = function (remove) {
			this.api(true).destroy(remove);
		};

		/**
   * Redraw the table
   *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
   *      oTable.fnDraw();
   *    } );
   */
		this.fnDraw = function (complete) {
			// Note that this isn't an exact match to the old call to _fnDraw - it takes
			// into account the new data, but can hold position.
			this.api(true).draw(complete);
		};

		/**
   * Filter the input based on data
   *  @param {string} sInput String to filter the table on
   *  @param {int|null} [iColumn] Column to limit filtering to
   *  @param {bool} [bRegex=false] Treat as regular expression or not
   *  @param {bool} [bSmart=true] Perform smart filtering or not
   *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
   *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Sometime later - filter...
   *      oTable.fnFilter( 'test string' );
   *    } );
   */
		this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
			var api = this.api(true);

			if (iColumn === null || iColumn === undefined) {
				api.search(sInput, bRegex, bSmart, bCaseInsensitive);
			} else {
				api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
			}

			api.draw();
		};

		/**
   * Get the data for the whole table, an individual row or an individual cell based on the
   * provided parameters.
   *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
   *    a TR node then the data source for the whole row will be returned. If given as a
   *    TD/TH cell node then iCol will be automatically calculated and the data for the
   *    cell returned. If given as an integer, then this is treated as the aoData internal
   *    data index for the row (see fnGetPosition) and the data for that row used.
   *  @param {int} [col] Optional column index that you want the data of.
   *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
   *    returned. If mRow is defined, just data for that row, and is iCol is
   *    defined, only data for the designated cell is returned.
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    // Row data
   *    $(document).ready(function() {
   *      oTable = $('#example').dataTable();
   *
   *      oTable.$('tr').click( function () {
   *        var data = oTable.fnGetData( this );
   *        // ... do something with the array / object of data for the row
   *      } );
   *    } );
   *
   *  @example
   *    // Individual cell data
   *    $(document).ready(function() {
   *      oTable = $('#example').dataTable();
   *
   *      oTable.$('td').click( function () {
   *        var sData = oTable.fnGetData( this );
   *        alert( 'The cell clicked on had the value of '+sData );
   *      } );
   *    } );
   */
		this.fnGetData = function (src, col) {
			var api = this.api(true);

			if (src !== undefined) {
				var type = src.nodeName ? src.nodeName.toLowerCase() : '';

				return col !== undefined || type == 'td' || type == 'th' ? api.cell(src, col).data() : api.row(src).data() || null;
			}

			return api.data().toArray();
		};

		/**
   * Get an array of the TR nodes that are used in the table's body. Note that you will
   * typically want to use the '$' API method in preference to this as it is more
   * flexible.
   *  @param {int} [iRow] Optional row index for the TR element you want
   *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
   *    in the table's body, or iRow is defined, just the TR element requested.
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Get the nodes from the table
   *      var nNodes = oTable.fnGetNodes( );
   *    } );
   */
		this.fnGetNodes = function (iRow) {
			var api = this.api(true);

			return iRow !== undefined ? api.row(iRow).node() : api.rows().nodes().flatten().toArray();
		};

		/**
   * Get the array indexes of a particular cell from it's DOM element
   * and column index including hidden columns
   *  @param {node} node this can either be a TR, TD or TH in the table's body
   *  @returns {int} If nNode is given as a TR, then a single index is returned, or
   *    if given as a cell, an array of [row index, column index (visible),
   *    column index (all)] is given.
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      $('#example tbody td').click( function () {
   *        // Get the position of the current data from the node
   *        var aPos = oTable.fnGetPosition( this );
   *
   *        // Get the data array for this row
   *        var aData = oTable.fnGetData( aPos[0] );
   *
   *        // Update the data array and return the value
   *        aData[ aPos[1] ] = 'clicked';
   *        this.innerHTML = 'clicked';
   *      } );
   *
   *      // Init DataTables
   *      oTable = $('#example').dataTable();
   *    } );
   */
		this.fnGetPosition = function (node) {
			var api = this.api(true);
			var nodeName = node.nodeName.toUpperCase();

			if (nodeName == 'TR') {
				return api.row(node).index();
			} else if (nodeName == 'TD' || nodeName == 'TH') {
				var cell = api.cell(node).index();

				return [cell.row, cell.columnVisible, cell.column];
			}
			return null;
		};

		/**
   * Check to see if a row is 'open' or not.
   *  @param {node} nTr the table row to check
   *  @returns {boolean} true if the row is currently open, false otherwise
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable;
   *
   *      // 'open' an information row when a row is clicked on
   *      $('#example tbody tr').click( function () {
   *        if ( oTable.fnIsOpen(this) ) {
   *          oTable.fnClose( this );
   *        } else {
   *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
   *        }
   *      } );
   *
   *      oTable = $('#example').dataTable();
   *    } );
   */
		this.fnIsOpen = function (nTr) {
			return this.api(true).row(nTr).child.isShown();
		};

		/**
   * This function will place a new row directly after a row which is currently
   * on display on the page, with the HTML contents that is passed into the
   * function. This can be used, for example, to ask for confirmation that a
   * particular record should be deleted.
   *  @param {node} nTr The table row to 'open'
   *  @param {string|node|jQuery} mHtml The HTML to put into the row
   *  @param {string} sClass Class to give the new TD cell
   *  @returns {node} The row opened. Note that if the table row passed in as the
   *    first parameter, is not found in the table, this method will silently
   *    return.
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable;
   *
   *      // 'open' an information row when a row is clicked on
   *      $('#example tbody tr').click( function () {
   *        if ( oTable.fnIsOpen(this) ) {
   *          oTable.fnClose( this );
   *        } else {
   *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
   *        }
   *      } );
   *
   *      oTable = $('#example').dataTable();
   *    } );
   */
		this.fnOpen = function (nTr, mHtml, sClass) {
			return this.api(true).row(nTr).child(mHtml, sClass).show().child()[0];
		};

		/**
   * Change the pagination - provides the internal logic for pagination in a simple API
   * function. With this function you can have a DataTables table go to the next,
   * previous, first or last pages.
   *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
   *    or page number to jump to (integer), note that page 0 is the first page.
   *  @param {bool} [bRedraw=true] Redraw the table or not
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *      oTable.fnPageChange( 'next' );
   *    } );
   */
		this.fnPageChange = function (mAction, bRedraw) {
			var api = this.api(true).page(mAction);

			if (bRedraw === undefined || bRedraw) {
				api.draw(false);
			}
		};

		/**
   * Show a particular column
   *  @param {int} iCol The column whose display should be changed
   *  @param {bool} bShow Show (true) or hide (false) the column
   *  @param {bool} [bRedraw=true] Redraw the table or not
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Hide the second column after initialisation
   *      oTable.fnSetColumnVis( 1, false );
   *    } );
   */
		this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
			var api = this.api(true).column(iCol).visible(bShow);

			if (bRedraw === undefined || bRedraw) {
				api.columns.adjust().draw();
			}
		};

		/**
   * Get the settings for a particular table for external manipulation
   *  @returns {object} DataTables settings object. See
   *    {@link DataTable.models.oSettings}
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *      var oSettings = oTable.fnSettings();
   *
   *      // Show an example parameter from the settings
   *      alert( oSettings._iDisplayStart );
   *    } );
   */
		this.fnSettings = function () {
			return _fnSettingsFromNode(this[_ext.iApiIndex]);
		};

		/**
   * Sort the table by a particular column
   *  @param {int} iCol the data index to sort on. Note that this will not match the
   *    'display index' if you have hidden data entries
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Sort immediately with columns 0 and 1
   *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
   *    } );
   */
		this.fnSort = function (aaSort) {
			this.api(true).order(aaSort).draw();
		};

		/**
   * Attach a sort listener to an element for a given column
   *  @param {node} nNode the element to attach the sort listener to
   *  @param {int} iColumn the column that a click on this node will sort on
   *  @param {function} [fnCallback] callback function when sort is run
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *
   *      // Sort on column 1, when 'sorter' is clicked on
   *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
   *    } );
   */
		this.fnSortListener = function (nNode, iColumn, fnCallback) {
			this.api(true).order.listener(nNode, iColumn, fnCallback);
		};

		/**
   * Update a table cell or row - this method will accept either a single value to
   * update the cell with, an array of values with one element for each column or
   * an object in the same format as the original data source. The function is
   * self-referencing in order to make the multi column updates easier.
   *  @param {object|array|string} mData Data to update the cell/row with
   *  @param {node|int} mRow TR element you want to update or the aoData index
   *  @param {int} [iColumn] The column to update, give as null or undefined to
   *    update a whole row.
   *  @param {bool} [bRedraw=true] Redraw the table or not
   *  @param {bool} [bAction=true] Perform pre-draw actions or not
   *  @returns {int} 0 on success, 1 on error
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
   *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
   *    } );
   */
		this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
			var api = this.api(true);

			if (iColumn === undefined || iColumn === null) {
				api.row(mRow).data(mData);
			} else {
				api.cell(mRow, iColumn).data(mData);
			}

			if (bAction === undefined || bAction) {
				api.columns.adjust();
			}

			if (bRedraw === undefined || bRedraw) {
				api.draw();
			}
			return 0;
		};

		/**
   * Provide a common method for plug-ins to check the version of DataTables being used, in order
   * to ensure compatibility.
   *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
   *    formats "X" and "X.Y" are also acceptable.
   *  @returns {boolean} true if this version of DataTables is greater or equal to the required
   *    version, or false if this version of DataTales is not suitable
   *  @method
   *  @dtopt API
   *  @deprecated Since v1.10
   *
   *  @example
   *    $(document).ready(function() {
   *      var oTable = $('#example').dataTable();
   *      alert( oTable.fnVersionCheck( '1.9.0' ) );
   *    } );
   */
		this.fnVersionCheck = _ext.fnVersionCheck;

		var _that = this;
		var emptyInit = options === undefined;
		var len = this.length;

		if (emptyInit) {
			options = {};
		}

		this.oApi = this.internal = _ext.internal;

		// Extend with old style plug-in API methods
		for (var fn in DataTable.ext.internal) {
			if (fn) {
				this[fn] = _fnExternApiFunc(fn);
			}
		}

		this.each(function () {
			// For each initialisation we want to give it a clean initialisation
			// object that can be bashed around
			var o = {};
			var oInit = len > 1 ? // optimisation for single table case
			_fnExtend(o, options, true) : options;

			/*global oInit,_that,emptyInit*/
			var i = 0,
			    iLen,
			    j,
			    jLen,
			    k,
			    kLen;
			var sId = this.getAttribute('id');
			var bInitHandedOff = false;
			var defaults = DataTable.defaults;
			var $this = $(this);

			/* Sanity check */
			if (this.nodeName.toLowerCase() != 'table') {
				_fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);
				return;
			}

			/* Backwards compatibility for the defaults */
			_fnCompatOpts(defaults);
			_fnCompatCols(defaults.column);

			/* Convert the camel-case defaults to Hungarian */
			_fnCamelToHungarian(defaults, defaults, true);
			_fnCamelToHungarian(defaults.column, defaults.column, true);

			/* Setting up the initialisation object */
			_fnCamelToHungarian(defaults, $.extend(oInit, $this.data()));

			/* Check to see if we are re-initialising a table */
			var allSettings = DataTable.settings;
			for (i = 0, iLen = allSettings.length; i < iLen; i++) {
				var s = allSettings[i];

				/* Base check on table node */
				if (s.nTable == this || s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
					var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
					var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

					if (emptyInit || bRetrieve) {
						return s.oInstance;
					} else if (bDestroy) {
						s.oInstance.fnDestroy();
						break;
					} else {
						_fnLog(s, 0, 'Cannot reinitialise DataTable', 3);
						return;
					}
				}

				/* If the element we are initialising has the same ID as a table which was previously
     * initialised, but the table nodes don't match (from before) then we destroy the old
     * instance by simply deleting it. This is under the assumption that the table has been
     * destroyed by other methods. Anyone using non-id selectors will need to do this manually
     */
				if (s.sTableId == this.id) {
					allSettings.splice(i, 1);
					break;
				}
			}

			/* Ensure the table has an ID - required for accessibility */
			if (sId === null || sId === "") {
				sId = "DataTables_Table_" + DataTable.ext._unique++;
				this.id = sId;
			}

			/* Create the settings object for this table and set some of the default parameters */
			var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
				"sDestroyWidth": $this[0].style.width,
				"sInstance": sId,
				"sTableId": sId
			});
			oSettings.nTable = this;
			oSettings.oApi = _that.internal;
			oSettings.oInit = oInit;

			allSettings.push(oSettings);

			// Need to add the instance after the instance after the settings object has been added
			// to the settings array, so we can self reference the table instance if more than one
			oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();

			// Backwards compatibility, before we apply all the defaults
			_fnCompatOpts(oInit);

			if (oInit.oLanguage) {
				_fnLanguageCompat(oInit.oLanguage);
			}

			// If the length menu is given, but the init display length is not, use the length menu
			if (oInit.aLengthMenu && !oInit.iDisplayLength) {
				oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
			}

			// Apply the defaults and init options to make a single init object will all
			// options defined from defaults and instance options.
			oInit = _fnExtend($.extend(true, {}, defaults), oInit);

			// Map the initialisation options onto the settings object
			_fnMap(oSettings.oFeatures, oInit, ["bPaginate", "bLengthChange", "bFilter", "bSort", "bSortMulti", "bInfo", "bProcessing", "bAutoWidth", "bSortClasses", "bServerSide", "bDeferRender"]);
			_fnMap(oSettings, oInit, ["asStripeClasses", "ajax", "fnServerData", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "sAjaxSource", "sAjaxDataProp", "iStateDuration", "sDom", "bSortCellsTop", "iTabIndex", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", "searchDelay", "rowId", ["iCookieDuration", "iStateDuration"], // backwards compat
			["oSearch", "oPreviousSearch"], ["aoSearchCols", "aoPreSearchCols"], ["iDisplayLength", "_iDisplayLength"], ["bJQueryUI", "bJUI"]]);
			_fnMap(oSettings.oScroll, oInit, [["sScrollX", "sX"], ["sScrollXInner", "sXInner"], ["sScrollY", "sY"], ["bScrollCollapse", "bCollapse"]]);
			_fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");

			/* Callback functions which are array driven */
			_fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');
			_fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');
			_fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');
			_fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');
			_fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');
			_fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');
			_fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');
			_fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');
			_fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');
			_fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');
			_fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

			oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);

			/* Browser support detection */
			_fnBrowserDetect(oSettings);

			var oClasses = oSettings.oClasses;

			// @todo Remove in 1.11
			if (oInit.bJQueryUI) {
				/* Use the JUI classes object for display. You could clone the oStdClasses object if
     * you want to have multiple tables with multiple independent classes
     */
				$.extend(oClasses, DataTable.ext.oJUIClasses, oInit.oClasses);

				if (oInit.sDom === defaults.sDom && defaults.sDom === "lfrtip") {
					/* Set the DOM to use a layout suitable for jQuery UI's theming */
					oSettings.sDom = '<"H"lfr>t<"F"ip>';
				}

				if (!oSettings.renderer) {
					oSettings.renderer = 'jqueryui';
				} else if ($.isPlainObject(oSettings.renderer) && !oSettings.renderer.header) {
					oSettings.renderer.header = 'jqueryui';
				}
			} else {
				$.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
			}
			$this.addClass(oClasses.sTable);

			if (oSettings.iInitDisplayStart === undefined) {
				/* Display start point, taking into account the save saving */
				oSettings.iInitDisplayStart = oInit.iDisplayStart;
				oSettings._iDisplayStart = oInit.iDisplayStart;
			}

			if (oInit.iDeferLoading !== null) {
				oSettings.bDeferLoading = true;
				var tmp = $.isArray(oInit.iDeferLoading);
				oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
				oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
			}

			/* Language definitions */
			var oLanguage = oSettings.oLanguage;
			$.extend(true, oLanguage, oInit.oLanguage);

			if (oLanguage.sUrl) {
				/* Get the language definitions from a file - because this Ajax call makes the language
     * get async to the remainder of this function we use bInitHandedOff to indicate that
     * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
     */
				$.ajax({
					dataType: 'json',
					url: oLanguage.sUrl,
					success: function success(json) {
						_fnLanguageCompat(json);
						_fnCamelToHungarian(defaults.oLanguage, json);
						$.extend(true, oLanguage, json);
						_fnInitialise(oSettings);
					},
					error: function error() {
						// Error occurred loading language file, continue on as best we can
						_fnInitialise(oSettings);
					}
				});
				bInitHandedOff = true;
			}

			/*
    * Stripes
    */
			if (oInit.asStripeClasses === null) {
				oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven];
			}

			/* Remove row stripe classes if they are already on the table row */
			var stripeClasses = oSettings.asStripeClasses;
			var rowOne = $this.children('tbody').find('tr').eq(0);
			if ($.inArray(true, $.map(stripeClasses, function (el, i) {
				return rowOne.hasClass(el);
			})) !== -1) {
				$('tbody tr', this).removeClass(stripeClasses.join(' '));
				oSettings.asDestroyStripes = stripeClasses.slice();
			}

			/*
    * Columns
    * See if we should load columns automatically or use defined ones
    */
			var anThs = [];
			var aoColumnsInit;
			var nThead = this.getElementsByTagName('thead');
			if (nThead.length !== 0) {
				_fnDetectHeader(oSettings.aoHeader, nThead[0]);
				anThs = _fnGetUniqueThs(oSettings);
			}

			/* If not given a column array, generate one with nulls */
			if (oInit.aoColumns === null) {
				aoColumnsInit = [];
				for (i = 0, iLen = anThs.length; i < iLen; i++) {
					aoColumnsInit.push(null);
				}
			} else {
				aoColumnsInit = oInit.aoColumns;
			}

			/* Add the columns */
			for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
				_fnAddColumn(oSettings, anThs ? anThs[i] : null);
			}

			/* Apply the column definitions */
			_fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
				_fnColumnOptions(oSettings, iCol, oDef);
			});

			/* HTML5 attribute detection - build an mData object automatically if the
    * attributes are found
    */
			if (rowOne.length) {
				var a = function a(cell, name) {
					return cell.getAttribute('data-' + name) !== null ? name : null;
				};

				$(rowOne[0]).children('th, td').each(function (i, cell) {
					var col = oSettings.aoColumns[i];

					if (col.mData === i) {
						var sort = a(cell, 'sort') || a(cell, 'order');
						var filter = a(cell, 'filter') || a(cell, 'search');

						if (sort !== null || filter !== null) {
							col.mData = {
								_: i + '.display',
								sort: sort !== null ? i + '.@data-' + sort : undefined,
								type: sort !== null ? i + '.@data-' + sort : undefined,
								filter: filter !== null ? i + '.@data-' + filter : undefined
							};

							_fnColumnOptions(oSettings, i);
						}
					}
				});
			}

			var features = oSettings.oFeatures;
			var loadedInit = function loadedInit() {
				/*
     * Sorting
     * @todo For modularisation (1.11) this needs to do into a sort start up handler
     */

				// If aaSorting is not defined, then we use the first indicator in asSorting
				// in case that has been altered, so the default sort reflects that option
				if (oInit.aaSorting === undefined) {
					var sorting = oSettings.aaSorting;
					for (i = 0, iLen = sorting.length; i < iLen; i++) {
						sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
					}
				}

				/* Do a first pass on the sorting classes (allows any size changes to be taken into
     * account, and also will apply sorting disabled classes if disabled
     */
				_fnSortingClasses(oSettings);

				if (features.bSort) {
					_fnCallbackReg(oSettings, 'aoDrawCallback', function () {
						if (oSettings.bSorted) {
							var aSort = _fnSortFlatten(oSettings);
							var sortedColumns = {};

							$.each(aSort, function (i, val) {
								sortedColumns[val.src] = val.dir;
							});

							_fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);
							_fnSortAria(oSettings);
						}
					});
				}

				_fnCallbackReg(oSettings, 'aoDrawCallback', function () {
					if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
						_fnSortingClasses(oSettings);
					}
				}, 'sc');

				/*
     * Final init
     * Cache the header, body and footer as required, creating them if needed
     */

				// Work around for Webkit bug 83867 - store the caption-side before removing from doc
				var captions = $this.children('caption').each(function () {
					this._captionSide = $(this).css('caption-side');
				});

				var thead = $this.children('thead');
				if (thead.length === 0) {
					thead = $('<thead/>').appendTo($this);
				}
				oSettings.nTHead = thead[0];

				var tbody = $this.children('tbody');
				if (tbody.length === 0) {
					tbody = $('<tbody/>').appendTo($this);
				}
				oSettings.nTBody = tbody[0];

				var tfoot = $this.children('tfoot');
				if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
					// If we are a scrolling table, and no footer has been given, then we need to create
					// a tfoot element for the caption element to be appended to
					tfoot = $('<tfoot/>').appendTo($this);
				}

				if (tfoot.length === 0 || tfoot.children().length === 0) {
					$this.addClass(oClasses.sNoFooter);
				} else if (tfoot.length > 0) {
					oSettings.nTFoot = tfoot[0];
					_fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
				}

				/* Check if there is data passing into the constructor */
				if (oInit.aaData) {
					for (i = 0; i < oInit.aaData.length; i++) {
						_fnAddData(oSettings, oInit.aaData[i]);
					}
				} else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
					/* Grab the data from the page - only do this when deferred loading or no Ajax
      * source since there is no point in reading the DOM data if we are then going
      * to replace it with Ajax data
      */
					_fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
				}

				/* Copy the data index array */
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

				/* Initialisation complete - table can be drawn */
				oSettings.bInitialised = true;

				/* Check if we need to initialise the table (it might not have been handed off to the
     * language processor)
     */
				if (bInitHandedOff === false) {
					_fnInitialise(oSettings);
				}
			};

			/* Must be done after everything which can be overridden by the state saving! */
			if (oInit.bStateSave) {
				features.bStateSave = true;
				_fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');
				_fnLoadState(oSettings, oInit, loadedInit);
			} else {
				loadedInit();
			}
		});
		_that = null;
		return this;
	};

	/*
  * It is useful to have variables which are scoped locally so only the
  * DataTables functions can access them and they don't leak into global space.
  * At the same time these functions are often useful over multiple files in the
  * core and API, so we list, or at least document, all variables which are used
  * by DataTables as private variables here. This also ensures that there is no
  * clashing of variable names and that they can easily referenced for reuse.
  */

	// Defined else where
	//  _selector_run
	//  _selector_opts
	//  _selector_first
	//  _selector_row_indexes

	var _ext; // DataTable.ext
	var _Api2; // DataTable.Api
	var _api_register; // DataTable.Api.register
	var _api_registerPlural; // DataTable.Api.registerPlural

	var _re_dic = {};
	var _re_new_lines = /[\r\n]/g;
	var _re_html = /<.*?>/g;

	// This is not strict ISO8601 - Date.parse() is quite lax, although
	// implementations differ between browsers.
	var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/;

	// Escape regular expression special characters
	var _re_escape_regex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'].join('|\\') + ')', 'g');

	// http://en.wikipedia.org/wiki/Foreign_exchange_market
	// - \u20BD - Russian ruble.
	// - \u20a9 - South Korean Won
	// - \u20BA - Turkish Lira
	// - \u20B9 - Indian Rupee
	// - R - Brazil (R$) and South Africa
	// - fr - Swiss Franc
	// - kr - Swedish krona, Norwegian krone and Danish krone
	// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
	//   standards as thousands separators.
	var _re_formatted_numeric = /[',$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;

	var _empty = function _empty(d) {
		return !d || d === true || d === '-' ? true : false;
	};

	var _intVal = function _intVal(s) {
		var integer = parseInt(s, 10);
		return !isNaN(integer) && isFinite(s) ? integer : null;
	};

	// Convert from a formatted number with characters other than `.` as the
	// decimal place, to a Javascript number
	var _numToDecimal = function _numToDecimal(num, decimalPoint) {
		// Cache created regular expressions for speed as this function is called often
		if (!_re_dic[decimalPoint]) {
			_re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
		}
		return typeof num === 'string' && decimalPoint !== '.' ? num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') : num;
	};

	var _isNumber = function _isNumber(d, decimalPoint, formatted) {
		var strType = typeof d === 'string';

		// If empty return immediately so there must be a number if it is a
		// formatted string (this stops the string "k", or "kr", etc being detected
		// as a formatted number for currency
		if (_empty(d)) {
			return true;
		}

		if (decimalPoint && strType) {
			d = _numToDecimal(d, decimalPoint);
		}

		if (formatted && strType) {
			d = d.replace(_re_formatted_numeric, '');
		}

		return !isNaN(parseFloat(d)) && isFinite(d);
	};

	// A string without HTML in it can be considered to be HTML still
	var _isHtml = function _isHtml(d) {
		return _empty(d) || typeof d === 'string';
	};

	var _htmlNumeric = function _htmlNumeric(d, decimalPoint, formatted) {
		if (_empty(d)) {
			return true;
		}

		var html = _isHtml(d);
		return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null;
	};

	var _pluck = function _pluck(a, prop, prop2) {
		var out = [];
		var i = 0,
		    ien = a.length;

		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if (prop2 !== undefined) {
			for (; i < ien; i++) {
				if (a[i] && a[i][prop]) {
					out.push(a[i][prop][prop2]);
				}
			}
		} else {
			for (; i < ien; i++) {
				if (a[i]) {
					out.push(a[i][prop]);
				}
			}
		}

		return out;
	};

	// Basically the same as _pluck, but rather than looping over `a` we use `order`
	// as the indexes to pick from `a`
	var _pluck_order = function _pluck_order(a, order, prop, prop2) {
		var out = [];
		var i = 0,
		    ien = order.length;

		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if (prop2 !== undefined) {
			for (; i < ien; i++) {
				if (a[order[i]][prop]) {
					out.push(a[order[i]][prop][prop2]);
				}
			}
		} else {
			for (; i < ien; i++) {
				out.push(a[order[i]][prop]);
			}
		}

		return out;
	};

	var _range = function _range(len, start) {
		var out = [];
		var end;

		if (start === undefined) {
			start = 0;
			end = len;
		} else {
			end = start;
			start = len;
		}

		for (var i = start; i < end; i++) {
			out.push(i);
		}

		return out;
	};

	var _removeEmpty = function _removeEmpty(a) {
		var out = [];

		for (var i = 0, ien = a.length; i < ien; i++) {
			if (a[i]) {
				// careful - will remove all falsy values!
				out.push(a[i]);
			}
		}

		return out;
	};

	var _stripHtml = function _stripHtml(d) {
		return d.replace(_re_html, '');
	};

	/**
  * Determine if all values in the array are unique. This means we can short
  * cut the _unique method at the cost of a single loop. A sorted array is used
  * to easily check the values.
  *
  * @param  {array} src Source array
  * @return {boolean} true if all unique, false otherwise
  * @ignore
  */
	var _areAllUnique = function _areAllUnique(src) {
		if (src.length < 2) {
			return true;
		}

		var sorted = src.slice().sort();
		var last = sorted[0];

		for (var i = 1, ien = sorted.length; i < ien; i++) {
			if (sorted[i] === last) {
				return false;
			}

			last = sorted[i];
		}

		return true;
	};

	/**
  * Find the unique elements in a source array.
  *
  * @param  {array} src Source array
  * @return {array} Array of unique items
  * @ignore
  */
	var _unique = function _unique(src) {
		if (_areAllUnique(src)) {
			return src.slice();
		}

		// A faster unique method is to use object keys to identify used values,
		// but this doesn't work with arrays or objects, which we must also
		// consider. See jsperf.com/compare-array-unique-versions/4 for more
		// information.
		var out = [],
		    val,
		    i,
		    ien = src.length,
		    j,
		    k = 0;

		again: for (i = 0; i < ien; i++) {
			val = src[i];

			for (j = 0; j < k; j++) {
				if (out[j] === val) {
					continue again;
				}
			}

			out.push(val);
			k++;
		}

		return out;
	};

	/**
  * DataTables utility methods
  * 
  * This namespace provides helper methods that DataTables uses internally to
  * create a DataTable, but which are not exclusively used only for DataTables.
  * These methods can be used by extension authors to save the duplication of
  * code.
  *
  *  @namespace
  */
	DataTable.util = {
		/**
   * Throttle the calls to a function. Arguments and context are maintained
   * for the throttled function.
   *
   * @param {function} fn Function to be called
   * @param {integer} freq Call frequency in mS
   * @return {function} Wrapped function
   */
		throttle: function throttle(fn, freq) {
			var frequency = freq !== undefined ? freq : 200,
			    last,
			    timer;

			return function () {
				var that = this,
				    now = +new Date(),
				    args = arguments;

				if (last && now < last + frequency) {
					clearTimeout(timer);

					timer = setTimeout(function () {
						last = undefined;
						fn.apply(that, args);
					}, frequency);
				} else {
					last = now;
					fn.apply(that, args);
				}
			};
		},

		/**
   * Escape a string such that it can be used in a regular expression
   *
   *  @param {string} val string to escape
   *  @returns {string} escaped string
   */
		escapeRegex: function escapeRegex(val) {
			return val.replace(_re_escape_regex, '\\$1');
		}
	};

	/**
  * Create a mapping object that allows camel case parameters to be looked up
  * for their Hungarian counterparts. The mapping is stored in a private
  * parameter called `_hungarianMap` which can be accessed on the source object.
  *  @param {object} o
  *  @memberof DataTable#oApi
  */
	function _fnHungarianMap(o) {
		var hungarian = 'a aa ai ao as b fn i m o s ',
		    match,
		    newKey,
		    map = {};

		$.each(o, function (key, val) {
			match = key.match(/^([^A-Z]+?)([A-Z])/);

			if (match && hungarian.indexOf(match[1] + ' ') !== -1) {
				newKey = key.replace(match[0], match[2].toLowerCase());
				map[newKey] = key;

				if (match[1] === 'o') {
					_fnHungarianMap(o[key]);
				}
			}
		});

		o._hungarianMap = map;
	}

	/**
  * Convert from camel case parameters to Hungarian, based on a Hungarian map
  * created by _fnHungarianMap.
  *  @param {object} src The model object which holds all parameters that can be
  *    mapped.
  *  @param {object} user The object to convert from camel case to Hungarian.
  *  @param {boolean} force When set to `true`, properties which already have a
  *    Hungarian value in the `user` object will be overwritten. Otherwise they
  *    won't be.
  *  @memberof DataTable#oApi
  */
	function _fnCamelToHungarian(src, user, force) {
		if (!src._hungarianMap) {
			_fnHungarianMap(src);
		}

		var hungarianKey;

		$.each(user, function (key, val) {
			hungarianKey = src._hungarianMap[key];

			if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
				// For objects, we need to buzz down into the object to copy parameters
				if (hungarianKey.charAt(0) === 'o') {
					// Copy the camelCase options over to the hungarian
					if (!user[hungarianKey]) {
						user[hungarianKey] = {};
					}
					$.extend(true, user[hungarianKey], user[key]);

					_fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
				} else {
					user[hungarianKey] = user[key];
				}
			}
		});
	}

	/**
  * Language compatibility - when certain options are given, and others aren't, we
  * need to duplicate the values over, in order to provide backwards compatibility
  * with older language files.
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnLanguageCompat(lang) {
		var defaults = DataTable.defaults.oLanguage;
		var zeroRecords = lang.sZeroRecords;

		/* Backwards compatibility - if there is no sEmptyTable given, then use the same as
   * sZeroRecords - assuming that is given.
   */
		if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === "No data available in table") {
			_fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
		}

		/* Likewise with loading records */
		if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === "Loading...") {
			_fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
		}

		// Old parameter name of the thousands separator mapped onto the new
		if (lang.sInfoThousands) {
			lang.sThousands = lang.sInfoThousands;
		}

		var decimal = lang.sDecimal;
		if (decimal) {
			_addNumericSort(decimal);
		}
	}

	/**
  * Map one parameter onto another
  *  @param {object} o Object to map
  *  @param {*} knew The new parameter name
  *  @param {*} old The old parameter name
  */
	var _fnCompatMap = function _fnCompatMap(o, knew, old) {
		if (o[knew] !== undefined) {
			o[old] = o[knew];
		}
	};

	/**
  * Provide backwards compatibility for the main DT options. Note that the new
  * options are mapped onto the old parameters, so this is an external interface
  * change only.
  *  @param {object} init Object to map
  */
	function _fnCompatOpts(init) {
		_fnCompatMap(init, 'ordering', 'bSort');
		_fnCompatMap(init, 'orderMulti', 'bSortMulti');
		_fnCompatMap(init, 'orderClasses', 'bSortClasses');
		_fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');
		_fnCompatMap(init, 'order', 'aaSorting');
		_fnCompatMap(init, 'orderFixed', 'aaSortingFixed');
		_fnCompatMap(init, 'paging', 'bPaginate');
		_fnCompatMap(init, 'pagingType', 'sPaginationType');
		_fnCompatMap(init, 'pageLength', 'iDisplayLength');
		_fnCompatMap(init, 'searching', 'bFilter');

		// Boolean initialisation of x-scrolling
		if (typeof init.sScrollX === 'boolean') {
			init.sScrollX = init.sScrollX ? '100%' : '';
		}
		if (typeof init.scrollX === 'boolean') {
			init.scrollX = init.scrollX ? '100%' : '';
		}

		// Column search objects are in an array, so it needs to be converted
		// element by element
		var searchCols = init.aoSearchCols;

		if (searchCols) {
			for (var i = 0, ien = searchCols.length; i < ien; i++) {
				if (searchCols[i]) {
					_fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
				}
			}
		}
	}

	/**
  * Provide backwards compatibility for column options. Note that the new options
  * are mapped onto the old parameters, so this is an external interface change
  * only.
  *  @param {object} init Object to map
  */
	function _fnCompatCols(init) {
		_fnCompatMap(init, 'orderable', 'bSortable');
		_fnCompatMap(init, 'orderData', 'aDataSort');
		_fnCompatMap(init, 'orderSequence', 'asSorting');
		_fnCompatMap(init, 'orderDataType', 'sortDataType');

		// orderData can be given as an integer
		var dataSort = init.aDataSort;
		if (typeof dataSort === 'number' && !$.isArray(dataSort)) {
			init.aDataSort = [dataSort];
		}
	}

	/**
  * Browser feature detection for capabilities, quirks
  *  @param {object} settings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnBrowserDetect(settings) {
		// We don't need to do this every time DataTables is constructed, the values
		// calculated are specific to the browser and OS configuration which we
		// don't expect to change between initialisations
		if (!DataTable.__browser) {
			var browser = {};
			DataTable.__browser = browser;

			// Scrolling feature / quirks detection
			var n = $('<div/>').css({
				position: 'fixed',
				top: 0,
				left: $(window).scrollLeft() * -1, // allow for scrolling
				height: 1,
				width: 1,
				overflow: 'hidden'
			}).append($('<div/>').css({
				position: 'absolute',
				top: 1,
				left: 1,
				width: 100,
				overflow: 'scroll'
			}).append($('<div/>').css({
				width: '100%',
				height: 10
			}))).appendTo('body');

			var outer = n.children();
			var inner = outer.children();

			// Numbers below, in order, are:
			// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
			//
			// IE6 XP:                           100 100 100  83
			// IE7 Vista:                        100 100 100  83
			// IE 8+ Windows:                     83  83 100  83
			// Evergreen Windows:                 83  83 100  83
			// Evergreen Mac with scrollbars:     85  85 100  85
			// Evergreen Mac without scrollbars: 100 100 100 100

			// Get scrollbar width
			browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;

			// IE6/7 will oversize a width 100% element inside a scrolling element, to
			// include the width of the scrollbar, while other browsers ensure the inner
			// element is contained without forcing scrolling
			browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;

			// In rtl text layout, some browsers (most, but not all) will place the
			// scrollbar on the left, rather than the right.
			browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;

			// IE8- don't provide height and width for getBoundingClientRect
			browser.bBounding = n[0].getBoundingClientRect().width ? true : false;

			n.remove();
		}

		$.extend(settings.oBrowser, DataTable.__browser);
		settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
	}

	/**
  * Array.prototype reduce[Right] method, used for browsers which don't support
  * JS 1.6. Done this way to reduce code size, since we iterate either way
  *  @param {object} settings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnReduce(that, fn, init, start, end, inc) {
		var i = start,
		    value,
		    isSet = false;

		if (init !== undefined) {
			value = init;
			isSet = true;
		}

		while (i !== end) {
			if (!that.hasOwnProperty(i)) {
				continue;
			}

			value = isSet ? fn(value, that[i], i, that) : that[i];

			isSet = true;
			i += inc;
		}

		return value;
	}

	/**
  * Add a column to the list used for the table with default values
  *  @param {object} oSettings dataTables settings object
  *  @param {node} nTh The th element for this column
  *  @memberof DataTable#oApi
  */
	function _fnAddColumn(oSettings, nTh) {
		// Add column to aoColumns array
		var oDefaults = DataTable.defaults.column;
		var iCol = oSettings.aoColumns.length;
		var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
			"nTh": nTh ? nTh : document.createElement('th'),
			"sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
			"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
			"mData": oDefaults.mData ? oDefaults.mData : iCol,
			idx: iCol
		});
		oSettings.aoColumns.push(oCol);

		// Add search object for column specific search. Note that the `searchCols[ iCol ]`
		// passed into extend can be undefined. This allows the user to give a default
		// with only some of the parameters defined, and also not give a default
		var searchCols = oSettings.aoPreSearchCols;
		searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]);

		// Use the default column options function to initialise classes etc
		_fnColumnOptions(oSettings, iCol, $(nTh).data());
	}

	/**
  * Apply options for a column
  *  @param {object} oSettings dataTables settings object
  *  @param {int} iCol column index to consider
  *  @param {object} oOptions object with sType, bVisible and bSearchable etc
  *  @memberof DataTable#oApi
  */
	function _fnColumnOptions(oSettings, iCol, oOptions) {
		var oCol = oSettings.aoColumns[iCol];
		var oClasses = oSettings.oClasses;
		var th = $(oCol.nTh);

		// Try to get width information from the DOM. We can't get it from CSS
		// as we'd need to parse the CSS stylesheet. `width` option can override
		if (!oCol.sWidthOrig) {
			// Width attribute
			oCol.sWidthOrig = th.attr('width') || null;

			// Style attribute
			var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
			if (t) {
				oCol.sWidthOrig = t[1];
			}
		}

		/* User specified column options */
		if (oOptions !== undefined && oOptions !== null) {
			// Backwards compatibility
			_fnCompatCols(oOptions);

			// Map camel case parameters to their Hungarian counterparts
			_fnCamelToHungarian(DataTable.defaults.column, oOptions);

			/* Backwards compatibility for mDataProp */
			if (oOptions.mDataProp !== undefined && !oOptions.mData) {
				oOptions.mData = oOptions.mDataProp;
			}

			if (oOptions.sType) {
				oCol._sManualType = oOptions.sType;
			}

			// `class` is a reserved word in Javascript, so we need to provide
			// the ability to use a valid name for the camel case input
			if (oOptions.className && !oOptions.sClass) {
				oOptions.sClass = oOptions.className;
			}

			$.extend(oCol, oOptions);
			_fnMap(oCol, oOptions, "sWidth", "sWidthOrig");

			/* iDataSort to be applied (backwards compatibility), but aDataSort will take
    * priority if defined
    */
			if (oOptions.iDataSort !== undefined) {
				oCol.aDataSort = [oOptions.iDataSort];
			}
			_fnMap(oCol, oOptions, "aDataSort");
		}

		/* Cache the data get and set functions for speed */
		var mDataSrc = oCol.mData;
		var mData = _fnGetObjectDataFn(mDataSrc);
		var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;

		var attrTest = function attrTest(src) {
			return typeof src === 'string' && src.indexOf('@') !== -1;
		};
		oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
		oCol._setter = null;

		oCol.fnGetData = function (rowData, type, meta) {
			var innerData = mData(rowData, type, undefined, meta);

			return mRender && type ? mRender(innerData, type, rowData, meta) : innerData;
		};
		oCol.fnSetData = function (rowData, val, meta) {
			return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
		};

		// Indicate if DataTables should read DOM data as an object or array
		// Used in _fnGetRowElements
		if (typeof mDataSrc !== 'number') {
			oSettings._rowReadObject = true;
		}

		/* Feature sorting overrides column specific when off */
		if (!oSettings.oFeatures.bSort) {
			oCol.bSortable = false;
			th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called
		}

		/* Check that the class assignment is correct for sorting */
		var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
		var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
		if (!oCol.bSortable || !bAsc && !bDesc) {
			oCol.sSortingClass = oClasses.sSortableNone;
			oCol.sSortingClassJUI = "";
		} else if (bAsc && !bDesc) {
			oCol.sSortingClass = oClasses.sSortableAsc;
			oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
		} else if (!bAsc && bDesc) {
			oCol.sSortingClass = oClasses.sSortableDesc;
			oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
		} else {
			oCol.sSortingClass = oClasses.sSortable;
			oCol.sSortingClassJUI = oClasses.sSortJUI;
		}
	}

	/**
  * Adjust the table column widths for new data. Note: you would probably want to
  * do a redraw after calling this function!
  *  @param {object} settings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnAdjustColumnSizing(settings) {
		/* Not interested in doing column width calculation if auto-width is disabled */
		if (settings.oFeatures.bAutoWidth !== false) {
			var columns = settings.aoColumns;

			_fnCalculateColumnWidths(settings);
			for (var i = 0, iLen = columns.length; i < iLen; i++) {
				columns[i].nTh.style.width = columns[i].sWidth;
			}
		}

		var scroll = settings.oScroll;
		if (scroll.sY !== '' || scroll.sX !== '') {
			_fnScrollDraw(settings);
		}

		_fnCallbackFire(settings, null, 'column-sizing', [settings]);
	}

	/**
  * Covert the index of a visible column to the index in the data array (take account
  * of hidden columns)
  *  @param {object} oSettings dataTables settings object
  *  @param {int} iMatch Visible column index to lookup
  *  @returns {int} i the data index
  *  @memberof DataTable#oApi
  */
	function _fnVisibleToColumnIndex(oSettings, iMatch) {
		var aiVis = _fnGetColumns(oSettings, 'bVisible');

		return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null;
	}

	/**
  * Covert the index of an index in the data array and convert it to the visible
  *   column index (take account of hidden columns)
  *  @param {int} iMatch Column index to lookup
  *  @param {object} oSettings dataTables settings object
  *  @returns {int} i the data index
  *  @memberof DataTable#oApi
  */
	function _fnColumnIndexToVisible(oSettings, iMatch) {
		var aiVis = _fnGetColumns(oSettings, 'bVisible');
		var iPos = $.inArray(iMatch, aiVis);

		return iPos !== -1 ? iPos : null;
	}

	/**
  * Get the number of visible columns
  *  @param {object} oSettings dataTables settings object
  *  @returns {int} i the number of visible columns
  *  @memberof DataTable#oApi
  */
	function _fnVisbleColumns(oSettings) {
		var vis = 0;

		// No reduce in IE8, use a loop for now
		$.each(oSettings.aoColumns, function (i, col) {
			if (col.bVisible && $(col.nTh).css('display') !== 'none') {
				vis++;
			}
		});

		return vis;
	}

	/**
  * Get an array of column indexes that match a given property
  *  @param {object} oSettings dataTables settings object
  *  @param {string} sParam Parameter in aoColumns to look for - typically
  *    bVisible or bSearchable
  *  @returns {array} Array of indexes with matched properties
  *  @memberof DataTable#oApi
  */
	function _fnGetColumns(oSettings, sParam) {
		var a = [];

		$.map(oSettings.aoColumns, function (val, i) {
			if (val[sParam]) {
				a.push(i);
			}
		});

		return a;
	}

	/**
  * Calculate the 'type' of a column
  *  @param {object} settings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnColumnTypes(settings) {
		var columns = settings.aoColumns;
		var data = settings.aoData;
		var types = DataTable.ext.type.detect;
		var i, ien, j, jen, k, ken;
		var col, cell, detectedType, cache;

		// For each column, spin over the 
		for (i = 0, ien = columns.length; i < ien; i++) {
			col = columns[i];
			cache = [];

			if (!col.sType && col._sManualType) {
				col.sType = col._sManualType;
			} else if (!col.sType) {
				for (j = 0, jen = types.length; j < jen; j++) {
					for (k = 0, ken = data.length; k < ken; k++) {
						// Use a cache array so we only need to get the type data
						// from the formatter once (when using multiple detectors)
						if (cache[k] === undefined) {
							cache[k] = _fnGetCellData(settings, k, i, 'type');
						}

						detectedType = types[j](cache[k], settings);

						// If null, then this type can't apply to this column, so
						// rather than testing all cells, break out. There is an
						// exception for the last type which is `html`. We need to
						// scan all rows since it is possible to mix string and HTML
						// types
						if (!detectedType && j !== types.length - 1) {
							break;
						}

						// Only a single match is needed for html type since it is
						// bottom of the pile and very similar to string
						if (detectedType === 'html') {
							break;
						}
					}

					// Type is valid for all data points in the column - use this
					// type
					if (detectedType) {
						col.sType = detectedType;
						break;
					}
				}

				// Fall back - if no type was detected, always use string
				if (!col.sType) {
					col.sType = 'string';
				}
			}
		}
	}

	/**
  * Take the column definitions and static columns arrays and calculate how
  * they relate to column indexes. The callback function will then apply the
  * definition found for a column to a suitable configuration object.
  *  @param {object} oSettings dataTables settings object
  *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
  *  @param {array} aoCols The aoColumns array that defines columns individually
  *  @param {function} fn Callback function - takes two parameters, the calculated
  *    column index and the definition for that column.
  *  @memberof DataTable#oApi
  */
	function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
		var i, iLen, j, jLen, k, kLen, def;
		var columns = oSettings.aoColumns;

		// Column definitions with aTargets
		if (aoColDefs) {
			/* Loop over the definitions array - loop in reverse so first instance has priority */
			for (i = aoColDefs.length - 1; i >= 0; i--) {
				def = aoColDefs[i];

				/* Each definition can target multiple columns, as it is an array */
				var aTargets = def.targets !== undefined ? def.targets : def.aTargets;

				if (!$.isArray(aTargets)) {
					aTargets = [aTargets];
				}

				for (j = 0, jLen = aTargets.length; j < jLen; j++) {
					if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
						/* Add columns that we don't yet know about */
						while (columns.length <= aTargets[j]) {
							_fnAddColumn(oSettings);
						}

						/* Integer, basic index */
						fn(aTargets[j], def);
					} else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
						/* Negative integer, right to left column counting */
						fn(columns.length + aTargets[j], def);
					} else if (typeof aTargets[j] === 'string') {
						/* Class name matching on TH element */
						for (k = 0, kLen = columns.length; k < kLen; k++) {
							if (aTargets[j] == "_all" || $(columns[k].nTh).hasClass(aTargets[j])) {
								fn(k, def);
							}
						}
					}
				}
			}
		}

		// Statically defined columns array
		if (aoCols) {
			for (i = 0, iLen = aoCols.length; i < iLen; i++) {
				fn(i, aoCols[i]);
			}
		}
	}

	/**
  * Add a data array to the table, creating DOM node etc. This is the parallel to
  * _fnGatherData, but for adding rows from a Javascript source, rather than a
  * DOM source.
  *  @param {object} oSettings dataTables settings object
  *  @param {array} aData data array to be added
  *  @param {node} [nTr] TR element to add to the table - optional. If not given,
  *    DataTables will create a row automatically
  *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
  *    if nTr is.
  *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
  *  @memberof DataTable#oApi
  */
	function _fnAddData(oSettings, aDataIn, nTr, anTds) {
		/* Create the object for storing information about this new row */
		var iRow = oSettings.aoData.length;
		var oData = $.extend(true, {}, DataTable.models.oRow, {
			src: nTr ? 'dom' : 'data',
			idx: iRow
		});

		oData._aData = aDataIn;
		oSettings.aoData.push(oData);

		/* Create the cells */
		var nTd, sThisType;
		var columns = oSettings.aoColumns;

		// Invalidate the column types as the new data needs to be revalidated
		for (var i = 0, iLen = columns.length; i < iLen; i++) {
			columns[i].sType = null;
		}

		/* Add to the display array */
		oSettings.aiDisplayMaster.push(iRow);

		var id = oSettings.rowIdFn(aDataIn);
		if (id !== undefined) {
			oSettings.aIds[id] = oData;
		}

		/* Create the DOM information, or register it if already present */
		if (nTr || !oSettings.oFeatures.bDeferRender) {
			_fnCreateTr(oSettings, iRow, nTr, anTds);
		}

		return iRow;
	}

	/**
  * Add one or more TR elements to the table. Generally we'd expect to
  * use this for reading data from a DOM sourced table, but it could be
  * used for an TR element. Note that if a TR is given, it is used (i.e.
  * it is not cloned).
  *  @param {object} settings dataTables settings object
  *  @param {array|node|jQuery} trs The TR element(s) to add to the table
  *  @returns {array} Array of indexes for the added rows
  *  @memberof DataTable#oApi
  */
	function _fnAddTr(settings, trs) {
		var row;

		// Allow an individual node to be passed in
		if (!(trs instanceof $)) {
			trs = $(trs);
		}

		return trs.map(function (i, el) {
			row = _fnGetRowElements(settings, el);
			return _fnAddData(settings, row.data, el, row.cells);
		});
	}

	/**
  * Take a TR element and convert it to an index in aoData
  *  @param {object} oSettings dataTables settings object
  *  @param {node} n the TR element to find
  *  @returns {int} index if the node is found, null if not
  *  @memberof DataTable#oApi
  */
	function _fnNodeToDataIndex(oSettings, n) {
		return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null;
	}

	/**
  * Take a TD element and convert it into a column data index (not the visible index)
  *  @param {object} oSettings dataTables settings object
  *  @param {int} iRow The row number the TD/TH can be found in
  *  @param {node} n The TD/TH element to find
  *  @returns {int} index if the node is found, -1 if not
  *  @memberof DataTable#oApi
  */
	function _fnNodeToColumnIndex(oSettings, iRow, n) {
		return $.inArray(n, oSettings.aoData[iRow].anCells);
	}

	/**
  * Get the data for a given cell from the internal cache, taking into account data mapping
  *  @param {object} settings dataTables settings object
  *  @param {int} rowIdx aoData row id
  *  @param {int} colIdx Column index
  *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
  *  @returns {*} Cell data
  *  @memberof DataTable#oApi
  */
	function _fnGetCellData(settings, rowIdx, colIdx, type) {
		var draw = settings.iDraw;
		var col = settings.aoColumns[colIdx];
		var rowData = settings.aoData[rowIdx]._aData;
		var defaultContent = col.sDefaultContent;
		var cellData = col.fnGetData(rowData, type, {
			settings: settings,
			row: rowIdx,
			col: colIdx
		});

		if (cellData === undefined) {
			if (settings.iDrawError != draw && defaultContent === null) {
				_fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == 'function' ? '{function}' : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
				settings.iDrawError = draw;
			}
			return defaultContent;
		}

		// When the data source is null and a specific data type is requested (i.e.
		// not the original data), we can use default column data
		if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined) {
			cellData = defaultContent;
		} else if (typeof cellData === 'function') {
			// If the data source is a function, then we run it and use the return,
			// executing in the scope of the data object (for instances)
			return cellData.call(rowData);
		}

		if (cellData === null && type == 'display') {
			return '';
		}
		return cellData;
	}

	/**
  * Set the value for a specific cell, into the internal data cache
  *  @param {object} settings dataTables settings object
  *  @param {int} rowIdx aoData row id
  *  @param {int} colIdx Column index
  *  @param {*} val Value to set
  *  @memberof DataTable#oApi
  */
	function _fnSetCellData(settings, rowIdx, colIdx, val) {
		var col = settings.aoColumns[colIdx];
		var rowData = settings.aoData[rowIdx]._aData;

		col.fnSetData(rowData, val, {
			settings: settings,
			row: rowIdx,
			col: colIdx
		});
	}

	// Private variable that is used to match action syntax in the data property object
	var __reArray = /\[.*?\]$/;
	var __reFn = /\(\)$/;

	/**
  * Split string on periods, taking into account escaped periods
  * @param  {string} str String to split
  * @return {array} Split string
  */
	function _fnSplitObjNotation(str) {
		return $.map(str.match(/(\\.|[^\.])+/g) || [''], function (s) {
			return s.replace(/\\\./g, '.');
		});
	}

	/**
  * Return a function that can be used to get data from a source object, taking
  * into account the ability to use nested objects as a source
  *  @param {string|int|function} mSource The data source for the object
  *  @returns {function} Data get function
  *  @memberof DataTable#oApi
  */
	function _fnGetObjectDataFn(mSource) {
		if ($.isPlainObject(mSource)) {
			/* Build an object of get functions, and wrap them in a single call */
			var o = {};
			$.each(mSource, function (key, val) {
				if (val) {
					o[key] = _fnGetObjectDataFn(val);
				}
			});

			return function (data, type, row, meta) {
				var t = o[type] || o._;
				return t !== undefined ? t(data, type, row, meta) : data;
			};
		} else if (mSource === null) {
			/* Give an empty string for rendering / sorting etc */
			return function (data) {
				// type, row and meta also passed, but not used
				return data;
			};
		} else if (typeof mSource === 'function') {
			return function (data, type, row, meta) {
				return mSource(data, type, row, meta);
			};
		} else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
			/* If there is a . in the source string then the data source is in a
    * nested object so we loop over the data for each level to get the next
    * level down. On each loop we test for undefined, and if found immediately
    * return. This allows entire objects to be missing and sDefaultContent to
    * be used if defined, rather than throwing an error
    */
			var fetchData = function fetchData(data, type, src) {
				var arrayNotation, funcNotation, out, innerSrc;

				if (src !== "") {
					var a = _fnSplitObjNotation(src);

					for (var i = 0, iLen = a.length; i < iLen; i++) {
						// Check if we are dealing with special notation
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);

						if (arrayNotation) {
							// Array notation
							a[i] = a[i].replace(__reArray, '');

							// Condition allows simply [] to be passed in
							if (a[i] !== "") {
								data = data[a[i]];
							}
							out = [];

							// Get the remainder of the nested object to get
							a.splice(0, i + 1);
							innerSrc = a.join('.');

							// Traverse each entry in the array getting the properties requested
							if ($.isArray(data)) {
								for (var j = 0, jLen = data.length; j < jLen; j++) {
									out.push(fetchData(data[j], type, innerSrc));
								}
							}

							// If a string is given in between the array notation indicators, that
							// is used to join the strings together, otherwise an array is returned
							var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
							data = join === "" ? out : out.join(join);

							// The inner call to fetchData has already traversed through the remainder
							// of the source requested, so we exit from the loop
							break;
						} else if (funcNotation) {
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[a[i]]();
							continue;
						}

						if (data === null || data[a[i]] === undefined) {
							return undefined;
						}
						data = data[a[i]];
					}
				}

				return data;
			};

			return function (data, type) {
				// row and meta also passed, but not used
				return fetchData(data, type, mSource);
			};
		} else {
			/* Array or flat object mapping */
			return function (data, type) {
				// row and meta also passed, but not used
				return data[mSource];
			};
		}
	}

	/**
  * Return a function that can be used to set data from a source object, taking
  * into account the ability to use nested objects as a source
  *  @param {string|int|function} mSource The data source for the object
  *  @returns {function} Data set function
  *  @memberof DataTable#oApi
  */
	function _fnSetObjectDataFn(mSource) {
		if ($.isPlainObject(mSource)) {
			/* Unlike get, only the underscore (global) option is used for for
    * setting data since we don't know the type here. This is why an object
    * option is not documented for `mData` (which is read/write), but it is
    * for `mRender` which is read only.
    */
			return _fnSetObjectDataFn(mSource._);
		} else if (mSource === null) {
			/* Nothing to do when the data source is null */
			return function () {};
		} else if (typeof mSource === 'function') {
			return function (data, val, meta) {
				mSource(data, 'set', val, meta);
			};
		} else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
			/* Like the get, we need to get data from a nested object */
			var setData = function setData(data, val, src) {
				var a = _fnSplitObjNotation(src),
				    b;
				var aLast = a[a.length - 1];
				var arrayNotation, funcNotation, o, innerSrc;

				for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
					// Check if we are dealing with an array notation request
					arrayNotation = a[i].match(__reArray);
					funcNotation = a[i].match(__reFn);

					if (arrayNotation) {
						a[i] = a[i].replace(__reArray, '');
						data[a[i]] = [];

						// Get the remainder of the nested object to set so we can recurse
						b = a.slice();
						b.splice(0, i + 1);
						innerSrc = b.join('.');

						// Traverse each entry in the array setting the properties requested
						if ($.isArray(val)) {
							for (var j = 0, jLen = val.length; j < jLen; j++) {
								o = {};
								setData(o, val[j], innerSrc);
								data[a[i]].push(o);
							}
						} else {
							// We've been asked to save data to an array, but it
							// isn't array data to be saved. Best that can be done
							// is to just save the value.
							data[a[i]] = val;
						}

						// The inner call to setData has already traversed through the remainder
						// of the source and has set the data, thus we can exit here
						return;
					} else if (funcNotation) {
						// Function call
						a[i] = a[i].replace(__reFn, '');
						data = data[a[i]](val);
					}

					// If the nested object doesn't currently exist - since we are
					// trying to set the value - create it
					if (data[a[i]] === null || data[a[i]] === undefined) {
						data[a[i]] = {};
					}
					data = data[a[i]];
				}

				// Last item in the input - i.e, the actual set
				if (aLast.match(__reFn)) {
					// Function call
					data = data[aLast.replace(__reFn, '')](val);
				} else {
					// If array notation is used, we just want to strip it and use the property name
					// and assign the value. If it isn't used, then we get the result we want anyway
					data[aLast.replace(__reArray, '')] = val;
				}
			};

			return function (data, val) {
				// meta is also passed in, but not used
				return setData(data, val, mSource);
			};
		} else {
			/* Array or flat object mapping */
			return function (data, val) {
				// meta is also passed in, but not used
				data[mSource] = val;
			};
		}
	}

	/**
  * Return an array with the full table data
  *  @param {object} oSettings dataTables settings object
  *  @returns array {array} aData Master data array
  *  @memberof DataTable#oApi
  */
	function _fnGetDataMaster(settings) {
		return _pluck(settings.aoData, '_aData');
	}

	/**
  * Nuke the table
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnClearTable(settings) {
		settings.aoData.length = 0;
		settings.aiDisplayMaster.length = 0;
		settings.aiDisplay.length = 0;
		settings.aIds = {};
	}

	/**
 * Take an array of integers (index array) and remove a target integer (value - not
 * the key!)
 *  @param {array} a Index array to target
 *  @param {int} iTarget value to find
 *  @memberof DataTable#oApi
 */
	function _fnDeleteIndex(a, iTarget, splice) {
		var iTargetIndex = -1;

		for (var i = 0, iLen = a.length; i < iLen; i++) {
			if (a[i] == iTarget) {
				iTargetIndex = i;
			} else if (a[i] > iTarget) {
				a[i]--;
			}
		}

		if (iTargetIndex != -1 && splice === undefined) {
			a.splice(iTargetIndex, 1);
		}
	}

	/**
  * Mark cached data as invalid such that a re-read of the data will occur when
  * the cached data is next requested. Also update from the data source object.
  *
  * @param {object} settings DataTables settings object
  * @param {int}    rowIdx   Row index to invalidate
  * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
  *     or 'data'
  * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
  *     row will be invalidated
  * @memberof DataTable#oApi
  *
  * @todo For the modularisation of v1.11 this will need to become a callback, so
  *   the sort and filter methods can subscribe to it. That will required
  *   initialisation options for sorting, which is why it is not already baked in
  */
	function _fnInvalidate(settings, rowIdx, src, colIdx) {
		var row = settings.aoData[rowIdx];
		var i, ien;
		var cellWrite = function cellWrite(cell, col) {
			// This is very frustrating, but in IE if you just write directly
			// to innerHTML, and elements that are overwritten are GC'ed,
			// even if there is a reference to them elsewhere
			while (cell.childNodes.length) {
				cell.removeChild(cell.firstChild);
			}

			cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
		};

		// Are we reading last data from DOM or the data object?
		if (src === 'dom' || (!src || src === 'auto') && row.src === 'dom') {
			// Read the data from the DOM
			row._aData = _fnGetRowElements(settings, row, colIdx, colIdx === undefined ? undefined : row._aData).data;
		} else {
			// Reading from data object, update the DOM
			var cells = row.anCells;

			if (cells) {
				if (colIdx !== undefined) {
					cellWrite(cells[colIdx], colIdx);
				} else {
					for (i = 0, ien = cells.length; i < ien; i++) {
						cellWrite(cells[i], i);
					}
				}
			}
		}

		// For both row and cell invalidation, the cached data for sorting and
		// filtering is nulled out
		row._aSortData = null;
		row._aFilterData = null;

		// Invalidate the type for a specific column (if given) or all columns since
		// the data might have changed
		var cols = settings.aoColumns;
		if (colIdx !== undefined) {
			cols[colIdx].sType = null;
		} else {
			for (i = 0, ien = cols.length; i < ien; i++) {
				cols[i].sType = null;
			}

			// Update DataTables special `DT_*` attributes for the row
			_fnRowAttributes(settings, row);
		}
	}

	/**
  * Build a data source object from an HTML row, reading the contents of the
  * cells that are in the row.
  *
  * @param {object} settings DataTables settings object
  * @param {node|object} TR element from which to read data or existing row
  *   object from which to re-read the data from the cells
  * @param {int} [colIdx] Optional column index
  * @param {array|object} [d] Data source object. If `colIdx` is given then this
  *   parameter should also be given and will be used to write the data into.
  *   Only the column in question will be written
  * @returns {object} Object with two parameters: `data` the data read, in
  *   document order, and `cells` and array of nodes (they can be useful to the
  *   caller, so rather than needing a second traversal to get them, just return
  *   them from here).
  * @memberof DataTable#oApi
  */
	function _fnGetRowElements(settings, row, colIdx, d) {
		var tds = [],
		    td = row.firstChild,
		    name,
		    col,
		    o,
		    i = 0,
		    contents,
		    columns = settings.aoColumns,
		    objectRead = settings._rowReadObject;

		// Allow the data object to be passed in, or construct
		d = d !== undefined ? d : objectRead ? {} : [];

		var attr = function attr(str, td) {
			if (typeof str === 'string') {
				var idx = str.indexOf('@');

				if (idx !== -1) {
					var attr = str.substring(idx + 1);
					var setter = _fnSetObjectDataFn(str);
					setter(d, td.getAttribute(attr));
				}
			}
		};

		// Read data from a cell and store into the data object
		var cellProcess = function cellProcess(cell) {
			if (colIdx === undefined || colIdx === i) {
				col = columns[i];
				contents = $.trim(cell.innerHTML);

				if (col && col._bAttrSrc) {
					var setter = _fnSetObjectDataFn(col.mData._);
					setter(d, contents);

					attr(col.mData.sort, cell);
					attr(col.mData.type, cell);
					attr(col.mData.filter, cell);
				} else {
					// Depending on the `data` option for the columns the data can
					// be read to either an object or an array.
					if (objectRead) {
						if (!col._setter) {
							// Cache the setter function
							col._setter = _fnSetObjectDataFn(col.mData);
						}
						col._setter(d, contents);
					} else {
						d[i] = contents;
					}
				}
			}

			i++;
		};

		if (td) {
			// `tr` element was passed in
			while (td) {
				name = td.nodeName.toUpperCase();

				if (name == "TD" || name == "TH") {
					cellProcess(td);
					tds.push(td);
				}

				td = td.nextSibling;
			}
		} else {
			// Existing row object passed in
			tds = row.anCells;

			for (var j = 0, jen = tds.length; j < jen; j++) {
				cellProcess(tds[j]);
			}
		}

		// Read the ID from the DOM if present
		var rowNode = row.firstChild ? row : row.nTr;

		if (rowNode) {
			var id = rowNode.getAttribute('id');

			if (id) {
				_fnSetObjectDataFn(settings.rowId)(d, id);
			}
		}

		return {
			data: d,
			cells: tds
		};
	}
	/**
  * Create a new TR element (and it's TD children) for a row
  *  @param {object} oSettings dataTables settings object
  *  @param {int} iRow Row to consider
  *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
  *    DataTables will create a row automatically
  *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
  *    if nTr is.
  *  @memberof DataTable#oApi
  */
	function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
		var row = oSettings.aoData[iRow],
		    rowData = row._aData,
		    cells = [],
		    nTr,
		    nTd,
		    oCol,
		    i,
		    iLen;

		if (row.nTr === null) {
			nTr = nTrIn || document.createElement('tr');

			row.nTr = nTr;
			row.anCells = cells;

			/* Use a private property on the node to allow reserve mapping from the node
    * to the aoData array for fast look up
    */
			nTr._DT_RowIndex = iRow;

			/* Special parameters can be given by the data source to be used on the row */
			_fnRowAttributes(oSettings, row);

			/* Process each column */
			for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
				oCol = oSettings.aoColumns[i];

				nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType);
				nTd._DT_CellIndex = {
					row: iRow,
					column: i
				};

				cells.push(nTd);

				// Need to create the HTML if new, or if a rendering function is defined
				if ((!nTrIn || oCol.mRender || oCol.mData !== i) && (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + '.display')) {
					nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
				}

				/* Add user defined class */
				if (oCol.sClass) {
					nTd.className += ' ' + oCol.sClass;
				}

				// Visibility - add or remove as required
				if (oCol.bVisible && !nTrIn) {
					nTr.appendChild(nTd);
				} else if (!oCol.bVisible && nTrIn) {
					nTd.parentNode.removeChild(nTd);
				}

				if (oCol.fnCreatedCell) {
					oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i);
				}
			}

			_fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow]);
		}

		// Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
		// and deployed
		row.nTr.setAttribute('role', 'row');
	}

	/**
  * Add attributes to a row based on the special `DT_*` parameters in a data
  * source object.
  *  @param {object} settings DataTables settings object
  *  @param {object} DataTables row object for the row to be modified
  *  @memberof DataTable#oApi
  */
	function _fnRowAttributes(settings, row) {
		var tr = row.nTr;
		var data = row._aData;

		if (tr) {
			var id = settings.rowIdFn(data);

			if (id) {
				tr.id = id;
			}

			if (data.DT_RowClass) {
				// Remove any classes added by DT_RowClass before
				var a = data.DT_RowClass.split(' ');
				row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;

				$(tr).removeClass(row.__rowc.join(' ')).addClass(data.DT_RowClass);
			}

			if (data.DT_RowAttr) {
				$(tr).attr(data.DT_RowAttr);
			}

			if (data.DT_RowData) {
				$(tr).data(data.DT_RowData);
			}
		}
	}

	/**
  * Create the HTML header for the table
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnBuildHead(oSettings) {
		var i, ien, cell, row, column;
		var thead = oSettings.nTHead;
		var tfoot = oSettings.nTFoot;
		var createHeader = $('th, td', thead).length === 0;
		var classes = oSettings.oClasses;
		var columns = oSettings.aoColumns;

		if (createHeader) {
			row = $('<tr/>').appendTo(thead);
		}

		for (i = 0, ien = columns.length; i < ien; i++) {
			column = columns[i];
			cell = $(column.nTh).addClass(column.sClass);

			if (createHeader) {
				cell.appendTo(row);
			}

			// 1.11 move into sorting
			if (oSettings.oFeatures.bSort) {
				cell.addClass(column.sSortingClass);

				if (column.bSortable !== false) {
					cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId);

					_fnSortAttachListener(oSettings, column.nTh, i);
				}
			}

			if (column.sTitle != cell[0].innerHTML) {
				cell.html(column.sTitle);
			}

			_fnRenderer(oSettings, 'header')(oSettings, cell, column, classes);
		}

		if (createHeader) {
			_fnDetectHeader(oSettings.aoHeader, thead);
		}

		/* ARIA role for the rows */
		$(thead).find('>tr').attr('role', 'row');

		/* Deal with the footer - add classes if required */
		$(thead).find('>tr>th, >tr>td').addClass(classes.sHeaderTH);
		$(tfoot).find('>tr>th, >tr>td').addClass(classes.sFooterTH);

		// Cache the footer cells. Note that we only take the cells from the first
		// row in the footer. If there is more than one row the user wants to
		// interact with, they need to use the table().foot() method. Note also this
		// allows cells to be used for multiple columns using colspan
		if (tfoot !== null) {
			var cells = oSettings.aoFooter[0];

			for (i = 0, ien = cells.length; i < ien; i++) {
				column = columns[i];
				column.nTf = cells[i].cell;

				if (column.sClass) {
					$(column.nTf).addClass(column.sClass);
				}
			}
		}
	}

	/**
  * Draw the header (or footer) element based on the column visibility states. The
  * methodology here is to use the layout array from _fnDetectHeader, modified for
  * the instantaneous column visibility, to construct the new layout. The grid is
  * traversed over cell at a time in a rows x columns grid fashion, although each
  * cell insert can cover multiple elements in the grid - which is tracks using the
  * aApplied array. Cell inserts in the grid will only occur where there isn't
  * already a cell in that position.
  *  @param {object} oSettings dataTables settings object
  *  @param array {objects} aoSource Layout array from _fnDetectHeader
  *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
  *  @memberof DataTable#oApi
  */
	function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
		var i, iLen, j, jLen, k, kLen, n, nLocalTr;
		var aoLocal = [];
		var aApplied = [];
		var iColumns = oSettings.aoColumns.length;
		var iRowspan, iColspan;

		if (!aoSource) {
			return;
		}

		if (bIncludeHidden === undefined) {
			bIncludeHidden = false;
		}

		/* Make a copy of the master layout array, but without the visible columns in it */
		for (i = 0, iLen = aoSource.length; i < iLen; i++) {
			aoLocal[i] = aoSource[i].slice();
			aoLocal[i].nTr = aoSource[i].nTr;

			/* Remove any columns which are currently hidden */
			for (j = iColumns - 1; j >= 0; j--) {
				if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
					aoLocal[i].splice(j, 1);
				}
			}

			/* Prep the applied array - it needs an element for each row */
			aApplied.push([]);
		}

		for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
			nLocalTr = aoLocal[i].nTr;

			/* All cells are going to be replaced, so empty out the row */
			if (nLocalTr) {
				while (n = nLocalTr.firstChild) {
					nLocalTr.removeChild(n);
				}
			}

			for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
				iRowspan = 1;
				iColspan = 1;

				/* Check to see if there is already a cell (row/colspan) covering our target
     * insert point. If there is, then there is nothing to do.
     */
				if (aApplied[i][j] === undefined) {
					nLocalTr.appendChild(aoLocal[i][j].cell);
					aApplied[i][j] = 1;

					/* Expand the cell to cover as many rows as needed */
					while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
						aApplied[i + iRowspan][j] = 1;
						iRowspan++;
					}

					/* Expand the cell to cover as many columns as needed */
					while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
						/* Must update the applied array over the rows for the columns */
						for (k = 0; k < iRowspan; k++) {
							aApplied[i + k][j + iColspan] = 1;
						}
						iColspan++;
					}

					/* Do the actual expansion in the DOM */
					$(aoLocal[i][j].cell).attr('rowspan', iRowspan).attr('colspan', iColspan);
				}
			}
		}
	}

	/**
  * Insert the required TR nodes into the table for display
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnDraw(oSettings) {
		/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
		var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);
		if ($.inArray(false, aPreDraw) !== -1) {
			_fnProcessingDisplay(oSettings, false);
			return;
		}

		var i, iLen, n;
		var anRows = [];
		var iRowCount = 0;
		var asStripeClasses = oSettings.asStripeClasses;
		var iStripes = asStripeClasses.length;
		var iOpenRows = oSettings.aoOpenRows.length;
		var oLang = oSettings.oLanguage;
		var iInitDisplayStart = oSettings.iInitDisplayStart;
		var bServerSide = _fnDataSource(oSettings) == 'ssp';
		var aiDisplay = oSettings.aiDisplay;

		oSettings.bDrawing = true;

		/* Check and see if we have an initial draw position from state saving */
		if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
			oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;

			oSettings.iInitDisplayStart = -1;
		}

		var iDisplayStart = oSettings._iDisplayStart;
		var iDisplayEnd = oSettings.fnDisplayEnd();

		/* Server-side processing draw intercept */
		if (oSettings.bDeferLoading) {
			oSettings.bDeferLoading = false;
			oSettings.iDraw++;
			_fnProcessingDisplay(oSettings, false);
		} else if (!bServerSide) {
			oSettings.iDraw++;
		} else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
			return;
		}

		if (aiDisplay.length !== 0) {
			var iStart = bServerSide ? 0 : iDisplayStart;
			var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

			for (var j = iStart; j < iEnd; j++) {
				var iDataIndex = aiDisplay[j];
				var aoData = oSettings.aoData[iDataIndex];
				if (aoData.nTr === null) {
					_fnCreateTr(oSettings, iDataIndex);
				}

				var nRow = aoData.nTr;

				/* Remove the old striping classes and then add the new one */
				if (iStripes !== 0) {
					var sStripe = asStripeClasses[iRowCount % iStripes];
					if (aoData._sRowStripe != sStripe) {
						$(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
						aoData._sRowStripe = sStripe;
					}
				}

				// Row callback functions - might want to manipulate the row
				// iRowCount and j are not currently documented. Are they at all
				// useful?
				_fnCallbackFire(oSettings, 'aoRowCallback', null, [nRow, aoData._aData, iRowCount, j]);

				anRows.push(nRow);
				iRowCount++;
			}
		} else {
			/* Table is empty - create a row with an empty message in it */
			var sZero = oLang.sZeroRecords;
			if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
				sZero = oLang.sLoadingRecords;
			} else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
				sZero = oLang.sEmptyTable;
			}

			anRows[0] = $('<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' }).append($('<td />', {
				'valign': 'top',
				'colSpan': _fnVisbleColumns(oSettings),
				'class': oSettings.oClasses.sRowEmpty
			}).html(sZero))[0];
		}

		/* Header and footer callbacks */
		_fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

		_fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

		var body = $(oSettings.nTBody);

		body.children().detach();
		body.append($(anRows));

		/* Call all required callback functions for the end of a draw */
		_fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);

		/* Draw is complete, sorting and filtering must be as well */
		oSettings.bSorted = false;
		oSettings.bFiltered = false;
		oSettings.bDrawing = false;
	}

	/**
  * Redraw the table - taking account of the various features which are enabled
  *  @param {object} oSettings dataTables settings object
  *  @param {boolean} [holdPosition] Keep the current paging position. By default
  *    the paging is reset to the first page
  *  @memberof DataTable#oApi
  */
	function _fnReDraw(settings, holdPosition) {
		var features = settings.oFeatures,
		    sort = features.bSort,
		    filter = features.bFilter;

		if (sort) {
			_fnSort(settings);
		}

		if (filter) {
			_fnFilterComplete(settings, settings.oPreviousSearch);
		} else {
			// No filtering, so we want to just use the display master
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		}

		if (holdPosition !== true) {
			settings._iDisplayStart = 0;
		}

		// Let any modules know about the draw hold position state (used by
		// scrolling internally)
		settings._drawHold = holdPosition;

		_fnDraw(settings);

		settings._drawHold = false;
	}

	/**
  * Add the options to the page HTML for the table
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnAddOptionsHtml(oSettings) {
		var classes = oSettings.oClasses;
		var table = $(oSettings.nTable);
		var holding = $('<div/>').insertBefore(table); // Holding element for speed
		var features = oSettings.oFeatures;

		// All DataTables are wrapped in a div
		var insert = $('<div/>', {
			id: oSettings.sTableId + '_wrapper',
			'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
		});

		oSettings.nHolding = holding[0];
		oSettings.nTableWrapper = insert[0];
		oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;

		/* Loop over the user set positioning and place the elements as needed */
		var aDom = oSettings.sDom.split('');
		var featureNode, cOption, nNewNode, cNext, sAttr, j;
		for (var i = 0; i < aDom.length; i++) {
			featureNode = null;
			cOption = aDom[i];

			if (cOption == '<') {
				/* New container div */
				nNewNode = $('<div/>')[0];

				/* Check to see if we should append an id and/or a class name to the container */
				cNext = aDom[i + 1];
				if (cNext == "'" || cNext == '"') {
					sAttr = "";
					j = 2;
					while (aDom[i + j] != cNext) {
						sAttr += aDom[i + j];
						j++;
					}

					/* Replace jQuery UI constants @todo depreciated */
					if (sAttr == "H") {
						sAttr = classes.sJUIHeader;
					} else if (sAttr == "F") {
						sAttr = classes.sJUIFooter;
					}

					/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
      * breaks the string into parts and applies them as needed
      */
					if (sAttr.indexOf('.') != -1) {
						var aSplit = sAttr.split('.');
						nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
						nNewNode.className = aSplit[1];
					} else if (sAttr.charAt(0) == "#") {
						nNewNode.id = sAttr.substr(1, sAttr.length - 1);
					} else {
						nNewNode.className = sAttr;
					}

					i += j; /* Move along the position array */
				}

				insert.append(nNewNode);
				insert = $(nNewNode);
			} else if (cOption == '>') {
				/* End container div */
				insert = insert.parent();
			}
			// @todo Move options into their own plugins?
			else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {
					/* Length */
					featureNode = _fnFeatureHtmlLength(oSettings);
				} else if (cOption == 'f' && features.bFilter) {
					/* Filter */
					featureNode = _fnFeatureHtmlFilter(oSettings);
				} else if (cOption == 'r' && features.bProcessing) {
					/* pRocessing */
					featureNode = _fnFeatureHtmlProcessing(oSettings);
				} else if (cOption == 't') {
					/* Table */
					featureNode = _fnFeatureHtmlTable(oSettings);
				} else if (cOption == 'i' && features.bInfo) {
					/* Info */
					featureNode = _fnFeatureHtmlInfo(oSettings);
				} else if (cOption == 'p' && features.bPaginate) {
					/* Pagination */
					featureNode = _fnFeatureHtmlPaginate(oSettings);
				} else if (DataTable.ext.feature.length !== 0) {
					/* Plug-in features */
					var aoFeatures = DataTable.ext.feature;
					for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
						if (cOption == aoFeatures[k].cFeature) {
							featureNode = aoFeatures[k].fnInit(oSettings);
							break;
						}
					}
				}

			/* Add to the 2D features array */
			if (featureNode) {
				var aanFeatures = oSettings.aanFeatures;

				if (!aanFeatures[cOption]) {
					aanFeatures[cOption] = [];
				}

				aanFeatures[cOption].push(featureNode);
				insert.append(featureNode);
			}
		}

		/* Built our DOM structure - replace the holding div with what we want */
		holding.replaceWith(insert);
		oSettings.nHolding = null;
	}

	/**
  * Use the DOM source to create up an array of header cells. The idea here is to
  * create a layout grid (array) of rows x columns, which contains a reference
  * to the cell that that point in the grid (regardless of col/rowspan), such that
  * any column / row could be removed and the new grid constructed
  *  @param array {object} aLayout Array to store the calculated layout in
  *  @param {node} nThead The header/footer element for the table
  *  @memberof DataTable#oApi
  */
	function _fnDetectHeader(aLayout, nThead) {
		var nTrs = $(nThead).children('tr');
		var nTr, nCell;
		var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
		var bUnique;
		var fnShiftCol = function fnShiftCol(a, i, j) {
			var k = a[i];
			while (k[j]) {
				j++;
			}
			return j;
		};

		aLayout.splice(0, aLayout.length);

		/* We know how many rows there are in the layout - so prep it */
		for (i = 0, iLen = nTrs.length; i < iLen; i++) {
			aLayout.push([]);
		}

		/* Calculate a layout array */
		for (i = 0, iLen = nTrs.length; i < iLen; i++) {
			nTr = nTrs[i];
			iColumn = 0;

			/* For every cell in the row... */
			nCell = nTr.firstChild;
			while (nCell) {
				if (nCell.nodeName.toUpperCase() == "TD" || nCell.nodeName.toUpperCase() == "TH") {
					/* Get the col and rowspan attributes from the DOM and sanitise them */
					iColspan = nCell.getAttribute('colspan') * 1;
					iRowspan = nCell.getAttribute('rowspan') * 1;
					iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan;
					iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan;

					/* There might be colspan cells already in this row, so shift our target
      * accordingly
      */
					iColShifted = fnShiftCol(aLayout, i, iColumn);

					/* Cache calculation for unique columns */
					bUnique = iColspan === 1 ? true : false;

					/* If there is col / rowspan, copy the information into the layout grid */
					for (l = 0; l < iColspan; l++) {
						for (k = 0; k < iRowspan; k++) {
							aLayout[i + k][iColShifted + l] = {
								"cell": nCell,
								"unique": bUnique
							};
							aLayout[i + k].nTr = nTr;
						}
					}
				}
				nCell = nCell.nextSibling;
			}
		}
	}

	/**
  * Get an array of unique th elements, one for each column
  *  @param {object} oSettings dataTables settings object
  *  @param {node} nHeader automatically detect the layout from this node - optional
  *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
  *  @returns array {node} aReturn list of unique th's
  *  @memberof DataTable#oApi
  */
	function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
		var aReturn = [];
		if (!aLayout) {
			aLayout = oSettings.aoHeader;
			if (nHeader) {
				aLayout = [];
				_fnDetectHeader(aLayout, nHeader);
			}
		}

		for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
			for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
				if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {
					aReturn[j] = aLayout[i][j].cell;
				}
			}
		}

		return aReturn;
	}

	/**
  * Create an Ajax call based on the table's settings, taking into account that
  * parameters can have multiple forms, and backwards compatibility.
  *
  * @param {object} oSettings dataTables settings object
  * @param {array} data Data to send to the server, required by
  *     DataTables - may be augmented by developer callbacks
  * @param {function} fn Callback function to run when data is obtained
  */
	function _fnBuildAjax(oSettings, data, fn) {
		// Compatibility with 1.9-, allow fnServerData and event to manipulate
		_fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]);

		// Convert to object based for 1.10+ if using the old array scheme which can
		// come from server-side processing or serverParams
		if (data && $.isArray(data)) {
			var tmp = {};
			var rbracket = /(.*?)\[\]$/;

			$.each(data, function (key, val) {
				var match = val.name.match(rbracket);

				if (match) {
					// Support for arrays
					var name = match[0];

					if (!tmp[name]) {
						tmp[name] = [];
					}
					tmp[name].push(val.value);
				} else {
					tmp[val.name] = val.value;
				}
			});
			data = tmp;
		}

		var ajaxData;
		var ajax = oSettings.ajax;
		var instance = oSettings.oInstance;
		var callback = function callback(json) {
			_fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);
			fn(json);
		};

		if ($.isPlainObject(ajax) && ajax.data) {
			ajaxData = ajax.data;

			var newData = $.isFunction(ajaxData) ? ajaxData(data, oSettings) : // fn can manipulate data or return
			ajaxData; // an object object or array to merge

			// If the function returned something, use that alone
			data = $.isFunction(ajaxData) && newData ? newData : $.extend(true, data, newData);

			// Remove the data property as we've resolved it already and don't want
			// jQuery to do it again (it is restored at the end of the function)
			delete ajax.data;
		}

		var baseAjax = {
			"data": data,
			"success": function success(json) {
				var error = json.error || json.sError;
				if (error) {
					_fnLog(oSettings, 0, error);
				}

				oSettings.json = json;
				callback(json);
			},
			"dataType": "json",
			"cache": false,
			"type": oSettings.sServerMethod,
			"error": function error(xhr, _error, thrown) {
				var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);

				if ($.inArray(true, ret) === -1) {
					if (_error == "parsererror") {
						_fnLog(oSettings, 0, 'Invalid JSON response', 1);
					} else if (xhr.readyState === 4) {
						_fnLog(oSettings, 0, 'Ajax error', 7);
					}
				}

				_fnProcessingDisplay(oSettings, false);
			}
		};

		// Store the data submitted for the API
		oSettings.oAjaxData = data;

		// Allow plug-ins and external processes to modify the data
		_fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);

		if (oSettings.fnServerData) {
			// DataTables 1.9- compatibility
			oSettings.fnServerData.call(instance, oSettings.sAjaxSource, $.map(data, function (val, key) {
				// Need to convert back to 1.9 trad format
				return { name: key, value: val };
			}), callback, oSettings);
		} else if (oSettings.sAjaxSource || typeof ajax === 'string') {
			// DataTables 1.9- compatibility
			oSettings.jqXHR = $.ajax($.extend(baseAjax, {
				url: ajax || oSettings.sAjaxSource
			}));
		} else if ($.isFunction(ajax)) {
			// Is a function - let the caller define what needs to be done
			oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
		} else {
			// Object to extend the base settings
			oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax));

			// Restore for next time around
			ajax.data = ajaxData;
		}
	}

	/**
  * Update the table using an Ajax call
  *  @param {object} settings dataTables settings object
  *  @returns {boolean} Block the table drawing or not
  *  @memberof DataTable#oApi
  */
	function _fnAjaxUpdate(settings) {
		if (settings.bAjaxDataGet) {
			settings.iDraw++;
			_fnProcessingDisplay(settings, true);

			_fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {
				_fnAjaxUpdateDraw(settings, json);
			});

			return false;
		}
		return true;
	}

	/**
  * Build up the parameters in an object needed for a server-side processing
  * request. Note that this is basically done twice, is different ways - a modern
  * method which is used by default in DataTables 1.10 which uses objects and
  * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
  * the sAjaxSource option is used in the initialisation, or the legacyAjax
  * option is set.
  *  @param {object} oSettings dataTables settings object
  *  @returns {bool} block the table drawing or not
  *  @memberof DataTable#oApi
  */
	function _fnAjaxParameters(settings) {
		var columns = settings.aoColumns,
		    columnCount = columns.length,
		    features = settings.oFeatures,
		    preSearch = settings.oPreviousSearch,
		    preColSearch = settings.aoPreSearchCols,
		    i,
		    data = [],
		    dataProp,
		    column,
		    columnSearch,
		    sort = _fnSortFlatten(settings),
		    displayStart = settings._iDisplayStart,
		    displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1;

		var param = function param(name, value) {
			data.push({ 'name': name, 'value': value });
		};

		// DataTables 1.9- compatible method
		param('sEcho', settings.iDraw);
		param('iColumns', columnCount);
		param('sColumns', _pluck(columns, 'sName').join(','));
		param('iDisplayStart', displayStart);
		param('iDisplayLength', displayLength);

		// DataTables 1.10+ method
		var d = {
			draw: settings.iDraw,
			columns: [],
			order: [],
			start: displayStart,
			length: displayLength,
			search: {
				value: preSearch.sSearch,
				regex: preSearch.bRegex
			}
		};

		for (i = 0; i < columnCount; i++) {
			column = columns[i];
			columnSearch = preColSearch[i];
			dataProp = typeof column.mData == "function" ? 'function' : column.mData;

			d.columns.push({
				data: dataProp,
				name: column.sName,
				searchable: column.bSearchable,
				orderable: column.bSortable,
				search: {
					value: columnSearch.sSearch,
					regex: columnSearch.bRegex
				}
			});

			param("mDataProp_" + i, dataProp);

			if (features.bFilter) {
				param('sSearch_' + i, columnSearch.sSearch);
				param('bRegex_' + i, columnSearch.bRegex);
				param('bSearchable_' + i, column.bSearchable);
			}

			if (features.bSort) {
				param('bSortable_' + i, column.bSortable);
			}
		}

		if (features.bFilter) {
			param('sSearch', preSearch.sSearch);
			param('bRegex', preSearch.bRegex);
		}

		if (features.bSort) {
			$.each(sort, function (i, val) {
				d.order.push({ column: val.col, dir: val.dir });

				param('iSortCol_' + i, val.col);
				param('sSortDir_' + i, val.dir);
			});

			param('iSortingCols', sort.length);
		}

		// If the legacy.ajax parameter is null, then we automatically decide which
		// form to use, based on sAjaxSource
		var legacy = DataTable.ext.legacy.ajax;
		if (legacy === null) {
			return settings.sAjaxSource ? data : d;
		}

		// Otherwise, if legacy has been specified then we use that to decide on the
		// form
		return legacy ? data : d;
	}

	/**
  * Data the data from the server (nuking the old) and redraw the table
  *  @param {object} oSettings dataTables settings object
  *  @param {object} json json data return from the server.
  *  @param {string} json.sEcho Tracking flag for DataTables to match requests
  *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
  *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
  *  @param {array} json.aaData The data to display on this page
  *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
  *  @memberof DataTable#oApi
  */
	function _fnAjaxUpdateDraw(settings, json) {
		// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
		// Support both
		var compat = function compat(old, modern) {
			return json[old] !== undefined ? json[old] : json[modern];
		};

		var data = _fnAjaxDataSrc(settings, json);
		var draw = compat('sEcho', 'draw');
		var recordsTotal = compat('iTotalRecords', 'recordsTotal');
		var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');

		if (draw) {
			// Protect against out of sequence returns
			if (draw * 1 < settings.iDraw) {
				return;
			}
			settings.iDraw = draw * 1;
		}

		_fnClearTable(settings);
		settings._iRecordsTotal = parseInt(recordsTotal, 10);
		settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

		for (var i = 0, ien = data.length; i < ien; i++) {
			_fnAddData(settings, data[i]);
		}
		settings.aiDisplay = settings.aiDisplayMaster.slice();

		settings.bAjaxDataGet = false;
		_fnDraw(settings);

		if (!settings._bInitComplete) {
			_fnInitComplete(settings, json);
		}

		settings.bAjaxDataGet = true;
		_fnProcessingDisplay(settings, false);
	}

	/**
  * Get the data from the JSON data source to use for drawing a table. Using
  * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
  * source object, or from a processing function.
  *  @param {object} oSettings dataTables settings object
  *  @param  {object} json Data source object / array from the server
  *  @return {array} Array of data to use
  */
	function _fnAjaxDataSrc(oSettings, json) {
		var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp; // Compatibility with 1.9-.

		// Compatibility with 1.9-. In order to read from aaData, check if the
		// default has been changed, if not, check for aaData
		if (dataSrc === 'data') {
			return json.aaData || json[dataSrc];
		}

		return dataSrc !== "" ? _fnGetObjectDataFn(dataSrc)(json) : json;
	}

	/**
  * Generate the node required for filtering text
  *  @returns {node} Filter control element
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnFeatureHtmlFilter(settings) {
		var classes = settings.oClasses;
		var tableId = settings.sTableId;
		var language = settings.oLanguage;
		var previousSearch = settings.oPreviousSearch;
		var features = settings.aanFeatures;
		var input = '<input type="search" class="' + classes.sFilterInput + '"/>';

		var str = language.sSearch;
		str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input;

		var filter = $('<div/>', {
			'id': !features.f ? tableId + '_filter' : null,
			'class': classes.sFilter
		}).append($('<label/>').append(str));

		var searchFn = function searchFn() {
			/* Update all other filter input elements for the new display */
			var n = features.f;
			var val = !this.value ? "" : this.value; // mental IE8 fix :-(

			/* Now do the filter */
			if (val != previousSearch.sSearch) {
				_fnFilterComplete(settings, {
					"sSearch": val,
					"bRegex": previousSearch.bRegex,
					"bSmart": previousSearch.bSmart,
					"bCaseInsensitive": previousSearch.bCaseInsensitive
				});

				// Need to redraw, without resorting
				settings._iDisplayStart = 0;
				_fnDraw(settings);
			}
		};

		var searchDelay = settings.searchDelay !== null ? settings.searchDelay : _fnDataSource(settings) === 'ssp' ? 400 : 0;

		var jqFilter = $('input', filter).val(previousSearch.sSearch).attr('placeholder', language.sSearchPlaceholder).on('keyup.DT search.DT input.DT paste.DT cut.DT', searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn).on('keypress.DT', function (e) {
			/* Prevent form submission */
			if (e.keyCode == 13) {
				return false;
			}
		}).attr('aria-controls', tableId);

		// Update the input elements whenever the table is filtered
		$(settings.nTable).on('search.dt.DT', function (ev, s) {
			if (settings === s) {
				// IE9 throws an 'unknown error' if document.activeElement is used
				// inside an iframe or frame...
				try {
					if (jqFilter[0] !== document.activeElement) {
						jqFilter.val(previousSearch.sSearch);
					}
				} catch (e) {}
			}
		});

		return filter[0];
	}

	/**
  * Filter the table using both the global filter and column based filtering
  *  @param {object} oSettings dataTables settings object
  *  @param {object} oSearch search information
  *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
  *  @memberof DataTable#oApi
  */
	function _fnFilterComplete(oSettings, oInput, iForce) {
		var oPrevSearch = oSettings.oPreviousSearch;
		var aoPrevSearch = oSettings.aoPreSearchCols;
		var fnSaveFilter = function fnSaveFilter(oFilter) {
			/* Save the filtering values */
			oPrevSearch.sSearch = oFilter.sSearch;
			oPrevSearch.bRegex = oFilter.bRegex;
			oPrevSearch.bSmart = oFilter.bSmart;
			oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
		};
		var fnRegex = function fnRegex(o) {
			// Backwards compatibility with the bEscapeRegex option
			return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
		};

		// Resolve any column types that are unknown due to addition or invalidation
		// @todo As per sort - can this be moved into an event handler?
		_fnColumnTypes(oSettings);

		/* In server-side processing all filtering is done by the server, so no point hanging around here */
		if (_fnDataSource(oSettings) != 'ssp') {
			/* Global filter */
			_fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);
			fnSaveFilter(oInput);

			/* Now do the individual column filter */
			for (var i = 0; i < aoPrevSearch.length; i++) {
				_fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]), aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
			}

			/* Custom filtering */
			_fnFilterCustom(oSettings);
		} else {
			fnSaveFilter(oInput);
		}

		/* Tell the draw function we have been filtering */
		oSettings.bFiltered = true;
		_fnCallbackFire(oSettings, null, 'search', [oSettings]);
	}

	/**
  * Apply custom filtering functions
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnFilterCustom(settings) {
		var filters = DataTable.ext.search;
		var displayRows = settings.aiDisplay;
		var row, rowIdx;

		for (var i = 0, ien = filters.length; i < ien; i++) {
			var rows = [];

			// Loop over each row and see if it should be included
			for (var j = 0, jen = displayRows.length; j < jen; j++) {
				rowIdx = displayRows[j];
				row = settings.aoData[rowIdx];

				if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
					rows.push(rowIdx);
				}
			}

			// So the array reference doesn't break set the results into the
			// existing array
			displayRows.length = 0;
			$.merge(displayRows, rows);
		}
	}

	/**
  * Filter the table on a per-column basis
  *  @param {object} oSettings dataTables settings object
  *  @param {string} sInput string to filter on
  *  @param {int} iColumn column to filter
  *  @param {bool} bRegex treat search string as a regular expression or not
  *  @param {bool} bSmart use smart filtering or not
  *  @param {bool} bCaseInsensitive Do case insenstive matching or not
  *  @memberof DataTable#oApi
  */
	function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
		if (searchStr === '') {
			return;
		}

		var data;
		var out = [];
		var display = settings.aiDisplay;
		var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);

		for (var i = 0; i < display.length; i++) {
			data = settings.aoData[display[i]]._aFilterData[colIdx];

			if (rpSearch.test(data)) {
				out.push(display[i]);
			}
		}

		settings.aiDisplay = out;
	}

	/**
  * Filter the data table based on user input and draw the table
  *  @param {object} settings dataTables settings object
  *  @param {string} input string to filter on
  *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
  *  @param {bool} regex treat as a regular expression or not
  *  @param {bool} smart perform smart filtering or not
  *  @param {bool} caseInsensitive Do case insenstive matching or not
  *  @memberof DataTable#oApi
  */
	function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
		var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);
		var prevSearch = settings.oPreviousSearch.sSearch;
		var displayMaster = settings.aiDisplayMaster;
		var display, invalidated, i;
		var filtered = [];

		// Need to take account of custom filtering functions - always filter
		if (DataTable.ext.search.length !== 0) {
			force = true;
		}

		// Check if any of the rows were invalidated
		invalidated = _fnFilterData(settings);

		// If the input is blank - we just want the full data set
		if (input.length <= 0) {
			settings.aiDisplay = displayMaster.slice();
		} else {
			// New search - start from the master array
			if (invalidated || force || prevSearch.length > input.length || input.indexOf(prevSearch) !== 0 || settings.bSorted // On resort, the display master needs to be
			// re-filtered since indexes will have changed
			) {
					settings.aiDisplay = displayMaster.slice();
				}

			// Search the display array
			display = settings.aiDisplay;

			for (i = 0; i < display.length; i++) {
				if (rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
					filtered.push(display[i]);
				}
			}

			settings.aiDisplay = filtered;
		}
	}

	/**
  * Build a regular expression object suitable for searching a table
  *  @param {string} sSearch string to search for
  *  @param {bool} bRegex treat as a regular expression or not
  *  @param {bool} bSmart perform smart filtering or not
  *  @param {bool} bCaseInsensitive Do case insensitive matching or not
  *  @returns {RegExp} constructed object
  *  @memberof DataTable#oApi
  */
	function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
		search = regex ? search : _fnEscapeRegex(search);

		if (smart) {
			/* For smart filtering we want to allow the search to work regardless of
    * word order. We also want double quoted text to be preserved, so word
    * order is important - a la google. So this is what we want to
    * generate:
    * 
    * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
    */
			var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function (word) {
				if (word.charAt(0) === '"') {
					var m = word.match(/^"(.*)"$/);
					word = m ? m[1] : word;
				}

				return word.replace('"', '');
			});

			search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
		}

		return new RegExp(search, caseInsensitive ? 'i' : '');
	}

	/**
  * Escape a string such that it can be used in a regular expression
  *  @param {string} sVal string to escape
  *  @returns {string} escaped string
  *  @memberof DataTable#oApi
  */
	var _fnEscapeRegex = DataTable.util.escapeRegex;

	var __filter_div = $('<div>')[0];
	var __filter_div_textContent = __filter_div.textContent !== undefined;

	// Update the filtering data for each row if needed (by invalidation or first run)
	function _fnFilterData(settings) {
		var columns = settings.aoColumns;
		var column;
		var i, j, ien, jen, filterData, cellData, row;
		var fomatters = DataTable.ext.type.search;
		var wasInvalidated = false;

		for (i = 0, ien = settings.aoData.length; i < ien; i++) {
			row = settings.aoData[i];

			if (!row._aFilterData) {
				filterData = [];

				for (j = 0, jen = columns.length; j < jen; j++) {
					column = columns[j];

					if (column.bSearchable) {
						cellData = _fnGetCellData(settings, i, j, 'filter');

						if (fomatters[column.sType]) {
							cellData = fomatters[column.sType](cellData);
						}

						// Search in DataTables 1.10 is string based. In 1.11 this
						// should be altered to also allow strict type checking.
						if (cellData === null) {
							cellData = '';
						}

						if (typeof cellData !== 'string' && cellData.toString) {
							cellData = cellData.toString();
						}
					} else {
						cellData = '';
					}

					// If it looks like there is an HTML entity in the string,
					// attempt to decode it so sorting works as expected. Note that
					// we could use a single line of jQuery to do this, but the DOM
					// method used here is much faster http://jsperf.com/html-decode
					if (cellData.indexOf && cellData.indexOf('&') !== -1) {
						__filter_div.innerHTML = cellData;
						cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
					}

					if (cellData.replace) {
						cellData = cellData.replace(/[\r\n]/g, '');
					}

					filterData.push(cellData);
				}

				row._aFilterData = filterData;
				row._sFilterRow = filterData.join('  ');
				wasInvalidated = true;
			}
		}

		return wasInvalidated;
	}

	/**
  * Convert from the internal Hungarian notation to camelCase for external
  * interaction
  *  @param {object} obj Object to convert
  *  @returns {object} Inverted object
  *  @memberof DataTable#oApi
  */
	function _fnSearchToCamel(obj) {
		return {
			search: obj.sSearch,
			smart: obj.bSmart,
			regex: obj.bRegex,
			caseInsensitive: obj.bCaseInsensitive
		};
	}

	/**
  * Convert from camelCase notation to the internal Hungarian. We could use the
  * Hungarian convert function here, but this is cleaner
  *  @param {object} obj Object to convert
  *  @returns {object} Inverted object
  *  @memberof DataTable#oApi
  */
	function _fnSearchToHung(obj) {
		return {
			sSearch: obj.search,
			bSmart: obj.smart,
			bRegex: obj.regex,
			bCaseInsensitive: obj.caseInsensitive
		};
	}

	/**
  * Generate the node required for the info display
  *  @param {object} oSettings dataTables settings object
  *  @returns {node} Information element
  *  @memberof DataTable#oApi
  */
	function _fnFeatureHtmlInfo(settings) {
		var tid = settings.sTableId,
		    nodes = settings.aanFeatures.i,
		    n = $('<div/>', {
			'class': settings.oClasses.sInfo,
			'id': !nodes ? tid + '_info' : null
		});

		if (!nodes) {
			// Update display on each draw
			settings.aoDrawCallback.push({
				"fn": _fnUpdateInfo,
				"sName": "information"
			});

			n.attr('role', 'status').attr('aria-live', 'polite');

			// Table is described by our info div
			$(settings.nTable).attr('aria-describedby', tid + '_info');
		}

		return n[0];
	}

	/**
  * Update the information elements in the display
  *  @param {object} settings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnUpdateInfo(settings) {
		/* Show information about the table */
		var nodes = settings.aanFeatures.i;
		if (nodes.length === 0) {
			return;
		}

		var lang = settings.oLanguage,
		    start = settings._iDisplayStart + 1,
		    end = settings.fnDisplayEnd(),
		    max = settings.fnRecordsTotal(),
		    total = settings.fnRecordsDisplay(),
		    out = total ? lang.sInfo : lang.sInfoEmpty;

		if (total !== max) {
			/* Record set after filtering */
			out += ' ' + lang.sInfoFiltered;
		}

		// Convert the macros
		out += lang.sInfoPostFix;
		out = _fnInfoMacros(settings, out);

		var callback = lang.fnInfoCallback;
		if (callback !== null) {
			out = callback.call(settings.oInstance, settings, start, end, max, total, out);
		}

		$(nodes).html(out);
	}

	function _fnInfoMacros(settings, str) {
		// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
		// internally
		var formatter = settings.fnFormatNumber,
		    start = settings._iDisplayStart + 1,
		    len = settings._iDisplayLength,
		    vis = settings.fnRecordsDisplay(),
		    all = len === -1;

		return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
	}

	/**
  * Draw the table for the first time, adding all required features
  *  @param {object} settings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnInitialise(settings) {
		var i,
		    iLen,
		    iAjaxStart = settings.iInitDisplayStart;
		var columns = settings.aoColumns,
		    column;
		var features = settings.oFeatures;
		var deferLoading = settings.bDeferLoading; // value modified by the draw

		/* Ensure that the table data is fully initialised */
		if (!settings.bInitialised) {
			setTimeout(function () {
				_fnInitialise(settings);
			}, 200);
			return;
		}

		/* Show the display HTML options */
		_fnAddOptionsHtml(settings);

		/* Build and draw the header / footer for the table */
		_fnBuildHead(settings);
		_fnDrawHead(settings, settings.aoHeader);
		_fnDrawHead(settings, settings.aoFooter);

		/* Okay to show that something is going on now */
		_fnProcessingDisplay(settings, true);

		/* Calculate sizes for columns */
		if (features.bAutoWidth) {
			_fnCalculateColumnWidths(settings);
		}

		for (i = 0, iLen = columns.length; i < iLen; i++) {
			column = columns[i];

			if (column.sWidth) {
				column.nTh.style.width = _fnStringToCss(column.sWidth);
			}
		}

		_fnCallbackFire(settings, null, 'preInit', [settings]);

		// If there is default sorting required - let's do it. The sort function
		// will do the drawing for us. Otherwise we draw the table regardless of the
		// Ajax source - this allows the table to look initialised for Ajax sourcing
		// data (show 'loading' message possibly)
		_fnReDraw(settings);

		// Server-side processing init complete is done by _fnAjaxUpdateDraw
		var dataSrc = _fnDataSource(settings);
		if (dataSrc != 'ssp' || deferLoading) {
			// if there is an ajax source load the data
			if (dataSrc == 'ajax') {
				_fnBuildAjax(settings, [], function (json) {
					var aData = _fnAjaxDataSrc(settings, json);

					// Got the data - add it to the table
					for (i = 0; i < aData.length; i++) {
						_fnAddData(settings, aData[i]);
					}

					// Reset the init display for cookie saving. We've already done
					// a filter, and therefore cleared it before. So we need to make
					// it appear 'fresh'
					settings.iInitDisplayStart = iAjaxStart;

					_fnReDraw(settings);

					_fnProcessingDisplay(settings, false);
					_fnInitComplete(settings, json);
				}, settings);
			} else {
				_fnProcessingDisplay(settings, false);
				_fnInitComplete(settings);
			}
		}
	}

	/**
  * Draw the table for the first time, adding all required features
  *  @param {object} oSettings dataTables settings object
  *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
  *    with client-side processing (optional)
  *  @memberof DataTable#oApi
  */
	function _fnInitComplete(settings, json) {
		settings._bInitComplete = true;

		// When data was added after the initialisation (data or Ajax) we need to
		// calculate the column sizing
		if (json || settings.oInit.aaData) {
			_fnAdjustColumnSizing(settings);
		}

		_fnCallbackFire(settings, null, 'plugin-init', [settings, json]);
		_fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);
	}

	function _fnLengthChange(settings, val) {
		var len = parseInt(val, 10);
		settings._iDisplayLength = len;

		_fnLengthOverflow(settings);

		// Fire length change event
		_fnCallbackFire(settings, null, 'length', [settings, len]);
	}

	/**
  * Generate the node required for user display length changing
  *  @param {object} settings dataTables settings object
  *  @returns {node} Display length feature node
  *  @memberof DataTable#oApi
  */
	function _fnFeatureHtmlLength(settings) {
		var classes = settings.oClasses,
		    tableId = settings.sTableId,
		    menu = settings.aLengthMenu,
		    d2 = $.isArray(menu[0]),
		    lengths = d2 ? menu[0] : menu,
		    language = d2 ? menu[1] : menu;

		var select = $('<select/>', {
			'name': tableId + '_length',
			'aria-controls': tableId,
			'class': classes.sLengthSelect
		});

		for (var i = 0, ien = lengths.length; i < ien; i++) {
			select[0][i] = new Option(language[i], lengths[i]);
		}

		var div = $('<div><label/></div>').addClass(classes.sLength);
		if (!settings.aanFeatures.l) {
			div[0].id = tableId + '_length';
		}

		div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML));

		// Can't use `select` variable as user might provide their own and the
		// reference is broken by the use of outerHTML
		$('select', div).val(settings._iDisplayLength).on('change.DT', function (e) {
			_fnLengthChange(settings, $(this).val());
			_fnDraw(settings);
		});

		// Update node value whenever anything changes the table's length
		$(settings.nTable).on('length.dt.DT', function (e, s, len) {
			if (settings === s) {
				$('select', div).val(len);
			}
		});

		return div[0];
	}

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Note that most of the paging logic is done in
  * DataTable.ext.pager
  */

	/**
  * Generate the node required for default pagination
  *  @param {object} oSettings dataTables settings object
  *  @returns {node} Pagination feature node
  *  @memberof DataTable#oApi
  */
	function _fnFeatureHtmlPaginate(settings) {
		var type = settings.sPaginationType,
		    plugin = DataTable.ext.pager[type],
		    modern = typeof plugin === 'function',
		    redraw = function redraw(settings) {
			_fnDraw(settings);
		},
		    node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],
		    features = settings.aanFeatures;

		if (!modern) {
			plugin.fnInit(settings, node, redraw);
		}

		/* Add a draw callback for the pagination on first instance, to update the paging display */
		if (!features.p) {
			node.id = settings.sTableId + '_paginate';

			settings.aoDrawCallback.push({
				"fn": function fn(settings) {
					if (modern) {
						var start = settings._iDisplayStart,
						    len = settings._iDisplayLength,
						    visRecords = settings.fnRecordsDisplay(),
						    all = len === -1,
						    page = all ? 0 : Math.ceil(start / len),
						    pages = all ? 1 : Math.ceil(visRecords / len),
						    buttons = plugin(page, pages),
						    i,
						    ien;

						for (i = 0, ien = features.p.length; i < ien; i++) {
							_fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages);
						}
					} else {
						plugin.fnUpdate(settings, redraw);
					}
				},
				"sName": "pagination"
			});
		}

		return node;
	}

	/**
  * Alter the display settings to change the page
  *  @param {object} settings DataTables settings object
  *  @param {string|int} action Paging action to take: "first", "previous",
  *    "next" or "last" or page number to jump to (integer)
  *  @param [bool] redraw Automatically draw the update or not
  *  @returns {bool} true page has changed, false - no change
  *  @memberof DataTable#oApi
  */
	function _fnPageChange(settings, action, redraw) {
		var start = settings._iDisplayStart,
		    len = settings._iDisplayLength,
		    records = settings.fnRecordsDisplay();

		if (records === 0 || len === -1) {
			start = 0;
		} else if (typeof action === "number") {
			start = action * len;

			if (start > records) {
				start = 0;
			}
		} else if (action == "first") {
			start = 0;
		} else if (action == "previous") {
			start = len >= 0 ? start - len : 0;

			if (start < 0) {
				start = 0;
			}
		} else if (action == "next") {
			if (start + len < records) {
				start += len;
			}
		} else if (action == "last") {
			start = Math.floor((records - 1) / len) * len;
		} else {
			_fnLog(settings, 0, "Unknown paging action: " + action, 5);
		}

		var changed = settings._iDisplayStart !== start;
		settings._iDisplayStart = start;

		if (changed) {
			_fnCallbackFire(settings, null, 'page', [settings]);

			if (redraw) {
				_fnDraw(settings);
			}
		}

		return changed;
	}

	/**
  * Generate the node required for the processing node
  *  @param {object} settings dataTables settings object
  *  @returns {node} Processing element
  *  @memberof DataTable#oApi
  */
	function _fnFeatureHtmlProcessing(settings) {
		return $('<div/>', {
			'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
			'class': settings.oClasses.sProcessing
		}).html(settings.oLanguage.sProcessing).insertBefore(settings.nTable)[0];
	}

	/**
  * Display or hide the processing indicator
  *  @param {object} settings dataTables settings object
  *  @param {bool} show Show the processing indicator (true) or not (false)
  *  @memberof DataTable#oApi
  */
	function _fnProcessingDisplay(settings, show) {
		if (settings.oFeatures.bProcessing) {
			$(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
		}

		_fnCallbackFire(settings, null, 'processing', [settings, show]);
	}

	/**
  * Add any control elements for the table - specifically scrolling
  *  @param {object} settings dataTables settings object
  *  @returns {node} Node to add to the DOM
  *  @memberof DataTable#oApi
  */
	function _fnFeatureHtmlTable(settings) {
		var table = $(settings.nTable);

		// Add the ARIA grid role to the table
		table.attr('role', 'grid');

		// Scrolling from here on in
		var scroll = settings.oScroll;

		if (scroll.sX === '' && scroll.sY === '') {
			return settings.nTable;
		}

		var scrollX = scroll.sX;
		var scrollY = scroll.sY;
		var classes = settings.oClasses;
		var caption = table.children('caption');
		var captionSide = caption.length ? caption[0]._captionSide : null;
		var headerClone = $(table[0].cloneNode(false));
		var footerClone = $(table[0].cloneNode(false));
		var footer = table.children('tfoot');
		var _div = '<div/>';
		var size = function size(s) {
			return !s ? null : _fnStringToCss(s);
		};

		if (!footer.length) {
			footer = null;
		}

		/*
   * The HTML structure that we want to generate in this function is:
   *  div - scroller
   *    div - scroll head
   *      div - scroll head inner
   *        table - scroll head table
   *          thead - thead
   *    div - scroll body
   *      table - table (master table)
   *        thead - thead clone for sizing
   *        tbody - tbody
   *    div - scroll foot
   *      div - scroll foot inner
   *        table - scroll foot table
   *          tfoot - tfoot
   */
		var scroller = $(_div, { 'class': classes.sScrollWrapper }).append($(_div, { 'class': classes.sScrollHead }).css({
			overflow: 'hidden',
			position: 'relative',
			border: 0,
			width: scrollX ? size(scrollX) : '100%'
		}).append($(_div, { 'class': classes.sScrollHeadInner }).css({
			'box-sizing': 'content-box',
			width: scroll.sXInner || '100%'
		}).append(headerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'top' ? caption : null).append(table.children('thead'))))).append($(_div, { 'class': classes.sScrollBody }).css({
			position: 'relative',
			overflow: 'auto',
			width: size(scrollX)
		}).append(table));

		if (footer) {
			scroller.append($(_div, { 'class': classes.sScrollFoot }).css({
				overflow: 'hidden',
				border: 0,
				width: scrollX ? size(scrollX) : '100%'
			}).append($(_div, { 'class': classes.sScrollFootInner }).append(footerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'bottom' ? caption : null).append(table.children('tfoot')))));
		}

		var children = scroller.children();
		var scrollHead = children[0];
		var scrollBody = children[1];
		var scrollFoot = footer ? children[2] : null;

		// When the body is scrolled, then we also want to scroll the headers
		if (scrollX) {
			$(scrollBody).on('scroll.DT', function (e) {
				var scrollLeft = this.scrollLeft;

				scrollHead.scrollLeft = scrollLeft;

				if (footer) {
					scrollFoot.scrollLeft = scrollLeft;
				}
			});
		}

		$(scrollBody).css(scrollY && scroll.bCollapse ? 'max-height' : 'height', scrollY);

		settings.nScrollHead = scrollHead;
		settings.nScrollBody = scrollBody;
		settings.nScrollFoot = scrollFoot;

		// On redraw - align columns
		settings.aoDrawCallback.push({
			"fn": _fnScrollDraw,
			"sName": "scrolling"
		});

		return scroller[0];
	}

	/**
  * Update the header, footer and body tables for resizing - i.e. column
  * alignment.
  *
  * Welcome to the most horrible function DataTables. The process that this
  * function follows is basically:
  *   1. Re-create the table inside the scrolling div
  *   2. Take live measurements from the DOM
  *   3. Apply the measurements to align the columns
  *   4. Clean up
  *
  *  @param {object} settings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnScrollDraw(settings) {
		// Given that this is such a monster function, a lot of variables are use
		// to try and keep the minimised size as small as possible
		var scroll = settings.oScroll,
		    scrollX = scroll.sX,
		    scrollXInner = scroll.sXInner,
		    scrollY = scroll.sY,
		    barWidth = scroll.iBarWidth,
		    divHeader = $(settings.nScrollHead),
		    divHeaderStyle = divHeader[0].style,
		    divHeaderInner = divHeader.children('div'),
		    divHeaderInnerStyle = divHeaderInner[0].style,
		    divHeaderTable = divHeaderInner.children('table'),
		    divBodyEl = settings.nScrollBody,
		    divBody = $(divBodyEl),
		    divBodyStyle = divBodyEl.style,
		    divFooter = $(settings.nScrollFoot),
		    divFooterInner = divFooter.children('div'),
		    divFooterTable = divFooterInner.children('table'),
		    header = $(settings.nTHead),
		    table = $(settings.nTable),
		    tableEl = table[0],
		    tableStyle = tableEl.style,
		    footer = settings.nTFoot ? $(settings.nTFoot) : null,
		    browser = settings.oBrowser,
		    ie67 = browser.bScrollOversize,
		    dtHeaderCells = _pluck(settings.aoColumns, 'nTh'),
		    headerTrgEls,
		    footerTrgEls,
		    headerSrcEls,
		    footerSrcEls,
		    headerCopy,
		    footerCopy,
		    headerWidths = [],
		    footerWidths = [],
		    headerContent = [],
		    footerContent = [],
		    idx,
		    correction,
		    sanityWidth,
		    zeroOut = function zeroOut(nSizer) {
			var style = nSizer.style;
			style.paddingTop = "0";
			style.paddingBottom = "0";
			style.borderTopWidth = "0";
			style.borderBottomWidth = "0";
			style.height = 0;
		};

		// If the scrollbar visibility has changed from the last draw, we need to
		// adjust the column sizes as the table width will have changed to account
		// for the scrollbar
		var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;

		if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) {
			settings.scrollBarVis = scrollBarVis;
			_fnAdjustColumnSizing(settings);
			return; // adjust column sizing will call this function again
		} else {
			settings.scrollBarVis = scrollBarVis;
		}

		/*
   * 1. Re-create the table inside the scrolling div
   */

		// Remove the old minimised thead and tfoot elements in the inner table
		table.children('thead, tfoot').remove();

		if (footer) {
			footerCopy = footer.clone().prependTo(table);
			footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
			footerSrcEls = footerCopy.find('tr');
		}

		// Clone the current header and footer elements and then place it into the inner table
		headerCopy = header.clone().prependTo(table);
		headerTrgEls = header.find('tr'); // original header is in its own table
		headerSrcEls = headerCopy.find('tr');
		headerCopy.find('th, td').removeAttr('tabindex');

		/*
   * 2. Take live measurements from the DOM - do not alter the DOM itself!
   */

		// Remove old sizing and apply the calculated column widths
		// Get the unique column headers in the newly created (cloned) header. We want to apply the
		// calculated sizes to this header
		if (!scrollX) {
			divBodyStyle.width = '100%';
			divHeader[0].style.width = '100%';
		}

		$.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {
			idx = _fnVisibleToColumnIndex(settings, i);
			el.style.width = settings.aoColumns[idx].sWidth;
		});

		if (footer) {
			_fnApplyToChildren(function (n) {
				n.style.width = "";
			}, footerSrcEls);
		}

		// Size the table as a whole
		sanityWidth = table.outerWidth();
		if (scrollX === "") {
			// No x scrolling
			tableStyle.width = "100%";

			// IE7 will make the width of the table when 100% include the scrollbar
			// - which is shouldn't. When there is a scrollbar we need to take this
			// into account.
			if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
				tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
			}

			// Recalculate the sanity width
			sanityWidth = table.outerWidth();
		} else if (scrollXInner !== "") {
			// legacy x scroll inner has been given - use it
			tableStyle.width = _fnStringToCss(scrollXInner);

			// Recalculate the sanity width
			sanityWidth = table.outerWidth();
		}

		// Hidden header should have zero height, so remove padding and borders. Then
		// set the width based on the real headers

		// Apply all styles in one pass
		_fnApplyToChildren(zeroOut, headerSrcEls);

		// Read all widths in next pass
		_fnApplyToChildren(function (nSizer) {
			headerContent.push(nSizer.innerHTML);
			headerWidths.push(_fnStringToCss($(nSizer).css('width')));
		}, headerSrcEls);

		// Apply all widths in final pass
		_fnApplyToChildren(function (nToSize, i) {
			// Only apply widths to the DataTables detected header cells - this
			// prevents complex headers from having contradictory sizes applied
			if ($.inArray(nToSize, dtHeaderCells) !== -1) {
				nToSize.style.width = headerWidths[i];
			}
		}, headerTrgEls);

		$(headerSrcEls).height(0);

		/* Same again with the footer if we have one */
		if (footer) {
			_fnApplyToChildren(zeroOut, footerSrcEls);

			_fnApplyToChildren(function (nSizer) {
				footerContent.push(nSizer.innerHTML);
				footerWidths.push(_fnStringToCss($(nSizer).css('width')));
			}, footerSrcEls);

			_fnApplyToChildren(function (nToSize, i) {
				nToSize.style.width = footerWidths[i];
			}, footerTrgEls);

			$(footerSrcEls).height(0);
		}

		/*
   * 3. Apply the measurements
   */

		// "Hide" the header and footer that we used for the sizing. We need to keep
		// the content of the cell so that the width applied to the header and body
		// both match, but we want to hide it completely. We want to also fix their
		// width to what they currently are
		_fnApplyToChildren(function (nSizer, i) {
			nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + headerContent[i] + '</div>';
			nSizer.style.width = headerWidths[i];
		}, headerSrcEls);

		if (footer) {
			_fnApplyToChildren(function (nSizer, i) {
				nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + footerContent[i] + '</div>';
				nSizer.style.width = footerWidths[i];
			}, footerSrcEls);
		}

		// Sanity check that the table is of a sensible width. If not then we are going to get
		// misalignment - try to prevent this by not allowing the table to shrink below its min width
		if (table.outerWidth() < sanityWidth) {
			// The min width depends upon if we have a vertical scrollbar visible or not */
			correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll" ? sanityWidth + barWidth : sanityWidth;

			// IE6/7 are a law unto themselves...
			if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
				tableStyle.width = _fnStringToCss(correction - barWidth);
			}

			// And give the user a warning that we've stopped the table getting too small
			if (scrollX === "" || scrollXInner !== "") {
				_fnLog(settings, 1, 'Possible column misalignment', 6);
			}
		} else {
			correction = '100%';
		}

		// Apply to the container elements
		divBodyStyle.width = _fnStringToCss(correction);
		divHeaderStyle.width = _fnStringToCss(correction);

		if (footer) {
			settings.nScrollFoot.style.width = _fnStringToCss(correction);
		}

		/*
   * 4. Clean up
   */
		if (!scrollY) {
			/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
    * the scrollbar height from the visible display, rather than adding it on. We need to
    * set the height in order to sort this. Don't want to do it in any other browsers.
    */
			if (ie67) {
				divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
			}
		}

		/* Finally set the width's of the header and footer tables */
		var iOuterWidth = table.outerWidth();
		divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
		divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);

		// Figure out if there are scrollbar present - if so then we need a the header and footer to
		// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
		var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
		var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
		divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";

		if (footer) {
			divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
			divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
			divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
		}

		// Correct DOM ordering for colgroup - comes before the thead
		table.children('colgroup').insertBefore(table.children('thead'));

		/* Adjust the position of the header in case we loose the y-scrollbar */
		divBody.scroll();

		// If sorting or filtering has occurred, jump the scrolling back to the top
		// only if we aren't holding the position
		if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
			divBodyEl.scrollTop = 0;
		}
	}

	/**
  * Apply a given function to the display child nodes of an element array (typically
  * TD children of TR rows
  *  @param {function} fn Method to apply to the objects
  *  @param array {nodes} an1 List of elements to look through for display children
  *  @param array {nodes} an2 Another list (identical structure to the first) - optional
  *  @memberof DataTable#oApi
  */
	function _fnApplyToChildren(fn, an1, an2) {
		var index = 0,
		    i = 0,
		    iLen = an1.length;
		var nNode1, nNode2;

		while (i < iLen) {
			nNode1 = an1[i].firstChild;
			nNode2 = an2 ? an2[i].firstChild : null;

			while (nNode1) {
				if (nNode1.nodeType === 1) {
					if (an2) {
						fn(nNode1, nNode2, index);
					} else {
						fn(nNode1, index);
					}

					index++;
				}

				nNode1 = nNode1.nextSibling;
				nNode2 = an2 ? nNode2.nextSibling : null;
			}

			i++;
		}
	}

	var __re_html_remove = /<.*?>/g;

	/**
  * Calculate the width of columns for the table
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnCalculateColumnWidths(oSettings) {
		var table = oSettings.nTable,
		    columns = oSettings.aoColumns,
		    scroll = oSettings.oScroll,
		    scrollY = scroll.sY,
		    scrollX = scroll.sX,
		    scrollXInner = scroll.sXInner,
		    columnCount = columns.length,
		    visibleColumns = _fnGetColumns(oSettings, 'bVisible'),
		    headerCells = $('th', oSettings.nTHead),
		    tableWidthAttr = table.getAttribute('width'),
		    // from DOM element
		tableContainer = table.parentNode,
		    userInputs = false,
		    i,
		    column,
		    columnIdx,
		    width,
		    outerWidth,
		    browser = oSettings.oBrowser,
		    ie67 = browser.bScrollOversize;

		var styleWidth = table.style.width;
		if (styleWidth && styleWidth.indexOf('%') !== -1) {
			tableWidthAttr = styleWidth;
		}

		/* Convert any user input sizes into pixel sizes */
		for (i = 0; i < visibleColumns.length; i++) {
			column = columns[visibleColumns[i]];

			if (column.sWidth !== null) {
				column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);

				userInputs = true;
			}
		}

		/* If the number of columns in the DOM equals the number that we have to
   * process in DataTables, then we can use the offsets that are created by
   * the web- browser. No custom sizes can be set in order for this to happen,
   * nor scrolling used
   */
		if (ie67 || !userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length) {
			for (i = 0; i < columnCount; i++) {
				var colIdx = _fnVisibleToColumnIndex(oSettings, i);

				if (colIdx !== null) {
					columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width());
				}
			}
		} else {
			// Otherwise construct a single row, worst case, table with the widest
			// node in the data, assign any user defined widths, then insert it into
			// the DOM and allow the browser to do all the hard work of calculating
			// table widths
			var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
			.css('visibility', 'hidden').removeAttr('id');

			// Clean up the table body
			tmpTable.find('tbody tr').remove();
			var tr = $('<tr/>').appendTo(tmpTable.find('tbody'));

			// Clone the table header and footer - we can't use the header / footer
			// from the cloned table, since if scrolling is active, the table's
			// real header and footer are contained in different table tags
			tmpTable.find('thead, tfoot').remove();
			tmpTable.append($(oSettings.nTHead).clone()).append($(oSettings.nTFoot).clone());

			// Remove any assigned widths from the footer (from scrolling)
			tmpTable.find('tfoot th, tfoot td').css('width', '');

			// Apply custom sizing to the cloned header
			headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);

			for (i = 0; i < visibleColumns.length; i++) {
				column = columns[visibleColumns[i]];

				headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : '';

				// For scrollX we need to force the column width otherwise the
				// browser will collapse it. If this width is smaller than the
				// width the column requires, then it will have no effect
				if (column.sWidthOrig && scrollX) {
					$(headerCells[i]).append($('<div/>').css({
						width: column.sWidthOrig,
						margin: 0,
						padding: 0,
						border: 0,
						height: 1
					}));
				}
			}

			// Find the widest cell for each column and put it into the table
			if (oSettings.aoData.length) {
				for (i = 0; i < visibleColumns.length; i++) {
					columnIdx = visibleColumns[i];
					column = columns[columnIdx];

					$(_fnGetWidestNode(oSettings, columnIdx)).clone(false).append(column.sContentPadding).appendTo(tr);
				}
			}

			// Tidy the temporary table - remove name attributes so there aren't
			// duplicated in the dom (radio elements for example)
			$('[name]', tmpTable).removeAttr('name');

			// Table has been built, attach to the document so we can work with it.
			// A holding element is used, positioned at the top of the container
			// with minimal height, so it has no effect on if the container scrolls
			// or not. Otherwise it might trigger scrolling when it actually isn't
			// needed
			var holder = $('<div/>').css(scrollX || scrollY ? {
				position: 'absolute',
				top: 0,
				left: 0,
				height: 1,
				right: 0,
				overflow: 'hidden'
			} : {}).append(tmpTable).appendTo(tableContainer);

			// When scrolling (X or Y) we want to set the width of the table as 
			// appropriate. However, when not scrolling leave the table width as it
			// is. This results in slightly different, but I think correct behaviour
			if (scrollX && scrollXInner) {
				tmpTable.width(scrollXInner);
			} else if (scrollX) {
				tmpTable.css('width', 'auto');
				tmpTable.removeAttr('width');

				// If there is no width attribute or style, then allow the table to
				// collapse
				if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
					tmpTable.width(tableContainer.clientWidth);
				}
			} else if (scrollY) {
				tmpTable.width(tableContainer.clientWidth);
			} else if (tableWidthAttr) {
				tmpTable.width(tableWidthAttr);
			}

			// Get the width of each column in the constructed table - we need to
			// know the inner width (so it can be assigned to the other table's
			// cells) and the outer width so we can calculate the full width of the
			// table. This is safe since DataTables requires a unique cell for each
			// column, but if ever a header can span multiple columns, this will
			// need to be modified.
			var total = 0;
			for (i = 0; i < visibleColumns.length; i++) {
				var cell = $(headerCells[i]);
				var border = cell.outerWidth() - cell.width();

				// Use getBounding... where possible (not IE8-) because it can give
				// sub-pixel accuracy, which we then want to round up!
				var bounding = browser.bBounding ? Math.ceil(headerCells[i].getBoundingClientRect().width) : cell.outerWidth();

				// Total is tracked to remove any sub-pixel errors as the outerWidth
				// of the table might not equal the total given here (IE!).
				total += bounding;

				// Width for each column to use
				columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border);
			}

			table.style.width = _fnStringToCss(total);

			// Finished with the table - ditch it
			holder.remove();
		}

		// If there is a width attr, we want to attach an event listener which
		// allows the table sizing to automatically adjust when the window is
		// resized. Use the width attr rather than CSS, since we can't know if the
		// CSS is a relative value or absolute - DOM read is always px.
		if (tableWidthAttr) {
			table.style.width = _fnStringToCss(tableWidthAttr);
		}

		if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
			var bindResize = function bindResize() {
				$(window).on('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {
					_fnAdjustColumnSizing(oSettings);
				}));
			};

			// IE6/7 will crash if we bind a resize event handler on page load.
			// To be removed in 1.11 which drops IE6/7 support
			if (ie67) {
				setTimeout(bindResize, 1000);
			} else {
				bindResize();
			}

			oSettings._reszEvt = true;
		}
	}

	/**
  * Throttle the calls to a function. Arguments and context are maintained for
  * the throttled function
  *  @param {function} fn Function to be called
  *  @param {int} [freq=200] call frequency in mS
  *  @returns {function} wrapped function
  *  @memberof DataTable#oApi
  */
	var _fnThrottle = DataTable.util.throttle;

	/**
  * Convert a CSS unit width to pixels (e.g. 2em)
  *  @param {string} width width to be converted
  *  @param {node} parent parent to get the with for (required for relative widths) - optional
  *  @returns {int} width in pixels
  *  @memberof DataTable#oApi
  */
	function _fnConvertToWidth(width, parent) {
		if (!width) {
			return 0;
		}

		var n = $('<div/>').css('width', _fnStringToCss(width)).appendTo(parent || document.body);

		var val = n[0].offsetWidth;
		n.remove();

		return val;
	}

	/**
  * Get the widest node
  *  @param {object} settings dataTables settings object
  *  @param {int} colIdx column of interest
  *  @returns {node} widest table node
  *  @memberof DataTable#oApi
  */
	function _fnGetWidestNode(settings, colIdx) {
		var idx = _fnGetMaxLenString(settings, colIdx);
		if (idx < 0) {
			return null;
		}

		var data = settings.aoData[idx];
		return !data.nTr ? // Might not have been created when deferred rendering
		$('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] : data.anCells[colIdx];
	}

	/**
  * Get the maximum strlen for each data column
  *  @param {object} settings dataTables settings object
  *  @param {int} colIdx column of interest
  *  @returns {string} max string length for each column
  *  @memberof DataTable#oApi
  */
	function _fnGetMaxLenString(settings, colIdx) {
		var s,
		    max = -1,
		    maxIdx = -1;

		for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
			s = _fnGetCellData(settings, i, colIdx, 'display') + '';
			s = s.replace(__re_html_remove, '');
			s = s.replace(/&nbsp;/g, ' ');

			if (s.length > max) {
				max = s.length;
				maxIdx = i;
			}
		}

		return maxIdx;
	}

	/**
  * Append a CSS unit (only if required) to a string
  *  @param {string} value to css-ify
  *  @returns {string} value with css unit
  *  @memberof DataTable#oApi
  */
	function _fnStringToCss(s) {
		if (s === null) {
			return '0px';
		}

		if (typeof s == 'number') {
			return s < 0 ? '0px' : s + 'px';
		}

		// Check it has a unit character already
		return s.match(/\d$/) ? s + 'px' : s;
	}

	function _fnSortFlatten(settings) {
		var i,
		    iLen,
		    k,
		    kLen,
		    aSort = [],
		    aiOrig = [],
		    aoColumns = settings.aoColumns,
		    aDataSort,
		    iCol,
		    sType,
		    srcCol,
		    fixed = settings.aaSortingFixed,
		    fixedObj = $.isPlainObject(fixed),
		    nestedSort = [],
		    add = function add(a) {
			if (a.length && !$.isArray(a[0])) {
				// 1D array
				nestedSort.push(a);
			} else {
				// 2D array
				$.merge(nestedSort, a);
			}
		};

		// Build the sort array, with pre-fix and post-fix options if they have been
		// specified
		if ($.isArray(fixed)) {
			add(fixed);
		}

		if (fixedObj && fixed.pre) {
			add(fixed.pre);
		}

		add(settings.aaSorting);

		if (fixedObj && fixed.post) {
			add(fixed.post);
		}

		for (i = 0; i < nestedSort.length; i++) {
			srcCol = nestedSort[i][0];
			aDataSort = aoColumns[srcCol].aDataSort;

			for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
				iCol = aDataSort[k];
				sType = aoColumns[iCol].sType || 'string';

				if (nestedSort[i]._idx === undefined) {
					nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
				}

				aSort.push({
					src: srcCol,
					col: iCol,
					dir: nestedSort[i][1],
					index: nestedSort[i]._idx,
					type: sType,
					formatter: DataTable.ext.type.order[sType + "-pre"]
				});
			}
		}

		return aSort;
	}

	/**
  * Change the order of the table
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  *  @todo This really needs split up!
  */
	function _fnSort(oSettings) {
		var i,
		    ien,
		    iLen,
		    j,
		    jLen,
		    k,
		    kLen,
		    sDataType,
		    nTh,
		    aiOrig = [],
		    oExtSort = DataTable.ext.type.order,
		    aoData = oSettings.aoData,
		    aoColumns = oSettings.aoColumns,
		    aDataSort,
		    data,
		    iCol,
		    sType,
		    oSort,
		    formatters = 0,
		    sortCol,
		    displayMaster = oSettings.aiDisplayMaster,
		    aSort;

		// Resolve any column types that are unknown due to addition or invalidation
		// @todo Can this be moved into a 'data-ready' handler which is called when
		//   data is going to be used in the table?
		_fnColumnTypes(oSettings);

		aSort = _fnSortFlatten(oSettings);

		for (i = 0, ien = aSort.length; i < ien; i++) {
			sortCol = aSort[i];

			// Track if we can use the fast sort algorithm
			if (sortCol.formatter) {
				formatters++;
			}

			// Load the data needed for the sort, for each cell
			_fnSortData(oSettings, sortCol.col);
		}

		/* No sorting required if server-side or no sorting array */
		if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
			// Create a value - key array of the current row positions such that we can use their
			// current position during the sort, if values match, in order to perform stable sorting
			for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
				aiOrig[displayMaster[i]] = i;
			}

			/* Do the sort - here we want multi-column sorting based on a given data source (column)
    * and sorting function (from oSort) in a certain direction. It's reasonably complex to
    * follow on it's own, but this is what we want (example two column sorting):
    *  fnLocalSorting = function(a,b){
    *    var iTest;
    *    iTest = oSort['string-asc']('data11', 'data12');
    *      if (iTest !== 0)
    *        return iTest;
    *    iTest = oSort['numeric-desc']('data21', 'data22');
    *    if (iTest !== 0)
    *      return iTest;
    *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
    *  }
    * Basically we have a test for each sorting column, if the data in that column is equal,
    * test the next column. If all columns match, then we use a numeric sort on the row
    * positions in the original data array to provide a stable sort.
    *
    * Note - I know it seems excessive to have two sorting methods, but the first is around
    * 15% faster, so the second is only maintained for backwards compatibility with sorting
    * methods which do not have a pre-sort formatting function.
    */
			if (formatters === aSort.length) {
				// All sort types have formatting functions
				displayMaster.sort(function (a, b) {
					var x,
					    y,
					    k,
					    test,
					    sort,
					    len = aSort.length,
					    dataA = aoData[a]._aSortData,
					    dataB = aoData[b]._aSortData;

					for (k = 0; k < len; k++) {
						sort = aSort[k];

						x = dataA[sort.col];
						y = dataB[sort.col];

						test = x < y ? -1 : x > y ? 1 : 0;
						if (test !== 0) {
							return sort.dir === 'asc' ? test : -test;
						}
					}

					x = aiOrig[a];
					y = aiOrig[b];
					return x < y ? -1 : x > y ? 1 : 0;
				});
			} else {
				// Depreciated - remove in 1.11 (providing a plug-in option)
				// Not all sort types have formatting methods, so we have to call their sorting
				// methods.
				displayMaster.sort(function (a, b) {
					var x,
					    y,
					    k,
					    l,
					    test,
					    sort,
					    fn,
					    len = aSort.length,
					    dataA = aoData[a]._aSortData,
					    dataB = aoData[b]._aSortData;

					for (k = 0; k < len; k++) {
						sort = aSort[k];

						x = dataA[sort.col];
						y = dataB[sort.col];

						fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
						test = fn(x, y);
						if (test !== 0) {
							return test;
						}
					}

					x = aiOrig[a];
					y = aiOrig[b];
					return x < y ? -1 : x > y ? 1 : 0;
				});
			}
		}

		/* Tell the draw function that we have sorted the data */
		oSettings.bSorted = true;
	}

	function _fnSortAria(settings) {
		var label;
		var nextSort;
		var columns = settings.aoColumns;
		var aSort = _fnSortFlatten(settings);
		var oAria = settings.oLanguage.oAria;

		// ARIA attributes - need to loop all columns, to update all (removing old
		// attributes as needed)
		for (var i = 0, iLen = columns.length; i < iLen; i++) {
			var col = columns[i];
			var asSorting = col.asSorting;
			var sTitle = col.sTitle.replace(/<.*?>/g, "");
			var th = col.nTh;

			// IE7 is throwing an error when setting these properties with jQuery's
			// attr() and removeAttr() methods...
			th.removeAttribute('aria-sort');

			/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
			if (col.bSortable) {
				if (aSort.length > 0 && aSort[0].col == i) {
					th.setAttribute('aria-sort', aSort[0].dir == "asc" ? "ascending" : "descending");
					nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
				} else {
					nextSort = asSorting[0];
				}

				label = sTitle + (nextSort === "asc" ? oAria.sSortAscending : oAria.sSortDescending);
			} else {
				label = sTitle;
			}

			th.setAttribute('aria-label', label);
		}
	}

	/**
  * Function to run on user sort request
  *  @param {object} settings dataTables settings object
  *  @param {node} attachTo node to attach the handler to
  *  @param {int} colIdx column sorting index
  *  @param {boolean} [append=false] Append the requested sort to the existing
  *    sort if true (i.e. multi-column sort)
  *  @param {function} [callback] callback function
  *  @memberof DataTable#oApi
  */
	function _fnSortListener(settings, colIdx, append, callback) {
		var col = settings.aoColumns[colIdx];
		var sorting = settings.aaSorting;
		var asSorting = col.asSorting;
		var nextSortIdx;
		var next = function next(a, overflow) {
			var idx = a._idx;
			if (idx === undefined) {
				idx = $.inArray(a[1], asSorting);
			}

			return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
		};

		// Convert to 2D array if needed
		if (typeof sorting[0] === 'number') {
			sorting = settings.aaSorting = [sorting];
		}

		// If appending the sort then we are multi-column sorting
		if (append && settings.oFeatures.bSortMulti) {
			// Are we already doing some kind of sort on this column?
			var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));

			if (sortIdx !== -1) {
				// Yes, modify the sort
				nextSortIdx = next(sorting[sortIdx], true);

				if (nextSortIdx === null && sorting.length === 1) {
					nextSortIdx = 0; // can't remove sorting completely
				}

				if (nextSortIdx === null) {
					sorting.splice(sortIdx, 1);
				} else {
					sorting[sortIdx][1] = asSorting[nextSortIdx];
					sorting[sortIdx]._idx = nextSortIdx;
				}
			} else {
				// No sort on this column yet
				sorting.push([colIdx, asSorting[0], 0]);
				sorting[sorting.length - 1]._idx = 0;
			}
		} else if (sorting.length && sorting[0][0] == colIdx) {
			// Single column - already sorting on this column, modify the sort
			nextSortIdx = next(sorting[0]);

			sorting.length = 1;
			sorting[0][1] = asSorting[nextSortIdx];
			sorting[0]._idx = nextSortIdx;
		} else {
			// Single column - sort only on this column
			sorting.length = 0;
			sorting.push([colIdx, asSorting[0]]);
			sorting[0]._idx = 0;
		}

		// Run the sort by calling a full redraw
		_fnReDraw(settings);

		// callback used for async user interaction
		if (typeof callback == 'function') {
			callback(settings);
		}
	}

	/**
  * Attach a sort handler (click) to a node
  *  @param {object} settings dataTables settings object
  *  @param {node} attachTo node to attach the handler to
  *  @param {int} colIdx column sorting index
  *  @param {function} [callback] callback function
  *  @memberof DataTable#oApi
  */
	function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
		var col = settings.aoColumns[colIdx];

		_fnBindAction(attachTo, {}, function (e) {
			/* If the column is not sortable - don't to anything */
			if (col.bSortable === false) {
				return;
			}

			// If processing is enabled use a timeout to allow the processing
			// display to be shown - otherwise to it synchronously
			if (settings.oFeatures.bProcessing) {
				_fnProcessingDisplay(settings, true);

				setTimeout(function () {
					_fnSortListener(settings, colIdx, e.shiftKey, callback);

					// In server-side processing, the draw callback will remove the
					// processing display
					if (_fnDataSource(settings) !== 'ssp') {
						_fnProcessingDisplay(settings, false);
					}
				}, 0);
			} else {
				_fnSortListener(settings, colIdx, e.shiftKey, callback);
			}
		});
	}

	/**
  * Set the sorting classes on table's body, Note: it is safe to call this function
  * when bSort and bSortClasses are false
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnSortingClasses(settings) {
		var oldSort = settings.aLastSort;
		var sortClass = settings.oClasses.sSortColumn;
		var sort = _fnSortFlatten(settings);
		var features = settings.oFeatures;
		var i, ien, colIdx;

		if (features.bSort && features.bSortClasses) {
			// Remove old sorting classes
			for (i = 0, ien = oldSort.length; i < ien; i++) {
				colIdx = oldSort[i].src;

				// Remove column sorting
				$(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
			}

			// Add new column sorting
			for (i = 0, ien = sort.length; i < ien; i++) {
				colIdx = sort[i].src;

				$(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
			}
		}

		settings.aLastSort = sort;
	}

	// Get the data to sort a column, be it from cache, fresh (populating the
	// cache), or from a sort formatter
	function _fnSortData(settings, idx) {
		// Custom sorting function - provided by the sort data type
		var column = settings.aoColumns[idx];
		var customSort = DataTable.ext.order[column.sSortDataType];
		var customData;

		if (customSort) {
			customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx));
		}

		// Use / populate cache
		var row, cellData;
		var formatter = DataTable.ext.type.order[column.sType + "-pre"];

		for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
			row = settings.aoData[i];

			if (!row._aSortData) {
				row._aSortData = [];
			}

			if (!row._aSortData[idx] || customSort) {
				cellData = customSort ? customData[i] : // If there was a custom sort function, use data from there
				_fnGetCellData(settings, i, idx, 'sort');

				row._aSortData[idx] = formatter ? formatter(cellData) : cellData;
			}
		}
	}

	/**
  * Save the state of a table
  *  @param {object} oSettings dataTables settings object
  *  @memberof DataTable#oApi
  */
	function _fnSaveState(settings) {
		if (!settings.oFeatures.bStateSave || settings.bDestroying) {
			return;
		}

		/* Store the interesting variables */
		var state = {
			time: +new Date(),
			start: settings._iDisplayStart,
			length: settings._iDisplayLength,
			order: $.extend(true, [], settings.aaSorting),
			search: _fnSearchToCamel(settings.oPreviousSearch),
			columns: $.map(settings.aoColumns, function (col, i) {
				return {
					visible: col.bVisible,
					search: _fnSearchToCamel(settings.aoPreSearchCols[i])
				};
			})
		};

		_fnCallbackFire(settings, "aoStateSaveParams", 'stateSaveParams', [settings, state]);

		settings.oSavedState = state;
		settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
	}

	/**
  * Attempt to load a saved table state
  *  @param {object} oSettings dataTables settings object
  *  @param {object} oInit DataTables init object so we can override settings
  *  @param {function} callback Callback to execute when the state has been loaded
  *  @memberof DataTable#oApi
  */
	function _fnLoadState(settings, oInit, callback) {
		var i, ien;
		var columns = settings.aoColumns;
		var loaded = function loaded(s) {
			if (!s || !s.time) {
				callback();
				return;
			}

			// Allow custom and plug-in manipulation functions to alter the saved data set and
			// cancelling of loading by returning false
			var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s]);
			if ($.inArray(false, abStateLoad) !== -1) {
				callback();
				return;
			}

			// Reject old data
			var duration = settings.iStateDuration;
			if (duration > 0 && s.time < +new Date() - duration * 1000) {
				callback();
				return;
			}

			// Number of columns have changed - all bets are off, no restore of settings
			if (s.columns && columns.length !== s.columns.length) {
				callback();
				return;
			}

			// Store the saved state so it might be accessed at any time
			settings.oLoadedState = $.extend(true, {}, s);

			// Restore key features - todo - for 1.11 this needs to be done by
			// subscribed events
			if (s.start !== undefined) {
				settings._iDisplayStart = s.start;
				settings.iInitDisplayStart = s.start;
			}
			if (s.length !== undefined) {
				settings._iDisplayLength = s.length;
			}

			// Order
			if (s.order !== undefined) {
				settings.aaSorting = [];
				$.each(s.order, function (i, col) {
					settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col);
				});
			}

			// Search
			if (s.search !== undefined) {
				$.extend(settings.oPreviousSearch, _fnSearchToHung(s.search));
			}

			// Columns
			//
			if (s.columns) {
				for (i = 0, ien = s.columns.length; i < ien; i++) {
					var col = s.columns[i];

					// Visibility
					if (col.visible !== undefined) {
						columns[i].bVisible = col.visible;
					}

					// Search
					if (col.search !== undefined) {
						$.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
					}
				}
			}

			_fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, s]);
			callback();
		};

		if (!settings.oFeatures.bStateSave) {
			callback();
			return;
		}

		var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);

		if (state !== undefined) {
			loaded(state);
		}
		// otherwise, wait for the loaded callback to be executed
	}

	/**
  * Return the settings object for a particular table
  *  @param {node} table table we are using as a dataTable
  *  @returns {object} Settings object - or null if not found
  *  @memberof DataTable#oApi
  */
	function _fnSettingsFromNode(table) {
		var settings = DataTable.settings;
		var idx = $.inArray(table, _pluck(settings, 'nTable'));

		return idx !== -1 ? settings[idx] : null;
	}

	/**
  * Log an error message
  *  @param {object} settings dataTables settings object
  *  @param {int} level log error messages, or display them to the user
  *  @param {string} msg error message
  *  @param {int} tn Technical note id to get more information about the error.
  *  @memberof DataTable#oApi
  */
	function _fnLog(settings, level, msg, tn) {
		msg = 'DataTables warning: ' + (settings ? 'table id=' + settings.sTableId + ' - ' : '') + msg;

		if (tn) {
			msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn;
		}

		if (!level) {
			// Backwards compatibility pre 1.10
			var ext = DataTable.ext;
			var type = ext.sErrMode || ext.errMode;

			if (settings) {
				_fnCallbackFire(settings, null, 'error', [settings, tn, msg]);
			}

			if (type == 'alert') {
				alert(msg);
			} else if (type == 'throw') {
				throw new Error(msg);
			} else if (typeof type == 'function') {
				type(settings, tn, msg);
			}
		} else if (window.console && console.log) {
			console.log(msg);
		}
	}

	/**
  * See if a property is defined on one object, if so assign it to the other object
  *  @param {object} ret target object
  *  @param {object} src source object
  *  @param {string} name property
  *  @param {string} [mappedName] name to map too - optional, name used if not given
  *  @memberof DataTable#oApi
  */
	function _fnMap(ret, src, name, mappedName) {
		if ($.isArray(name)) {
			$.each(name, function (i, val) {
				if ($.isArray(val)) {
					_fnMap(ret, src, val[0], val[1]);
				} else {
					_fnMap(ret, src, val);
				}
			});

			return;
		}

		if (mappedName === undefined) {
			mappedName = name;
		}

		if (src[name] !== undefined) {
			ret[mappedName] = src[name];
		}
	}

	/**
  * Extend objects - very similar to jQuery.extend, but deep copy objects, and
  * shallow copy arrays. The reason we need to do this, is that we don't want to
  * deep copy array init values (such as aaSorting) since the dev wouldn't be
  * able to override them, but we do want to deep copy arrays.
  *  @param {object} out Object to extend
  *  @param {object} extender Object from which the properties will be applied to
  *      out
  *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
  *      independent copy with the exception of the `data` or `aaData` parameters
  *      if they are present. This is so you can pass in a collection to
  *      DataTables and have that used as your data source without breaking the
  *      references
  *  @returns {object} out Reference, just for convenience - out === the return.
  *  @memberof DataTable#oApi
  *  @todo This doesn't take account of arrays inside the deep copied objects.
  */
	function _fnExtend(out, extender, breakRefs) {
		var val;

		for (var prop in extender) {
			if (extender.hasOwnProperty(prop)) {
				val = extender[prop];

				if ($.isPlainObject(val)) {
					if (!$.isPlainObject(out[prop])) {
						out[prop] = {};
					}
					$.extend(true, out[prop], val);
				} else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {
					out[prop] = val.slice();
				} else {
					out[prop] = val;
				}
			}
		}

		return out;
	}

	/**
  * Bind an event handers to allow a click or return key to activate the callback.
  * This is good for accessibility since a return on the keyboard will have the
  * same effect as a click, if the element has focus.
  *  @param {element} n Element to bind the action to
  *  @param {object} oData Data object to pass to the triggered function
  *  @param {function} fn Callback function for when the event is triggered
  *  @memberof DataTable#oApi
  */
	function _fnBindAction(n, oData, fn) {
		$(n).on('click.DT', oData, function (e) {
			n.blur(); // Remove focus outline for mouse users
			fn(e);
		}).on('keypress.DT', oData, function (e) {
			if (e.which === 13) {
				e.preventDefault();
				fn(e);
			}
		}).on('selectstart.DT', function () {
			/* Take the brutal approach to cancelling text selection */
			return false;
		});
	}

	/**
  * Register a callback function. Easily allows a callback function to be added to
  * an array store of callback functions that can then all be called together.
  *  @param {object} oSettings dataTables settings object
  *  @param {string} sStore Name of the array storage for the callbacks in oSettings
  *  @param {function} fn Function to be called back
  *  @param {string} sName Identifying name for the callback (i.e. a label)
  *  @memberof DataTable#oApi
  */
	function _fnCallbackReg(oSettings, sStore, fn, sName) {
		if (fn) {
			oSettings[sStore].push({
				"fn": fn,
				"sName": sName
			});
		}
	}

	/**
  * Fire callback functions and trigger events. Note that the loop over the
  * callback array store is done backwards! Further note that you do not want to
  * fire off triggers in time sensitive applications (for example cell creation)
  * as its slow.
  *  @param {object} settings dataTables settings object
  *  @param {string} callbackArr Name of the array storage for the callbacks in
  *      oSettings
  *  @param {string} eventName Name of the jQuery custom event to trigger. If
  *      null no trigger is fired
  *  @param {array} args Array of arguments to pass to the callback function /
  *      trigger
  *  @memberof DataTable#oApi
  */
	function _fnCallbackFire(settings, callbackArr, eventName, args) {
		var ret = [];

		if (callbackArr) {
			ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {
				return val.fn.apply(settings.oInstance, args);
			});
		}

		if (eventName !== null) {
			var e = $.Event(eventName + '.dt');

			$(settings.nTable).trigger(e, args);

			ret.push(e.result);
		}

		return ret;
	}

	function _fnLengthOverflow(settings) {
		var start = settings._iDisplayStart,
		    end = settings.fnDisplayEnd(),
		    len = settings._iDisplayLength;

		/* If we have space to show extra rows (backing up from the end point - then do so */
		if (start >= end) {
			start = end - len;
		}

		// Keep the start record on the current page
		start -= start % len;

		if (len === -1 || start < 0) {
			start = 0;
		}

		settings._iDisplayStart = start;
	}

	function _fnRenderer(settings, type) {
		var renderer = settings.renderer;
		var host = DataTable.ext.renderer[type];

		if ($.isPlainObject(renderer) && renderer[type]) {
			// Specific renderer for this type. If available use it, otherwise use
			// the default.
			return host[renderer[type]] || host._;
		} else if (typeof renderer === 'string') {
			// Common renderer - if there is one available for this type use it,
			// otherwise use the default
			return host[renderer] || host._;
		}

		// Use the default
		return host._;
	}

	/**
  * Detect the data source being used for the table. Used to simplify the code
  * a little (ajax) and to make it compress a little smaller.
  *
  *  @param {object} settings dataTables settings object
  *  @returns {string} Data source
  *  @memberof DataTable#oApi
  */
	function _fnDataSource(settings) {
		if (settings.oFeatures.bServerSide) {
			return 'ssp';
		} else if (settings.ajax || settings.sAjaxSource) {
			return 'ajax';
		}
		return 'dom';
	}

	/**
  * Computed structure of the DataTables API, defined by the options passed to
  * `DataTable.Api.register()` when building the API.
  *
  * The structure is built in order to speed creation and extension of the Api
  * objects since the extensions are effectively pre-parsed.
  *
  * The array is an array of objects with the following structure, where this
  * base array represents the Api prototype base:
  *
  *     [
  *       {
  *         name:      'data'                -- string   - Property name
  *         val:       function () {},       -- function - Api method (or undefined if just an object
  *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
  *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
  *       },
  *       {
  *         name:     'row'
  *         val:       {},
  *         methodExt: [ ... ],
  *         propExt:   [
  *           {
  *             name:      'data'
  *             val:       function () {},
  *             methodExt: [ ... ],
  *             propExt:   [ ... ]
  *           },
  *           ...
  *         ]
  *       }
  *     ]
  *
  * @type {Array}
  * @ignore
  */
	var __apiStruct = [];

	/**
  * `Array.prototype` reference.
  *
  * @type object
  * @ignore
  */
	var __arrayProto = Array.prototype;

	/**
  * Abstraction for `context` parameter of the `Api` constructor to allow it to
  * take several different forms for ease of use.
  *
  * Each of the input parameter types will be converted to a DataTables settings
  * object where possible.
  *
  * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
  *   of:
  *
  *   * `string` - jQuery selector. Any DataTables' matching the given selector
  *     with be found and used.
  *   * `node` - `TABLE` node which has already been formed into a DataTable.
  *   * `jQuery` - A jQuery object of `TABLE` nodes.
  *   * `object` - DataTables settings object
  *   * `DataTables.Api` - API instance
  * @return {array|null} Matching DataTables settings objects. `null` or
  *   `undefined` is returned if no matching DataTable is found.
  * @ignore
  */
	var _toSettings = function _toSettings(mixed) {
		var idx, jq;
		var settings = DataTable.settings;
		var tables = $.map(settings, function (el, i) {
			return el.nTable;
		});

		if (!mixed) {
			return [];
		} else if (mixed.nTable && mixed.oApi) {
			// DataTables settings object
			return [mixed];
		} else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
			// Table node
			idx = $.inArray(mixed, tables);
			return idx !== -1 ? [settings[idx]] : null;
		} else if (mixed && typeof mixed.settings === 'function') {
			return mixed.settings().toArray();
		} else if (typeof mixed === 'string') {
			// jQuery selector
			jq = $(mixed);
		} else if (mixed instanceof $) {
			// jQuery object (also DataTables instance)
			jq = mixed;
		}

		if (jq) {
			return jq.map(function (i) {
				idx = $.inArray(this, tables);
				return idx !== -1 ? settings[idx] : null;
			}).toArray();
		}
	};

	/**
  * DataTables API class - used to control and interface with  one or more
  * DataTables enhanced tables.
  *
  * The API class is heavily based on jQuery, presenting a chainable interface
  * that you can use to interact with tables. Each instance of the API class has
  * a "context" - i.e. the tables that it will operate on. This could be a single
  * table, all tables on a page or a sub-set thereof.
  *
  * Additionally the API is designed to allow you to easily work with the data in
  * the tables, retrieving and manipulating it as required. This is done by
  * presenting the API class as an array like interface. The contents of the
  * array depend upon the actions requested by each method (for example
  * `rows().nodes()` will return an array of nodes, while `rows().data()` will
  * return an array of objects or arrays depending upon your table's
  * configuration). The API object has a number of array like methods (`push`,
  * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
  * `unique` etc) to assist your working with the data held in a table.
  *
  * Most methods (those which return an Api instance) are chainable, which means
  * the return from a method call also has all of the methods available that the
  * top level object had. For example, these two calls are equivalent:
  *
  *     // Not chained
  *     api.row.add( {...} );
  *     api.draw();
  *
  *     // Chained
  *     api.row.add( {...} ).draw();
  *
  * @class DataTable.Api
  * @param {array|object|string|jQuery} context DataTable identifier. This is
  *   used to define which DataTables enhanced tables this API will operate on.
  *   Can be one of:
  *
  *   * `string` - jQuery selector. Any DataTables' matching the given selector
  *     with be found and used.
  *   * `node` - `TABLE` node which has already been formed into a DataTable.
  *   * `jQuery` - A jQuery object of `TABLE` nodes.
  *   * `object` - DataTables settings object
  * @param {array} [data] Data to initialise the Api instance with.
  *
  * @example
  *   // Direct initialisation during DataTables construction
  *   var api = $('#example').DataTable();
  *
  * @example
  *   // Initialisation using a DataTables jQuery object
  *   var api = $('#example').dataTable().api();
  *
  * @example
  *   // Initialisation as a constructor
  *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
  */
	_Api2 = function _Api(context, data) {
		if (!(this instanceof _Api2)) {
			return new _Api2(context, data);
		}

		var settings = [];
		var ctxSettings = function ctxSettings(o) {
			var a = _toSettings(o);
			if (a) {
				settings = settings.concat(a);
			}
		};

		if ($.isArray(context)) {
			for (var i = 0, ien = context.length; i < ien; i++) {
				ctxSettings(context[i]);
			}
		} else {
			ctxSettings(context);
		}

		// Remove duplicates
		this.context = _unique(settings);

		// Initial data
		if (data) {
			$.merge(this, data);
		}

		// selector
		this.selector = {
			rows: null,
			cols: null,
			opts: null
		};

		_Api2.extend(this, this, __apiStruct);
	};

	DataTable.Api = _Api2;

	// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
	// isPlainObject.
	$.extend(_Api2.prototype, {
		any: function any() {
			return this.count() !== 0;
		},

		concat: __arrayProto.concat,

		context: [], // array of table settings objects


		count: function count() {
			return this.flatten().length;
		},

		each: function each(fn) {
			for (var i = 0, ien = this.length; i < ien; i++) {
				fn.call(this, this[i], i, this);
			}

			return this;
		},

		eq: function eq(idx) {
			var ctx = this.context;

			return ctx.length > idx ? new _Api2(ctx[idx], this[idx]) : null;
		},

		filter: function filter(fn) {
			var a = [];

			if (__arrayProto.filter) {
				a = __arrayProto.filter.call(this, fn, this);
			} else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for (var i = 0, ien = this.length; i < ien; i++) {
					if (fn.call(this, this[i], i, this)) {
						a.push(this[i]);
					}
				}
			}

			return new _Api2(this.context, a);
		},

		flatten: function flatten() {
			var a = [];
			return new _Api2(this.context, a.concat.apply(a, this.toArray()));
		},

		join: __arrayProto.join,

		indexOf: __arrayProto.indexOf || function (obj, start) {
			for (var i = start || 0, ien = this.length; i < ien; i++) {
				if (this[i] === obj) {
					return i;
				}
			}
			return -1;
		},

		iterator: function iterator(flatten, type, fn, alwaysNew) {
			var a = [],
			    ret,
			    i,
			    ien,
			    j,
			    jen,
			    context = this.context,
			    rows,
			    items,
			    item,
			    selector = this.selector;

			// Argument shifting
			if (typeof flatten === 'string') {
				alwaysNew = fn;
				fn = type;
				type = flatten;
				flatten = false;
			}

			for (i = 0, ien = context.length; i < ien; i++) {
				var apiInst = new _Api2(context[i]);

				if (type === 'table') {
					ret = fn.call(apiInst, context[i], i);

					if (ret !== undefined) {
						a.push(ret);
					}
				} else if (type === 'columns' || type === 'rows') {
					// this has same length as context - one entry for each table
					ret = fn.call(apiInst, context[i], this[i], i);

					if (ret !== undefined) {
						a.push(ret);
					}
				} else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
					// columns and rows share the same structure.
					// 'this' is an array of column indexes for each context
					items = this[i];

					if (type === 'column-rows') {
						rows = _selector_row_indexes(context[i], selector.opts);
					}

					for (j = 0, jen = items.length; j < jen; j++) {
						item = items[j];

						if (type === 'cell') {
							ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
						} else {
							ret = fn.call(apiInst, context[i], item, i, j, rows);
						}

						if (ret !== undefined) {
							a.push(ret);
						}
					}
				}
			}

			if (a.length || alwaysNew) {
				var api = new _Api2(context, flatten ? a.concat.apply([], a) : a);
				var apiSelector = api.selector;
				apiSelector.rows = selector.rows;
				apiSelector.cols = selector.cols;
				apiSelector.opts = selector.opts;
				return api;
			}
			return this;
		},

		lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {
			// Bit cheeky...
			return this.indexOf.apply(this.toArray.reverse(), arguments);
		},

		length: 0,

		map: function map(fn) {
			var a = [];

			if (__arrayProto.map) {
				a = __arrayProto.map.call(this, fn, this);
			} else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for (var i = 0, ien = this.length; i < ien; i++) {
					a.push(fn.call(this, this[i], i));
				}
			}

			return new _Api2(this.context, a);
		},

		pluck: function pluck(prop) {
			return this.map(function (el) {
				return el[prop];
			});
		},

		pop: __arrayProto.pop,

		push: __arrayProto.push,

		// Does not return an API instance
		reduce: __arrayProto.reduce || function (fn, init) {
			return _fnReduce(this, fn, init, 0, this.length, 1);
		},

		reduceRight: __arrayProto.reduceRight || function (fn, init) {
			return _fnReduce(this, fn, init, this.length - 1, -1, -1);
		},

		reverse: __arrayProto.reverse,

		// Object with rows, columns and opts
		selector: null,

		shift: __arrayProto.shift,

		slice: function slice() {
			return new _Api2(this.context, this);
		},

		sort: __arrayProto.sort, // ? name - order?


		splice: __arrayProto.splice,

		toArray: function toArray() {
			return __arrayProto.slice.call(this);
		},

		to$: function to$() {
			return $(this);
		},

		toJQuery: function toJQuery() {
			return $(this);
		},

		unique: function unique() {
			return new _Api2(this.context, _unique(this));
		},

		unshift: __arrayProto.unshift
	});

	_Api2.extend = function (scope, obj, ext) {
		// Only extend API instances and static properties of the API
		if (!ext.length || !obj || !(obj instanceof _Api2) && !obj.__dt_wrapper) {
			return;
		}

		var i,
		    ien,
		    j,
		    jen,
		    struct,
		    inner,
		    methodScoping = function methodScoping(scope, fn, struc) {
			return function () {
				var ret = fn.apply(scope, arguments);

				// Method extension
				_Api2.extend(ret, ret, struc.methodExt);
				return ret;
			};
		};

		for (i = 0, ien = ext.length; i < ien; i++) {
			struct = ext[i];

			// Value
			obj[struct.name] = typeof struct.val === 'function' ? methodScoping(scope, struct.val, struct) : $.isPlainObject(struct.val) ? {} : struct.val;

			obj[struct.name].__dt_wrapper = true;

			// Property extension
			_Api2.extend(scope, obj[struct.name], struct.propExt);
		}
	};

	// @todo - Is there need for an augment function?
	// _Api.augment = function ( inst, name )
	// {
	// 	// Find src object in the structure from the name
	// 	var parts = name.split('.');

	// 	_Api.extend( inst, obj );
	// };


	//     [
	//       {
	//         name:      'data'                -- string   - Property name
	//         val:       function () {},       -- function - Api method (or undefined if just an object
	//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	//       },
	//       {
	//         name:     'row'
	//         val:       {},
	//         methodExt: [ ... ],
	//         propExt:   [
	//           {
	//             name:      'data'
	//             val:       function () {},
	//             methodExt: [ ... ],
	//             propExt:   [ ... ]
	//           },
	//           ...
	//         ]
	//       }
	//     ]

	_Api2.register = _api_register = function _api_register(name, val) {
		if ($.isArray(name)) {
			for (var j = 0, jen = name.length; j < jen; j++) {
				_Api2.register(name[j], val);
			}
			return;
		}

		var i,
		    ien,
		    heir = name.split('.'),
		    struct = __apiStruct,
		    key,
		    method;

		var find = function find(src, name) {
			for (var i = 0, ien = src.length; i < ien; i++) {
				if (src[i].name === name) {
					return src[i];
				}
			}
			return null;
		};

		for (i = 0, ien = heir.length; i < ien; i++) {
			method = heir[i].indexOf('()') !== -1;
			key = method ? heir[i].replace('()', '') : heir[i];

			var src = find(struct, key);
			if (!src) {
				src = {
					name: key,
					val: {},
					methodExt: [],
					propExt: []
				};
				struct.push(src);
			}

			if (i === ien - 1) {
				src.val = val;
			} else {
				struct = method ? src.methodExt : src.propExt;
			}
		}
	};

	_Api2.registerPlural = _api_registerPlural = function _api_registerPlural(pluralName, singularName, val) {
		_Api2.register(pluralName, val);

		_Api2.register(singularName, function () {
			var ret = val.apply(this, arguments);

			if (ret === this) {
				// Returned item is the API instance that was passed in, return it
				return this;
			} else if (ret instanceof _Api2) {
				// New API instance returned, want the value from the first item
				// in the returned array for the singular result.
				return ret.length ? $.isArray(ret[0]) ? new _Api2(ret.context, ret[0]) : // Array results are 'enhanced'
				ret[0] : undefined;
			}

			// Non-API return - just fire it back
			return ret;
		});
	};

	/**
  * Selector for HTML tables. Apply the given selector to the give array of
  * DataTables settings objects.
  *
  * @param {string|integer} [selector] jQuery selector string or integer
  * @param  {array} Array of DataTables settings objects to be filtered
  * @return {array}
  * @ignore
  */
	var __table_selector = function __table_selector(selector, a) {
		// Integer is used to pick out a table by index
		if (typeof selector === 'number') {
			return [a[selector]];
		}

		// Perform a jQuery selector on the table nodes
		var nodes = $.map(a, function (el, i) {
			return el.nTable;
		});

		return $(nodes).filter(selector).map(function (i) {
			// Need to translate back from the table node to the settings
			var idx = $.inArray(this, nodes);
			return a[idx];
		}).toArray();
	};

	/**
  * Context selector for the API's context (i.e. the tables the API instance
  * refers to.
  *
  * @name    DataTable.Api#tables
  * @param {string|integer} [selector] Selector to pick which tables the iterator
  *   should operate on. If not given, all tables in the current context are
  *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
  *   select multiple tables or as an integer to select a single table.
  * @returns {DataTable.Api} Returns a new API instance if a selector is given.
  */
	_api_register('tables()', function (selector) {
		// A new instance is created if there was a selector specified
		return selector ? new _Api2(__table_selector(selector, this.context)) : this;
	});

	_api_register('table()', function (selector) {
		var tables = this.tables(selector);
		var ctx = tables.context;

		// Truncate to the first matched table
		return ctx.length ? new _Api2(ctx[0]) : tables;
	});

	_api_registerPlural('tables().nodes()', 'table().node()', function () {
		return this.iterator('table', function (ctx) {
			return ctx.nTable;
		}, 1);
	});

	_api_registerPlural('tables().body()', 'table().body()', function () {
		return this.iterator('table', function (ctx) {
			return ctx.nTBody;
		}, 1);
	});

	_api_registerPlural('tables().header()', 'table().header()', function () {
		return this.iterator('table', function (ctx) {
			return ctx.nTHead;
		}, 1);
	});

	_api_registerPlural('tables().footer()', 'table().footer()', function () {
		return this.iterator('table', function (ctx) {
			return ctx.nTFoot;
		}, 1);
	});

	_api_registerPlural('tables().containers()', 'table().container()', function () {
		return this.iterator('table', function (ctx) {
			return ctx.nTableWrapper;
		}, 1);
	});

	/**
  * Redraw the tables in the current context.
  */
	_api_register('draw()', function (paging) {
		return this.iterator('table', function (settings) {
			if (paging === 'page') {
				_fnDraw(settings);
			} else {
				if (typeof paging === 'string') {
					paging = paging === 'full-hold' ? false : true;
				}

				_fnReDraw(settings, paging === false);
			}
		});
	});

	/**
  * Get the current page index.
  *
  * @return {integer} Current page index (zero based)
  */ /**
     * Set the current page.
     *
     * Note that if you attempt to show a page which does not exist, DataTables will
     * not throw an error, but rather reset the paging.
     *
     * @param {integer|string} action The paging action to take. This can be one of:
     *  * `integer` - The page index to jump to
     *  * `string` - An action to take:
     *    * `first` - Jump to first page.
     *    * `next` - Jump to the next page
     *    * `previous` - Jump to previous page
     *    * `last` - Jump to the last page.
     * @returns {DataTables.Api} this
     */
	_api_register('page()', function (action) {
		if (action === undefined) {
			return this.page.info().page; // not an expensive call
		}

		// else, have an action to take on all tables
		return this.iterator('table', function (settings) {
			_fnPageChange(settings, action);
		});
	});

	/**
  * Paging information for the first table in the current context.
  *
  * If you require paging information for another table, use the `table()` method
  * with a suitable selector.
  *
  * @return {object} Object with the following properties set:
  *  * `page` - Current page index (zero based - i.e. the first page is `0`)
  *  * `pages` - Total number of pages
  *  * `start` - Display index for the first record shown on the current page
  *  * `end` - Display index for the last record shown on the current page
  *  * `length` - Display length (number of records). Note that generally `start
  *    + length = end`, but this is not always true, for example if there are
  *    only 2 records to show on the final page, with a length of 10.
  *  * `recordsTotal` - Full data set length
  *  * `recordsDisplay` - Data set length once the current filtering criterion
  *    are applied.
  */
	_api_register('page.info()', function (action) {
		if (this.context.length === 0) {
			return undefined;
		}

		var settings = this.context[0],
		    start = settings._iDisplayStart,
		    len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
		    visRecords = settings.fnRecordsDisplay(),
		    all = len === -1;

		return {
			"page": all ? 0 : Math.floor(start / len),
			"pages": all ? 1 : Math.ceil(visRecords / len),
			"start": start,
			"end": settings.fnDisplayEnd(),
			"length": len,
			"recordsTotal": settings.fnRecordsTotal(),
			"recordsDisplay": visRecords,
			"serverSide": _fnDataSource(settings) === 'ssp'
		};
	});

	/**
  * Get the current page length.
  *
  * @return {integer} Current page length. Note `-1` indicates that all records
  *   are to be shown.
  */ /**
     * Set the current page length.
     *
     * @param {integer} Page length to set. Use `-1` to show all records.
     * @returns {DataTables.Api} this
     */
	_api_register('page.len()', function (len) {
		// Note that we can't call this function 'length()' because `length`
		// is a Javascript property of functions which defines how many arguments
		// the function expects.
		if (len === undefined) {
			return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined;
		}

		// else, set the page length
		return this.iterator('table', function (settings) {
			_fnLengthChange(settings, len);
		});
	});

	var __reload = function __reload(settings, holdPosition, callback) {
		// Use the draw event to trigger a callback
		if (callback) {
			var api = new _Api2(settings);

			api.one('draw', function () {
				callback(api.ajax.json());
			});
		}

		if (_fnDataSource(settings) == 'ssp') {
			_fnReDraw(settings, holdPosition);
		} else {
			_fnProcessingDisplay(settings, true);

			// Cancel an existing request
			var xhr = settings.jqXHR;
			if (xhr && xhr.readyState !== 4) {
				xhr.abort();
			}

			// Trigger xhr
			_fnBuildAjax(settings, [], function (json) {
				_fnClearTable(settings);

				var data = _fnAjaxDataSrc(settings, json);
				for (var i = 0, ien = data.length; i < ien; i++) {
					_fnAddData(settings, data[i]);
				}

				_fnReDraw(settings, holdPosition);
				_fnProcessingDisplay(settings, false);
			});
		}
	};

	/**
  * Get the JSON response from the last Ajax request that DataTables made to the
  * server. Note that this returns the JSON from the first table in the current
  * context.
  *
  * @return {object} JSON received from the server.
  */
	_api_register('ajax.json()', function () {
		var ctx = this.context;

		if (ctx.length > 0) {
			return ctx[0].json;
		}

		// else return undefined;
	});

	/**
  * Get the data submitted in the last Ajax request
  */
	_api_register('ajax.params()', function () {
		var ctx = this.context;

		if (ctx.length > 0) {
			return ctx[0].oAjaxData;
		}

		// else return undefined;
	});

	/**
  * Reload tables from the Ajax data source. Note that this function will
  * automatically re-draw the table when the remote data has been loaded.
  *
  * @param {boolean} [reset=true] Reset (default) or hold the current paging
  *   position. A full re-sort and re-filter is performed when this method is
  *   called, which is why the pagination reset is the default action.
  * @returns {DataTables.Api} this
  */
	_api_register('ajax.reload()', function (callback, resetPaging) {
		return this.iterator('table', function (settings) {
			__reload(settings, resetPaging === false, callback);
		});
	});

	/**
  * Get the current Ajax URL. Note that this returns the URL from the first
  * table in the current context.
  *
  * @return {string} Current Ajax source URL
  */ /**
     * Set the Ajax URL. Note that this will set the URL for all tables in the
     * current context.
     *
     * @param {string} url URL to set.
     * @returns {DataTables.Api} this
     */
	_api_register('ajax.url()', function (url) {
		var ctx = this.context;

		if (url === undefined) {
			// get
			if (ctx.length === 0) {
				return undefined;
			}
			ctx = ctx[0];

			return ctx.ajax ? $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource;
		}

		// set
		return this.iterator('table', function (settings) {
			if ($.isPlainObject(settings.ajax)) {
				settings.ajax.url = url;
			} else {
				settings.ajax = url;
			}
			// No need to consider sAjaxSource here since DataTables gives priority
			// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
			// value of `sAjaxSource` redundant.
		});
	});

	/**
  * Load data from the newly set Ajax URL. Note that this method is only
  * available when `ajax.url()` is used to set a URL. Additionally, this method
  * has the same effect as calling `ajax.reload()` but is provided for
  * convenience when setting a new URL. Like `ajax.reload()` it will
  * automatically redraw the table once the remote data has been loaded.
  *
  * @returns {DataTables.Api} this
  */
	_api_register('ajax.url().load()', function (callback, resetPaging) {
		// Same as a reload, but makes sense to present it for easy access after a
		// url change
		return this.iterator('table', function (ctx) {
			__reload(ctx, resetPaging === false, callback);
		});
	});

	var _selector_run = function _selector_run(type, selector, selectFn, settings, opts) {
		var out = [],
		    res,
		    a,
		    i,
		    ien,
		    j,
		    jen,
		    selectorType = typeof selector === 'undefined' ? 'undefined' : _typeof(selector);

		// Can't just check for isArray here, as an API or jQuery instance might be
		// given with their array like look
		if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
			selector = [selector];
		}

		for (i = 0, ien = selector.length; i < ien; i++) {
			// Only split on simple strings - complex expressions will be jQuery selectors
			a = selector[i] && selector[i].split && !selector[i].match(/[\[\(:]/) ? selector[i].split(',') : [selector[i]];

			for (j = 0, jen = a.length; j < jen; j++) {
				res = selectFn(typeof a[j] === 'string' ? $.trim(a[j]) : a[j]);

				if (res && res.length) {
					out = out.concat(res);
				}
			}
		}

		// selector extensions
		var ext = _ext.selector[type];
		if (ext.length) {
			for (i = 0, ien = ext.length; i < ien; i++) {
				out = ext[i](settings, opts, out);
			}
		}

		return _unique(out);
	};

	var _selector_opts = function _selector_opts(opts) {
		if (!opts) {
			opts = {};
		}

		// Backwards compatibility for 1.9- which used the terminology filter rather
		// than search
		if (opts.filter && opts.search === undefined) {
			opts.search = opts.filter;
		}

		return $.extend({
			search: 'none',
			order: 'current',
			page: 'all'
		}, opts);
	};

	var _selector_first = function _selector_first(inst) {
		// Reduce the API instance to the first item found
		for (var i = 0, ien = inst.length; i < ien; i++) {
			if (inst[i].length > 0) {
				// Assign the first element to the first item in the instance
				// and truncate the instance and context
				inst[0] = inst[i];
				inst[0].length = 1;
				inst.length = 1;
				inst.context = [inst.context[i]];

				return inst;
			}
		}

		// Not found - return an empty instance
		inst.length = 0;
		return inst;
	};

	var _selector_row_indexes = function _selector_row_indexes(settings, opts) {
		var i,
		    ien,
		    tmp,
		    a = [],
		    displayFiltered = settings.aiDisplay,
		    displayMaster = settings.aiDisplayMaster;

		var search = opts.search,
		    // none, applied, removed
		order = opts.order,
		    // applied, current, index (original - compatibility with 1.9)
		page = opts.page; // all, current

		if (_fnDataSource(settings) == 'ssp') {
			// In server-side processing mode, most options are irrelevant since
			// rows not shown don't exist and the index order is the applied order
			// Removed is a special case - for consistency just return an empty
			// array
			return search === 'removed' ? [] : _range(0, displayMaster.length);
		} else if (page == 'current') {
			// Current page implies that order=current and fitler=applied, since it is
			// fairly senseless otherwise, regardless of what order and search actually
			// are
			for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
				a.push(displayFiltered[i]);
			}
		} else if (order == 'current' || order == 'applied') {
			a = search == 'none' ? displayMaster.slice() : // no search
			search == 'applied' ? displayFiltered.slice() : // applied search
			$.map(displayMaster, function (el, i) {
				// removed search
				return $.inArray(el, displayFiltered) === -1 ? el : null;
			});
		} else if (order == 'index' || order == 'original') {
			for (i = 0, ien = settings.aoData.length; i < ien; i++) {
				if (search == 'none') {
					a.push(i);
				} else {
					// applied | removed
					tmp = $.inArray(i, displayFiltered);

					if (tmp === -1 && search == 'removed' || tmp >= 0 && search == 'applied') {
						a.push(i);
					}
				}
			}
		}

		return a;
	};

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Rows
  *
  * {}          - no selector - use all available rows
  * {integer}   - row aoData index
  * {node}      - TR node
  * {string}    - jQuery selector to apply to the TR elements
  * {array}     - jQuery array of nodes, or simply an array of TR nodes
  *
  */

	var __row_selector = function __row_selector(settings, selector, opts) {
		var rows;
		var run = function run(sel) {
			var selInt = _intVal(sel);
			var i, ien;

			// Short cut - selector is a number and no options provided (default is
			// all records, so no need to check if the index is in there, since it
			// must be - dev error if the index doesn't exist).
			if (selInt !== null && !opts) {
				return [selInt];
			}

			if (!rows) {
				rows = _selector_row_indexes(settings, opts);
			}

			if (selInt !== null && $.inArray(selInt, rows) !== -1) {
				// Selector - integer
				return [selInt];
			} else if (sel === null || sel === undefined || sel === '') {
				// Selector - none
				return rows;
			}

			// Selector - function
			if (typeof sel === 'function') {
				return $.map(rows, function (idx) {
					var row = settings.aoData[idx];
					return sel(idx, row._aData, row.nTr) ? idx : null;
				});
			}

			// Get nodes in the order from the `rows` array with null values removed
			var nodes = _removeEmpty(_pluck_order(settings.aoData, rows, 'nTr'));

			// Selector - node
			if (sel.nodeName) {
				if (sel._DT_RowIndex !== undefined) {
					return [sel._DT_RowIndex]; // Property added by DT for fast lookup
				} else if (sel._DT_CellIndex) {
					return [sel._DT_CellIndex.row];
				} else {
					var host = $(sel).closest('*[data-dt-row]');
					return host.length ? [host.data('dt-row')] : [];
				}
			}

			// ID selector. Want to always be able to select rows by id, regardless
			// of if the tr element has been created or not, so can't rely upon
			// jQuery here - hence a custom implementation. This does not match
			// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
			// but to select it using a CSS selector engine (like Sizzle or
			// querySelect) it would need to need to be escaped for some characters.
			// DataTables simplifies this for row selectors since you can select
			// only a row. A # indicates an id any anything that follows is the id -
			// unescaped.
			if (typeof sel === 'string' && sel.charAt(0) === '#') {
				// get row index from id
				var rowObj = settings.aIds[sel.replace(/^#/, '')];
				if (rowObj !== undefined) {
					return [rowObj.idx];
				}

				// need to fall through to jQuery in case there is DOM id that
				// matches
			}

			// Selector - jQuery selector string, array of nodes or jQuery object/
			// As jQuery's .filter() allows jQuery objects to be passed in filter,
			// it also allows arrays, so this will cope with all three options
			return $(nodes).filter(sel).map(function () {
				return this._DT_RowIndex;
			}).toArray();
		};

		return _selector_run('row', selector, run, settings, opts);
	};

	_api_register('rows()', function (selector, opts) {
		// argument shifting
		if (selector === undefined) {
			selector = '';
		} else if ($.isPlainObject(selector)) {
			opts = selector;
			selector = '';
		}

		opts = _selector_opts(opts);

		var inst = this.iterator('table', function (settings) {
			return __row_selector(settings, selector, opts);
		}, 1);

		// Want argument shifting here and in __row_selector?
		inst.selector.rows = selector;
		inst.selector.opts = opts;

		return inst;
	});

	_api_register('rows().nodes()', function () {
		return this.iterator('row', function (settings, row) {
			return settings.aoData[row].nTr || undefined;
		}, 1);
	});

	_api_register('rows().data()', function () {
		return this.iterator(true, 'rows', function (settings, rows) {
			return _pluck_order(settings.aoData, rows, '_aData');
		}, 1);
	});

	_api_registerPlural('rows().cache()', 'row().cache()', function (type) {
		return this.iterator('row', function (settings, row) {
			var r = settings.aoData[row];
			return type === 'search' ? r._aFilterData : r._aSortData;
		}, 1);
	});

	_api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {
		return this.iterator('row', function (settings, row) {
			_fnInvalidate(settings, row, src);
		});
	});

	_api_registerPlural('rows().indexes()', 'row().index()', function () {
		return this.iterator('row', function (settings, row) {
			return row;
		}, 1);
	});

	_api_registerPlural('rows().ids()', 'row().id()', function (hash) {
		var a = [];
		var context = this.context;

		// `iterator` will drop undefined values, but in this case we want them
		for (var i = 0, ien = context.length; i < ien; i++) {
			for (var j = 0, jen = this[i].length; j < jen; j++) {
				var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
				a.push((hash === true ? '#' : '') + id);
			}
		}

		return new _Api2(context, a);
	});

	_api_registerPlural('rows().remove()', 'row().remove()', function () {
		var that = this;

		this.iterator('row', function (settings, row, thatIdx) {
			var data = settings.aoData;
			var rowData = data[row];
			var i, ien, j, jen;
			var loopRow, loopCells;

			data.splice(row, 1);

			// Update the cached indexes
			for (i = 0, ien = data.length; i < ien; i++) {
				loopRow = data[i];
				loopCells = loopRow.anCells;

				// Rows
				if (loopRow.nTr !== null) {
					loopRow.nTr._DT_RowIndex = i;
				}

				// Cells
				if (loopCells !== null) {
					for (j = 0, jen = loopCells.length; j < jen; j++) {
						loopCells[j]._DT_CellIndex.row = i;
					}
				}
			}

			// Delete from the display arrays
			_fnDeleteIndex(settings.aiDisplayMaster, row);
			_fnDeleteIndex(settings.aiDisplay, row);
			_fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes

			// Check for an 'overflow' they case for displaying the table
			_fnLengthOverflow(settings);

			// Remove the row's ID reference if there is one
			var id = settings.rowIdFn(rowData._aData);
			if (id !== undefined) {
				delete settings.aIds[id];
			}
		});

		this.iterator('table', function (settings) {
			for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
				settings.aoData[i].idx = i;
			}
		});

		return this;
	});

	_api_register('rows.add()', function (rows) {
		var newRows = this.iterator('table', function (settings) {
			var row, i, ien;
			var out = [];

			for (i = 0, ien = rows.length; i < ien; i++) {
				row = rows[i];

				if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
					out.push(_fnAddTr(settings, row)[0]);
				} else {
					out.push(_fnAddData(settings, row));
				}
			}

			return out;
		}, 1);

		// Return an Api.rows() extended instance, so rows().nodes() etc can be used
		var modRows = this.rows(-1);
		modRows.pop();
		$.merge(modRows, newRows);

		return modRows;
	});

	/**
  *
  */
	_api_register('row()', function (selector, opts) {
		return _selector_first(this.rows(selector, opts));
	});

	_api_register('row().data()', function (data) {
		var ctx = this.context;

		if (data === undefined) {
			// Get
			return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined;
		}

		// Set
		ctx[0].aoData[this[0]]._aData = data;

		// Automatically invalidate
		_fnInvalidate(ctx[0], this[0], 'data');

		return this;
	});

	_api_register('row().node()', function () {
		var ctx = this.context;

		return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null;
	});

	_api_register('row.add()', function (row) {
		// Allow a jQuery object to be passed in - only a single row is added from
		// it though - the first element in the set
		if (row instanceof $ && row.length) {
			row = row[0];
		}

		var rows = this.iterator('table', function (settings) {
			if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
				return _fnAddTr(settings, row)[0];
			}
			return _fnAddData(settings, row);
		});

		// Return an Api.rows() extended instance, with the newly added row selected
		return this.row(rows[0]);
	});

	var __details_add = function __details_add(ctx, row, data, klass) {
		// Convert to array of TR elements
		var rows = [];
		var addRow = function addRow(r, k) {
			// Recursion to allow for arrays of jQuery objects
			if ($.isArray(r) || r instanceof $) {
				for (var i = 0, ien = r.length; i < ien; i++) {
					addRow(r[i], k);
				}
				return;
			}

			// If we get a TR element, then just add it directly - up to the dev
			// to add the correct number of columns etc
			if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {
				rows.push(r);
			} else {
				// Otherwise create a row with a wrapper
				var created = $('<tr><td/></tr>').addClass(k);
				$('td', created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);

				rows.push(created[0]);
			}
		};

		addRow(data, klass);

		if (row._details) {
			row._details.detach();
		}

		row._details = $(rows);

		// If the children were already shown, that state should be retained
		if (row._detailsShow) {
			row._details.insertAfter(row.nTr);
		}
	};

	var __details_remove = function __details_remove(api, idx) {
		var ctx = api.context;

		if (ctx.length) {
			var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];

			if (row && row._details) {
				row._details.remove();

				row._detailsShow = undefined;
				row._details = undefined;
			}
		}
	};

	var __details_display = function __details_display(api, show) {
		var ctx = api.context;

		if (ctx.length && api.length) {
			var row = ctx[0].aoData[api[0]];

			if (row._details) {
				row._detailsShow = show;

				if (show) {
					row._details.insertAfter(row.nTr);
				} else {
					row._details.detach();
				}

				__details_events(ctx[0]);
			}
		}
	};

	var __details_events = function __details_events(settings) {
		var api = new _Api2(settings);
		var namespace = '.dt.DT_details';
		var drawEvent = 'draw' + namespace;
		var colvisEvent = 'column-visibility' + namespace;
		var destroyEvent = 'destroy' + namespace;
		var data = settings.aoData;

		api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);

		if (_pluck(data, '_details').length > 0) {
			// On each draw, insert the required elements into the document
			api.on(drawEvent, function (e, ctx) {
				if (settings !== ctx) {
					return;
				}

				api.rows({ page: 'current' }).eq(0).each(function (idx) {
					// Internal data grab
					var row = data[idx];

					if (row._detailsShow) {
						row._details.insertAfter(row.nTr);
					}
				});
			});

			// Column visibility change - update the colspan
			api.on(colvisEvent, function (e, ctx, idx, vis) {
				if (settings !== ctx) {
					return;
				}

				// Update the colspan for the details rows (note, only if it already has
				// a colspan)
				var row,
				    visible = _fnVisbleColumns(ctx);

				for (var i = 0, ien = data.length; i < ien; i++) {
					row = data[i];

					if (row._details) {
						row._details.children('td[colspan]').attr('colspan', visible);
					}
				}
			});

			// Table destroyed - nuke any child rows
			api.on(destroyEvent, function (e, ctx) {
				if (settings !== ctx) {
					return;
				}

				for (var i = 0, ien = data.length; i < ien; i++) {
					if (data[i]._details) {
						__details_remove(api, i);
					}
				}
			});
		}
	};

	// Strings for the method names to help minification
	var _emp = '';
	var _child_obj = _emp + 'row().child';
	var _child_mth = _child_obj + '()';

	// data can be:
	//  tr
	//  string
	//  jQuery or array of any of the above
	_api_register(_child_mth, function (data, klass) {
		var ctx = this.context;

		if (data === undefined) {
			// get
			return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined;
		} else if (data === true) {
			// show
			this.child.show();
		} else if (data === false) {
			// remove
			__details_remove(this);
		} else if (ctx.length && this.length) {
			// set
			__details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
		}

		return this;
	});

	_api_register([_child_obj + '.show()', _child_mth + '.show()' // only when `child()` was called with parameters (without
	], function (show) {
		// it returns an object and this method is not executed)
		__details_display(this, true);
		return this;
	});

	_api_register([_child_obj + '.hide()', _child_mth + '.hide()' // only when `child()` was called with parameters (without
	], function () {
		// it returns an object and this method is not executed)
		__details_display(this, false);
		return this;
	});

	_api_register([_child_obj + '.remove()', _child_mth + '.remove()' // only when `child()` was called with parameters (without
	], function () {
		// it returns an object and this method is not executed)
		__details_remove(this);
		return this;
	});

	_api_register(_child_obj + '.isShown()', function () {
		var ctx = this.context;

		if (ctx.length && this.length) {
			// _detailsShown as false or undefined will fall through to return false
			return ctx[0].aoData[this[0]]._detailsShow || false;
		}
		return false;
	});

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Columns
  *
  * {integer}           - column index (>=0 count from left, <0 count from right)
  * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
  * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
  * "{string}:name"     - column name
  * "{string}"          - jQuery selector on column header nodes
  *
  */

	// can be an array of these items, comma separated list, or an array of comma
	// separated lists

	var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;

	// r1 and r2 are redundant - but it means that the parameters match for the
	// iterator callback in columns().data()
	var __columnData = function __columnData(settings, column, r1, r2, rows) {
		var a = [];
		for (var row = 0, ien = rows.length; row < ien; row++) {
			a.push(_fnGetCellData(settings, rows[row], column));
		}
		return a;
	};

	var __column_selector = function __column_selector(settings, selector, opts) {
		var columns = settings.aoColumns,
		    names = _pluck(columns, 'sName'),
		    nodes = _pluck(columns, 'nTh');

		var run = function run(s) {
			var selInt = _intVal(s);

			// Selector - all
			if (s === '') {
				return _range(columns.length);
			}

			// Selector - index
			if (selInt !== null) {
				return [selInt >= 0 ? selInt : // Count from left
				columns.length + selInt // Count from right (+ because its a negative value)
				];
			}

			// Selector = function
			if (typeof s === 'function') {
				var rows = _selector_row_indexes(settings, opts);

				return $.map(columns, function (col, idx) {
					return s(idx, __columnData(settings, idx, 0, 0, rows), nodes[idx]) ? idx : null;
				});
			}

			// jQuery or string selector
			var match = typeof s === 'string' ? s.match(__re_column_selector) : '';

			if (match) {
				switch (match[2]) {
					case 'visIdx':
					case 'visible':
						var idx = parseInt(match[1], 10);
						// Visible index given, convert to column index
						if (idx < 0) {
							// Counting from the right
							var visColumns = $.map(columns, function (col, i) {
								return col.bVisible ? i : null;
							});
							return [visColumns[visColumns.length + idx]];
						}
						// Counting from the left
						return [_fnVisibleToColumnIndex(settings, idx)];

					case 'name':
						// match by name. `names` is column index complete and in order
						return $.map(names, function (name, i) {
							return name === match[1] ? i : null;
						});

					default:
						return [];
				}
			}

			// Cell in the table body
			if (s.nodeName && s._DT_CellIndex) {
				return [s._DT_CellIndex.column];
			}

			// jQuery selector on the TH elements for the columns
			var jqResult = $(nodes).filter(s).map(function () {
				return $.inArray(this, nodes); // `nodes` is column index complete and in order
			}).toArray();

			if (jqResult.length || !s.nodeName) {
				return jqResult;
			}

			// Otherwise a node which might have a `dt-column` data attribute, or be
			// a child or such an element
			var host = $(s).closest('*[data-dt-column]');
			return host.length ? [host.data('dt-column')] : [];
		};

		return _selector_run('column', selector, run, settings, opts);
	};

	var __setColumnVis = function __setColumnVis(settings, column, vis) {
		var cols = settings.aoColumns,
		    col = cols[column],
		    data = settings.aoData,
		    row,
		    cells,
		    i,
		    ien,
		    tr;

		// Get
		if (vis === undefined) {
			return col.bVisible;
		}

		// Set
		// No change
		if (col.bVisible === vis) {
			return;
		}

		if (vis) {
			// Insert column
			// Need to decide if we should use appendChild or insertBefore
			var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);

			for (i = 0, ien = data.length; i < ien; i++) {
				tr = data[i].nTr;
				cells = data[i].anCells;

				if (tr) {
					// insertBefore can act like appendChild if 2nd arg is null
					tr.insertBefore(cells[column], cells[insertBefore] || null);
				}
			}
		} else {
			// Remove column
			$(_pluck(settings.aoData, 'anCells', column)).detach();
		}

		// Common actions
		col.bVisible = vis;
		_fnDrawHead(settings, settings.aoHeader);
		_fnDrawHead(settings, settings.aoFooter);

		_fnSaveState(settings);
	};

	_api_register('columns()', function (selector, opts) {
		// argument shifting
		if (selector === undefined) {
			selector = '';
		} else if ($.isPlainObject(selector)) {
			opts = selector;
			selector = '';
		}

		opts = _selector_opts(opts);

		var inst = this.iterator('table', function (settings) {
			return __column_selector(settings, selector, opts);
		}, 1);

		// Want argument shifting here and in _row_selector?
		inst.selector.cols = selector;
		inst.selector.opts = opts;

		return inst;
	});

	_api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {
		return this.iterator('column', function (settings, column) {
			return settings.aoColumns[column].nTh;
		}, 1);
	});

	_api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {
		return this.iterator('column', function (settings, column) {
			return settings.aoColumns[column].nTf;
		}, 1);
	});

	_api_registerPlural('columns().data()', 'column().data()', function () {
		return this.iterator('column-rows', __columnData, 1);
	});

	_api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {
		return this.iterator('column', function (settings, column) {
			return settings.aoColumns[column].mData;
		}, 1);
	});

	_api_registerPlural('columns().cache()', 'column().cache()', function (type) {
		return this.iterator('column-rows', function (settings, column, i, j, rows) {
			return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column);
		}, 1);
	});

	_api_registerPlural('columns().nodes()', 'column().nodes()', function () {
		return this.iterator('column-rows', function (settings, column, i, j, rows) {
			return _pluck_order(settings.aoData, rows, 'anCells', column);
		}, 1);
	});

	_api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {
		var ret = this.iterator('column', function (settings, column) {
			if (vis === undefined) {
				return settings.aoColumns[column].bVisible;
			} // else
			__setColumnVis(settings, column, vis);
		});

		// Group the column visibility changes
		if (vis !== undefined) {
			// Second loop once the first is done for events
			this.iterator('column', function (settings, column) {
				_fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis, calc]);
			});

			if (calc === undefined || calc) {
				this.columns.adjust();
			}
		}

		return ret;
	});

	_api_registerPlural('columns().indexes()', 'column().index()', function (type) {
		return this.iterator('column', function (settings, column) {
			return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column;
		}, 1);
	});

	_api_register('columns.adjust()', function () {
		return this.iterator('table', function (settings) {
			_fnAdjustColumnSizing(settings);
		}, 1);
	});

	_api_register('column.index()', function (type, idx) {
		if (this.context.length !== 0) {
			var ctx = this.context[0];

			if (type === 'fromVisible' || type === 'toData') {
				return _fnVisibleToColumnIndex(ctx, idx);
			} else if (type === 'fromData' || type === 'toVisible') {
				return _fnColumnIndexToVisible(ctx, idx);
			}
		}
	});

	_api_register('column()', function (selector, opts) {
		return _selector_first(this.columns(selector, opts));
	});

	var __cell_selector = function __cell_selector(settings, selector, opts) {
		var data = settings.aoData;
		var rows = _selector_row_indexes(settings, opts);
		var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));
		var allCells = $([].concat.apply([], cells));
		var row;
		var columns = settings.aoColumns.length;
		var a, i, ien, j, o, host;

		var run = function run(s) {
			var fnSelector = typeof s === 'function';

			if (s === null || s === undefined || fnSelector) {
				// All cells and function selectors
				a = [];

				for (i = 0, ien = rows.length; i < ien; i++) {
					row = rows[i];

					for (j = 0; j < columns; j++) {
						o = {
							row: row,
							column: j
						};

						if (fnSelector) {
							// Selector - function
							host = data[row];

							if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
								a.push(o);
							}
						} else {
							// Selector - all
							a.push(o);
						}
					}
				}

				return a;
			}

			// Selector - index
			if ($.isPlainObject(s)) {
				return [s];
			}

			// Selector - jQuery filtered cells
			var jqResult = allCells.filter(s).map(function (i, el) {
				return { // use a new object, in case someone changes the values
					row: el._DT_CellIndex.row,
					column: el._DT_CellIndex.column
				};
			}).toArray();

			if (jqResult.length || !s.nodeName) {
				return jqResult;
			}

			// Otherwise the selector is a node, and there is one last option - the
			// element might be a child of an element which has dt-row and dt-column
			// data attributes
			host = $(s).closest('*[data-dt-row]');
			return host.length ? [{
				row: host.data('dt-row'),
				column: host.data('dt-column')
			}] : [];
		};

		return _selector_run('cell', selector, run, settings, opts);
	};

	_api_register('cells()', function (rowSelector, columnSelector, opts) {
		// Argument shifting
		if ($.isPlainObject(rowSelector)) {
			// Indexes
			if (rowSelector.row === undefined) {
				// Selector options in first parameter
				opts = rowSelector;
				rowSelector = null;
			} else {
				// Cell index objects in first parameter
				opts = columnSelector;
				columnSelector = null;
			}
		}
		if ($.isPlainObject(columnSelector)) {
			opts = columnSelector;
			columnSelector = null;
		}

		// Cell selector
		if (columnSelector === null || columnSelector === undefined) {
			return this.iterator('table', function (settings) {
				return __cell_selector(settings, rowSelector, _selector_opts(opts));
			});
		}

		// Row + column selector
		var columns = this.columns(columnSelector, opts);
		var rows = this.rows(rowSelector, opts);
		var a, i, ien, j, jen;

		var cells = this.iterator('table', function (settings, idx) {
			a = [];

			for (i = 0, ien = rows[idx].length; i < ien; i++) {
				for (j = 0, jen = columns[idx].length; j < jen; j++) {
					a.push({
						row: rows[idx][i],
						column: columns[idx][j]
					});
				}
			}

			return a;
		}, 1);

		$.extend(cells.selector, {
			cols: columnSelector,
			rows: rowSelector,
			opts: opts
		});

		return cells;
	});

	_api_registerPlural('cells().nodes()', 'cell().node()', function () {
		return this.iterator('cell', function (settings, row, column) {
			var data = settings.aoData[row];

			return data && data.anCells ? data.anCells[column] : undefined;
		}, 1);
	});

	_api_register('cells().data()', function () {
		return this.iterator('cell', function (settings, row, column) {
			return _fnGetCellData(settings, row, column);
		}, 1);
	});

	_api_registerPlural('cells().cache()', 'cell().cache()', function (type) {
		type = type === 'search' ? '_aFilterData' : '_aSortData';

		return this.iterator('cell', function (settings, row, column) {
			return settings.aoData[row][type][column];
		}, 1);
	});

	_api_registerPlural('cells().render()', 'cell().render()', function (type) {
		return this.iterator('cell', function (settings, row, column) {
			return _fnGetCellData(settings, row, column, type);
		}, 1);
	});

	_api_registerPlural('cells().indexes()', 'cell().index()', function () {
		return this.iterator('cell', function (settings, row, column) {
			return {
				row: row,
				column: column,
				columnVisible: _fnColumnIndexToVisible(settings, column)
			};
		}, 1);
	});

	_api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {
		return this.iterator('cell', function (settings, row, column) {
			_fnInvalidate(settings, row, src, column);
		});
	});

	_api_register('cell()', function (rowSelector, columnSelector, opts) {
		return _selector_first(this.cells(rowSelector, columnSelector, opts));
	});

	_api_register('cell().data()', function (data) {
		var ctx = this.context;
		var cell = this[0];

		if (data === undefined) {
			// Get
			return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined;
		}

		// Set
		_fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);
		_fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);

		return this;
	});

	/**
  * Get current ordering (sorting) that has been applied to the table.
  *
  * @returns {array} 2D array containing the sorting information for the first
  *   table in the current context. Each element in the parent array represents
  *   a column being sorted upon (i.e. multi-sorting with two columns would have
  *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
  *   the column index that the sorting condition applies to, the second is the
  *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
  *   index of the sorting order from the `column.sorting` initialisation array.
  */ /**
     * Set the ordering for the table.
     *
     * @param {integer} order Column index to sort upon.
     * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
     * @returns {DataTables.Api} this
     */ /**
        * Set the ordering for the table.
        *
        * @param {array} order 1D array of sorting information to be applied.
        * @param {array} [...] Optional additional sorting conditions
        * @returns {DataTables.Api} this
        */ /**
           * Set the ordering for the table.
           *
           * @param {array} order 2D array of sorting information to be applied.
           * @returns {DataTables.Api} this
           */
	_api_register('order()', function (order, dir) {
		var ctx = this.context;

		if (order === undefined) {
			// get
			return ctx.length !== 0 ? ctx[0].aaSorting : undefined;
		}

		// set
		if (typeof order === 'number') {
			// Simple column / direction passed in
			order = [[order, dir]];
		} else if (order.length && !$.isArray(order[0])) {
			// Arguments passed in (list of 1D arrays)
			order = Array.prototype.slice.call(arguments);
		}
		// otherwise a 2D array was passed in

		return this.iterator('table', function (settings) {
			settings.aaSorting = order.slice();
		});
	});

	/**
  * Attach a sort listener to an element for a given column
  *
  * @param {node|jQuery|string} node Identifier for the element(s) to attach the
  *   listener to. This can take the form of a single DOM node, a jQuery
  *   collection of nodes or a jQuery selector which will identify the node(s).
  * @param {integer} column the column that a click on this node will sort on
  * @param {function} [callback] callback function when sort is run
  * @returns {DataTables.Api} this
  */
	_api_register('order.listener()', function (node, column, callback) {
		return this.iterator('table', function (settings) {
			_fnSortAttachListener(settings, node, column, callback);
		});
	});

	_api_register('order.fixed()', function (set) {
		if (!set) {
			var ctx = this.context;
			var fixed = ctx.length ? ctx[0].aaSortingFixed : undefined;

			return $.isArray(fixed) ? { pre: fixed } : fixed;
		}

		return this.iterator('table', function (settings) {
			settings.aaSortingFixed = $.extend(true, {}, set);
		});
	});

	// Order by the selected column(s)
	_api_register(['columns().order()', 'column().order()'], function (dir) {
		var that = this;

		return this.iterator('table', function (settings, i) {
			var sort = [];

			$.each(that[i], function (j, col) {
				sort.push([col, dir]);
			});

			settings.aaSorting = sort;
		});
	});

	_api_register('search()', function (input, regex, smart, caseInsen) {
		var ctx = this.context;

		if (input === undefined) {
			// get
			return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined;
		}

		// set
		return this.iterator('table', function (settings) {
			if (!settings.oFeatures.bFilter) {
				return;
			}

			_fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
				"sSearch": input + "",
				"bRegex": regex === null ? false : regex,
				"bSmart": smart === null ? true : smart,
				"bCaseInsensitive": caseInsen === null ? true : caseInsen
			}), 1);
		});
	});

	_api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {
		return this.iterator('column', function (settings, column) {
			var preSearch = settings.aoPreSearchCols;

			if (input === undefined) {
				// get
				return preSearch[column].sSearch;
			}

			// set
			if (!settings.oFeatures.bFilter) {
				return;
			}

			$.extend(preSearch[column], {
				"sSearch": input + "",
				"bRegex": regex === null ? false : regex,
				"bSmart": smart === null ? true : smart,
				"bCaseInsensitive": caseInsen === null ? true : caseInsen
			});

			_fnFilterComplete(settings, settings.oPreviousSearch, 1);
		});
	});

	/*
  * State API methods
  */

	_api_register('state()', function () {
		return this.context.length ? this.context[0].oSavedState : null;
	});

	_api_register('state.clear()', function () {
		return this.iterator('table', function (settings) {
			// Save an empty object
			settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
		});
	});

	_api_register('state.loaded()', function () {
		return this.context.length ? this.context[0].oLoadedState : null;
	});

	_api_register('state.save()', function () {
		return this.iterator('table', function (settings) {
			_fnSaveState(settings);
		});
	});

	/**
  * Provide a common method for plug-ins to check the version of DataTables being
  * used, in order to ensure compatibility.
  *
  *  @param {string} version Version string to check for, in the format "X.Y.Z".
  *    Note that the formats "X" and "X.Y" are also acceptable.
  *  @returns {boolean} true if this version of DataTables is greater or equal to
  *    the required version, or false if this version of DataTales is not
  *    suitable
  *  @static
  *  @dtopt API-Static
  *
  *  @example
  *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
  */
	DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {
		var aThis = DataTable.version.split('.');
		var aThat = version.split('.');
		var iThis, iThat;

		for (var i = 0, iLen = aThat.length; i < iLen; i++) {
			iThis = parseInt(aThis[i], 10) || 0;
			iThat = parseInt(aThat[i], 10) || 0;

			// Parts are the same, keep comparing
			if (iThis === iThat) {
				continue;
			}

			// Parts are different, return immediately
			return iThis > iThat;
		}

		return true;
	};

	/**
  * Check if a `<table>` node is a DataTable table already or not.
  *
  *  @param {node|jquery|string} table Table node, jQuery object or jQuery
  *      selector for the table to test. Note that if more than more than one
  *      table is passed on, only the first will be checked
  *  @returns {boolean} true the table given is a DataTable, or false otherwise
  *  @static
  *  @dtopt API-Static
  *
  *  @example
  *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
  *      $('#example').dataTable();
  *    }
  */
	DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {
		var t = $(table).get(0);
		var is = false;

		if (table instanceof DataTable.Api) {
			return true;
		}

		$.each(DataTable.settings, function (i, o) {
			var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
			var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

			if (o.nTable === t || head === t || foot === t) {
				is = true;
			}
		});

		return is;
	};

	/**
  * Get all DataTable tables that have been initialised - optionally you can
  * select to get only currently visible tables.
  *
  *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
  *    or visible tables only.
  *  @returns {array} Array of `table` nodes (not DataTable instances) which are
  *    DataTables
  *  @static
  *  @dtopt API-Static
  *
  *  @example
  *    $.each( $.fn.dataTable.tables(true), function () {
  *      $(table).DataTable().columns.adjust();
  *    } );
  */
	DataTable.tables = DataTable.fnTables = function (visible) {
		var api = false;

		if ($.isPlainObject(visible)) {
			api = visible.api;
			visible = visible.visible;
		}

		var a = $.map(DataTable.settings, function (o) {
			if (!visible || visible && $(o.nTable).is(':visible')) {
				return o.nTable;
			}
		});

		return api ? new _Api2(a) : a;
	};

	/**
  * Convert from camel case parameters to Hungarian notation. This is made public
  * for the extensions to provide the same ability as DataTables core to accept
  * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
  * parameters.
  *
  *  @param {object} src The model object which holds all parameters that can be
  *    mapped.
  *  @param {object} user The object to convert from camel case to Hungarian.
  *  @param {boolean} force When set to `true`, properties which already have a
  *    Hungarian value in the `user` object will be overwritten. Otherwise they
  *    won't be.
  */
	DataTable.camelToHungarian = _fnCamelToHungarian;

	/**
  *
  */
	_api_register('$()', function (selector, opts) {
		var rows = this.rows(opts).nodes(),
		    // Get all rows
		jqRows = $(rows);

		return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()));
	});

	// jQuery functions to operate on the tables
	$.each(['on', 'one', 'off'], function (i, key) {
		_api_register(key + '()', function () /* event, handler */{
			var args = Array.prototype.slice.call(arguments);

			// Add the `dt` namespace automatically if it isn't already present
			args[0] = $.map(args[0].split(/\s/), function (e) {
				return !e.match(/\.dt\b/) ? e + '.dt' : e;
			}).join(' ');

			var inst = $(this.tables().nodes());
			inst[key].apply(inst, args);
			return this;
		});
	});

	_api_register('clear()', function () {
		return this.iterator('table', function (settings) {
			_fnClearTable(settings);
		});
	});

	_api_register('settings()', function () {
		return new _Api2(this.context, this.context);
	});

	_api_register('init()', function () {
		var ctx = this.context;
		return ctx.length ? ctx[0].oInit : null;
	});

	_api_register('data()', function () {
		return this.iterator('table', function (settings) {
			return _pluck(settings.aoData, '_aData');
		}).flatten();
	});

	_api_register('destroy()', function (remove) {
		remove = remove || false;

		return this.iterator('table', function (settings) {
			var orig = settings.nTableWrapper.parentNode;
			var classes = settings.oClasses;
			var table = settings.nTable;
			var tbody = settings.nTBody;
			var thead = settings.nTHead;
			var tfoot = settings.nTFoot;
			var jqTable = $(table);
			var jqTbody = $(tbody);
			var jqWrapper = $(settings.nTableWrapper);
			var rows = $.map(settings.aoData, function (r) {
				return r.nTr;
			});
			var i, ien;

			// Flag to note that the table is currently being destroyed - no action
			// should be taken
			settings.bDestroying = true;

			// Fire off the destroy callbacks for plug-ins etc
			_fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]);

			// If not being removed from the document, make all columns visible
			if (!remove) {
				new _Api2(settings).columns().visible(true);
			}

			// Blitz all `DT` namespaced events (these are internal events, the
			// lowercase, `dt` events are user subscribed and they are responsible
			// for removing them
			jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
			$(window).off('.DT-' + settings.sInstance);

			// When scrolling we had to break the table up - restore it
			if (table != thead.parentNode) {
				jqTable.children('thead').detach();
				jqTable.append(thead);
			}

			if (tfoot && table != tfoot.parentNode) {
				jqTable.children('tfoot').detach();
				jqTable.append(tfoot);
			}

			settings.aaSorting = [];
			settings.aaSortingFixed = [];
			_fnSortingClasses(settings);

			$(rows).removeClass(settings.asStripeClasses.join(' '));

			$('th, td', thead).removeClass(classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone);

			if (settings.bJUI) {
				$('th span.' + classes.sSortIcon + ', td span.' + classes.sSortIcon, thead).detach();
				$('th, td', thead).each(function () {
					var wrapper = $('div.' + classes.sSortJUIWrapper, this);
					$(this).append(wrapper.contents());
					wrapper.detach();
				});
			}

			// Add the TR elements back into the table in their original order
			jqTbody.children().detach();
			jqTbody.append(rows);

			// Remove the DataTables generated nodes, events and classes
			var removedMethod = remove ? 'remove' : 'detach';
			jqTable[removedMethod]();
			jqWrapper[removedMethod]();

			// If we need to reattach the table to the document
			if (!remove && orig) {
				// insertBefore acts like appendChild if !arg[1]
				orig.insertBefore(table, settings.nTableReinsertBefore);

				// Restore the width of the original table - was read from the style property,
				// so we can restore directly to that
				jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable);

				// If the were originally stripe classes - then we add them back here.
				// Note this is not fool proof (for example if not all rows had stripe
				// classes - but it's a good effort without getting carried away
				ien = settings.asDestroyStripes.length;

				if (ien) {
					jqTbody.children().each(function (i) {
						$(this).addClass(settings.asDestroyStripes[i % ien]);
					});
				}
			}

			/* Remove the settings object from the settings array */
			var idx = $.inArray(settings, DataTable.settings);
			if (idx !== -1) {
				DataTable.settings.splice(idx, 1);
			}
		});
	});

	// Add the `every()` method for rows, columns and cells in a compact form
	$.each(['column', 'row', 'cell'], function (i, type) {
		_api_register(type + 's().every()', function (fn) {
			var opts = this.selector.opts;
			var api = this;

			return this.iterator(type, function (settings, arg1, arg2, arg3, arg4) {
				// Rows and columns:
				//  arg1 - index
				//  arg2 - table counter
				//  arg3 - loop counter
				//  arg4 - undefined
				// Cells:
				//  arg1 - row index
				//  arg2 - column index
				//  arg3 - table counter
				//  arg4 - loop counter
				fn.call(api[type](arg1, type === 'cell' ? arg2 : opts, type === 'cell' ? opts : undefined), arg1, arg2, arg3, arg4);
			});
		});
	});

	// i18n method for extensions to be able to use the language object from the
	// DataTable
	_api_register('i18n()', function (token, def, plural) {
		var ctx = this.context[0];
		var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);

		if (resolved === undefined) {
			resolved = def;
		}

		if (plural !== undefined && $.isPlainObject(resolved)) {
			resolved = resolved[plural] !== undefined ? resolved[plural] : resolved._;
		}

		return resolved.replace('%d', plural); // nb: plural might be undefined,
	});

	/**
  * Version string for plug-ins to check compatibility. Allowed format is
  * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
  * only for non-release builds. See http://semver.org/ for more information.
  *  @member
  *  @type string
  *  @default Version number
  */
	DataTable.version = "1.10.15";

	/**
  * Private data store, containing all of the settings objects that are
  * created for the tables on a given page.
  *
  * Note that the `DataTable.settings` object is aliased to
  * `jQuery.fn.dataTableExt` through which it may be accessed and
  * manipulated, or `jQuery.fn.dataTable.settings`.
  *  @member
  *  @type array
  *  @default []
  *  @private
  */
	DataTable.settings = [];

	/**
  * Object models container, for the various models that DataTables has
  * available to it. These models define the objects that are used to hold
  * the active state and configuration of the table.
  *  @namespace
  */
	DataTable.models = {};

	/**
  * Template object for the way in which DataTables holds information about
  * search information for the global filter and individual column filters.
  *  @namespace
  */
	DataTable.models.oSearch = {
		/**
   * Flag to indicate if the filtering should be case insensitive or not
   *  @type boolean
   *  @default true
   */
		"bCaseInsensitive": true,

		/**
   * Applied search term
   *  @type string
   *  @default <i>Empty string</i>
   */
		"sSearch": "",

		/**
   * Flag to indicate if the search term should be interpreted as a
   * regular expression (true) or not (false) and therefore and special
   * regex characters escaped.
   *  @type boolean
   *  @default false
   */
		"bRegex": false,

		/**
   * Flag to indicate if DataTables is to use its smart filtering or not.
   *  @type boolean
   *  @default true
   */
		"bSmart": true
	};

	/**
  * Template object for the way in which DataTables holds information about
  * each individual row. This is the object format used for the settings
  * aoData array.
  *  @namespace
  */
	DataTable.models.oRow = {
		/**
   * TR element for the row
   *  @type node
   *  @default null
   */
		"nTr": null,

		/**
   * Array of TD elements for each row. This is null until the row has been
   * created.
   *  @type array nodes
   *  @default []
   */
		"anCells": null,

		/**
   * Data object from the original data source for the row. This is either
   * an array if using the traditional form of DataTables, or an object if
   * using mData options. The exact type will depend on the passed in
   * data from the data source, or will be an array if using DOM a data
   * source.
   *  @type array|object
   *  @default []
   */
		"_aData": [],

		/**
   * Sorting data cache - this array is ostensibly the same length as the
   * number of columns (although each index is generated only as it is
   * needed), and holds the data that is used for sorting each column in the
   * row. We do this cache generation at the start of the sort in order that
   * the formatting of the sort data need be done only once for each cell
   * per sort. This array should not be read from or written to by anything
   * other than the master sorting methods.
   *  @type array
   *  @default null
   *  @private
   */
		"_aSortData": null,

		/**
   * Per cell filtering data cache. As per the sort data cache, used to
   * increase the performance of the filtering in DataTables
   *  @type array
   *  @default null
   *  @private
   */
		"_aFilterData": null,

		/**
   * Filtering data cache. This is the same as the cell filtering cache, but
   * in this case a string rather than an array. This is easily computed with
   * a join on `_aFilterData`, but is provided as a cache so the join isn't
   * needed on every search (memory traded for performance)
   *  @type array
   *  @default null
   *  @private
   */
		"_sFilterRow": null,

		/**
   * Cache of the class name that DataTables has applied to the row, so we
   * can quickly look at this variable rather than needing to do a DOM check
   * on className for the nTr property.
   *  @type string
   *  @default <i>Empty string</i>
   *  @private
   */
		"_sRowStripe": "",

		/**
   * Denote if the original data source was from the DOM, or the data source
   * object. This is used for invalidating data, so DataTables can
   * automatically read data from the original source, unless uninstructed
   * otherwise.
   *  @type string
   *  @default null
   *  @private
   */
		"src": null,

		/**
   * Index in the aoData array. This saves an indexOf lookup when we have the
   * object, but want to know the index
   *  @type integer
   *  @default -1
   *  @private
   */
		"idx": -1
	};

	/**
  * Template object for the column information object in DataTables. This object
  * is held in the settings aoColumns array and contains all the information that
  * DataTables needs about each individual column.
  *
  * Note that this object is related to {@link DataTable.defaults.column}
  * but this one is the internal data store for DataTables's cache of columns.
  * It should NOT be manipulated outside of DataTables. Any configuration should
  * be done through the initialisation options.
  *  @namespace
  */
	DataTable.models.oColumn = {
		/**
   * Column index. This could be worked out on-the-fly with $.inArray, but it
   * is faster to just hold it as a variable
   *  @type integer
   *  @default null
   */
		"idx": null,

		/**
   * A list of the columns that sorting should occur on when this column
   * is sorted. That this property is an array allows multi-column sorting
   * to be defined for a column (for example first name / last name columns
   * would benefit from this). The values are integers pointing to the
   * columns to be sorted on (typically it will be a single integer pointing
   * at itself, but that doesn't need to be the case).
   *  @type array
   */
		"aDataSort": null,

		/**
   * Define the sorting directions that are applied to the column, in sequence
   * as the column is repeatedly sorted upon - i.e. the first value is used
   * as the sorting direction when the column if first sorted (clicked on).
   * Sort it again (click again) and it will move on to the next index.
   * Repeat until loop.
   *  @type array
   */
		"asSorting": null,

		/**
   * Flag to indicate if the column is searchable, and thus should be included
   * in the filtering or not.
   *  @type boolean
   */
		"bSearchable": null,

		/**
   * Flag to indicate if the column is sortable or not.
   *  @type boolean
   */
		"bSortable": null,

		/**
   * Flag to indicate if the column is currently visible in the table or not
   *  @type boolean
   */
		"bVisible": null,

		/**
   * Store for manual type assignment using the `column.type` option. This
   * is held in store so we can manipulate the column's `sType` property.
   *  @type string
   *  @default null
   *  @private
   */
		"_sManualType": null,

		/**
   * Flag to indicate if HTML5 data attributes should be used as the data
   * source for filtering or sorting. True is either are.
   *  @type boolean
   *  @default false
   *  @private
   */
		"_bAttrSrc": false,

		/**
   * Developer definable function that is called whenever a cell is created (Ajax source,
   * etc) or processed for input (DOM source). This can be used as a compliment to mRender
   * allowing you to modify the DOM element (add background colour for example) when the
   * element is available.
   *  @type function
   *  @param {element} nTd The TD node that has been created
   *  @param {*} sData The Data for the cell
   *  @param {array|object} oData The data for the whole row
   *  @param {int} iRow The row index for the aoData data store
   *  @default null
   */
		"fnCreatedCell": null,

		/**
   * Function to get data from a cell in a column. You should <b>never</b>
   * access data directly through _aData internally in DataTables - always use
   * the method attached to this property. It allows mData to function as
   * required. This function is automatically assigned by the column
   * initialisation method
   *  @type function
   *  @param {array|object} oData The data array/object for the array
   *    (i.e. aoData[]._aData)
   *  @param {string} sSpecific The specific data type you want to get -
   *    'display', 'type' 'filter' 'sort'
   *  @returns {*} The data for the cell from the given row's data
   *  @default null
   */
		"fnGetData": null,

		/**
   * Function to set data for a cell in the column. You should <b>never</b>
   * set the data directly to _aData internally in DataTables - always use
   * this method. It allows mData to function as required. This function
   * is automatically assigned by the column initialisation method
   *  @type function
   *  @param {array|object} oData The data array/object for the array
   *    (i.e. aoData[]._aData)
   *  @param {*} sValue Value to set
   *  @default null
   */
		"fnSetData": null,

		/**
   * Property to read the value for the cells in the column from the data
   * source array / object. If null, then the default content is used, if a
   * function is given then the return from the function is used.
   *  @type function|int|string|null
   *  @default null
   */
		"mData": null,

		/**
   * Partner property to mData which is used (only when defined) to get
   * the data - i.e. it is basically the same as mData, but without the
   * 'set' option, and also the data fed to it is the result from mData.
   * This is the rendering method to match the data method of mData.
   *  @type function|int|string|null
   *  @default null
   */
		"mRender": null,

		/**
   * Unique header TH/TD element for this column - this is what the sorting
   * listener is attached to (if sorting is enabled.)
   *  @type node
   *  @default null
   */
		"nTh": null,

		/**
   * Unique footer TH/TD element for this column (if there is one). Not used
   * in DataTables as such, but can be used for plug-ins to reference the
   * footer for each column.
   *  @type node
   *  @default null
   */
		"nTf": null,

		/**
   * The class to apply to all TD elements in the table's TBODY for the column
   *  @type string
   *  @default null
   */
		"sClass": null,

		/**
   * When DataTables calculates the column widths to assign to each column,
   * it finds the longest string in each column and then constructs a
   * temporary table and reads the widths from that. The problem with this
   * is that "mmm" is much wider then "iiii", but the latter is a longer
   * string - thus the calculation can go wrong (doing it properly and putting
   * it into an DOM object and measuring that is horribly(!) slow). Thus as
   * a "work around" we provide this option. It will append its value to the
   * text that is found to be the longest string for the column - i.e. padding.
   *  @type string
   */
		"sContentPadding": null,

		/**
   * Allows a default value to be given for a column's data, and will be used
   * whenever a null data source is encountered (this can be because mData
   * is set to null, or because the data source itself is null).
   *  @type string
   *  @default null
   */
		"sDefaultContent": null,

		/**
   * Name for the column, allowing reference to the column by name as well as
   * by index (needs a lookup to work by name).
   *  @type string
   */
		"sName": null,

		/**
   * Custom sorting data type - defines which of the available plug-ins in
   * afnSortData the custom sorting will use - if any is defined.
   *  @type string
   *  @default std
   */
		"sSortDataType": 'std',

		/**
   * Class to be applied to the header element when sorting on this column
   *  @type string
   *  @default null
   */
		"sSortingClass": null,

		/**
   * Class to be applied to the header element when sorting on this column -
   * when jQuery UI theming is used.
   *  @type string
   *  @default null
   */
		"sSortingClassJUI": null,

		/**
   * Title of the column - what is seen in the TH element (nTh).
   *  @type string
   */
		"sTitle": null,

		/**
   * Column sorting and filtering type
   *  @type string
   *  @default null
   */
		"sType": null,

		/**
   * Width of the column
   *  @type string
   *  @default null
   */
		"sWidth": null,

		/**
   * Width of the column when it was first "encountered"
   *  @type string
   *  @default null
   */
		"sWidthOrig": null
	};

	/*
  * Developer note: The properties of the object below are given in Hungarian
  * notation, that was used as the interface for DataTables prior to v1.10, however
  * from v1.10 onwards the primary interface is camel case. In order to avoid
  * breaking backwards compatibility utterly with this change, the Hungarian
  * version is still, internally the primary interface, but is is not documented
  * - hence the @name tags in each doc comment. This allows a Javascript function
  * to create a map from Hungarian notation to camel case (going the other direction
  * would require each property to be listed, which would at around 3K to the size
  * of DataTables, while this method is about a 0.5K hit.
  *
  * Ultimately this does pave the way for Hungarian notation to be dropped
  * completely, but that is a massive amount of work and will break current
  * installs (therefore is on-hold until v2).
  */

	/**
  * Initialisation options that can be given to DataTables at initialisation
  * time.
  *  @namespace
  */
	DataTable.defaults = {
		/**
   * An array of data to use for the table, passed in at initialisation which
   * will be used in preference to any data which is already in the DOM. This is
   * particularly useful for constructing tables purely in Javascript, for
   * example with a custom Ajax call.
   *  @type array
   *  @default null
   *
   *  @dtopt Option
   *  @name DataTable.defaults.data
   *
   *  @example
   *    // Using a 2D array data source
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "data": [
   *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
   *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
   *        ],
   *        "columns": [
   *          { "title": "Engine" },
   *          { "title": "Browser" },
   *          { "title": "Platform" },
   *          { "title": "Version" },
   *          { "title": "Grade" }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using an array of objects as a data source (`data`)
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "data": [
   *          {
   *            "engine":   "Trident",
   *            "browser":  "Internet Explorer 4.0",
   *            "platform": "Win 95+",
   *            "version":  4,
   *            "grade":    "X"
   *          },
   *          {
   *            "engine":   "Trident",
   *            "browser":  "Internet Explorer 5.0",
   *            "platform": "Win 95+",
   *            "version":  5,
   *            "grade":    "C"
   *          }
   *        ],
   *        "columns": [
   *          { "title": "Engine",   "data": "engine" },
   *          { "title": "Browser",  "data": "browser" },
   *          { "title": "Platform", "data": "platform" },
   *          { "title": "Version",  "data": "version" },
   *          { "title": "Grade",    "data": "grade" }
   *        ]
   *      } );
   *    } );
   */
		"aaData": null,

		/**
   * If ordering is enabled, then DataTables will perform a first pass sort on
   * initialisation. You can define which column(s) the sort is performed
   * upon, and the sorting direction, with this variable. The `sorting` array
   * should contain an array for each column to be sorted initially containing
   * the column's index and a direction string ('asc' or 'desc').
   *  @type array
   *  @default [[0,'asc']]
   *
   *  @dtopt Option
   *  @name DataTable.defaults.order
   *
   *  @example
   *    // Sort by 3rd column first, and then 4th column
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "order": [[2,'asc'], [3,'desc']]
   *      } );
   *    } );
   *
   *    // No initial sorting
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "order": []
   *      } );
   *    } );
   */
		"aaSorting": [[0, 'asc']],

		/**
   * This parameter is basically identical to the `sorting` parameter, but
   * cannot be overridden by user interaction with the table. What this means
   * is that you could have a column (visible or hidden) which the sorting
   * will always be forced on first - any sorting after that (from the user)
   * will then be performed as required. This can be useful for grouping rows
   * together.
   *  @type array
   *  @default null
   *
   *  @dtopt Option
   *  @name DataTable.defaults.orderFixed
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "orderFixed": [[0,'asc']]
   *      } );
   *    } )
   */
		"aaSortingFixed": [],

		/**
   * DataTables can be instructed to load data to display in the table from a
   * Ajax source. This option defines how that Ajax call is made and where to.
   *
   * The `ajax` property has three different modes of operation, depending on
   * how it is defined. These are:
   *
   * * `string` - Set the URL from where the data should be loaded from.
   * * `object` - Define properties for `jQuery.ajax`.
   * * `function` - Custom data get function
   *
   * `string`
   * --------
   *
   * As a string, the `ajax` property simply defines the URL from which
   * DataTables will load data.
   *
   * `object`
   * --------
   *
   * As an object, the parameters in the object are passed to
   * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
   * of the Ajax request. DataTables has a number of default parameters which
   * you can override using this option. Please refer to the jQuery
   * documentation for a full description of the options available, although
   * the following parameters provide additional options in DataTables or
   * require special consideration:
   *
   * * `data` - As with jQuery, `data` can be provided as an object, but it
   *   can also be used as a function to manipulate the data DataTables sends
   *   to the server. The function takes a single parameter, an object of
   *   parameters with the values that DataTables has readied for sending. An
   *   object may be returned which will be merged into the DataTables
   *   defaults, or you can add the items to the object that was passed in and
   *   not return anything from the function. This supersedes `fnServerParams`
   *   from DataTables 1.9-.
   *
   * * `dataSrc` - By default DataTables will look for the property `data` (or
   *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
   *   from an Ajax source or for server-side processing - this parameter
   *   allows that property to be changed. You can use Javascript dotted
   *   object notation to get a data source for multiple levels of nesting, or
   *   it my be used as a function. As a function it takes a single parameter,
   *   the JSON returned from the server, which can be manipulated as
   *   required, with the returned value being that used by DataTables as the
   *   data source for the table. This supersedes `sAjaxDataProp` from
   *   DataTables 1.9-.
   *
   * * `success` - Should not be overridden it is used internally in
   *   DataTables. To manipulate / transform the data returned by the server
   *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
   *
   * `function`
   * ----------
   *
   * As a function, making the Ajax call is left up to yourself allowing
   * complete control of the Ajax request. Indeed, if desired, a method other
   * than Ajax could be used to obtain the required data, such as Web storage
   * or an AIR database.
   *
   * The function is given four parameters and no return is required. The
   * parameters are:
   *
   * 1. _object_ - Data to send to the server
   * 2. _function_ - Callback function that must be executed when the required
   *    data has been obtained. That data should be passed into the callback
   *    as the only parameter
   * 3. _object_ - DataTables settings object for the table
   *
   * Note that this supersedes `fnServerData` from DataTables 1.9-.
   *
   *  @type string|object|function
   *  @default null
   *
   *  @dtopt Option
   *  @name DataTable.defaults.ajax
   *  @since 1.10.0
   *
   * @example
   *   // Get JSON data from a file via Ajax.
   *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
   *   $('#example').dataTable( {
   *     "ajax": "data.json"
   *   } );
   *
   * @example
   *   // Get JSON data from a file via Ajax, using `dataSrc` to change
   *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
   *   $('#example').dataTable( {
   *     "ajax": {
   *       "url": "data.json",
   *       "dataSrc": "tableData"
   *     }
   *   } );
   *
   * @example
   *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
   *   // from a plain array rather than an array in an object
   *   $('#example').dataTable( {
   *     "ajax": {
   *       "url": "data.json",
   *       "dataSrc": ""
   *     }
   *   } );
   *
   * @example
   *   // Manipulate the data returned from the server - add a link to data
   *   // (note this can, should, be done using `render` for the column - this
   *   // is just a simple example of how the data can be manipulated).
   *   $('#example').dataTable( {
   *     "ajax": {
   *       "url": "data.json",
   *       "dataSrc": function ( json ) {
   *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
   *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
   *         }
   *         return json;
   *       }
   *     }
   *   } );
   *
   * @example
   *   // Add data to the request
   *   $('#example').dataTable( {
   *     "ajax": {
   *       "url": "data.json",
   *       "data": function ( d ) {
   *         return {
   *           "extra_search": $('#extra').val()
   *         };
   *       }
   *     }
   *   } );
   *
   * @example
   *   // Send request as POST
   *   $('#example').dataTable( {
   *     "ajax": {
   *       "url": "data.json",
   *       "type": "POST"
   *     }
   *   } );
   *
   * @example
   *   // Get the data from localStorage (could interface with a form for
   *   // adding, editing and removing rows).
   *   $('#example').dataTable( {
   *     "ajax": function (data, callback, settings) {
   *       callback(
   *         JSON.parse( localStorage.getItem('dataTablesData') )
   *       );
   *     }
   *   } );
   */
		"ajax": null,

		/**
   * This parameter allows you to readily specify the entries in the length drop
   * down menu that DataTables shows when pagination is enabled. It can be
   * either a 1D array of options which will be used for both the displayed
   * option and the value, or a 2D array which will use the array in the first
   * position as the value, and the array in the second position as the
   * displayed options (useful for language strings such as 'All').
   *
   * Note that the `pageLength` property will be automatically set to the
   * first value given in this array, unless `pageLength` is also provided.
   *  @type array
   *  @default [ 10, 25, 50, 100 ]
   *
   *  @dtopt Option
   *  @name DataTable.defaults.lengthMenu
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
   *      } );
   *    } );
   */
		"aLengthMenu": [10, 25, 50, 100],

		/**
   * The `columns` option in the initialisation parameter allows you to define
   * details about the way individual columns behave. For a full list of
   * column options that can be set, please see
   * {@link DataTable.defaults.column}. Note that if you use `columns` to
   * define your columns, you must have an entry in the array for every single
   * column that you have in your table (these can be null if you don't which
   * to specify any options).
   *  @member
   *
   *  @name DataTable.defaults.column
   */
		"aoColumns": null,

		/**
   * Very similar to `columns`, `columnDefs` allows you to target a specific
   * column, multiple columns, or all columns, using the `targets` property of
   * each object in the array. This allows great flexibility when creating
   * tables, as the `columnDefs` arrays can be of any length, targeting the
   * columns you specifically want. `columnDefs` may use any of the column
   * options available: {@link DataTable.defaults.column}, but it _must_
   * have `targets` defined in each object in the array. Values in the `targets`
   * array may be:
   *   <ul>
   *     <li>a string - class name will be matched on the TH for the column</li>
   *     <li>0 or a positive integer - column index counting from the left</li>
   *     <li>a negative integer - column index counting from the right</li>
   *     <li>the string "_all" - all columns (i.e. assign a default)</li>
   *   </ul>
   *  @member
   *
   *  @name DataTable.defaults.columnDefs
   */
		"aoColumnDefs": null,

		/**
   * Basically the same as `search`, this parameter defines the individual column
   * filtering state at initialisation time. The array must be of the same size
   * as the number of columns, and each element be an object with the parameters
   * `search` and `escapeRegex` (the latter is optional). 'null' is also
   * accepted and the default will be used.
   *  @type array
   *  @default []
   *
   *  @dtopt Option
   *  @name DataTable.defaults.searchCols
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "searchCols": [
   *          null,
   *          { "search": "My filter" },
   *          null,
   *          { "search": "^[0-9]", "escapeRegex": false }
   *        ]
   *      } );
   *    } )
   */
		"aoSearchCols": [],

		/**
   * An array of CSS classes that should be applied to displayed rows. This
   * array may be of any length, and DataTables will apply each class
   * sequentially, looping when required.
   *  @type array
   *  @default null <i>Will take the values determined by the `oClasses.stripe*`
   *    options</i>
   *
   *  @dtopt Option
   *  @name DataTable.defaults.stripeClasses
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
   *      } );
   *    } )
   */
		"asStripeClasses": null,

		/**
   * Enable or disable automatic column width calculation. This can be disabled
   * as an optimisation (it takes some time to calculate the widths) if the
   * tables widths are passed in using `columns`.
   *  @type boolean
   *  @default true
   *
   *  @dtopt Features
   *  @name DataTable.defaults.autoWidth
   *
   *  @example
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "autoWidth": false
   *      } );
   *    } );
   */
		"bAutoWidth": true,

		/**
   * Deferred rendering can provide DataTables with a huge speed boost when you
   * are using an Ajax or JS data source for the table. This option, when set to
   * true, will cause DataTables to defer the creation of the table elements for
   * each row until they are needed for a draw - saving a significant amount of
   * time.
   *  @type boolean
   *  @default false
   *
   *  @dtopt Features
   *  @name DataTable.defaults.deferRender
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "ajax": "sources/arrays.txt",
   *        "deferRender": true
   *      } );
   *    } );
   */
		"bDeferRender": false,

		/**
   * Replace a DataTable which matches the given selector and replace it with
   * one which has the properties of the new initialisation object passed. If no
   * table matches the selector, then the new DataTable will be constructed as
   * per normal.
   *  @type boolean
   *  @default false
   *
   *  @dtopt Options
   *  @name DataTable.defaults.destroy
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "srollY": "200px",
   *        "paginate": false
   *      } );
   *
   *      // Some time later....
   *      $('#example').dataTable( {
   *        "filter": false,
   *        "destroy": true
   *      } );
   *    } );
   */
		"bDestroy": false,

		/**
   * Enable or disable filtering of data. Filtering in DataTables is "smart" in
   * that it allows the end user to input multiple words (space separated) and
   * will match a row containing those words, even if not in the order that was
   * specified (this allow matching across multiple columns). Note that if you
   * wish to use filtering in DataTables this must remain 'true' - to remove the
   * default filtering input box and retain filtering abilities, please use
   * {@link DataTable.defaults.dom}.
   *  @type boolean
   *  @default true
   *
   *  @dtopt Features
   *  @name DataTable.defaults.searching
   *
   *  @example
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "searching": false
   *      } );
   *    } );
   */
		"bFilter": true,

		/**
   * Enable or disable the table information display. This shows information
   * about the data that is currently visible on the page, including information
   * about filtered data if that action is being performed.
   *  @type boolean
   *  @default true
   *
   *  @dtopt Features
   *  @name DataTable.defaults.info
   *
   *  @example
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "info": false
   *      } );
   *    } );
   */
		"bInfo": true,

		/**
   * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
   * slightly different and additional mark-up from what DataTables has
   * traditionally used).
   *  @type boolean
   *  @default false
   *
   *  @dtopt Features
   *  @name DataTable.defaults.jQueryUI
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "jQueryUI": true
   *      } );
   *    } );
   */
		"bJQueryUI": false,

		/**
   * Allows the end user to select the size of a formatted page from a select
   * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
   *  @type boolean
   *  @default true
   *
   *  @dtopt Features
   *  @name DataTable.defaults.lengthChange
   *
   *  @example
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "lengthChange": false
   *      } );
   *    } );
   */
		"bLengthChange": true,

		/**
   * Enable or disable pagination.
   *  @type boolean
   *  @default true
   *
   *  @dtopt Features
   *  @name DataTable.defaults.paging
   *
   *  @example
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "paging": false
   *      } );
   *    } );
   */
		"bPaginate": true,

		/**
   * Enable or disable the display of a 'processing' indicator when the table is
   * being processed (e.g. a sort). This is particularly useful for tables with
   * large amounts of data where it can take a noticeable amount of time to sort
   * the entries.
   *  @type boolean
   *  @default false
   *
   *  @dtopt Features
   *  @name DataTable.defaults.processing
   *
   *  @example
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "processing": true
   *      } );
   *    } );
   */
		"bProcessing": false,

		/**
   * Retrieve the DataTables object for the given selector. Note that if the
   * table has already been initialised, this parameter will cause DataTables
   * to simply return the object that has already been set up - it will not take
   * account of any changes you might have made to the initialisation object
   * passed to DataTables (setting this parameter to true is an acknowledgement
   * that you understand this). `destroy` can be used to reinitialise a table if
   * you need.
   *  @type boolean
   *  @default false
   *
   *  @dtopt Options
   *  @name DataTable.defaults.retrieve
   *
   *  @example
   *    $(document).ready( function() {
   *      initTable();
   *      tableActions();
   *    } );
   *
   *    function initTable ()
   *    {
   *      return $('#example').dataTable( {
   *        "scrollY": "200px",
   *        "paginate": false,
   *        "retrieve": true
   *      } );
   *    }
   *
   *    function tableActions ()
   *    {
   *      var table = initTable();
   *      // perform API operations with oTable
   *    }
   */
		"bRetrieve": false,

		/**
   * When vertical (y) scrolling is enabled, DataTables will force the height of
   * the table's viewport to the given height at all times (useful for layout).
   * However, this can look odd when filtering data down to a small data set,
   * and the footer is left "floating" further down. This parameter (when
   * enabled) will cause DataTables to collapse the table's viewport down when
   * the result set will fit within the given Y height.
   *  @type boolean
   *  @default false
   *
   *  @dtopt Options
   *  @name DataTable.defaults.scrollCollapse
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "scrollY": "200",
   *        "scrollCollapse": true
   *      } );
   *    } );
   */
		"bScrollCollapse": false,

		/**
   * Configure DataTables to use server-side processing. Note that the
   * `ajax` parameter must also be given in order to give DataTables a
   * source to obtain the required data for each draw.
   *  @type boolean
   *  @default false
   *
   *  @dtopt Features
   *  @dtopt Server-side
   *  @name DataTable.defaults.serverSide
   *
   *  @example
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "serverSide": true,
   *        "ajax": "xhr.php"
   *      } );
   *    } );
   */
		"bServerSide": false,

		/**
   * Enable or disable sorting of columns. Sorting of individual columns can be
   * disabled by the `sortable` option for each column.
   *  @type boolean
   *  @default true
   *
   *  @dtopt Features
   *  @name DataTable.defaults.ordering
   *
   *  @example
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "ordering": false
   *      } );
   *    } );
   */
		"bSort": true,

		/**
   * Enable or display DataTables' ability to sort multiple columns at the
   * same time (activated by shift-click by the user).
   *  @type boolean
   *  @default true
   *
   *  @dtopt Options
   *  @name DataTable.defaults.orderMulti
   *
   *  @example
   *    // Disable multiple column sorting ability
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "orderMulti": false
   *      } );
   *    } );
   */
		"bSortMulti": true,

		/**
   * Allows control over whether DataTables should use the top (true) unique
   * cell that is found for a single column, or the bottom (false - default).
   * This is useful when using complex headers.
   *  @type boolean
   *  @default false
   *
   *  @dtopt Options
   *  @name DataTable.defaults.orderCellsTop
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "orderCellsTop": true
   *      } );
   *    } );
   */
		"bSortCellsTop": false,

		/**
   * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
   * `sorting\_3` to the columns which are currently being sorted on. This is
   * presented as a feature switch as it can increase processing time (while
   * classes are removed and added) so for large data sets you might want to
   * turn this off.
   *  @type boolean
   *  @default true
   *
   *  @dtopt Features
   *  @name DataTable.defaults.orderClasses
   *
   *  @example
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "orderClasses": false
   *      } );
   *    } );
   */
		"bSortClasses": true,

		/**
   * Enable or disable state saving. When enabled HTML5 `localStorage` will be
   * used to save table display information such as pagination information,
   * display length, filtering and sorting. As such when the end user reloads
   * the page the display display will match what thy had previously set up.
   *
   * Due to the use of `localStorage` the default state saving is not supported
   * in IE6 or 7. If state saving is required in those browsers, use
   * `stateSaveCallback` to provide a storage solution such as cookies.
   *  @type boolean
   *  @default false
   *
   *  @dtopt Features
   *  @name DataTable.defaults.stateSave
   *
   *  @example
   *    $(document).ready( function () {
   *      $('#example').dataTable( {
   *        "stateSave": true
   *      } );
   *    } );
   */
		"bStateSave": false,

		/**
   * This function is called when a TR element is created (and all TD child
   * elements have been inserted), or registered if using a DOM source, allowing
   * manipulation of the TR element (adding classes etc).
   *  @type function
   *  @param {node} row "TR" element for the current row
   *  @param {array} data Raw data array for this row
   *  @param {int} dataIndex The index of this row in the internal aoData array
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.createdRow
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "createdRow": function( row, data, dataIndex ) {
   *          // Bold the grade for all 'A' grade browsers
   *          if ( data[4] == "A" )
   *          {
   *            $('td:eq(4)', row).html( '<b>A</b>' );
   *          }
   *        }
   *      } );
   *    } );
   */
		"fnCreatedRow": null,

		/**
   * This function is called on every 'draw' event, and allows you to
   * dynamically modify any aspect you want about the created DOM.
   *  @type function
   *  @param {object} settings DataTables settings object
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.drawCallback
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "drawCallback": function( settings ) {
   *          alert( 'DataTables has redrawn the table' );
   *        }
   *      } );
   *    } );
   */
		"fnDrawCallback": null,

		/**
   * Identical to fnHeaderCallback() but for the table footer this function
   * allows you to modify the table footer on every 'draw' event.
   *  @type function
   *  @param {node} foot "TR" element for the footer
   *  @param {array} data Full table data (as derived from the original HTML)
   *  @param {int} start Index for the current display starting point in the
   *    display array
   *  @param {int} end Index for the current display ending point in the
   *    display array
   *  @param {array int} display Index array to translate the visual position
   *    to the full data array
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.footerCallback
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "footerCallback": function( tfoot, data, start, end, display ) {
   *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
   *        }
   *      } );
   *    } )
   */
		"fnFooterCallback": null,

		/**
   * When rendering large numbers in the information element for the table
   * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
   * to have a comma separator for the 'thousands' units (e.g. 1 million is
   * rendered as "1,000,000") to help readability for the end user. This
   * function will override the default method DataTables uses.
   *  @type function
   *  @member
   *  @param {int} toFormat number to be formatted
   *  @returns {string} formatted string for DataTables to show the number
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.formatNumber
   *
   *  @example
   *    // Format a number using a single quote for the separator (note that
   *    // this can also be done with the language.thousands option)
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "formatNumber": function ( toFormat ) {
   *          return toFormat.toString().replace(
   *            /\B(?=(\d{3})+(?!\d))/g, "'"
   *          );
   *        };
   *      } );
   *    } );
   */
		"fnFormatNumber": function fnFormatNumber(toFormat) {
			return toFormat.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands);
		},

		/**
   * This function is called on every 'draw' event, and allows you to
   * dynamically modify the header row. This can be used to calculate and
   * display useful information about the table.
   *  @type function
   *  @param {node} head "TR" element for the header
   *  @param {array} data Full table data (as derived from the original HTML)
   *  @param {int} start Index for the current display starting point in the
   *    display array
   *  @param {int} end Index for the current display ending point in the
   *    display array
   *  @param {array int} display Index array to translate the visual position
   *    to the full data array
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.headerCallback
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "fheaderCallback": function( head, data, start, end, display ) {
   *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
   *        }
   *      } );
   *    } )
   */
		"fnHeaderCallback": null,

		/**
   * The information element can be used to convey information about the current
   * state of the table. Although the internationalisation options presented by
   * DataTables are quite capable of dealing with most customisations, there may
   * be times where you wish to customise the string further. This callback
   * allows you to do exactly that.
   *  @type function
   *  @param {object} oSettings DataTables settings object
   *  @param {int} start Starting position in data for the draw
   *  @param {int} end End position in data for the draw
   *  @param {int} max Total number of rows in the table (regardless of
   *    filtering)
   *  @param {int} total Total number of rows in the data set, after filtering
   *  @param {string} pre The string that DataTables has formatted using it's
   *    own rules
   *  @returns {string} The string to be displayed in the information element.
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.infoCallback
   *
   *  @example
   *    $('#example').dataTable( {
   *      "infoCallback": function( settings, start, end, max, total, pre ) {
   *        return start +" to "+ end;
   *      }
   *    } );
   */
		"fnInfoCallback": null,

		/**
   * Called when the table has been initialised. Normally DataTables will
   * initialise sequentially and there will be no need for this function,
   * however, this does not hold true when using external language information
   * since that is obtained using an async XHR call.
   *  @type function
   *  @param {object} settings DataTables settings object
   *  @param {object} json The JSON object request from the server - only
   *    present if client-side Ajax sourced data is used
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.initComplete
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "initComplete": function(settings, json) {
   *          alert( 'DataTables has finished its initialisation.' );
   *        }
   *      } );
   *    } )
   */
		"fnInitComplete": null,

		/**
   * Called at the very start of each table draw and can be used to cancel the
   * draw by returning false, any other return (including undefined) results in
   * the full draw occurring).
   *  @type function
   *  @param {object} settings DataTables settings object
   *  @returns {boolean} False will cancel the draw, anything else (including no
   *    return) will allow it to complete.
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.preDrawCallback
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "preDrawCallback": function( settings ) {
   *          if ( $('#test').val() == 1 ) {
   *            return false;
   *          }
   *        }
   *      } );
   *    } );
   */
		"fnPreDrawCallback": null,

		/**
   * This function allows you to 'post process' each row after it have been
   * generated for each table draw, but before it is rendered on screen. This
   * function might be used for setting the row class name etc.
   *  @type function
   *  @param {node} row "TR" element for the current row
   *  @param {array} data Raw data array for this row
   *  @param {int} displayIndex The display index for the current table draw
   *  @param {int} displayIndexFull The index of the data in the full list of
   *    rows (after filtering)
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.rowCallback
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
   *          // Bold the grade for all 'A' grade browsers
   *          if ( data[4] == "A" ) {
   *            $('td:eq(4)', row).html( '<b>A</b>' );
   *          }
   *        }
   *      } );
   *    } );
   */
		"fnRowCallback": null,

		/**
   * __Deprecated__ The functionality provided by this parameter has now been
   * superseded by that provided through `ajax`, which should be used instead.
   *
   * This parameter allows you to override the default function which obtains
   * the data from the server so something more suitable for your application.
   * For example you could use POST data, or pull information from a Gears or
   * AIR database.
   *  @type function
   *  @member
   *  @param {string} source HTTP source to obtain the data from (`ajax`)
   *  @param {array} data A key/value pair object containing the data to send
   *    to the server
   *  @param {function} callback to be called on completion of the data get
   *    process that will draw the data on the page.
   *  @param {object} settings DataTables settings object
   *
   *  @dtopt Callbacks
   *  @dtopt Server-side
   *  @name DataTable.defaults.serverData
   *
   *  @deprecated 1.10. Please use `ajax` for this functionality now.
   */
		"fnServerData": null,

		/**
   * __Deprecated__ The functionality provided by this parameter has now been
   * superseded by that provided through `ajax`, which should be used instead.
   *
   *  It is often useful to send extra data to the server when making an Ajax
   * request - for example custom filtering information, and this callback
   * function makes it trivial to send extra information to the server. The
   * passed in parameter is the data set that has been constructed by
   * DataTables, and you can add to this or modify it as you require.
   *  @type function
   *  @param {array} data Data array (array of objects which are name/value
   *    pairs) that has been constructed by DataTables and will be sent to the
   *    server. In the case of Ajax sourced data with server-side processing
   *    this will be an empty array, for server-side processing there will be a
   *    significant number of parameters!
   *  @returns {undefined} Ensure that you modify the data array passed in,
   *    as this is passed by reference.
   *
   *  @dtopt Callbacks
   *  @dtopt Server-side
   *  @name DataTable.defaults.serverParams
   *
   *  @deprecated 1.10. Please use `ajax` for this functionality now.
   */
		"fnServerParams": null,

		/**
   * Load the table state. With this function you can define from where, and how, the
   * state of a table is loaded. By default DataTables will load from `localStorage`
   * but you might wish to use a server-side database or cookies.
   *  @type function
   *  @member
   *  @param {object} settings DataTables settings object
   *  @param {object} callback Callback that can be executed when done. It
   *    should be passed the loaded state object.
   *  @return {object} The DataTables state object to be loaded
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.stateLoadCallback
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "stateSave": true,
   *        "stateLoadCallback": function (settings, callback) {
   *          $.ajax( {
   *            "url": "/state_load",
   *            "dataType": "json",
   *            "success": function (json) {
   *              callback( json );
   *            }
   *          } );
   *        }
   *      } );
   *    } );
   */
		"fnStateLoadCallback": function fnStateLoadCallback(settings) {
			try {
				return JSON.parse((settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem('DataTables_' + settings.sInstance + '_' + location.pathname));
			} catch (e) {}
		},

		/**
   * Callback which allows modification of the saved state prior to loading that state.
   * This callback is called when the table is loading state from the stored data, but
   * prior to the settings object being modified by the saved state. Note that for
   * plug-in authors, you should use the `stateLoadParams` event to load parameters for
   * a plug-in.
   *  @type function
   *  @param {object} settings DataTables settings object
   *  @param {object} data The state object that is to be loaded
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.stateLoadParams
   *
   *  @example
   *    // Remove a saved filter, so filtering is never loaded
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "stateSave": true,
   *        "stateLoadParams": function (settings, data) {
   *          data.oSearch.sSearch = "";
   *        }
   *      } );
   *    } );
   *
   *  @example
   *    // Disallow state loading by returning false
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "stateSave": true,
   *        "stateLoadParams": function (settings, data) {
   *          return false;
   *        }
   *      } );
   *    } );
   */
		"fnStateLoadParams": null,

		/**
   * Callback that is called when the state has been loaded from the state saving method
   * and the DataTables settings object has been modified as a result of the loaded state.
   *  @type function
   *  @param {object} settings DataTables settings object
   *  @param {object} data The state object that was loaded
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.stateLoaded
   *
   *  @example
   *    // Show an alert with the filtering value that was saved
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "stateSave": true,
   *        "stateLoaded": function (settings, data) {
   *          alert( 'Saved filter was: '+data.oSearch.sSearch );
   *        }
   *      } );
   *    } );
   */
		"fnStateLoaded": null,

		/**
   * Save the table state. This function allows you to define where and how the state
   * information for the table is stored By default DataTables will use `localStorage`
   * but you might wish to use a server-side database or cookies.
   *  @type function
   *  @member
   *  @param {object} settings DataTables settings object
   *  @param {object} data The state object to be saved
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.stateSaveCallback
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "stateSave": true,
   *        "stateSaveCallback": function (settings, data) {
   *          // Send an Ajax request to the server with the state object
   *          $.ajax( {
   *            "url": "/state_save",
   *            "data": data,
   *            "dataType": "json",
   *            "method": "POST"
   *            "success": function () {}
   *          } );
   *        }
   *      } );
   *    } );
   */
		"fnStateSaveCallback": function fnStateSaveCallback(settings, data) {
			try {
				(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem('DataTables_' + settings.sInstance + '_' + location.pathname, JSON.stringify(data));
			} catch (e) {}
		},

		/**
   * Callback which allows modification of the state to be saved. Called when the table
   * has changed state a new state save is required. This method allows modification of
   * the state saving object prior to actually doing the save, including addition or
   * other state properties or modification. Note that for plug-in authors, you should
   * use the `stateSaveParams` event to save parameters for a plug-in.
   *  @type function
   *  @param {object} settings DataTables settings object
   *  @param {object} data The state object to be saved
   *
   *  @dtopt Callbacks
   *  @name DataTable.defaults.stateSaveParams
   *
   *  @example
   *    // Remove a saved filter, so filtering is never saved
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "stateSave": true,
   *        "stateSaveParams": function (settings, data) {
   *          data.oSearch.sSearch = "";
   *        }
   *      } );
   *    } );
   */
		"fnStateSaveParams": null,

		/**
   * Duration for which the saved state information is considered valid. After this period
   * has elapsed the state will be returned to the default.
   * Value is given in seconds.
   *  @type int
   *  @default 7200 <i>(2 hours)</i>
   *
   *  @dtopt Options
   *  @name DataTable.defaults.stateDuration
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "stateDuration": 60*60*24; // 1 day
   *      } );
   *    } )
   */
		"iStateDuration": 7200,

		/**
   * When enabled DataTables will not make a request to the server for the first
   * page draw - rather it will use the data already on the page (no sorting etc
   * will be applied to it), thus saving on an XHR at load time. `deferLoading`
   * is used to indicate that deferred loading is required, but it is also used
   * to tell DataTables how many records there are in the full table (allowing
   * the information element and pagination to be displayed correctly). In the case
   * where a filtering is applied to the table on initial load, this can be
   * indicated by giving the parameter as an array, where the first element is
   * the number of records available after filtering and the second element is the
   * number of records without filtering (allowing the table information element
   * to be shown correctly).
   *  @type int | array
   *  @default null
   *
   *  @dtopt Options
   *  @name DataTable.defaults.deferLoading
   *
   *  @example
   *    // 57 records available in the table, no filtering applied
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "serverSide": true,
   *        "ajax": "scripts/server_processing.php",
   *        "deferLoading": 57
   *      } );
   *    } );
   *
   *  @example
   *    // 57 records after filtering, 100 without filtering (an initial filter applied)
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "serverSide": true,
   *        "ajax": "scripts/server_processing.php",
   *        "deferLoading": [ 57, 100 ],
   *        "search": {
   *          "search": "my_filter"
   *        }
   *      } );
   *    } );
   */
		"iDeferLoading": null,

		/**
   * Number of rows to display on a single page when using pagination. If
   * feature enabled (`lengthChange`) then the end user will be able to override
   * this to a custom setting using a pop-up menu.
   *  @type int
   *  @default 10
   *
   *  @dtopt Options
   *  @name DataTable.defaults.pageLength
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "pageLength": 50
   *      } );
   *    } )
   */
		"iDisplayLength": 10,

		/**
   * Define the starting point for data display when using DataTables with
   * pagination. Note that this parameter is the number of records, rather than
   * the page number, so if you have 10 records per page and want to start on
   * the third page, it should be "20".
   *  @type int
   *  @default 0
   *
   *  @dtopt Options
   *  @name DataTable.defaults.displayStart
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "displayStart": 20
   *      } );
   *    } )
   */
		"iDisplayStart": 0,

		/**
   * By default DataTables allows keyboard navigation of the table (sorting, paging,
   * and filtering) by adding a `tabindex` attribute to the required elements. This
   * allows you to tab through the controls and press the enter key to activate them.
   * The tabindex is default 0, meaning that the tab follows the flow of the document.
   * You can overrule this using this parameter if you wish. Use a value of -1 to
   * disable built-in keyboard navigation.
   *  @type int
   *  @default 0
   *
   *  @dtopt Options
   *  @name DataTable.defaults.tabIndex
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "tabIndex": 1
   *      } );
   *    } );
   */
		"iTabIndex": 0,

		/**
   * Classes that DataTables assigns to the various components and features
   * that it adds to the HTML table. This allows classes to be configured
   * during initialisation in addition to through the static
   * {@link DataTable.ext.oStdClasses} object).
   *  @namespace
   *  @name DataTable.defaults.classes
   */
		"oClasses": {},

		/**
   * All strings that DataTables uses in the user interface that it creates
   * are defined in this object, allowing you to modified them individually or
   * completely replace them all as required.
   *  @namespace
   *  @name DataTable.defaults.language
   */
		"oLanguage": {
			/**
    * Strings that are used for WAI-ARIA labels and controls only (these are not
    * actually visible on the page, but will be read by screenreaders, and thus
    * must be internationalised as well).
    *  @namespace
    *  @name DataTable.defaults.language.aria
    */
			"oAria": {
				/**
     * ARIA label that is added to the table headers when the column may be
     * sorted ascending by activing the column (click or return when focused).
     * Note that the column header is prefixed to this string.
     *  @type string
     *  @default : activate to sort column ascending
     *
     *  @dtopt Language
     *  @name DataTable.defaults.language.aria.sortAscending
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "language": {
     *          "aria": {
     *            "sortAscending": " - click/return to sort ascending"
     *          }
     *        }
     *      } );
     *    } );
     */
				"sSortAscending": ": activate to sort column ascending",

				/**
     * ARIA label that is added to the table headers when the column may be
     * sorted descending by activing the column (click or return when focused).
     * Note that the column header is prefixed to this string.
     *  @type string
     *  @default : activate to sort column ascending
     *
     *  @dtopt Language
     *  @name DataTable.defaults.language.aria.sortDescending
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "language": {
     *          "aria": {
     *            "sortDescending": " - click/return to sort descending"
     *          }
     *        }
     *      } );
     *    } );
     */
				"sSortDescending": ": activate to sort column descending"
			},

			/**
    * Pagination string used by DataTables for the built-in pagination
    * control types.
    *  @namespace
    *  @name DataTable.defaults.language.paginate
    */
			"oPaginate": {
				/**
     * Text to use when using the 'full_numbers' type of pagination for the
     * button to take the user to the first page.
     *  @type string
     *  @default First
     *
     *  @dtopt Language
     *  @name DataTable.defaults.language.paginate.first
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "language": {
     *          "paginate": {
     *            "first": "First page"
     *          }
     *        }
     *      } );
     *    } );
     */
				"sFirst": "First",

				/**
     * Text to use when using the 'full_numbers' type of pagination for the
     * button to take the user to the last page.
     *  @type string
     *  @default Last
     *
     *  @dtopt Language
     *  @name DataTable.defaults.language.paginate.last
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "language": {
     *          "paginate": {
     *            "last": "Last page"
     *          }
     *        }
     *      } );
     *    } );
     */
				"sLast": "Last",

				/**
     * Text to use for the 'next' pagination button (to take the user to the
     * next page).
     *  @type string
     *  @default Next
     *
     *  @dtopt Language
     *  @name DataTable.defaults.language.paginate.next
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "language": {
     *          "paginate": {
     *            "next": "Next page"
     *          }
     *        }
     *      } );
     *    } );
     */
				"sNext": "Next",

				/**
     * Text to use for the 'previous' pagination button (to take the user to
     * the previous page).
     *  @type string
     *  @default Previous
     *
     *  @dtopt Language
     *  @name DataTable.defaults.language.paginate.previous
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "language": {
     *          "paginate": {
     *            "previous": "Previous page"
     *          }
     *        }
     *      } );
     *    } );
     */
				"sPrevious": "Previous"
			},

			/**
    * This string is shown in preference to `zeroRecords` when the table is
    * empty of data (regardless of filtering). Note that this is an optional
    * parameter - if it is not given, the value of `zeroRecords` will be used
    * instead (either the default or given value).
    *  @type string
    *  @default No data available in table
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.emptyTable
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "emptyTable": "No data available in table"
    *        }
    *      } );
    *    } );
    */
			"sEmptyTable": "No data available in table",

			/**
    * This string gives information to the end user about the information
    * that is current on display on the page. The following tokens can be
    * used in the string and will be dynamically replaced as the table
    * display updates. This tokens can be placed anywhere in the string, or
    * removed as needed by the language requires:
    *
    * * `\_START\_` - Display index of the first record on the current page
    * * `\_END\_` - Display index of the last record on the current page
    * * `\_TOTAL\_` - Number of records in the table after filtering
    * * `\_MAX\_` - Number of records in the table without filtering
    * * `\_PAGE\_` - Current page number
    * * `\_PAGES\_` - Total number of pages of data in the table
    *
    *  @type string
    *  @default Showing _START_ to _END_ of _TOTAL_ entries
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.info
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "info": "Showing page _PAGE_ of _PAGES_"
    *        }
    *      } );
    *    } );
    */
			"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",

			/**
    * Display information string for when the table is empty. Typically the
    * format of this string should match `info`.
    *  @type string
    *  @default Showing 0 to 0 of 0 entries
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.infoEmpty
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "infoEmpty": "No entries to show"
    *        }
    *      } );
    *    } );
    */
			"sInfoEmpty": "Showing 0 to 0 of 0 entries",

			/**
    * When a user filters the information in a table, this string is appended
    * to the information (`info`) to give an idea of how strong the filtering
    * is. The variable _MAX_ is dynamically updated.
    *  @type string
    *  @default (filtered from _MAX_ total entries)
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.infoFiltered
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "infoFiltered": " - filtering from _MAX_ records"
    *        }
    *      } );
    *    } );
    */
			"sInfoFiltered": "(filtered from _MAX_ total entries)",

			/**
    * If can be useful to append extra information to the info string at times,
    * and this variable does exactly that. This information will be appended to
    * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
    * being used) at all times.
    *  @type string
    *  @default <i>Empty string</i>
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.infoPostFix
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "infoPostFix": "All records shown are derived from real information."
    *        }
    *      } );
    *    } );
    */
			"sInfoPostFix": "",

			/**
    * This decimal place operator is a little different from the other
    * language options since DataTables doesn't output floating point
    * numbers, so it won't ever use this for display of a number. Rather,
    * what this parameter does is modify the sort methods of the table so
    * that numbers which are in a format which has a character other than
    * a period (`.`) as a decimal place will be sorted numerically.
    *
    * Note that numbers with different decimal places cannot be shown in
    * the same table and still be sortable, the table must be consistent.
    * However, multiple different tables on the page can use different
    * decimal place characters.
    *  @type string
    *  @default 
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.decimal
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "decimal": ","
    *          "thousands": "."
    *        }
    *      } );
    *    } );
    */
			"sDecimal": "",

			/**
    * DataTables has a build in number formatter (`formatNumber`) which is
    * used to format large numbers that are used in the table information.
    * By default a comma is used, but this can be trivially changed to any
    * character you wish with this parameter.
    *  @type string
    *  @default ,
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.thousands
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "thousands": "'"
    *        }
    *      } );
    *    } );
    */
			"sThousands": ",",

			/**
    * Detail the action that will be taken when the drop down menu for the
    * pagination length option is changed. The '_MENU_' variable is replaced
    * with a default select list of 10, 25, 50 and 100, and can be replaced
    * with a custom select box if required.
    *  @type string
    *  @default Show _MENU_ entries
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.lengthMenu
    *
    *  @example
    *    // Language change only
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "lengthMenu": "Display _MENU_ records"
    *        }
    *      } );
    *    } );
    *
    *  @example
    *    // Language and options change
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "lengthMenu": 'Display <select>'+
    *            '<option value="10">10</option>'+
    *            '<option value="20">20</option>'+
    *            '<option value="30">30</option>'+
    *            '<option value="40">40</option>'+
    *            '<option value="50">50</option>'+
    *            '<option value="-1">All</option>'+
    *            '</select> records'
    *        }
    *      } );
    *    } );
    */
			"sLengthMenu": "Show _MENU_ entries",

			/**
    * When using Ajax sourced data and during the first draw when DataTables is
    * gathering the data, this message is shown in an empty row in the table to
    * indicate to the end user the the data is being loaded. Note that this
    * parameter is not used when loading data by server-side processing, just
    * Ajax sourced data with client-side processing.
    *  @type string
    *  @default Loading...
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.loadingRecords
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "loadingRecords": "Please wait - loading..."
    *        }
    *      } );
    *    } );
    */
			"sLoadingRecords": "Loading...",

			/**
    * Text which is displayed when the table is processing a user action
    * (usually a sort command or similar).
    *  @type string
    *  @default Processing...
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.processing
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "processing": "DataTables is currently busy"
    *        }
    *      } );
    *    } );
    */
			"sProcessing": "Processing...",

			/**
    * Details the actions that will be taken when the user types into the
    * filtering input text box. The variable "_INPUT_", if used in the string,
    * is replaced with the HTML text box for the filtering input allowing
    * control over where it appears in the string. If "_INPUT_" is not given
    * then the input box is appended to the string automatically.
    *  @type string
    *  @default Search:
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.search
    *
    *  @example
    *    // Input text box will be appended at the end automatically
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "search": "Filter records:"
    *        }
    *      } );
    *    } );
    *
    *  @example
    *    // Specify where the filter should appear
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "search": "Apply filter _INPUT_ to table"
    *        }
    *      } );
    *    } );
    */
			"sSearch": "Search:",

			/**
    * Assign a `placeholder` attribute to the search `input` element
    *  @type string
    *  @default 
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.searchPlaceholder
    */
			"sSearchPlaceholder": "",

			/**
    * All of the language information can be stored in a file on the
    * server-side, which DataTables will look up if this parameter is passed.
    * It must store the URL of the language file, which is in a JSON format,
    * and the object has the same properties as the oLanguage object in the
    * initialiser object (i.e. the above parameters). Please refer to one of
    * the example language files to see how this works in action.
    *  @type string
    *  @default <i>Empty string - i.e. disabled</i>
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.url
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
    *        }
    *      } );
    *    } );
    */
			"sUrl": "",

			/**
    * Text shown inside the table records when the is no information to be
    * displayed after filtering. `emptyTable` is shown when there is simply no
    * information in the table at all (regardless of filtering).
    *  @type string
    *  @default No matching records found
    *
    *  @dtopt Language
    *  @name DataTable.defaults.language.zeroRecords
    *
    *  @example
    *    $(document).ready( function() {
    *      $('#example').dataTable( {
    *        "language": {
    *          "zeroRecords": "No records to display"
    *        }
    *      } );
    *    } );
    */
			"sZeroRecords": "No matching records found"
		},

		/**
   * This parameter allows you to have define the global filtering state at
   * initialisation time. As an object the `search` parameter must be
   * defined, but all other parameters are optional. When `regex` is true,
   * the search string will be treated as a regular expression, when false
   * (default) it will be treated as a straight string. When `smart`
   * DataTables will use it's smart filtering methods (to word match at
   * any point in the data), when false this will not be done.
   *  @namespace
   *  @extends DataTable.models.oSearch
   *
   *  @dtopt Options
   *  @name DataTable.defaults.search
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "search": {"search": "Initial search"}
   *      } );
   *    } )
   */
		"oSearch": $.extend({}, DataTable.models.oSearch),

		/**
   * __Deprecated__ The functionality provided by this parameter has now been
   * superseded by that provided through `ajax`, which should be used instead.
   *
   * By default DataTables will look for the property `data` (or `aaData` for
   * compatibility with DataTables 1.9-) when obtaining data from an Ajax
   * source or for server-side processing - this parameter allows that
   * property to be changed. You can use Javascript dotted object notation to
   * get a data source for multiple levels of nesting.
   *  @type string
   *  @default data
   *
   *  @dtopt Options
   *  @dtopt Server-side
   *  @name DataTable.defaults.ajaxDataProp
   *
   *  @deprecated 1.10. Please use `ajax` for this functionality now.
   */
		"sAjaxDataProp": "data",

		/**
   * __Deprecated__ The functionality provided by this parameter has now been
   * superseded by that provided through `ajax`, which should be used instead.
   *
   * You can instruct DataTables to load data from an external
   * source using this parameter (use aData if you want to pass data in you
   * already have). Simply provide a url a JSON object can be obtained from.
   *  @type string
   *  @default null
   *
   *  @dtopt Options
   *  @dtopt Server-side
   *  @name DataTable.defaults.ajaxSource
   *
   *  @deprecated 1.10. Please use `ajax` for this functionality now.
   */
		"sAjaxSource": null,

		/**
   * This initialisation variable allows you to specify exactly where in the
   * DOM you want DataTables to inject the various controls it adds to the page
   * (for example you might want the pagination controls at the top of the
   * table). DIV elements (with or without a custom class) can also be added to
   * aid styling. The follow syntax is used:
   *   <ul>
   *     <li>The following options are allowed:
   *       <ul>
   *         <li>'l' - Length changing</li>
   *         <li>'f' - Filtering input</li>
   *         <li>'t' - The table!</li>
   *         <li>'i' - Information</li>
   *         <li>'p' - Pagination</li>
   *         <li>'r' - pRocessing</li>
   *       </ul>
   *     </li>
   *     <li>The following constants are allowed:
   *       <ul>
   *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
   *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
   *       </ul>
   *     </li>
   *     <li>The following syntax is expected:
   *       <ul>
   *         <li>'&lt;' and '&gt;' - div elements</li>
   *         <li>'&lt;"class" and '&gt;' - div with a class</li>
   *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
   *       </ul>
   *     </li>
   *     <li>Examples:
   *       <ul>
   *         <li>'&lt;"wrapper"flipt&gt;'</li>
   *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
   *       </ul>
   *     </li>
   *   </ul>
   *  @type string
   *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
   *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
   *
   *  @dtopt Options
   *  @name DataTable.defaults.dom
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
   *      } );
   *    } );
   */
		"sDom": "lfrtip",

		/**
   * Search delay option. This will throttle full table searches that use the
   * DataTables provided search input element (it does not effect calls to
   * `dt-api search()`, providing a delay before the search is made.
   *  @type integer
   *  @default 0
   *
   *  @dtopt Options
   *  @name DataTable.defaults.searchDelay
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "searchDelay": 200
   *      } );
   *    } )
   */
		"searchDelay": null,

		/**
   * DataTables features six different built-in options for the buttons to
   * display for pagination control:
   *
   * * `numbers` - Page number buttons only
   * * `simple` - 'Previous' and 'Next' buttons only
   * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
   * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
   * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
   * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
   *  
   * Further methods can be added using {@link DataTable.ext.oPagination}.
   *  @type string
   *  @default simple_numbers
   *
   *  @dtopt Options
   *  @name DataTable.defaults.pagingType
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "pagingType": "full_numbers"
   *      } );
   *    } )
   */
		"sPaginationType": "simple_numbers",

		/**
   * Enable horizontal scrolling. When a table is too wide to fit into a
   * certain layout, or you have a large number of columns in the table, you
   * can enable x-scrolling to show the table in a viewport, which can be
   * scrolled. This property can be `true` which will allow the table to
   * scroll horizontally when needed, or any CSS unit, or a number (in which
   * case it will be treated as a pixel measurement). Setting as simply `true`
   * is recommended.
   *  @type boolean|string
   *  @default <i>blank string - i.e. disabled</i>
   *
   *  @dtopt Features
   *  @name DataTable.defaults.scrollX
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "scrollX": true,
   *        "scrollCollapse": true
   *      } );
   *    } );
   */
		"sScrollX": "",

		/**
   * This property can be used to force a DataTable to use more width than it
   * might otherwise do when x-scrolling is enabled. For example if you have a
   * table which requires to be well spaced, this parameter is useful for
   * "over-sizing" the table, and thus forcing scrolling. This property can by
   * any CSS unit, or a number (in which case it will be treated as a pixel
   * measurement).
   *  @type string
   *  @default <i>blank string - i.e. disabled</i>
   *
   *  @dtopt Options
   *  @name DataTable.defaults.scrollXInner
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "scrollX": "100%",
   *        "scrollXInner": "110%"
   *      } );
   *    } );
   */
		"sScrollXInner": "",

		/**
   * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
   * to the given height, and enable scrolling for any data which overflows the
   * current viewport. This can be used as an alternative to paging to display
   * a lot of data in a small area (although paging and scrolling can both be
   * enabled at the same time). This property can be any CSS unit, or a number
   * (in which case it will be treated as a pixel measurement).
   *  @type string
   *  @default <i>blank string - i.e. disabled</i>
   *
   *  @dtopt Features
   *  @name DataTable.defaults.scrollY
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "scrollY": "200px",
   *        "paginate": false
   *      } );
   *    } );
   */
		"sScrollY": "",

		/**
   * __Deprecated__ The functionality provided by this parameter has now been
   * superseded by that provided through `ajax`, which should be used instead.
   *
   * Set the HTTP method that is used to make the Ajax call for server-side
   * processing or Ajax sourced data.
   *  @type string
   *  @default GET
   *
   *  @dtopt Options
   *  @dtopt Server-side
   *  @name DataTable.defaults.serverMethod
   *
   *  @deprecated 1.10. Please use `ajax` for this functionality now.
   */
		"sServerMethod": "GET",

		/**
   * DataTables makes use of renderers when displaying HTML elements for
   * a table. These renderers can be added or modified by plug-ins to
   * generate suitable mark-up for a site. For example the Bootstrap
   * integration plug-in for DataTables uses a paging button renderer to
   * display pagination buttons in the mark-up required by Bootstrap.
   *
   * For further information about the renderers available see
   * DataTable.ext.renderer
   *  @type string|object
   *  @default null
   *
   *  @name DataTable.defaults.renderer
   *
   */
		"renderer": null,

		/**
   * Set the data property name that DataTables should use to get a row's id
   * to set as the `id` property in the node.
   *  @type string
   *  @default DT_RowId
   *
   *  @name DataTable.defaults.rowId
   */
		"rowId": "DT_RowId"
	};

	_fnHungarianMap(DataTable.defaults);

	/*
  * Developer note - See note in model.defaults.js about the use of Hungarian
  * notation and camel case.
  */

	/**
  * Column options that can be given to DataTables at initialisation time.
  *  @namespace
  */
	DataTable.defaults.column = {
		/**
   * Define which column(s) an order will occur on for this column. This
   * allows a column's ordering to take multiple columns into account when
   * doing a sort or use the data from a different column. For example first
   * name / last name columns make sense to do a multi-column sort over the
   * two columns.
   *  @type array|int
   *  @default null <i>Takes the value of the column index automatically</i>
   *
   *  @name DataTable.defaults.column.orderData
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
   *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
   *          { "orderData": 2, "targets": [ 2 ] }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          { "orderData": [ 0, 1 ] },
   *          { "orderData": [ 1, 0 ] },
   *          { "orderData": 2 },
   *          null,
   *          null
   *        ]
   *      } );
   *    } );
   */
		"aDataSort": null,
		"iDataSort": -1,

		/**
   * You can control the default ordering direction, and even alter the
   * behaviour of the sort handler (i.e. only allow ascending ordering etc)
   * using this parameter.
   *  @type array
   *  @default [ 'asc', 'desc' ]
   *
   *  @name DataTable.defaults.column.orderSequence
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
   *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
   *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          null,
   *          { "orderSequence": [ "asc" ] },
   *          { "orderSequence": [ "desc", "asc", "asc" ] },
   *          { "orderSequence": [ "desc" ] },
   *          null
   *        ]
   *      } );
   *    } );
   */
		"asSorting": ['asc', 'desc'],

		/**
   * Enable or disable filtering on the data in this column.
   *  @type boolean
   *  @default true
   *
   *  @name DataTable.defaults.column.searchable
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "searchable": false, "targets": [ 0 ] }
   *        ] } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          { "searchable": false },
   *          null,
   *          null,
   *          null,
   *          null
   *        ] } );
   *    } );
   */
		"bSearchable": true,

		/**
   * Enable or disable ordering on this column.
   *  @type boolean
   *  @default true
   *
   *  @name DataTable.defaults.column.orderable
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "orderable": false, "targets": [ 0 ] }
   *        ] } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          { "orderable": false },
   *          null,
   *          null,
   *          null,
   *          null
   *        ] } );
   *    } );
   */
		"bSortable": true,

		/**
   * Enable or disable the display of this column.
   *  @type boolean
   *  @default true
   *
   *  @name DataTable.defaults.column.visible
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "visible": false, "targets": [ 0 ] }
   *        ] } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          { "visible": false },
   *          null,
   *          null,
   *          null,
   *          null
   *        ] } );
   *    } );
   */
		"bVisible": true,

		/**
   * Developer definable function that is called whenever a cell is created (Ajax source,
   * etc) or processed for input (DOM source). This can be used as a compliment to mRender
   * allowing you to modify the DOM element (add background colour for example) when the
   * element is available.
   *  @type function
   *  @param {element} td The TD node that has been created
   *  @param {*} cellData The Data for the cell
   *  @param {array|object} rowData The data for the whole row
   *  @param {int} row The row index for the aoData data store
   *  @param {int} col The column index for aoColumns
   *
   *  @name DataTable.defaults.column.createdCell
   *  @dtopt Columns
   *
   *  @example
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [ {
   *          "targets": [3],
   *          "createdCell": function (td, cellData, rowData, row, col) {
   *            if ( cellData == "1.7" ) {
   *              $(td).css('color', 'blue')
   *            }
   *          }
   *        } ]
   *      });
   *    } );
   */
		"fnCreatedCell": null,

		/**
   * This parameter has been replaced by `data` in DataTables to ensure naming
   * consistency. `dataProp` can still be used, as there is backwards
   * compatibility in DataTables for this option, but it is strongly
   * recommended that you use `data` in preference to `dataProp`.
   *  @name DataTable.defaults.column.dataProp
   */

		/**
   * This property can be used to read data from any data source property,
   * including deeply nested objects / properties. `data` can be given in a
   * number of different ways which effect its behaviour:
   *
   * * `integer` - treated as an array index for the data source. This is the
   *   default that DataTables uses (incrementally increased for each column).
   * * `string` - read an object property from the data source. There are
   *   three 'special' options that can be used in the string to alter how
   *   DataTables reads the data from the source object:
   *    * `.` - Dotted Javascript notation. Just as you use a `.` in
   *      Javascript to read from nested objects, so to can the options
   *      specified in `data`. For example: `browser.version` or
   *      `browser.name`. If your object parameter name contains a period, use
   *      `\\` to escape it - i.e. `first\\.name`.
   *    * `[]` - Array notation. DataTables can automatically combine data
   *      from and array source, joining the data with the characters provided
   *      between the two brackets. For example: `name[, ]` would provide a
   *      comma-space separated list from the source array. If no characters
   *      are provided between the brackets, the original array source is
   *      returned.
   *    * `()` - Function notation. Adding `()` to the end of a parameter will
   *      execute a function of the name given. For example: `browser()` for a
   *      simple function on the data source, `browser.version()` for a
   *      function in a nested property or even `browser().version` to get an
   *      object property if the function called returns an object. Note that
   *      function notation is recommended for use in `render` rather than
   *      `data` as it is much simpler to use as a renderer.
   * * `null` - use the original data source for the row rather than plucking
   *   data directly from it. This action has effects on two other
   *   initialisation options:
   *    * `defaultContent` - When null is given as the `data` option and
   *      `defaultContent` is specified for the column, the value defined by
   *      `defaultContent` will be used for the cell.
   *    * `render` - When null is used for the `data` option and the `render`
   *      option is specified for the column, the whole data source for the
   *      row is used for the renderer.
   * * `function` - the function given will be executed whenever DataTables
   *   needs to set or get the data for a cell in the column. The function
   *   takes three parameters:
   *    * Parameters:
   *      * `{array|object}` The data source for the row
   *      * `{string}` The type call data requested - this will be 'set' when
   *        setting data or 'filter', 'display', 'type', 'sort' or undefined
   *        when gathering data. Note that when `undefined` is given for the
   *        type DataTables expects to get the raw data for the object back<
   *      * `{*}` Data to set when the second parameter is 'set'.
   *    * Return:
   *      * The return value from the function is not required when 'set' is
   *        the type of call, but otherwise the return is what will be used
   *        for the data requested.
   *
   * Note that `data` is a getter and setter option. If you just require
   * formatting of data for output, you will likely want to use `render` which
   * is simply a getter and thus simpler to use.
   *
   * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
   * name change reflects the flexibility of this property and is consistent
   * with the naming of mRender. If 'mDataProp' is given, then it will still
   * be used by DataTables, as it automatically maps the old name to the new
   * if required.
   *
   *  @type string|int|function|null
   *  @default null <i>Use automatically calculated column index</i>
   *
   *  @name DataTable.defaults.column.data
   *  @dtopt Columns
   *
   *  @example
   *    // Read table data from objects
   *    // JSON structure for each row:
   *    //   {
   *    //      "engine": {value},
   *    //      "browser": {value},
   *    //      "platform": {value},
   *    //      "version": {value},
   *    //      "grade": {value}
   *    //   }
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "ajaxSource": "sources/objects.txt",
   *        "columns": [
   *          { "data": "engine" },
   *          { "data": "browser" },
   *          { "data": "platform" },
   *          { "data": "version" },
   *          { "data": "grade" }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Read information from deeply nested objects
   *    // JSON structure for each row:
   *    //   {
   *    //      "engine": {value},
   *    //      "browser": {value},
   *    //      "platform": {
   *    //         "inner": {value}
   *    //      },
   *    //      "details": [
   *    //         {value}, {value}
   *    //      ]
   *    //   }
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "ajaxSource": "sources/deep.txt",
   *        "columns": [
   *          { "data": "engine" },
   *          { "data": "browser" },
   *          { "data": "platform.inner" },
   *          { "data": "platform.details.0" },
   *          { "data": "platform.details.1" }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using `data` as a function to provide different information for
   *    // sorting, filtering and display. In this case, currency (price)
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [ {
   *          "targets": [ 0 ],
   *          "data": function ( source, type, val ) {
   *            if (type === 'set') {
   *              source.price = val;
   *              // Store the computed dislay and filter values for efficiency
   *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
   *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
   *              return;
   *            }
   *            else if (type === 'display') {
   *              return source.price_display;
   *            }
   *            else if (type === 'filter') {
   *              return source.price_filter;
   *            }
   *            // 'sort', 'type' and undefined all just use the integer
   *            return source.price;
   *          }
   *        } ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using default content
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [ {
   *          "targets": [ 0 ],
   *          "data": null,
   *          "defaultContent": "Click to edit"
   *        } ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using array notation - outputting a list from an array
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [ {
   *          "targets": [ 0 ],
   *          "data": "name[, ]"
   *        } ]
   *      } );
   *    } );
   *
   */
		"mData": null,

		/**
   * This property is the rendering partner to `data` and it is suggested that
   * when you want to manipulate data for display (including filtering,
   * sorting etc) without altering the underlying data for the table, use this
   * property. `render` can be considered to be the the read only companion to
   * `data` which is read / write (then as such more complex). Like `data`
   * this option can be given in a number of different ways to effect its
   * behaviour:
   *
   * * `integer` - treated as an array index for the data source. This is the
   *   default that DataTables uses (incrementally increased for each column).
   * * `string` - read an object property from the data source. There are
   *   three 'special' options that can be used in the string to alter how
   *   DataTables reads the data from the source object:
   *    * `.` - Dotted Javascript notation. Just as you use a `.` in
   *      Javascript to read from nested objects, so to can the options
   *      specified in `data`. For example: `browser.version` or
   *      `browser.name`. If your object parameter name contains a period, use
   *      `\\` to escape it - i.e. `first\\.name`.
   *    * `[]` - Array notation. DataTables can automatically combine data
   *      from and array source, joining the data with the characters provided
   *      between the two brackets. For example: `name[, ]` would provide a
   *      comma-space separated list from the source array. If no characters
   *      are provided between the brackets, the original array source is
   *      returned.
   *    * `()` - Function notation. Adding `()` to the end of a parameter will
   *      execute a function of the name given. For example: `browser()` for a
   *      simple function on the data source, `browser.version()` for a
   *      function in a nested property or even `browser().version` to get an
   *      object property if the function called returns an object.
   * * `object` - use different data for the different data types requested by
   *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
   *   of the object is the data type the property refers to and the value can
   *   defined using an integer, string or function using the same rules as
   *   `render` normally does. Note that an `_` option _must_ be specified.
   *   This is the default value to use if you haven't specified a value for
   *   the data type requested by DataTables.
   * * `function` - the function given will be executed whenever DataTables
   *   needs to set or get the data for a cell in the column. The function
   *   takes three parameters:
   *    * Parameters:
   *      * {array|object} The data source for the row (based on `data`)
   *      * {string} The type call data requested - this will be 'filter',
   *        'display', 'type' or 'sort'.
   *      * {array|object} The full data source for the row (not based on
   *        `data`)
   *    * Return:
   *      * The return value from the function is what will be used for the
   *        data requested.
   *
   *  @type string|int|function|object|null
   *  @default null Use the data source value.
   *
   *  @name DataTable.defaults.column.render
   *  @dtopt Columns
   *
   *  @example
   *    // Create a comma separated list from an array of objects
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "ajaxSource": "sources/deep.txt",
   *        "columns": [
   *          { "data": "engine" },
   *          { "data": "browser" },
   *          {
   *            "data": "platform",
   *            "render": "[, ].name"
   *          }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Execute a function to obtain data
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [ {
   *          "targets": [ 0 ],
   *          "data": null, // Use the full data source object for the renderer's source
   *          "render": "browserName()"
   *        } ]
   *      } );
   *    } );
   *
   *  @example
   *    // As an object, extracting different data for the different types
   *    // This would be used with a data source such as:
   *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
   *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
   *    // (which has both forms) is used for filtering for if a user inputs either format, while
   *    // the formatted phone number is the one that is shown in the table.
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [ {
   *          "targets": [ 0 ],
   *          "data": null, // Use the full data source object for the renderer's source
   *          "render": {
   *            "_": "phone",
   *            "filter": "phone_filter",
   *            "display": "phone_display"
   *          }
   *        } ]
   *      } );
   *    } );
   *
   *  @example
   *    // Use as a function to create a link from the data source
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [ {
   *          "targets": [ 0 ],
   *          "data": "download_link",
   *          "render": function ( data, type, full ) {
   *            return '<a href="'+data+'">Download</a>';
   *          }
   *        } ]
   *      } );
   *    } );
   */
		"mRender": null,

		/**
   * Change the cell type created for the column - either TD cells or TH cells. This
   * can be useful as TH cells have semantic meaning in the table body, allowing them
   * to act as a header for a row (you may wish to add scope='row' to the TH elements).
   *  @type string
   *  @default td
   *
   *  @name DataTable.defaults.column.cellType
   *  @dtopt Columns
   *
   *  @example
   *    // Make the first column use TH cells
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [ {
   *          "targets": [ 0 ],
   *          "cellType": "th"
   *        } ]
   *      } );
   *    } );
   */
		"sCellType": "td",

		/**
   * Class to give to each cell in this column.
   *  @type string
   *  @default <i>Empty string</i>
   *
   *  @name DataTable.defaults.column.class
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "class": "my_class", "targets": [ 0 ] }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          { "class": "my_class" },
   *          null,
   *          null,
   *          null,
   *          null
   *        ]
   *      } );
   *    } );
   */
		"sClass": "",

		/**
   * When DataTables calculates the column widths to assign to each column,
   * it finds the longest string in each column and then constructs a
   * temporary table and reads the widths from that. The problem with this
   * is that "mmm" is much wider then "iiii", but the latter is a longer
   * string - thus the calculation can go wrong (doing it properly and putting
   * it into an DOM object and measuring that is horribly(!) slow). Thus as
   * a "work around" we provide this option. It will append its value to the
   * text that is found to be the longest string for the column - i.e. padding.
   * Generally you shouldn't need this!
   *  @type string
   *  @default <i>Empty string<i>
   *
   *  @name DataTable.defaults.column.contentPadding
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          null,
   *          null,
   *          null,
   *          {
   *            "contentPadding": "mmm"
   *          }
   *        ]
   *      } );
   *    } );
   */
		"sContentPadding": "",

		/**
   * Allows a default value to be given for a column's data, and will be used
   * whenever a null data source is encountered (this can be because `data`
   * is set to null, or because the data source itself is null).
   *  @type string
   *  @default null
   *
   *  @name DataTable.defaults.column.defaultContent
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          {
   *            "data": null,
   *            "defaultContent": "Edit",
   *            "targets": [ -1 ]
   *          }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          null,
   *          null,
   *          null,
   *          {
   *            "data": null,
   *            "defaultContent": "Edit"
   *          }
   *        ]
   *      } );
   *    } );
   */
		"sDefaultContent": null,

		/**
   * This parameter is only used in DataTables' server-side processing. It can
   * be exceptionally useful to know what columns are being displayed on the
   * client side, and to map these to database fields. When defined, the names
   * also allow DataTables to reorder information from the server if it comes
   * back in an unexpected order (i.e. if you switch your columns around on the
   * client-side, your server-side code does not also need updating).
   *  @type string
   *  @default <i>Empty string</i>
   *
   *  @name DataTable.defaults.column.name
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "name": "engine", "targets": [ 0 ] },
   *          { "name": "browser", "targets": [ 1 ] },
   *          { "name": "platform", "targets": [ 2 ] },
   *          { "name": "version", "targets": [ 3 ] },
   *          { "name": "grade", "targets": [ 4 ] }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          { "name": "engine" },
   *          { "name": "browser" },
   *          { "name": "platform" },
   *          { "name": "version" },
   *          { "name": "grade" }
   *        ]
   *      } );
   *    } );
   */
		"sName": "",

		/**
   * Defines a data source type for the ordering which can be used to read
   * real-time information from the table (updating the internally cached
   * version) prior to ordering. This allows ordering to occur on user
   * editable elements such as form inputs.
   *  @type string
   *  @default std
   *
   *  @name DataTable.defaults.column.orderDataType
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
   *          { "type": "numeric", "targets": [ 3 ] },
   *          { "orderDataType": "dom-select", "targets": [ 4 ] },
   *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          null,
   *          null,
   *          { "orderDataType": "dom-text" },
   *          { "orderDataType": "dom-text", "type": "numeric" },
   *          { "orderDataType": "dom-select" },
   *          { "orderDataType": "dom-checkbox" }
   *        ]
   *      } );
   *    } );
   */
		"sSortDataType": "std",

		/**
   * The title of this column.
   *  @type string
   *  @default null <i>Derived from the 'TH' value for this column in the
   *    original HTML table.</i>
   *
   *  @name DataTable.defaults.column.title
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "title": "My column title", "targets": [ 0 ] }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          { "title": "My column title" },
   *          null,
   *          null,
   *          null,
   *          null
   *        ]
   *      } );
   *    } );
   */
		"sTitle": null,

		/**
   * The type allows you to specify how the data for this column will be
   * ordered. Four types (string, numeric, date and html (which will strip
   * HTML tags before ordering)) are currently available. Note that only date
   * formats understood by Javascript's Date() object will be accepted as type
   * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
   * 'numeric', 'date' or 'html' (by default). Further types can be adding
   * through plug-ins.
   *  @type string
   *  @default null <i>Auto-detected from raw data</i>
   *
   *  @name DataTable.defaults.column.type
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "type": "html", "targets": [ 0 ] }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          { "type": "html" },
   *          null,
   *          null,
   *          null,
   *          null
   *        ]
   *      } );
   *    } );
   */
		"sType": null,

		/**
   * Defining the width of the column, this parameter may take any CSS value
   * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
   * been given a specific width through this interface ensuring that the table
   * remains readable.
   *  @type string
   *  @default null <i>Automatic</i>
   *
   *  @name DataTable.defaults.column.width
   *  @dtopt Columns
   *
   *  @example
   *    // Using `columnDefs`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columnDefs": [
   *          { "width": "20%", "targets": [ 0 ] }
   *        ]
   *      } );
   *    } );
   *
   *  @example
   *    // Using `columns`
   *    $(document).ready( function() {
   *      $('#example').dataTable( {
   *        "columns": [
   *          { "width": "20%" },
   *          null,
   *          null,
   *          null,
   *          null
   *        ]
   *      } );
   *    } );
   */
		"sWidth": null
	};

	_fnHungarianMap(DataTable.defaults.column);

	/**
  * DataTables settings object - this holds all the information needed for a
  * given table, including configuration, data and current application of the
  * table options. DataTables does not have a single instance for each DataTable
  * with the settings attached to that instance, but rather instances of the
  * DataTable "class" are created on-the-fly as needed (typically by a
  * $().dataTable() call) and the settings object is then applied to that
  * instance.
  *
  * Note that this object is related to {@link DataTable.defaults} but this
  * one is the internal data store for DataTables's cache of columns. It should
  * NOT be manipulated outside of DataTables. Any configuration should be done
  * through the initialisation options.
  *  @namespace
  *  @todo Really should attach the settings object to individual instances so we
  *    don't need to create new instances on each $().dataTable() call (if the
  *    table already exists). It would also save passing oSettings around and
  *    into every single function. However, this is a very significant
  *    architecture change for DataTables and will almost certainly break
  *    backwards compatibility with older installations. This is something that
  *    will be done in 2.0.
  */
	DataTable.models.oSettings = {
		/**
   * Primary features of DataTables and their enablement state.
   *  @namespace
   */
		"oFeatures": {

			/**
    * Flag to say if DataTables should automatically try to calculate the
    * optimum table and columns widths (true) or not (false).
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bAutoWidth": null,

			/**
    * Delay the creation of TR and TD elements until they are actually
    * needed by a driven page draw. This can give a significant speed
    * increase for Ajax source and Javascript source data, but makes no
    * difference at all fro DOM and server-side processing tables.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bDeferRender": null,

			/**
    * Enable filtering on the table or not. Note that if this is disabled
    * then there is no filtering at all on the table, including fnFilter.
    * To just remove the filtering input use sDom and remove the 'f' option.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bFilter": null,

			/**
    * Table information element (the 'Showing x of y records' div) enable
    * flag.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bInfo": null,

			/**
    * Present a user control allowing the end user to change the page size
    * when pagination is enabled.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bLengthChange": null,

			/**
    * Pagination enabled or not. Note that if this is disabled then length
    * changing must also be disabled.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bPaginate": null,

			/**
    * Processing indicator enable flag whenever DataTables is enacting a
    * user request - typically an Ajax request for server-side processing.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bProcessing": null,

			/**
    * Server-side processing enabled flag - when enabled DataTables will
    * get all data from the server for every draw - there is no filtering,
    * sorting or paging done on the client-side.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bServerSide": null,

			/**
    * Sorting enablement flag.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bSort": null,

			/**
    * Multi-column sorting
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bSortMulti": null,

			/**
    * Apply a class to the columns which are being sorted to provide a
    * visual highlight or not. This can slow things down when enabled since
    * there is a lot of DOM interaction.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bSortClasses": null,

			/**
    * State saving enablement flag.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bStateSave": null
		},

		/**
   * Scrolling settings for a table.
   *  @namespace
   */
		"oScroll": {
			/**
    * When the table is shorter in height than sScrollY, collapse the
    * table container down to the height of the table (when true).
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type boolean
    */
			"bCollapse": null,

			/**
    * Width of the scrollbar for the web-browser's platform. Calculated
    * during table initialisation.
    *  @type int
    *  @default 0
    */
			"iBarWidth": 0,

			/**
    * Viewport width for horizontal scrolling. Horizontal scrolling is
    * disabled if an empty string.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type string
    */
			"sX": null,

			/**
    * Width to expand the table to when using x-scrolling. Typically you
    * should not need to use this.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type string
    *  @deprecated
    */
			"sXInner": null,

			/**
    * Viewport height for vertical scrolling. Vertical scrolling is disabled
    * if an empty string.
    * Note that this parameter will be set by the initialisation routine. To
    * set a default use {@link DataTable.defaults}.
    *  @type string
    */
			"sY": null
		},

		/**
   * Language information for the table.
   *  @namespace
   *  @extends DataTable.defaults.oLanguage
   */
		"oLanguage": {
			/**
    * Information callback function. See
    * {@link DataTable.defaults.fnInfoCallback}
    *  @type function
    *  @default null
    */
			"fnInfoCallback": null
		},

		/**
   * Browser support parameters
   *  @namespace
   */
		"oBrowser": {
			/**
    * Indicate if the browser incorrectly calculates width:100% inside a
    * scrolling element (IE6/7)
    *  @type boolean
    *  @default false
    */
			"bScrollOversize": false,

			/**
    * Determine if the vertical scrollbar is on the right or left of the
    * scrolling container - needed for rtl language layout, although not
    * all browsers move the scrollbar (Safari).
    *  @type boolean
    *  @default false
    */
			"bScrollbarLeft": false,

			/**
    * Flag for if `getBoundingClientRect` is fully supported or not
    *  @type boolean
    *  @default false
    */
			"bBounding": false,

			/**
    * Browser scrollbar width
    *  @type integer
    *  @default 0
    */
			"barWidth": 0
		},

		"ajax": null,

		/**
   * Array referencing the nodes which are used for the features. The
   * parameters of this object match what is allowed by sDom - i.e.
   *   <ul>
   *     <li>'l' - Length changing</li>
   *     <li>'f' - Filtering input</li>
   *     <li>'t' - The table!</li>
   *     <li>'i' - Information</li>
   *     <li>'p' - Pagination</li>
   *     <li>'r' - pRocessing</li>
   *   </ul>
   *  @type array
   *  @default []
   */
		"aanFeatures": [],

		/**
   * Store data information - see {@link DataTable.models.oRow} for detailed
   * information.
   *  @type array
   *  @default []
   */
		"aoData": [],

		/**
   * Array of indexes which are in the current display (after filtering etc)
   *  @type array
   *  @default []
   */
		"aiDisplay": [],

		/**
   * Array of indexes for display - no filtering
   *  @type array
   *  @default []
   */
		"aiDisplayMaster": [],

		/**
   * Map of row ids to data indexes
   *  @type object
   *  @default {}
   */
		"aIds": {},

		/**
   * Store information about each column that is in use
   *  @type array
   *  @default []
   */
		"aoColumns": [],

		/**
   * Store information about the table's header
   *  @type array
   *  @default []
   */
		"aoHeader": [],

		/**
   * Store information about the table's footer
   *  @type array
   *  @default []
   */
		"aoFooter": [],

		/**
   * Store the applied global search information in case we want to force a
   * research or compare the old search to a new one.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @namespace
   *  @extends DataTable.models.oSearch
   */
		"oPreviousSearch": {},

		/**
   * Store the applied search for each column - see
   * {@link DataTable.models.oSearch} for the format that is used for the
   * filtering information for each column.
   *  @type array
   *  @default []
   */
		"aoPreSearchCols": [],

		/**
   * Sorting that is applied to the table. Note that the inner arrays are
   * used in the following manner:
   * <ul>
   *   <li>Index 0 - column number</li>
   *   <li>Index 1 - current sorting direction</li>
   * </ul>
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type array
   *  @todo These inner arrays should really be objects
   */
		"aaSorting": null,

		/**
   * Sorting that is always applied to the table (i.e. prefixed in front of
   * aaSorting).
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type array
   *  @default []
   */
		"aaSortingFixed": [],

		/**
   * Classes to use for the striping of a table.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type array
   *  @default []
   */
		"asStripeClasses": null,

		/**
   * If restoring a table - we should restore its striping classes as well
   *  @type array
   *  @default []
   */
		"asDestroyStripes": [],

		/**
   * If restoring a table - we should restore its width
   *  @type int
   *  @default 0
   */
		"sDestroyWidth": 0,

		/**
   * Callback functions array for every time a row is inserted (i.e. on a draw).
   *  @type array
   *  @default []
   */
		"aoRowCallback": [],

		/**
   * Callback functions for the header on each draw.
   *  @type array
   *  @default []
   */
		"aoHeaderCallback": [],

		/**
   * Callback function for the footer on each draw.
   *  @type array
   *  @default []
   */
		"aoFooterCallback": [],

		/**
   * Array of callback functions for draw callback functions
   *  @type array
   *  @default []
   */
		"aoDrawCallback": [],

		/**
   * Array of callback functions for row created function
   *  @type array
   *  @default []
   */
		"aoRowCreatedCallback": [],

		/**
   * Callback functions for just before the table is redrawn. A return of
   * false will be used to cancel the draw.
   *  @type array
   *  @default []
   */
		"aoPreDrawCallback": [],

		/**
   * Callback functions for when the table has been initialised.
   *  @type array
   *  @default []
   */
		"aoInitComplete": [],

		/**
   * Callbacks for modifying the settings to be stored for state saving, prior to
   * saving state.
   *  @type array
   *  @default []
   */
		"aoStateSaveParams": [],

		/**
   * Callbacks for modifying the settings that have been stored for state saving
   * prior to using the stored values to restore the state.
   *  @type array
   *  @default []
   */
		"aoStateLoadParams": [],

		/**
   * Callbacks for operating on the settings object once the saved state has been
   * loaded
   *  @type array
   *  @default []
   */
		"aoStateLoaded": [],

		/**
   * Cache the table ID for quick access
   *  @type string
   *  @default <i>Empty string</i>
   */
		"sTableId": "",

		/**
   * The TABLE node for the main table
   *  @type node
   *  @default null
   */
		"nTable": null,

		/**
   * Permanent ref to the thead element
   *  @type node
   *  @default null
   */
		"nTHead": null,

		/**
   * Permanent ref to the tfoot element - if it exists
   *  @type node
   *  @default null
   */
		"nTFoot": null,

		/**
   * Permanent ref to the tbody element
   *  @type node
   *  @default null
   */
		"nTBody": null,

		/**
   * Cache the wrapper node (contains all DataTables controlled elements)
   *  @type node
   *  @default null
   */
		"nTableWrapper": null,

		/**
   * Indicate if when using server-side processing the loading of data
   * should be deferred until the second draw.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type boolean
   *  @default false
   */
		"bDeferLoading": false,

		/**
   * Indicate if all required information has been read in
   *  @type boolean
   *  @default false
   */
		"bInitialised": false,

		/**
   * Information about open rows. Each object in the array has the parameters
   * 'nTr' and 'nParent'
   *  @type array
   *  @default []
   */
		"aoOpenRows": [],

		/**
   * Dictate the positioning of DataTables' control elements - see
   * {@link DataTable.model.oInit.sDom}.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type string
   *  @default null
   */
		"sDom": null,

		/**
   * Search delay (in mS)
   *  @type integer
   *  @default null
   */
		"searchDelay": null,

		/**
   * Which type of pagination should be used.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type string
   *  @default two_button
   */
		"sPaginationType": "two_button",

		/**
   * The state duration (for `stateSave`) in seconds.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type int
   *  @default 0
   */
		"iStateDuration": 0,

		/**
   * Array of callback functions for state saving. Each array element is an
   * object with the following parameters:
   *   <ul>
   *     <li>function:fn - function to call. Takes two parameters, oSettings
   *       and the JSON string to save that has been thus far created. Returns
   *       a JSON string to be inserted into a json object
   *       (i.e. '"param": [ 0, 1, 2]')</li>
   *     <li>string:sName - name of callback</li>
   *   </ul>
   *  @type array
   *  @default []
   */
		"aoStateSave": [],

		/**
   * Array of callback functions for state loading. Each array element is an
   * object with the following parameters:
   *   <ul>
   *     <li>function:fn - function to call. Takes two parameters, oSettings
   *       and the object stored. May return false to cancel state loading</li>
   *     <li>string:sName - name of callback</li>
   *   </ul>
   *  @type array
   *  @default []
   */
		"aoStateLoad": [],

		/**
   * State that was saved. Useful for back reference
   *  @type object
   *  @default null
   */
		"oSavedState": null,

		/**
   * State that was loaded. Useful for back reference
   *  @type object
   *  @default null
   */
		"oLoadedState": null,

		/**
   * Source url for AJAX data for the table.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type string
   *  @default null
   */
		"sAjaxSource": null,

		/**
   * Property from a given object from which to read the table data from. This
   * can be an empty string (when not server-side processing), in which case
   * it is  assumed an an array is given directly.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type string
   */
		"sAjaxDataProp": null,

		/**
   * Note if draw should be blocked while getting data
   *  @type boolean
   *  @default true
   */
		"bAjaxDataGet": true,

		/**
   * The last jQuery XHR object that was used for server-side data gathering.
   * This can be used for working with the XHR information in one of the
   * callbacks
   *  @type object
   *  @default null
   */
		"jqXHR": null,

		/**
   * JSON returned from the server in the last Ajax request
   *  @type object
   *  @default undefined
   */
		"json": undefined,

		/**
   * Data submitted as part of the last Ajax request
   *  @type object
   *  @default undefined
   */
		"oAjaxData": undefined,

		/**
   * Function to get the server-side data.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type function
   */
		"fnServerData": null,

		/**
   * Functions which are called prior to sending an Ajax request so extra
   * parameters can easily be sent to the server
   *  @type array
   *  @default []
   */
		"aoServerParams": [],

		/**
   * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
   * required).
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type string
   */
		"sServerMethod": null,

		/**
   * Format numbers for display.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type function
   */
		"fnFormatNumber": null,

		/**
   * List of options that can be used for the user selectable length menu.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type array
   *  @default []
   */
		"aLengthMenu": null,

		/**
   * Counter for the draws that the table does. Also used as a tracker for
   * server-side processing
   *  @type int
   *  @default 0
   */
		"iDraw": 0,

		/**
   * Indicate if a redraw is being done - useful for Ajax
   *  @type boolean
   *  @default false
   */
		"bDrawing": false,

		/**
   * Draw index (iDraw) of the last error when parsing the returned data
   *  @type int
   *  @default -1
   */
		"iDrawError": -1,

		/**
   * Paging display length
   *  @type int
   *  @default 10
   */
		"_iDisplayLength": 10,

		/**
   * Paging start point - aiDisplay index
   *  @type int
   *  @default 0
   */
		"_iDisplayStart": 0,

		/**
   * Server-side processing - number of records in the result set
   * (i.e. before filtering), Use fnRecordsTotal rather than
   * this property to get the value of the number of records, regardless of
   * the server-side processing setting.
   *  @type int
   *  @default 0
   *  @private
   */
		"_iRecordsTotal": 0,

		/**
   * Server-side processing - number of records in the current display set
   * (i.e. after filtering). Use fnRecordsDisplay rather than
   * this property to get the value of the number of records, regardless of
   * the server-side processing setting.
   *  @type boolean
   *  @default 0
   *  @private
   */
		"_iRecordsDisplay": 0,

		/**
   * Flag to indicate if jQuery UI marking and classes should be used.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type boolean
   */
		"bJUI": null,

		/**
   * The classes to use for the table
   *  @type object
   *  @default {}
   */
		"oClasses": {},

		/**
   * Flag attached to the settings object so you can check in the draw
   * callback if filtering has been done in the draw. Deprecated in favour of
   * events.
   *  @type boolean
   *  @default false
   *  @deprecated
   */
		"bFiltered": false,

		/**
   * Flag attached to the settings object so you can check in the draw
   * callback if sorting has been done in the draw. Deprecated in favour of
   * events.
   *  @type boolean
   *  @default false
   *  @deprecated
   */
		"bSorted": false,

		/**
   * Indicate that if multiple rows are in the header and there is more than
   * one unique cell per column, if the top one (true) or bottom one (false)
   * should be used for sorting / title by DataTables.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   *  @type boolean
   */
		"bSortCellsTop": null,

		/**
   * Initialisation object that is used for the table
   *  @type object
   *  @default null
   */
		"oInit": null,

		/**
   * Destroy callback functions - for plug-ins to attach themselves to the
   * destroy so they can clean up markup and events.
   *  @type array
   *  @default []
   */
		"aoDestroyCallback": [],

		/**
   * Get the number of records in the current record set, before filtering
   *  @type function
   */
		"fnRecordsTotal": function fnRecordsTotal() {
			return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
		},

		/**
   * Get the number of records in the current record set, after filtering
   *  @type function
   */
		"fnRecordsDisplay": function fnRecordsDisplay() {
			return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
		},

		/**
   * Get the display end point - aiDisplay index
   *  @type function
   */
		"fnDisplayEnd": function fnDisplayEnd() {
			var len = this._iDisplayLength,
			    start = this._iDisplayStart,
			    calc = start + len,
			    records = this.aiDisplay.length,
			    features = this.oFeatures,
			    paginate = features.bPaginate;

			if (features.bServerSide) {
				return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
			} else {
				return !paginate || calc > records || len === -1 ? records : calc;
			}
		},

		/**
   * The DataTables object for this table
   *  @type object
   *  @default null
   */
		"oInstance": null,

		/**
   * Unique identifier for each instance of the DataTables object. If there
   * is an ID on the table node, then it takes that value, otherwise an
   * incrementing internal counter is used.
   *  @type string
   *  @default null
   */
		"sInstance": null,

		/**
   * tabindex attribute value that is added to DataTables control elements, allowing
   * keyboard navigation of the table and its controls.
   */
		"iTabIndex": 0,

		/**
   * DIV container for the footer scrolling table if scrolling
   */
		"nScrollHead": null,

		/**
   * DIV container for the footer scrolling table if scrolling
   */
		"nScrollFoot": null,

		/**
   * Last applied sort
   *  @type array
   *  @default []
   */
		"aLastSort": [],

		/**
   * Stored plug-in instances
   *  @type object
   *  @default {}
   */
		"oPlugins": {},

		/**
   * Function used to get a row's id from the row's data
   *  @type function
   *  @default null
   */
		"rowIdFn": null,

		/**
   * Data location where to store a row's id
   *  @type string
   *  @default null
   */
		"rowId": null
	};

	/**
  * Extension object for DataTables that is used to provide all extension
  * options.
  *
  * Note that the `DataTable.ext` object is available through
  * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
  * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
  *  @namespace
  *  @extends DataTable.models.ext
  */

	/**
  * DataTables extensions
  * 
  * This namespace acts as a collection area for plug-ins that can be used to
  * extend DataTables capabilities. Indeed many of the build in methods
  * use this method to provide their own capabilities (sorting methods for
  * example).
  *
  * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
  * reasons
  *
  *  @namespace
  */
	DataTable.ext = _ext = {
		/**
   * Buttons. For use with the Buttons extension for DataTables. This is
   * defined here so other extensions can define buttons regardless of load
   * order. It is _not_ used by DataTables core.
   *
   *  @type object
   *  @default {}
   */
		buttons: {},

		/**
   * Element class names
   *
   *  @type object
   *  @default {}
   */
		classes: {},

		/**
   * DataTables build type (expanded by the download builder)
   *
   *  @type string
   */
		builder: "-source-",

		/**
   * Error reporting.
   * 
   * How should DataTables report an error. Can take the value 'alert',
   * 'throw', 'none' or a function.
   *
   *  @type string|function
   *  @default alert
   */
		errMode: "alert",

		/**
   * Feature plug-ins.
   * 
   * This is an array of objects which describe the feature plug-ins that are
   * available to DataTables. These feature plug-ins are then available for
   * use through the `dom` initialisation option.
   * 
   * Each feature plug-in is described by an object which must have the
   * following properties:
   * 
   * * `fnInit` - function that is used to initialise the plug-in,
   * * `cFeature` - a character so the feature can be enabled by the `dom`
   *   instillation option. This is case sensitive.
   *
   * The `fnInit` function has the following input parameters:
   *
   * 1. `{object}` DataTables settings object: see
   *    {@link DataTable.models.oSettings}
   *
   * And the following return is expected:
   * 
   * * {node|null} The element which contains your feature. Note that the
   *   return may also be void if your plug-in does not require to inject any
   *   DOM elements into DataTables control (`dom`) - for example this might
   *   be useful when developing a plug-in which allows table control via
   *   keyboard entry
   *
   *  @type array
   *
   *  @example
   *    $.fn.dataTable.ext.features.push( {
   *      "fnInit": function( oSettings ) {
   *        return new TableTools( { "oDTSettings": oSettings } );
   *      },
   *      "cFeature": "T"
   *    } );
   */
		feature: [],

		/**
   * Row searching.
   * 
   * This method of searching is complimentary to the default type based
   * searching, and a lot more comprehensive as it allows you complete control
   * over the searching logic. Each element in this array is a function
   * (parameters described below) that is called for every row in the table,
   * and your logic decides if it should be included in the searching data set
   * or not.
   *
   * Searching functions have the following input parameters:
   *
   * 1. `{object}` DataTables settings object: see
   *    {@link DataTable.models.oSettings}
   * 2. `{array|object}` Data for the row to be processed (same as the
   *    original format that was passed in as the data source, or an array
   *    from a DOM data source
   * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
   *    can be useful to retrieve the `TR` element if you need DOM interaction.
   *
   * And the following return is expected:
   *
   * * {boolean} Include the row in the searched result set (true) or not
   *   (false)
   *
   * Note that as with the main search ability in DataTables, technically this
   * is "filtering", since it is subtractive. However, for consistency in
   * naming we call it searching here.
   *
   *  @type array
   *  @default []
   *
   *  @example
   *    // The following example shows custom search being applied to the
   *    // fourth column (i.e. the data[3] index) based on two input values
   *    // from the end-user, matching the data in a certain range.
   *    $.fn.dataTable.ext.search.push(
   *      function( settings, data, dataIndex ) {
   *        var min = document.getElementById('min').value * 1;
   *        var max = document.getElementById('max').value * 1;
   *        var version = data[3] == "-" ? 0 : data[3]*1;
   *
   *        if ( min == "" && max == "" ) {
   *          return true;
   *        }
   *        else if ( min == "" && version < max ) {
   *          return true;
   *        }
   *        else if ( min < version && "" == max ) {
   *          return true;
   *        }
   *        else if ( min < version && version < max ) {
   *          return true;
   *        }
   *        return false;
   *      }
   *    );
   */
		search: [],

		/**
   * Selector extensions
   *
   * The `selector` option can be used to extend the options available for the
   * selector modifier options (`selector-modifier` object data type) that
   * each of the three built in selector types offer (row, column and cell +
   * their plural counterparts). For example the Select extension uses this
   * mechanism to provide an option to select only rows, columns and cells
   * that have been marked as selected by the end user (`{selected: true}`),
   * which can be used in conjunction with the existing built in selector
   * options.
   *
   * Each property is an array to which functions can be pushed. The functions
   * take three attributes:
   *
   * * Settings object for the host table
   * * Options object (`selector-modifier` object type)
   * * Array of selected item indexes
   *
   * The return is an array of the resulting item indexes after the custom
   * selector has been applied.
   *
   *  @type object
   */
		selector: {
			cell: [],
			column: [],
			row: []
		},

		/**
   * Internal functions, exposed for used in plug-ins.
   * 
   * Please note that you should not need to use the internal methods for
   * anything other than a plug-in (and even then, try to avoid if possible).
   * The internal function may change between releases.
   *
   *  @type object
   *  @default {}
   */
		internal: {},

		/**
   * Legacy configuration options. Enable and disable legacy options that
   * are available in DataTables.
   *
   *  @type object
   */
		legacy: {
			/**
    * Enable / disable DataTables 1.9 compatible server-side processing
    * requests
    *
    *  @type boolean
    *  @default null
    */
			ajax: null
		},

		/**
   * Pagination plug-in methods.
   * 
   * Each entry in this object is a function and defines which buttons should
   * be shown by the pagination rendering method that is used for the table:
   * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
   * buttons are displayed in the document, while the functions here tell it
   * what buttons to display. This is done by returning an array of button
   * descriptions (what each button will do).
   *
   * Pagination types (the four built in options and any additional plug-in
   * options defined here) can be used through the `paginationType`
   * initialisation parameter.
   *
   * The functions defined take two parameters:
   *
   * 1. `{int} page` The current page index
   * 2. `{int} pages` The number of pages in the table
   *
   * Each function is expected to return an array where each element of the
   * array can be one of:
   *
   * * `first` - Jump to first page when activated
   * * `last` - Jump to last page when activated
   * * `previous` - Show previous page when activated
   * * `next` - Show next page when activated
   * * `{int}` - Show page of the index given
   * * `{array}` - A nested array containing the above elements to add a
   *   containing 'DIV' element (might be useful for styling).
   *
   * Note that DataTables v1.9- used this object slightly differently whereby
   * an object with two functions would be defined for each plug-in. That
   * ability is still supported by DataTables 1.10+ to provide backwards
   * compatibility, but this option of use is now decremented and no longer
   * documented in DataTables 1.10+.
   *
   *  @type object
   *  @default {}
   *
   *  @example
   *    // Show previous, next and current page buttons only
   *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
   *      return [ 'previous', page, 'next' ];
   *    };
   */
		pager: {},

		renderer: {
			pageButton: {},
			header: {}
		},

		/**
   * Ordering plug-ins - custom data source
   * 
   * The extension options for ordering of data available here is complimentary
   * to the default type based ordering that DataTables typically uses. It
   * allows much greater control over the the data that is being used to
   * order a column, but is necessarily therefore more complex.
   * 
   * This type of ordering is useful if you want to do ordering based on data
   * live from the DOM (for example the contents of an 'input' element) rather
   * than just the static string that DataTables knows of.
   * 
   * The way these plug-ins work is that you create an array of the values you
   * wish to be ordering for the column in question and then return that
   * array. The data in the array much be in the index order of the rows in
   * the table (not the currently ordering order!). Which order data gathering
   * function is run here depends on the `dt-init columns.orderDataType`
   * parameter that is used for the column (if any).
   *
   * The functions defined take two parameters:
   *
   * 1. `{object}` DataTables settings object: see
   *    {@link DataTable.models.oSettings}
   * 2. `{int}` Target column index
   *
   * Each function is expected to return an array:
   *
   * * `{array}` Data for the column to be ordering upon
   *
   *  @type array
   *
   *  @example
   *    // Ordering using `input` node values
   *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
   *    {
   *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
   *        return $('input', td).val();
   *      } );
   *    }
   */
		order: {},

		/**
   * Type based plug-ins.
   *
   * Each column in DataTables has a type assigned to it, either by automatic
   * detection or by direct assignment using the `type` option for the column.
   * The type of a column will effect how it is ordering and search (plug-ins
   * can also make use of the column type if required).
   *
   * @namespace
   */
		type: {
			/**
    * Type detection functions.
    *
    * The functions defined in this object are used to automatically detect
    * a column's type, making initialisation of DataTables super easy, even
    * when complex data is in the table.
    *
    * The functions defined take two parameters:
    *
       *  1. `{*}` Data from the column cell to be analysed
       *  2. `{settings}` DataTables settings object. This can be used to
       *     perform context specific type detection - for example detection
       *     based on language settings such as using a comma for a decimal
       *     place. Generally speaking the options from the settings will not
       *     be required
    *
    * Each function is expected to return:
    *
    * * `{string|null}` Data type detected, or null if unknown (and thus
    *   pass it on to the other type detection functions.
    *
    *  @type array
    *
    *  @example
    *    // Currency type detection plug-in:
    *    $.fn.dataTable.ext.type.detect.push(
    *      function ( data, settings ) {
    *        // Check the numeric part
    *        if ( ! $.isNumeric( data.substring(1) ) ) {
    *          return null;
    *        }
    *
    *        // Check prefixed by currency
    *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
    *          return 'currency';
    *        }
    *        return null;
    *      }
    *    );
    */
			detect: [],

			/**
    * Type based search formatting.
    *
    * The type based searching functions can be used to pre-format the
    * data to be search on. For example, it can be used to strip HTML
    * tags or to de-format telephone numbers for numeric only searching.
    *
    * Note that is a search is not defined for a column of a given type,
    * no search formatting will be performed.
    * 
    * Pre-processing of searching data plug-ins - When you assign the sType
    * for a column (or have it automatically detected for you by DataTables
    * or a type detection plug-in), you will typically be using this for
    * custom sorting, but it can also be used to provide custom searching
    * by allowing you to pre-processing the data and returning the data in
    * the format that should be searched upon. This is done by adding
    * functions this object with a parameter name which matches the sType
    * for that target column. This is the corollary of <i>afnSortData</i>
    * for searching data.
    *
    * The functions defined take a single parameter:
    *
       *  1. `{*}` Data from the column cell to be prepared for searching
    *
    * Each function is expected to return:
    *
    * * `{string|null}` Formatted string that will be used for the searching.
    *
    *  @type object
    *  @default {}
    *
    *  @example
    *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
    *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
    *    }
    */
			search: {},

			/**
    * Type based ordering.
    *
    * The column type tells DataTables what ordering to apply to the table
    * when a column is sorted upon. The order for each type that is defined,
    * is defined by the functions available in this object.
    *
    * Each ordering option can be described by three properties added to
    * this object:
    *
    * * `{type}-pre` - Pre-formatting function
    * * `{type}-asc` - Ascending order function
    * * `{type}-desc` - Descending order function
    *
    * All three can be used together, only `{type}-pre` or only
    * `{type}-asc` and `{type}-desc` together. It is generally recommended
    * that only `{type}-pre` is used, as this provides the optimal
    * implementation in terms of speed, although the others are provided
    * for compatibility with existing Javascript sort functions.
    *
    * `{type}-pre`: Functions defined take a single parameter:
    *
       *  1. `{*}` Data from the column cell to be prepared for ordering
    *
    * And return:
    *
    * * `{*}` Data to be sorted upon
    *
    * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
    * functions, taking two parameters:
    *
       *  1. `{*}` Data to compare to the second parameter
       *  2. `{*}` Data to compare to the first parameter
    *
    * And returning:
    *
    * * `{*}` Ordering match: <0 if first parameter should be sorted lower
    *   than the second parameter, ===0 if the two parameters are equal and
    *   >0 if the first parameter should be sorted height than the second
    *   parameter.
    * 
    *  @type object
    *  @default {}
    *
    *  @example
    *    // Numeric ordering of formatted numbers with a pre-formatter
    *    $.extend( $.fn.dataTable.ext.type.order, {
    *      "string-pre": function(x) {
    *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
    *        return parseFloat( a );
    *      }
    *    } );
    *
    *  @example
    *    // Case-sensitive string ordering, with no pre-formatting method
    *    $.extend( $.fn.dataTable.ext.order, {
    *      "string-case-asc": function(x,y) {
    *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
    *      },
    *      "string-case-desc": function(x,y) {
    *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
    *      }
    *    } );
    */
			order: {}
		},

		/**
   * Unique DataTables instance counter
   *
   * @type int
   * @private
   */
		_unique: 0,

		//
		// Depreciated
		// The following properties are retained for backwards compatiblity only.
		// The should not be used in new projects and will be removed in a future
		// version
		//

		/**
   * Version check function.
   *  @type function
   *  @depreciated Since 1.10
   */
		fnVersionCheck: DataTable.fnVersionCheck,

		/**
   * Index for what 'this' index API functions should use
   *  @type int
   *  @deprecated Since v1.10
   */
		iApiIndex: 0,

		/**
   * jQuery UI class container
   *  @type object
   *  @deprecated Since v1.10
   */
		oJUIClasses: {},

		/**
   * Software version
   *  @type string
   *  @deprecated Since v1.10
   */
		sVersion: DataTable.version
	};

	//
	// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
	//
	$.extend(_ext, {
		afnFiltering: _ext.search,
		aTypes: _ext.type.detect,
		ofnSearch: _ext.type.search,
		oSort: _ext.type.order,
		afnSortData: _ext.order,
		aoFeatures: _ext.feature,
		oApi: _ext.internal,
		oStdClasses: _ext.classes,
		oPagination: _ext.pager
	});

	$.extend(DataTable.ext.classes, {
		"sTable": "dataTable",
		"sNoFooter": "no-footer",

		/* Paging buttons */
		"sPageButton": "paginate_button btn waves-effect",
		"sPageButtonActive": "current",
		"sPageButtonDisabled": "disabled",

		/* Striping classes */
		"sStripeOdd": "odd",
		"sStripeEven": "even",

		/* Empty row */
		"sRowEmpty": "dataTables_empty",

		/* Features */
		"sWrapper": "dataTables_wrapper",
		"sFilter": "dataTables_filter",
		"sInfo": "dataTables_info",
		"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
		"sLength": "dataTables_length",
		"sProcessing": "dataTables_processing",

		/* Sorting */
		"sSortAsc": "sorting_asc",
		"sSortDesc": "sorting_desc",
		"sSortable": "sorting", /* Sortable in both directions */
		"sSortableAsc": "sorting_asc_disabled",
		"sSortableDesc": "sorting_desc_disabled",
		"sSortableNone": "sorting_disabled",
		"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */

		/* Filtering */
		"sFilterInput": "",

		/* Page length */
		"sLengthSelect": "",

		/* Scrolling */
		"sScrollWrapper": "dataTables_scroll",
		"sScrollHead": "dataTables_scrollHead",
		"sScrollHeadInner": "dataTables_scrollHeadInner",
		"sScrollBody": "dataTables_scrollBody",
		"sScrollFoot": "dataTables_scrollFoot",
		"sScrollFootInner": "dataTables_scrollFootInner",

		/* Misc */
		"sHeaderTH": "",
		"sFooterTH": "",

		// Deprecated
		"sSortJUIAsc": "",
		"sSortJUIDesc": "",
		"sSortJUI": "",
		"sSortJUIAscAllowed": "",
		"sSortJUIDescAllowed": "",
		"sSortJUIWrapper": "",
		"sSortIcon": "",
		"sJUIHeader": "",
		"sJUIFooter": ""
	});

	(function () {

		// Reused strings for better compression. Closure compiler appears to have a
		// weird edge case where it is trying to expand strings rather than use the
		// variable version. This results in about 200 bytes being added, for very
		// little preference benefit since it this run on script load only.
		var _empty = '';
		_empty = '';

		var _stateDefault = _empty + 'ui-state-default';
		var _sortIcon = _empty + 'css_right ui-icon ui-icon-';
		var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';

		$.extend(DataTable.ext.oJUIClasses, DataTable.ext.classes, {
			/* Full numbers paging buttons */
			"sPageButton": "fg-button ui-button " + _stateDefault,
			"sPageButtonActive": "ui-state-disabled",
			"sPageButtonDisabled": "ui-state-disabled",

			/* Features */
			"sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi " + "ui-buttonset-multi paging_", /* Note that the type is postfixed */

			/* Sorting */
			"sSortAsc": _stateDefault + " sorting_asc",
			"sSortDesc": _stateDefault + " sorting_desc",
			"sSortable": _stateDefault + " sorting",
			"sSortableAsc": _stateDefault + " sorting_asc_disabled",
			"sSortableDesc": _stateDefault + " sorting_desc_disabled",
			"sSortableNone": _stateDefault + " sorting_disabled",
			"sSortJUIAsc": _sortIcon + "triangle-1-n",
			"sSortJUIDesc": _sortIcon + "triangle-1-s",
			"sSortJUI": _sortIcon + "carat-2-n-s",
			"sSortJUIAscAllowed": _sortIcon + "carat-1-n",
			"sSortJUIDescAllowed": _sortIcon + "carat-1-s",
			"sSortJUIWrapper": "DataTables_sort_wrapper",
			"sSortIcon": "DataTables_sort_icon",

			/* Scrolling */
			"sScrollHead": "dataTables_scrollHead " + _stateDefault,
			"sScrollFoot": "dataTables_scrollFoot " + _stateDefault,

			/* Misc */
			"sHeaderTH": _stateDefault,
			"sFooterTH": _stateDefault,
			"sJUIHeader": _headerFooter + " ui-corner-tl ui-corner-tr",
			"sJUIFooter": _headerFooter + " ui-corner-bl ui-corner-br"
		});
	})();

	var extPagination = DataTable.ext.pager;

	function _numbers(page, pages) {
		var numbers = [],
		    buttons = extPagination.numbers_length,
		    half = Math.floor(buttons / 2),
		    i = 1;

		if (pages <= buttons) {
			numbers = _range(0, pages);
		} else if (page <= half) {
			numbers = _range(0, buttons - 2);
			numbers.push('ellipsis');
			numbers.push(pages - 1);
		} else if (page >= pages - 1 - half) {
			numbers = _range(pages - (buttons - 2), pages);
			numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6
			numbers.splice(0, 0, 0);
		} else {
			numbers = _range(page - half + 2, page + half - 1);
			numbers.push('ellipsis');
			numbers.push(pages - 1);
			numbers.splice(0, 0, 'ellipsis');
			numbers.splice(0, 0, 0);
		}

		numbers.DT_el = 'span';
		return numbers;
	}

	$.extend(extPagination, {
		simple: function simple(page, pages) {
			return ['previous', 'next'];
		},

		full: function full(page, pages) {
			return ['first', 'previous', 'next', 'last'];
		},

		numbers: function numbers(page, pages) {
			return [_numbers(page, pages)];
		},

		simple_numbers: function simple_numbers(page, pages) {
			return ['previous', _numbers(page, pages), 'next'];
		},

		full_numbers: function full_numbers(page, pages) {
			return ['first', 'previous', _numbers(page, pages), 'next', 'last'];
		},

		first_last_numbers: function first_last_numbers(page, pages) {
			return ['first', _numbers(page, pages), 'last'];
		},

		// For testing and plug-ins to use
		_numbers: _numbers,

		// Number of number buttons (including ellipsis) to show. _Must be odd!_
		numbers_length: 7
	});

	$.extend(true, DataTable.ext.renderer, {
		pageButton: {
			_: function _(settings, host, idx, buttons, page, pages) {
				var classes = settings.oClasses;
				var lang = settings.oLanguage.oPaginate;
				var aria = settings.oLanguage.oAria.paginate || {};
				var btnDisplay,
				    btnClass,
				    counter = 0;

				var attach = function attach(container, buttons) {
					var i, ien, node, button;
					var clickHandler = function clickHandler(e) {
						_fnPageChange(settings, e.data.action, true);
					};

					for (i = 0, ien = buttons.length; i < ien; i++) {
						button = buttons[i];

						if ($.isArray(button)) {
							var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container);
							attach(inner, button);
						} else {
							btnDisplay = null;
							btnClass = '';

							switch (button) {
								case 'ellipsis':
									container.append('<span class="ellipsis">&#x2026;</span>');
									break;

								case 'first':
									btnDisplay = lang.sFirst;
									btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled);
									break;

								case 'previous':
									btnDisplay = lang.sPrevious;
									btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled);
									break;

								case 'next':
									btnDisplay = lang.sNext;
									btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled);
									break;

								case 'last':
									btnDisplay = lang.sLast;
									btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled);
									break;

								default:
									btnDisplay = button + 1;
									btnClass = page === button ? classes.sPageButtonActive : '';
									break;
							}

							if (btnDisplay !== null) {
								node = $('<a>', {
									'class': classes.sPageButton + ' ' + btnClass,
									'aria-controls': settings.sTableId,
									'aria-label': aria[button],
									'data-dt-idx': counter,
									'tabindex': settings.iTabIndex,
									'id': idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null
								}).html(btnDisplay).appendTo(container);

								_fnBindAction(node, { action: button }, clickHandler);

								counter++;
							}
						}
					}
				};

				// IE9 throws an 'unknown error' if document.activeElement is used
				// inside an iframe or frame. Try / catch the error. Not good for
				// accessibility, but neither are frames.
				var activeEl;

				try {
					// Because this approach is destroying and recreating the paging
					// elements, focus is lost on the select button which is bad for
					// accessibility. So we want to restore focus once the draw has
					// completed
					activeEl = $(host).find(document.activeElement).data('dt-idx');
				} catch (e) {}

				attach($(host).empty(), buttons);

				if (activeEl !== undefined) {
					$(host).find('[data-dt-idx=' + activeEl + ']').focus();
				}
			}
		}
	});

	// Built in type detection. See model.ext.aTypes for information about
	// what is required from this methods.
	$.extend(DataTable.ext.type.detect, [
	// Plain numbers - first since V8 detects some plain numbers as dates
	// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
	function (d, settings) {
		var decimal = settings.oLanguage.sDecimal;
		return _isNumber(d, decimal) ? 'num' + decimal : null;
	},

	// Dates (only those recognised by the browser's Date.parse)
	function (d, settings) {
		// V8 tries _very_ hard to make a string passed into `Date.parse()`
		// valid, so we need to use a regex to restrict date formats. Use a
		// plug-in for anything other than ISO8601 style strings
		if (d && !(d instanceof Date) && !_re_date.test(d)) {
			return null;
		}
		var parsed = Date.parse(d);
		return parsed !== null && !isNaN(parsed) || _empty(d) ? 'date' : null;
	},

	// Formatted numbers
	function (d, settings) {
		var decimal = settings.oLanguage.sDecimal;
		return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
	},

	// HTML numeric
	function (d, settings) {
		var decimal = settings.oLanguage.sDecimal;
		return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
	},

	// HTML numeric, formatted
	function (d, settings) {
		var decimal = settings.oLanguage.sDecimal;
		return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
	},

	// HTML (this is strict checking - there must be html)
	function (d, settings) {
		return _empty(d) || typeof d === 'string' && d.indexOf('<') !== -1 ? 'html' : null;
	}]);

	// Filter formatting functions. See model.ext.ofnSearch for information about
	// what is required from these methods.
	// 
	// Note that additional search methods are added for the html numbers and
	// html formatted numbers by `_addNumericSort()` when we know what the decimal
	// place is


	$.extend(DataTable.ext.type.search, {
		html: function html(data) {
			return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ").replace(_re_html, "") : '';
		},

		string: function string(data) {
			return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ") : data;
		}
	});

	var __numericReplace = function __numericReplace(d, decimalPlace, re1, re2) {
		if (d !== 0 && (!d || d === '-')) {
			return -Infinity;
		}

		// If a decimal place other than `.` is used, it needs to be given to the
		// function so we can detect it and replace with a `.` which is the only
		// decimal place Javascript recognises - it is not locale aware.
		if (decimalPlace) {
			d = _numToDecimal(d, decimalPlace);
		}

		if (d.replace) {
			if (re1) {
				d = d.replace(re1, '');
			}

			if (re2) {
				d = d.replace(re2, '');
			}
		}

		return d * 1;
	};

	// Add the numeric 'deformatting' functions for sorting and search. This is done
	// in a function to provide an easy ability for the language options to add
	// additional methods if a non-period decimal place is used.
	function _addNumericSort(decimalPlace) {
		$.each({
			// Plain numbers
			"num": function num(d) {
				return __numericReplace(d, decimalPlace);
			},

			// Formatted numbers
			"num-fmt": function numFmt(d) {
				return __numericReplace(d, decimalPlace, _re_formatted_numeric);
			},

			// HTML numeric
			"html-num": function htmlNum(d) {
				return __numericReplace(d, decimalPlace, _re_html);
			},

			// HTML numeric, formatted
			"html-num-fmt": function htmlNumFmt(d) {
				return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
			}
		}, function (key, fn) {
			// Add the ordering method
			_ext.type.order[key + decimalPlace + '-pre'] = fn;

			// For HTML types add a search formatter that will strip the HTML
			if (key.match(/^html\-/)) {
				_ext.type.search[key + decimalPlace] = _ext.type.search.html;
			}
		});
	}

	// Default sort methods
	$.extend(_ext.type.order, {
		// Dates
		"date-pre": function datePre(d) {
			return Date.parse(d) || -Infinity;
		},

		// html
		"html-pre": function htmlPre(a) {
			return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + '';
		},

		// string
		"string-pre": function stringPre(a) {
			// This is a little complex, but faster than always calling toString,
			// http://jsperf.com/tostring-v-check
			return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString();
		},

		// string-asc and -desc are retained only for compatibility with the old
		// sort methods
		"string-asc": function stringAsc(x, y) {
			return x < y ? -1 : x > y ? 1 : 0;
		},

		"string-desc": function stringDesc(x, y) {
			return x < y ? 1 : x > y ? -1 : 0;
		}
	});

	// Numeric sorting types - order doesn't matter here
	_addNumericSort('');

	$.extend(true, DataTable.ext.renderer, {
		header: {
			_: function _(settings, cell, column, classes) {
				// No additional mark-up required
				// Attach a sort listener to update on sort - note that using the
				// `DT` namespace will allow the event to be removed automatically
				// on destroy, while the `dt` namespaced event is the one we are
				// listening for
				$(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
					if (settings !== ctx) {
						// need to check this this is the host
						return; // table, not a nested one
					}

					var colIdx = column.idx;

					cell.removeClass(column.sSortingClass + ' ' + classes.sSortAsc + ' ' + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
				});
			},

			jqueryui: function jqueryui(settings, cell, column, classes) {
				$('<div/>').addClass(classes.sSortJUIWrapper).append(cell.contents()).append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)).appendTo(cell);

				// Attach a sort listener to update on sort
				$(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
					if (settings !== ctx) {
						return;
					}

					var colIdx = column.idx;

					cell.removeClass(classes.sSortAsc + " " + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);

					cell.find('span.' + classes.sSortIcon).removeClass(classes.sSortJUIAsc + " " + classes.sSortJUIDesc + " " + classes.sSortJUI + " " + classes.sSortJUIAscAllowed + " " + classes.sSortJUIDescAllowed).addClass(columns[colIdx] == 'asc' ? classes.sSortJUIAsc : columns[colIdx] == 'desc' ? classes.sSortJUIDesc : column.sSortingClassJUI);
				});
			}
		}
	});

	/*
  * Public helper functions. These aren't used internally by DataTables, or
  * called by any of the options passed into DataTables, but they can be used
  * externally by developers working with DataTables. They are helper functions
  * to make working with DataTables a little bit easier.
  */

	var __htmlEscapeEntities = function __htmlEscapeEntities(d) {
		return typeof d === 'string' ? d.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') : d;
	};

	/**
  * Helpers for `columns.render`.
  *
  * The options defined here can be used with the `columns.render` initialisation
  * option to provide a display renderer. The following functions are defined:
  *
  * * `number` - Will format numeric data (defined by `columns.data`) for
  *   display, retaining the original unformatted data for sorting and filtering.
  *   It takes 5 parameters:
  *   * `string` - Thousands grouping separator
  *   * `string` - Decimal point indicator
  *   * `integer` - Number of decimal points to show
  *   * `string` (optional) - Prefix.
  *   * `string` (optional) - Postfix (/suffix).
  * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
  *   parameters.
  *
  * @example
  *   // Column definition using the number renderer
  *   {
  *     data: "salary",
  *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
  *   }
  *
  * @namespace
  */
	DataTable.render = {
		number: function number(thousands, decimal, precision, prefix, postfix) {
			return {
				display: function display(d) {
					if (typeof d !== 'number' && typeof d !== 'string') {
						return d;
					}

					var negative = d < 0 ? '-' : '';
					var flo = parseFloat(d);

					// If NaN then there isn't much formatting that we can do - just
					// return immediately, escaping any HTML (this was supposed to
					// be a number after all)
					if (isNaN(flo)) {
						return __htmlEscapeEntities(d);
					}

					flo = flo.toFixed(precision);
					d = Math.abs(flo);

					var intPart = parseInt(d, 10);
					var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : '';

					return negative + (prefix || '') + intPart.toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousands) + floatPart + (postfix || '');
				}
			};
		},

		text: function text() {
			return {
				display: __htmlEscapeEntities
			};
		}
	};

	/*
  * This is really a good bit rubbish this method of exposing the internal methods
  * publicly... - To be fixed in 2.0 using methods on the prototype
  */

	/**
  * Create a wrapper function for exporting an internal functions to an external API.
  *  @param {string} fn API function name
  *  @returns {function} wrapped function
  *  @memberof DataTable#internal
  */
	function _fnExternApiFunc(fn) {
		return function () {
			var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
			return DataTable.ext.internal[fn].apply(this, args);
		};
	}

	/**
  * Reference to internal functions for use by plug-in developers. Note that
  * these methods are references to internal functions and are considered to be
  * private. If you use these methods, be aware that they are liable to change
  * between versions.
  *  @namespace
  */
	$.extend(DataTable.ext.internal, {
		_fnExternApiFunc: _fnExternApiFunc,
		_fnBuildAjax: _fnBuildAjax,
		_fnAjaxUpdate: _fnAjaxUpdate,
		_fnAjaxParameters: _fnAjaxParameters,
		_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
		_fnAjaxDataSrc: _fnAjaxDataSrc,
		_fnAddColumn: _fnAddColumn,
		_fnColumnOptions: _fnColumnOptions,
		_fnAdjustColumnSizing: _fnAdjustColumnSizing,
		_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
		_fnColumnIndexToVisible: _fnColumnIndexToVisible,
		_fnVisbleColumns: _fnVisbleColumns,
		_fnGetColumns: _fnGetColumns,
		_fnColumnTypes: _fnColumnTypes,
		_fnApplyColumnDefs: _fnApplyColumnDefs,
		_fnHungarianMap: _fnHungarianMap,
		_fnCamelToHungarian: _fnCamelToHungarian,
		_fnLanguageCompat: _fnLanguageCompat,
		_fnBrowserDetect: _fnBrowserDetect,
		_fnAddData: _fnAddData,
		_fnAddTr: _fnAddTr,
		_fnNodeToDataIndex: _fnNodeToDataIndex,
		_fnNodeToColumnIndex: _fnNodeToColumnIndex,
		_fnGetCellData: _fnGetCellData,
		_fnSetCellData: _fnSetCellData,
		_fnSplitObjNotation: _fnSplitObjNotation,
		_fnGetObjectDataFn: _fnGetObjectDataFn,
		_fnSetObjectDataFn: _fnSetObjectDataFn,
		_fnGetDataMaster: _fnGetDataMaster,
		_fnClearTable: _fnClearTable,
		_fnDeleteIndex: _fnDeleteIndex,
		_fnInvalidate: _fnInvalidate,
		_fnGetRowElements: _fnGetRowElements,
		_fnCreateTr: _fnCreateTr,
		_fnBuildHead: _fnBuildHead,
		_fnDrawHead: _fnDrawHead,
		_fnDraw: _fnDraw,
		_fnReDraw: _fnReDraw,
		_fnAddOptionsHtml: _fnAddOptionsHtml,
		_fnDetectHeader: _fnDetectHeader,
		_fnGetUniqueThs: _fnGetUniqueThs,
		_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
		_fnFilterComplete: _fnFilterComplete,
		_fnFilterCustom: _fnFilterCustom,
		_fnFilterColumn: _fnFilterColumn,
		_fnFilter: _fnFilter,
		_fnFilterCreateSearch: _fnFilterCreateSearch,
		_fnEscapeRegex: _fnEscapeRegex,
		_fnFilterData: _fnFilterData,
		_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
		_fnUpdateInfo: _fnUpdateInfo,
		_fnInfoMacros: _fnInfoMacros,
		_fnInitialise: _fnInitialise,
		_fnInitComplete: _fnInitComplete,
		_fnLengthChange: _fnLengthChange,
		_fnFeatureHtmlLength: _fnFeatureHtmlLength,
		_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
		_fnPageChange: _fnPageChange,
		_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
		_fnProcessingDisplay: _fnProcessingDisplay,
		_fnFeatureHtmlTable: _fnFeatureHtmlTable,
		_fnScrollDraw: _fnScrollDraw,
		_fnApplyToChildren: _fnApplyToChildren,
		_fnCalculateColumnWidths: _fnCalculateColumnWidths,
		_fnThrottle: _fnThrottle,
		_fnConvertToWidth: _fnConvertToWidth,
		_fnGetWidestNode: _fnGetWidestNode,
		_fnGetMaxLenString: _fnGetMaxLenString,
		_fnStringToCss: _fnStringToCss,
		_fnSortFlatten: _fnSortFlatten,
		_fnSort: _fnSort,
		_fnSortAria: _fnSortAria,
		_fnSortListener: _fnSortListener,
		_fnSortAttachListener: _fnSortAttachListener,
		_fnSortingClasses: _fnSortingClasses,
		_fnSortData: _fnSortData,
		_fnSaveState: _fnSaveState,
		_fnLoadState: _fnLoadState,
		_fnSettingsFromNode: _fnSettingsFromNode,
		_fnLog: _fnLog,
		_fnMap: _fnMap,
		_fnBindAction: _fnBindAction,
		_fnCallbackReg: _fnCallbackReg,
		_fnCallbackFire: _fnCallbackFire,
		_fnLengthOverflow: _fnLengthOverflow,
		_fnRenderer: _fnRenderer,
		_fnDataSource: _fnDataSource,
		_fnRowAttributes: _fnRowAttributes,
		_fnCalculateEnd: function _fnCalculateEnd() {} // Used by a lot of plug-ins, but redundant
		// in 1.10, so this dead-end function is
		// added to prevent errors
	});

	// jQuery access
	$.fn.dataTable = DataTable;

	// Provide access to the host jQuery object (circular reference)
	DataTable.$ = $;

	// Legacy aliases
	$.fn.dataTableSettings = DataTable.settings;
	$.fn.dataTableExt = DataTable.ext;

	// With a capital `D` we return a DataTables API instance rather than a
	// jQuery object
	$.fn.DataTable = function (opts) {
		return $(this).dataTable(opts).api();
	};

	// All properties that are available to $.fn.dataTable should also be
	// available on $.fn.DataTable
	$.each(DataTable, function (prop, val) {
		$.fn.DataTable[prop] = val;
	});

	// Information about events fired by DataTables - for documentation.
	/**
  * Draw event, fired whenever the table is redrawn on the page, at the same
  * point as fnDrawCallback. This may be useful for binding events or
  * performing calculations when the table is altered at all.
  *  @name DataTable#draw.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  */

	/**
  * Search event, fired when the searching applied to the table (using the
  * built-in global search, or column filters) is altered.
  *  @name DataTable#search.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  */

	/**
  * Page change event, fired when the paging of the table is altered.
  *  @name DataTable#page.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  */

	/**
  * Order event, fired when the ordering applied to the table is altered.
  *  @name DataTable#order.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  */

	/**
  * DataTables initialisation complete event, fired when the table is fully
  * drawn, including Ajax data loaded, if Ajax data is required.
  *  @name DataTable#init.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} oSettings DataTables settings object
  *  @param {object} json The JSON object request from the server - only
  *    present if client-side Ajax sourced data is used</li></ol>
  */

	/**
  * State save event, fired when the table has changed state a new state save
  * is required. This event allows modification of the state saving object
  * prior to actually doing the save, including addition or other state
  * properties (for plug-ins) or modification of a DataTables core property.
  *  @name DataTable#stateSaveParams.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} oSettings DataTables settings object
  *  @param {object} json The state information to be saved
  */

	/**
  * State load event, fired when the table is loading state from the stored
  * data, but prior to the settings object being modified by the saved state
  * - allowing modification of the saved state is required or loading of
  * state for a plug-in.
  *  @name DataTable#stateLoadParams.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} oSettings DataTables settings object
  *  @param {object} json The saved state information
  */

	/**
  * State loaded event, fired when state has been loaded from stored data and
  * the settings object has been modified by the loaded data.
  *  @name DataTable#stateLoaded.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} oSettings DataTables settings object
  *  @param {object} json The saved state information
  */

	/**
  * Processing event, fired when DataTables is doing some kind of processing
  * (be it, order, searcg or anything else). It can be used to indicate to
  * the end user that there is something happening, or that something has
  * finished.
  *  @name DataTable#processing.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} oSettings DataTables settings object
  *  @param {boolean} bShow Flag for if DataTables is doing processing or not
  */

	/**
  * Ajax (XHR) event, fired whenever an Ajax request is completed from a
  * request to made to the server for new data. This event is called before
  * DataTables processed the returned data, so it can also be used to pre-
  * process the data returned from the server, if needed.
  *
  * Note that this trigger is called in `fnServerData`, if you override
  * `fnServerData` and which to use this event, you need to trigger it in you
  * success function.
  *  @name DataTable#xhr.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  *  @param {object} json JSON returned from the server
  *
  *  @example
  *     // Use a custom property returned from the server in another DOM element
  *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
  *       $('#status').html( json.status );
  *     } );
  *
  *  @example
  *     // Pre-process the data returned from the server
  *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
  *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
  *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
  *       }
  *       // Note no return - manipulate the data directly in the JSON object.
  *     } );
  */

	/**
  * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
  * or passing the bDestroy:true parameter in the initialisation object. This
  * can be used to remove bound events, added DOM nodes, etc.
  *  @name DataTable#destroy.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  */

	/**
  * Page length change event, fired when number of records to show on each
  * page (the length) is changed.
  *  @name DataTable#length.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  *  @param {integer} len New length
  */

	/**
  * Column sizing has changed.
  *  @name DataTable#column-sizing.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  */

	/**
  * Column visibility has changed.
  *  @name DataTable#column-visibility.dt
  *  @event
  *  @param {event} e jQuery event object
  *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  *  @param {int} column Column index
  *  @param {bool} vis `false` if column now hidden, or `true` if visible
  */

	return $.fn.dataTable;
});

/***/ }),
/* 11 */,
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODNlZTdjMTAyZTQ4NThiMmQwN2Q/YzU1MiIsIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qcz8yN2Q5Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvbWF0ZXJpYWxpemUvYmluL21hdGVyaWFsaXplLmpzP2YxMTMiLCJ3ZWJwYWNrOi8vLy4vfi9oYW1tZXJqcy9oYW1tZXIuanM/Yjk5YSIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcz8wYmJhIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcz81ZjcxIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/YzNjMiIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2FkbWluLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvZGF0YXRhYmxlcy5qcyJdLCJuYW1lcyI6WyJqUXVlcnkiLCIkIiwicmVxdWlyZSIsImVhc2luZyIsImV4dGVuZCIsImRlZiIsInN3aW5nIiwieCIsInQiLCJiIiwiYyIsImQiLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluQ3ViaWMiLCJlYXNlT3V0Q3ViaWMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJblF1YXJ0IiwiZWFzZU91dFF1YXJ0IiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VPdXRRdWludCIsImVhc2VJbk91dFF1aW50IiwiZWFzZUluU2luZSIsIk1hdGgiLCJjb3MiLCJQSSIsImVhc2VPdXRTaW5lIiwic2luIiwiZWFzZUluT3V0U2luZSIsImVhc2VJbkV4cG8iLCJwb3ciLCJlYXNlT3V0RXhwbyIsImVhc2VJbk91dEV4cG8iLCJlYXNlSW5DaXJjIiwic3FydCIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJzIiwicCIsImEiLCJhYnMiLCJhc2luIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsInVuZGVmaW5lZCIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJlYXNlSW5PdXRCb3VuY2UiLCJlYXNlSW5PdXRNYXRlcmlhbCIsIlZlbG9jaXR5IiwiY29uc29sZSIsImxvZyIsImUiLCJsZW5ndGgiLCJyIiwidHlwZSIsImlzV2luZG93Iiwibm9kZVR5cGUiLCJmbiIsImluaXQiLCJ3aW5kb3ciLCJuIiwiaSIsImNhbGwiLCJpc0FycmF5IiwiQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwiY29uc3RydWN0b3IiLCJvIiwicHJvdG90eXBlIiwiZWFjaCIsImFwcGx5IiwiZGF0YSIsImV4cGFuZG8iLCJ1dWlkIiwicmVtb3ZlRGF0YSIsImFyZ3VtZW50cyIsImwiLCJ1IiwicXVldWUiLCJPYmplY3QiLCJwdXNoIiwiZGVxdWV1ZSIsInNoaWZ0IiwidW5zaGlmdCIsIkVycm9yIiwib2Zmc2V0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwibGVmdCIsInBhZ2VZT2Zmc2V0IiwiZG9jdW1lbnQiLCJzY3JvbGxUb3AiLCJjbGllbnRUb3AiLCJwYWdlWE9mZnNldCIsInNjcm9sbExlZnQiLCJjbGllbnRMZWZ0IiwicG9zaXRpb24iLCJvZmZzZXRQYXJlbnQiLCJ0b0xvd2VyQ2FzZSIsInN0eWxlIiwidGVzdCIsIm5vZGVOYW1lIiwicGFyc2VGbG9hdCIsIm1hcmdpblRvcCIsIm1hcmdpbkxlZnQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsIkRhdGUiLCJnZXRUaW1lIiwiaGFzT3duUHJvcGVydHkiLCJ0b1N0cmluZyIsInNwbGl0IiwiVXRpbGl0aWVzIiwibW9kdWxlIiwiZXhwb3J0cyIsIm0iLCJpc1dyYXBwZWQiLCJzbGljZSIsImlzTm9kZSIsImYiLCJyb3VuZCIsInciLCJoIiwidiIsInkiLCJnIiwiViIsIlMiLCJQIiwiaXNOYU4iLCJpc0Zpbml0ZSIsIm1pbiIsIm1heCIsIkZsb2F0MzJBcnJheSIsIkMiLCJnZXRDb250cm9sUG9pbnRzIiwiVCIsImlzU3RyaW5nIiwiRWFzaW5ncyIsImNvbmNhdCIsImRlZmF1bHRzIiwiU3RhdGUiLCJjYWxscyIsImR1cmF0aW9uIiwiZWxlbWVudCIsImRpc3BsYXkiLCJzZXRQcm9wZXJ0eVZhbHVlIiwidmlzaWJpbGl0eSIsImsiLCJBIiwiRiIsImoiLCJlbmRWYWx1ZSIsIkUiLCJzdGFydFZhbHVlIiwiY3VycmVudFZhbHVlIiwiSG9va3MiLCJyZWdpc3RlcmVkIiwiSCIsImdldFJvb3QiLCJOIiwicm9vdFByb3BlcnR5VmFsdWVDYWNoZSIsInJvb3RQcm9wZXJ0eVZhbHVlIiwiTCIsInVuaXRUeXBlIiwic2Nyb2xsRGF0YSIsIk5vcm1hbGl6YXRpb25zIiwibW9iaWxlSEEiLCJ0cmFuc2Zvcm1DYWNoZSIsInRyYW5zbGF0ZTNkIiwiZmx1c2hUcmFuc2Zvcm1DYWNoZSIsInByb2dyZXNzIiwiaXNUaWNraW5nIiwibG9vcCIsImlzQW5pbWF0aW5nIiwiTGlzdHMiLCJ0cmFuc2Zvcm1zM0QiLCJSZWdFeHAiLCJWYWx1ZXMiLCJyZW1vdmVDbGFzcyIsImNvbXBsZXRlIiwic2V0VGltZW91dCIsInR3ZWVuc0NvbnRhaW5lciIsImRlbGF5IiwiZG9jdW1lbnRNb2RlIiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaXNGdW5jdGlvbiIsImlzTm9kZUxpc3QiLCJqcXVlcnkiLCJaZXB0byIsInplcHRvIiwiaXNaIiwiaXNTVkciLCJTVkdFbGVtZW50IiwiaXNFbXB0eU9iamVjdCIsInZlbG9jaXR5IiwiYW5pbWF0ZSIsImlzTW9iaWxlIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNBbmRyb2lkIiwiaXNHaW5nZXJicmVhZCIsImlzQ2hyb21lIiwiY2hyb21lIiwiaXNGaXJlZm94IiwicHJlZml4RWxlbWVudCIsInByZWZpeE1hdGNoZXMiLCJzY3JvbGxBbmNob3IiLCJzY3JvbGxQcm9wZXJ0eUxlZnQiLCJzY3JvbGxQcm9wZXJ0eVRvcCIsIkNTUyIsIlJlZGlyZWN0cyIsIlByb21pc2UiLCJiZWdpbiIsIl9jYWNoZVZhbHVlcyIsImNvbXB1dGVkU3R5bGUiLCJob29rIiwibW9jayIsInZlcnNpb24iLCJtYWpvciIsIm1pbm9yIiwicGF0Y2giLCJkZWJ1ZyIsImRvY3VtZW50RWxlbWVudCIsImJvZHkiLCJwYXJlbnROb2RlIiwidGVuc2lvbiIsImZyaWN0aW9uIiwiZHgiLCJkdiIsImxpbmVhciIsInNwcmluZyIsImV4cCIsIlJlZ0V4IiwiaXNIZXgiLCJ2YWx1ZVVud3JhcCIsIndyYXBwZWRWYWx1ZUFscmVhZHlFeHRyYWN0ZWQiLCJ2YWx1ZVNwbGl0IiwiY29sb3JzIiwidHJhbnNmb3Jtc0Jhc2UiLCJ0ZW1wbGF0ZXMiLCJ0ZXh0U2hhZG93IiwiYm94U2hhZG93IiwiY2xpcCIsImJhY2tncm91bmRQb3NpdGlvbiIsInRyYW5zZm9ybU9yaWdpbiIsInBlcnNwZWN0aXZlT3JpZ2luIiwicmVnaXN0ZXIiLCJtYXRjaCIsImpvaW4iLCJjbGVhblJvb3RQcm9wZXJ0eVZhbHVlIiwiaXNDU1NOdWxsVmFsdWUiLCJleHRyYWN0VmFsdWUiLCJpbmplY3RWYWx1ZSIsInJlcGxhY2UiLCJibHVyIiwib3BhY2l0eSIsInpvb20iLCJwYXJzZUludCIsInN1YnN0ciIsImJsYWNrIiwiYmx1ZSIsImdyYXkiLCJncmVlbiIsInJlZCIsIndoaXRlIiwiaGV4VG9SZ2IiLCJOYW1lcyIsImNhbWVsQ2FzZSIsInRvVXBwZXJDYXNlIiwiU1ZHQXR0cmlidXRlIiwicHJlZml4Q2hlY2siLCJleGVjIiwiZ2V0VW5pdFR5cGUiLCJnZXREaXNwbGF5VHlwZSIsInRhZ05hbWUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsImFkZCIsImNsYXNzTmFtZSIsInJlbW92ZSIsImdldFByb3BlcnR5VmFsdWUiLCJjc3MiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRCQm94IiwiZ2V0QXR0cmlidXRlIiwiY29udGFpbmVyIiwiZGlyZWN0aW9uIiwic2Nyb2xsVG8iLCJhbHRlcm5hdGVWYWx1ZSIsInNldEF0dHJpYnV0ZSIsInRyYW5zbGF0ZSIsInNrZXdYIiwic2tld1kiLCJzY2FsZSIsInJvdGF0ZSIsInByb21pc2UiLCJteVBhcmVudCIsImZvbnRTaXplIiwibGFzdFBvc2l0aW9uIiwibGFzdFBhcmVudCIsImxhc3RGb250U2l6ZSIsImVtVG9QeCIsImxhc3RFbVRvUHgiLCJwZXJjZW50VG9QeFdpZHRoIiwibGFzdFBlcmNlbnRUb1B4V2lkdGgiLCJwZXJjZW50VG9QeEhlaWdodCIsImxhc3RQZXJjZW50VG9QeEhlaWdodCIsImNyZWF0ZUVsZW1lbnROUyIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJyZW1Ub1B4IiwidndUb1B4IiwiaW5uZXJXaWR0aCIsInZoVG9QeCIsImlubmVySGVpZ2h0IiwiSlNPTiIsInN0cmluZ2lmeSIsImF4aXMiLCJzY3JvbGwiLCJvcHRzIiwieiIsIk8iLCJxIiwiTSIsIkkiLCJCIiwiVyIsIkciLCJZIiwiRCIsIlEiLCJSIiwicmVzb2x2ZXIiLCJ2ZWxvY2l0eVF1ZXVlRW50cnlGbGFnIiwiZGVsYXlUaW1lciIsIm5leHQiLCJwcm9wZXJ0aWVzIiwibmFtZXMiLCJlbGVtZW50cyIsIm9wdGlvbnMiLCJyZWplY3RlciIsImNsZWFyVGltZW91dCIsImJhY2t3YXJkcyIsInJldmVyc2UiLCJzdGFnZ2VyIiwiZHJhZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImhpZGRlbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJoZWlnaHQiLCJtYXJnaW5Cb3R0b20iLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsIm92ZXJmbG93IiwiZm9yRWFjaCIsImtleXMiLCJjcmVhdGUiLCJfc3VwZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaW5kZXhPZiIsInRyaW0iLCJzb3J0Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiYWIiLCJtYW5hZ2VyIiwiY2FsbGJhY2siLCJ0YXJnZXQiLCJpbnB1dFRhcmdldCIsImRvbUhhbmRsZXIiLCJlbmFibGUiLCJoYW5kbGVyIiwiYmIiLCJpbnB1dENsYXNzIiwid2IiLCJFYiIsIkdiIiwicmIiLCJjYiIsInBvaW50ZXJzIiwiY2hhbmdlZFBvaW50ZXJzIiwiaXNGaXJzdCIsImlzRmluYWwiLCJzZXNzaW9uIiwiZXZlbnRUeXBlIiwiZGIiLCJlbWl0IiwicmVjb2duaXplIiwicHJldklucHV0IiwiZmlyc3RJbnB1dCIsImdiIiwiZmlyc3RNdWx0aXBsZSIsImNlbnRlciIsImhiIiwidGltZVN0YW1wIiwiZGVsdGFUaW1lIiwiYW5nbGUiLCJsYiIsImRpc3RhbmNlIiwia2IiLCJlYiIsIm9mZnNldERpcmVjdGlvbiIsImpiIiwiZGVsdGFYIiwiZGVsdGFZIiwibmIiLCJyb3RhdGlvbiIsIm1iIiwiZmIiLCJzcmNFdmVudCIsIm9mZnNldERlbHRhIiwicHJldkRlbHRhIiwibGFzdEludGVydmFsIiwiaWIiLCJ2ZWxvY2l0eVgiLCJ2ZWxvY2l0eVkiLCJjbGllbnRYIiwiY2xpZW50WSIsIlUiLCJhdGFuMiIsIl8iLCJldkVsIiwicGIiLCJldldpbiIsInFiIiwiYWxsb3ciLCJwcmVzc2VkIiwidWIiLCJ2YiIsInN0b3JlIiwicG9pbnRlckV2ZW50cyIsIkFiIiwiZXZUYXJnZXQiLCJ5YiIsInpiIiwic3RhcnRlZCIsIkJiIiwidG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiRGIiLCJ0YXJnZXRJZHMiLCJGYiIsImlkZW50aWZpZXIiLCJmaWx0ZXIiLCJ0b3VjaCIsIm1vdXNlIiwiUGIiLCJzZXQiLCJRYiIsIk1iIiwiTmIiLCJPYiIsIkxiIiwiS2IiLCJZYiIsImlkIiwic3RhdGUiLCJSYiIsInNpbXVsdGFuZW91cyIsInJlcXVpcmVGYWlsIiwiWmIiLCJXYiIsIlViIiwiVGIiLCJTYiIsIiRiIiwiX2IiLCJnZXQiLCJhYyIsImJjIiwicFgiLCJwWSIsImNjIiwiZGMiLCJfdGltZXIiLCJfaW5wdXQiLCJlYyIsImZjIiwiZ2MiLCJwVGltZSIsInBDZW50ZXIiLCJjb3VudCIsImhjIiwicmVjb2duaXplcnMiLCJwcmVzZXQiLCJrYyIsImhhbmRsZXJzIiwiaW5wdXQiLCJ0b3VjaEFjdGlvbiIsImxjIiwicmVjb2duaXplV2l0aCIsInJlcXVpcmVGYWlsdXJlIiwiY3NzUHJvcHMiLCJtYyIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZ2VzdHVyZSIsImRpc3BhdGNoRXZlbnQiLCJub3ciLCJKIiwiSyIsIlgiLCJaIiwiZGVzdHJveSIsIm9iIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsImJ1dHRvbiIsIndoaWNoIiwicG9pbnRlclR5cGUiLCJzYiIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJwb2ludGVyY2FuY2VsIiwicG9pbnRlcm91dCIsInRiIiwiTVNQb2ludGVyRXZlbnQiLCJwb2ludGVySWQiLCJzcGxpY2UiLCJ4YiIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsInRvdWNoY2FuY2VsIiwiQ2IiLCJIYiIsIkliIiwiSmIiLCJjb21wdXRlIiwiYWN0aW9ucyIsInVwZGF0ZSIsImdldFRvdWNoQWN0aW9uIiwicHJldmVudERlZmF1bHRzIiwicHJldmVudGVkIiwicHJldmVudERlZmF1bHQiLCJwcmV2ZW50U3JjIiwiVmIiLCJYYiIsImRyb3BSZWNvZ25pemVXaXRoIiwiZHJvcFJlcXVpcmVGYWlsdXJlIiwiaGFzUmVxdWlyZUZhaWx1cmVzIiwiY2FuUmVjb2duaXplV2l0aCIsImV2ZW50IiwidHJ5RW1pdCIsImNhbkVtaXQiLCJwcm9jZXNzIiwicmVzZXQiLCJhdHRyVGVzdCIsInRocmVzaG9sZCIsImRpcmVjdGlvblRlc3QiLCJ0aW1lIiwidGFwcyIsImludGVydmFsIiwicG9zVGhyZXNob2xkIiwiZmFpbFRpbWVvdXQiLCJ0YXBDb3VudCIsIlZFUlNJT04iLCJkb21FdmVudHMiLCJ1c2VyU2VsZWN0IiwidG91Y2hTZWxlY3QiLCJ0b3VjaENhbGxvdXQiLCJjb250ZW50Wm9vbWluZyIsInVzZXJEcmFnIiwidGFwSGlnaGxpZ2h0Q29sb3IiLCJpYyIsImpjIiwic3RvcCIsInN0b3BwZWQiLCJjdXJSZWNvZ25pemVyIiwib24iLCJvZmYiLCJJTlBVVF9TVEFSVCIsIklOUFVUX01PVkUiLCJJTlBVVF9FTkQiLCJJTlBVVF9DQU5DRUwiLCJTVEFURV9QT1NTSUJMRSIsIlNUQVRFX0JFR0FOIiwiU1RBVEVfQ0hBTkdFRCIsIlNUQVRFX0VOREVEIiwiU1RBVEVfUkVDT0dOSVpFRCIsIlNUQVRFX0NBTkNFTExFRCIsIlNUQVRFX0ZBSUxFRCIsIkRJUkVDVElPTl9OT05FIiwiRElSRUNUSU9OX0xFRlQiLCJESVJFQ1RJT05fUklHSFQiLCJESVJFQ1RJT05fVVAiLCJESVJFQ1RJT05fRE9XTiIsIkRJUkVDVElPTl9IT1JJWk9OVEFMIiwiRElSRUNUSU9OX1ZFUlRJQ0FMIiwiRElSRUNUSU9OX0FMTCIsIk1hbmFnZXIiLCJJbnB1dCIsIlRvdWNoQWN0aW9uIiwiVG91Y2hJbnB1dCIsIk1vdXNlSW5wdXQiLCJQb2ludGVyRXZlbnRJbnB1dCIsIlRvdWNoTW91c2VJbnB1dCIsIlNpbmdsZVRvdWNoSW5wdXQiLCJSZWNvZ25pemVyIiwiQXR0clJlY29nbml6ZXIiLCJUYXAiLCJQYW4iLCJTd2lwZSIsIlBpbmNoIiwiUm90YXRlIiwiUHJlc3MiLCJtZXJnZSIsImluaGVyaXQiLCJiaW5kRm4iLCJwcmVmaXhlZCIsImZhY3RvcnkiLCJkZWZpbmUiLCJIYW1tZXIiLCJoYW1tZXJpZnkiLCJlbCIsIiRlbCIsImhhbW1lciIsIm9yaWdpbmFsRW1pdCIsInRyaWdnZXIiLCJQYWNrYWdlIiwiTWF0ZXJpYWxpemUiLCJsYXN0VGltZSIsInZlbmRvcnMiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm5leHRUaW1lIiwib2JqZWN0U2VsZWN0b3JTdHJpbmciLCJvYmoiLCJ0YWdTdHIiLCJwcm9wIiwiaWRTdHIiLCJhdHRyIiwiY2xhc3NTdHIiLCJndWlkIiwiczQiLCJmbG9vciIsInJhbmRvbSIsInN1YnN0cmluZyIsImVzY2FwZUhhc2giLCJoYXNoIiwiZWxlbWVudE9yUGFyZW50SXNGaXhlZCIsIiRlbGVtZW50IiwiJGNoZWNrRWxlbWVudHMiLCJwYXJlbnRzIiwiaXNGaXhlZCIsInRocm90dGxlIiwiZnVuYyIsIndhaXQiLCJjb250ZXh0IiwiYXJncyIsInJlc3VsdCIsInRpbWVvdXQiLCJwcmV2aW91cyIsImxhdGVyIiwibGVhZGluZyIsInJlbWFpbmluZyIsInRyYWlsaW5nIiwiVmVsIiwiY29sbGFwc2libGUiLCJtZXRob2RQYXJhbSIsImFjY29yZGlvbiIsIm9uT3BlbiIsIm9uQ2xvc2UiLCJtZXRob2ROYW1lIiwiJHRoaXMiLCIkcGFuZWxfaGVhZGVycyIsImZpbmQiLCJjb2xsYXBzaWJsZV90eXBlIiwiYWNjb3JkaW9uT3BlbiIsIm9iamVjdCIsImhhc0NsYXNzIiwicGFyZW50Iiwic2libGluZ3MiLCJzbGlkZURvd24iLCJzbGlkZVVwIiwibm90IiwiY2hpbGRyZW4iLCJpcyIsImV4ZWNDYWxsYmFja3MiLCJleHBhbmRhYmxlT3BlbiIsImNvbGxhcHNpYmxlT3BlbiIsIm5vVG9nZ2xlIiwidG9nZ2xlQ2xhc3MiLCJpc0NoaWxkcmVuT2ZQYW5lbEhlYWRlciIsInBhbmVsSGVhZGVyIiwiZ2V0UGFuZWxIZWFkZXIiLCJjbG9zZXN0IiwicmVtb3ZlRXZlbnRIYW5kbGVycyIsIiRjdXJyX2hlYWRlciIsImVxIiwiZmlyc3QiLCJyZWFkeSIsImVsZW0iLCJkcm9wZG93biIsImluRHVyYXRpb24iLCJvdXREdXJhdGlvbiIsImNvbnN0cmFpbldpZHRoIiwiaG92ZXIiLCJndXR0ZXIiLCJiZWxvd09yaWdpbiIsImFsaWdubWVudCIsInN0b3BQcm9wYWdhdGlvbiIsIm9yaWdpbiIsImN1cnJfb3B0aW9ucyIsImlzRm9jdXNlZCIsImFjdGl2YXRlcyIsInVwZGF0ZU9wdGlvbnMiLCJhZnRlciIsInBsYWNlRHJvcGRvd24iLCJvdXRlcldpZHRoIiwid2luZG93SGVpZ2h0Iiwib3JpZ2luSGVpZ2h0Iiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsImN1cnJBbGlnbm1lbnQiLCJndXR0ZXJTcGFjaW5nIiwibGVmdFBvc2l0aW9uIiwidmVydGljYWxPZmZzZXQiLCJzY3JvbGxZT2Zmc2V0Iiwic2Nyb2xsWE9mZnNldCIsIndyYXBwZXIiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwid2lkdGgiLCJhZGp1c3RlZEhlaWdodCIsIm9mZnNldFJpZ2h0IiwiYmluZCIsImhpZGVEcm9wZG93biIsInVuYmluZCIsImZhZGVPdXQiLCJvcGVuIiwidG9FbCIsInRvRWxlbWVudCIsInJlbGF0ZWRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwiX3N0YWNrIiwiX2xhc3RJRCIsIl9nZW5lcmF0ZUlEIiwibWV0aG9kcyIsImRpc21pc3NpYmxlIiwic3RhcnRpbmdUb3AiLCJlbmRpbmdUb3AiLCIkbW9kYWwiLCJtb2RhbF9pZCIsImNsb3NlTW9kYWwiLCJvdmVybGF5SUQiLCIkb3ZlcmxheSIsImVhc2UiLCJleGl0VmVsb2NpdHlPcHRpb25zIiwiYm90dG9tIiwic2NhbGVYIiwib3Blbk1vZGFsIiwiJHRyaWdnZXIiLCIkYm9keSIsIm9sZFdpZHRoIiwibFN0YWNrIiwiYXBwZW5kIiwiY2xpY2siLCJrZXlDb2RlIiwiZW50ZXJWZWxvY2l0eU9wdGlvbnMiLCJjbG9zZSIsIm1vZGFsIiwibWV0aG9kT3JPcHRpb25zIiwiZXJyb3IiLCJtYXRlcmlhbGJveCIsIm92ZXJsYXlBY3RpdmUiLCJkb25lQW5pbWF0aW5nIiwicGxhY2Vob2xkZXIiLCJvcmlnaW5hbFdpZHRoIiwib3JpZ2luYWxIZWlnaHQiLCJhbmNlc3RvcnNDaGFuZ2VkIiwiYW5jZXN0b3IiLCJvcmlnaW5JbmxpbmVTdHlsZXMiLCJ3cmFwIiwid2luZG93V2lkdGgiLCJyZXR1cm5Ub09yaWdpbmFsIiwiY3VyciIsIm92ZXJsYXkiLCJiZWZvcmUiLCJvdmVybGF5T2Zmc2V0IiwiJHBob3RvX2NhcHRpb24iLCJ0ZXh0IiwicmF0aW8iLCJ3aWR0aFBlcmNlbnQiLCJoZWlnaHRQZXJjZW50IiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJrZXl1cCIsInJlbW92ZUF0dHIiLCJwYXJhbGxheCIsIndpbmRvd193aWR0aCIsInVwZGF0ZVBhcmFsbGF4IiwiaW5pdGlhbCIsImNvbnRhaW5lcl9oZWlnaHQiLCIkaW1nIiwiaW1nX2hlaWdodCIsInBhcmFsbGF4X2Rpc3QiLCJ3aW5kb3dCb3R0b20iLCJwZXJjZW50U2Nyb2xsZWQiLCJvbmUiLCJyZXNpemUiLCJvblNob3ciLCJzd2lwZWFibGUiLCJyZXNwb25zaXZlVGhyZXNob2xkIiwiSW5maW5pdHkiLCJuYW1lc3BhY2UiLCJ1bmlxdWVOYW1lc3BhY2UiLCIkYWN0aXZlIiwiJGNvbnRlbnQiLCIkbGlua3MiLCIkdGFic193aWR0aCIsIiR0YWJzX2NvbnRlbnQiLCIkdGFic193cmFwcGVyIiwiJHRhYl93aWR0aCIsIiRpbmRpY2F0b3IiLCJpbmRleCIsInByZXZfaW5kZXgiLCJjbGlja2VkIiwiY2xpY2tlZFRpbWVvdXQiLCJ0cmFuc2l0aW9uIiwiY2FsY1JpZ2h0UG9zIiwiY2VpbCIsImNhbGNMZWZ0UG9zIiwiYW5pbWF0ZUluZGljYXRvciIsImxvY2F0aW9uIiwiJGN1cnJfY29udGVudCIsIndyYXBBbGwiLCJjYXJvdXNlbCIsImZ1bGxXaWR0aCIsIm5vV3JhcCIsIm9uQ3ljbGVUbyIsIml0ZW0iLCJoaWRlIiwiJG9sZENvbnRlbnQiLCJhY3RpdmVSZWN0Iiwic2hvdyIsInNlbGVjdF90YWIiLCJ0YWJzIiwidG9vbHRpcCIsIm1hcmdpbiIsImh0bWwiLCJ0b29sdGlwSWQiLCJhbGxvd0h0bWwiLCJ0b29sdGlwRGVsYXkiLCJ0b29sdGlwUG9zaXRpb24iLCJ0b29sdGlwVGV4dCIsInRvb2x0aXBFbCIsImJhY2tkcm9wIiwic2V0QXR0cmlidXRlcyIsInJlbmRlclRvb2x0aXBFbCIsImFwcGVuZFRvIiwidGltZW91dFJlZiIsInNob3dUb29sdGlwIiwib3JpZ2luV2lkdGgiLCJvdXRlckhlaWdodCIsInRvb2x0aXBIZWlnaHQiLCJ0b29sdGlwV2lkdGgiLCJ0b29sdGlwVmVydGljYWxNb3ZlbWVudCIsInRvb2x0aXBIb3Jpem9udGFsTW92ZW1lbnQiLCJiYWNrZHJvcE9mZnNldFdpZHRoIiwiYmFja2Ryb3BPZmZzZXRIZWlnaHQiLCJzY2FsZVhGYWN0b3IiLCJzY2FsZVlGYWN0b3IiLCJzY2FsZUZhY3RvciIsInRhcmdldFRvcCIsInRhcmdldExlZnQiLCJuZXdDb29yZGluYXRlcyIsInJlcG9zaXRpb25XaXRoaW5TY3JlZW4iLCJib3JkZXJSYWRpdXMiLCJyaWdodCIsIlNRUlQyIiwidHJhbnNsYXRlWSIsInRyYW5zbGF0ZVgiLCJzY2FsZVkiLCJuZXdYIiwibmV3WSIsIldhdmVzIiwiJCQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0V2luZG93IiwiZG9jRWxlbSIsIndpbiIsImJveCIsImRvYyIsImNvbnZlcnRTdHlsZSIsIkVmZmVjdCIsInJpcHBsZSIsInBvcyIsInJlbGF0aXZlWSIsInBhZ2VZIiwicmVsYXRpdmVYIiwicGFnZVgiLCJyaXBwbGVTdHlsZSIsInRyYW5zZm9ybSIsIlRvdWNoSGFuZGxlciIsInRvdWNodXAiLCJyaXBwbGVzIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImRpZmYiLCJOdW1iZXIiLCJ3cmFwSW5wdXQiLCJlbGVtZW50U3R5bGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZXBsYWNlQ2hpbGQiLCJhbGxvd0V2ZW50IiwiZ2V0V2F2ZXNFZmZlY3RFbGVtZW50Iiwic3JjRWxlbWVudCIsInBhcmVudEVsZW1lbnQiLCJjb250YWlucyIsInNob3dFZmZlY3QiLCJkaXNwbGF5RWZmZWN0IiwiYXR0YWNoIiwidG9hc3QiLCJtZXNzYWdlIiwiZGlzcGxheUxlbmd0aCIsImNvbXBsZXRlQ2FsbGJhY2siLCJnZXRFbGVtZW50QnlJZCIsIm5ld1RvYXN0IiwiY3JlYXRlVG9hc3QiLCJ0aW1lTGVmdCIsImNvdW50ZXJJbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsYXNzZXMiLCJIVE1MRWxlbWVudCIsImhhbW1lckhhbmRsZXIiLCJwcmV2ZW50X2RlZmF1bHQiLCJhY3RpdmF0aW9uRGlzdGFuY2UiLCJvcGFjaXR5UGVyY2VudCIsIm1lbnVXaWR0aCIsImVkZ2UiLCJjbG9zZU9uQ2xpY2siLCJkcmFnZ2FibGUiLCJtZW51SWQiLCJtZW51IiwiJGRyYWdUYXJnZXQiLCJtZW51T3V0IiwicmVtb3ZlTWVudSIsInJlc3RvcmVOYXYiLCJwYW5uaW5nIiwicmlnaHRQb3MiLCJvdmVybGF5UGVyYyIsImxlZnRQb3MiLCJzaWRlTmF2IiwialdpbmRvdyIsImVsZW1lbnRzSW5WaWV3IiwiaXNTcHlpbmciLCJ0aWNrcyIsInVuaXF1ZV9pZCIsImZpbmRFbGVtZW50cyIsImhpdHMiLCJlbFRvcCIsImVsTGVmdCIsImVsUmlnaHQiLCJlbEJvdHRvbSIsImlzSW50ZXJzZWN0Iiwib25TY3JvbGwiLCJzY3JvbGxPZmZzZXQiLCJpbnRlcnNlY3Rpb25zIiwibGFzdFRpY2siLCJ0cmlnZ2VySGFuZGxlciIsIm9uV2luU2l6ZSIsInNjcm9sbFNweSIsInNlbGVjdG9yIiwidmlzaWJsZSIsIm9mZnNldEJvdHRvbSIsInRocm90dGxlZFNjcm9sbCIsInJlYWR5U2Nyb2xsIiwiZ3JlcCIsInZhbHVlIiwid2luU2l6ZVNweSIsInVwZGF0ZVRleHRGaWVsZHMiLCJpbnB1dF9zZWxlY3RvciIsInZhbCIsImF1dG9mb2N1cyIsInZhbGlkaXR5IiwiYmFkSW5wdXQiLCJ2YWxpZGF0ZV9maWVsZCIsImZvcm1SZXNldCIsInJlc2V0X3RleHQiLCIkaW5wdXRFbGVtZW50IiwiaGFzTGVuZ3RoIiwibGVuQXR0ciIsImxlbiIsInJhZGlvX2NoZWNrYm94IiwiaGlkZGVuRGl2IiwidGV4dF9hcmVhX3NlbGVjdG9yIiwidGV4dGFyZWFBdXRvUmVzaXplIiwiJHRleHRhcmVhIiwiZm9udEZhbWlseSIsImxpbmVIZWlnaHQiLCJjb250ZW50IiwiZmlsZV9maWVsZCIsInBhdGhfaW5wdXQiLCJmaWxlcyIsImZpbGVfbmFtZXMiLCJuYW1lIiwicmFuZ2VfdHlwZSIsInJhbmdlX21vdXNlZG93biIsInRodW1iIiwic2hvd1JhbmdlQnViYmxlIiwicGFkZGluZ0xlZnQiLCJjYWxjUmFuZ2VPZmZzZXQiLCJyYW5nZSIsInBlcmNlbnQiLCJyYW5nZV93cmFwcGVyIiwiYXV0b2NvbXBsZXRlIiwibGltaXQiLCJvbkF1dG9jb21wbGV0ZSIsIm1pbkxlbmd0aCIsIiRpbnB1dCIsImFjdGl2ZUluZGV4Iiwib2xkVmFsIiwiJGlucHV0RGl2IiwiJGF1dG9jb21wbGV0ZSIsIiRvbGRBdXRvY29tcGxldGUiLCJoaWdobGlnaHQiLCJzdHJpbmciLCJpbWciLCJtYXRjaFN0YXJ0IiwibWF0Y2hFbmQiLCJiZWZvcmVNYXRjaCIsIm1hdGNoVGV4dCIsImFmdGVyTWF0Y2giLCJwcmVwZW5kIiwicmVzZXRDdXJyZW50RWxlbWVudCIsInJlbW92ZUF1dG9jb21wbGV0ZSIsImVtcHR5Iiwia2V5IiwiYXV0b2NvbXBsZXRlT3B0aW9uIiwibGlFbGVtZW50IiwibnVtSXRlbXMiLCJtYXRlcmlhbF9zZWxlY3QiLCIkc2VsZWN0IiwibXVsdGlwbGUiLCJsYXN0SUQiLCJ1bndyYXAiLCJ1bmlxdWVJRCIsInNlbGVjdENoaWxkcmVuIiwidmFsdWVzU2VsZWN0ZWQiLCJvcHRpb25zSG92ZXIiLCJsYWJlbCIsImFwcGVuZE9wdGlvbldpdGhJY29uIiwic2VsZWN0Iiwib3B0aW9uIiwiZGlzYWJsZWRDbGFzcyIsIm9wdGdyb3VwQ2xhc3MiLCJtdWx0aXBsZUNoZWNrYm94IiwiaWNvbl91cmwiLCJjbGFzc1N0cmluZyIsInNlbGVjdE9wdGlvbnMiLCJzZWxlY3RlZCIsInRvZ2dsZUVudHJ5RnJvbUFycmF5IiwiJG5ld1NlbGVjdCIsImFjdGl2YXRlT3B0aW9uIiwiZHJvcGRvd25JY29uIiwic2FuaXRpemVkTGFiZWxIdG1sIiwic2VsZWN0ZWRPcHRpb24iLCJjb2xsZWN0aW9uIiwibmV3T3B0aW9uIiwiZmlyc3RBY3RpdmF0aW9uIiwiZmlsdGVyUXVlcnkiLCJvbktleURvd24iLCJsZXR0ZXIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJub25MZXR0ZXJzIiwiYWN0aXZlT3B0aW9uIiwicHJldiIsImVudHJpZXNBcnJheSIsImVudHJ5SW5kZXgiLCJub3RBZGRlZCIsInNldFZhbHVlVG9JbnB1dCIsImluZGljYXRvcnMiLCIkc2xpZGVyIiwiJHNsaWRlcyIsIiRhY3RpdmVfaW5kZXgiLCIkaW5kaWNhdG9ycyIsIiRpbnRlcnZhbCIsImNhcHRpb25UcmFuc2l0aW9uIiwiY2FwdGlvbiIsIm1vdmVUb1NsaWRlIiwiJGNhcHRpb24iLCJwbGFjZWhvbGRlckJhc2U2NCIsIiRwYXJlbnQiLCJjdXJyX2luZGV4Iiwic3dpcGVMZWZ0Iiwic3dpcGVSaWdodCIsIiRjdXJyX3NsaWRlIiwibmV4dF9zbGlkZSIsImxhc3QiLCJwYXVzZSIsInN0YXJ0Iiwic2xpZGVyIiwibWF0ZXJpYWxDaGlwc0RlZmF1bHRzIiwic2Vjb25kYXJ5UGxhY2Vob2xkZXIiLCJhdXRvY29tcGxldGVPcHRpb25zIiwiJGNoaXBzIiwibWF0ZXJpYWxfY2hpcCIsInNlbGYiLCIkZG9jdW1lbnQiLCJTRUxTIiwiQ0hJUFMiLCJDSElQIiwiSU5QVVQiLCJERUxFVEUiLCJTRUxFQ1RFRF9DSElQIiwiaGFzQXV0b2NvbXBsZXRlIiwiY2hpcHMiLCJjaGlwSWQiLCJoYW5kbGVFdmVudHMiLCJmb2N1cyIsIiRjaGlwIiwid2FzU2VsZWN0ZWQiLCJzZWxlY3RDaGlwIiwiZGVsZXRlQ2hpcCIsInNlbGVjdEluZGV4IiwiJGN1cnJDaGlwcyIsIiR0YXJnZXQiLCJjaGlwc0xlbmd0aCIsImFkZENoaXAiLCJ0YWciLCJyZW5kZXJDaGlwIiwic2V0UGxhY2Vob2xkZXIiLCIkcmVuZGVyZWRDaGlwIiwiaXNWYWxpZCIsImV4aXN0cyIsIm5ld0RhdGEiLCJvbGREYXRhIiwiaW5zZXJ0QmVmb3JlIiwiY2hpcEluZGV4IiwiY2hpcCIsImdldENoaXBzRWxlbWVudCIsInB1c2hwaW4iLCIkaW5kZXgiLCIkdW5pcXVlSWQiLCIkb3JpZ2luYWxfb2Zmc2V0IiwicmVtb3ZlUGluQ2xhc3NlcyIsInVwZGF0ZUVsZW1lbnRzIiwib2JqZWN0cyIsInNjcm9sbGVkIiwiJHNjcm9sbGVkIiwib3BlbkZBQk1lbnUiLCJjbG9zZUZBQk1lbnUiLCIkbWVudSIsIkZBQnRvVG9vbGJhciIsIm9wZW5GQUIiLCJjbG9zZUZBQiIsIm9wZW5Ub29sYmFyIiwiY2xvc2VUb29sYmFyIiwidG9vbGJhclRvRkFCIiwiYnRuIiwiaG9yaXpvbnRhbCIsIm9mZnNldFkiLCJvZmZzZXRYIiwiYnRuUmVjdCIsImFuY2hvciIsImZhYkNvbG9yIiwiYnRuV2lkdGgiLCJidG5Cb3R0b20iLCJidG5MZWZ0IiwiZmFkZUluSW1hZ2UiLCJzZWxlY3Rvck9yRWwiLCJzdGVwIiwiZngiLCJncmF5c2NhbGVfc2V0dGluZyIsImJyaWdodG5lc3Nfc2V0dGluZyIsInNob3dTdGFnZ2VyZWRMaXN0IiwicGFkZGluZyIsInNjcm9sbEZpcmVFdmVudHNIYW5kbGVkIiwic2Nyb2xsRmlyZSIsIndpbmRvd1Njcm9sbCIsImN1cnJlbnRFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImVsZW1lbnRPZmZzZXQiLCJkb25lIiwiY2FsbGJhY2tGdW5jIiwiRnVuY3Rpb24iLCJQaWNrZXIiLCIkd2luZG93IiwiJGh0bWwiLCJQaWNrZXJDb25zdHJ1Y3RvciIsIkVMRU1FTlQiLCJOQU1FIiwiQ09NUE9ORU5UIiwiT1BUSU9OUyIsIklTX0RFRkFVTFRfVEhFTUUiLCJTVEFURSIsIlNFVFRJTkdTIiwiQ0xBU1NFUyIsImtsYXNzZXMiLCJrbGFzcyIsIiRFTEVNRU5UIiwiUGlja2VySW5zdGFuY2UiLCIkbm9kZSIsImdldEFjdGl2ZUVsZW1lbnQiLCJyZWFkT25seSIsImVkaXRhYmxlIiwiY29tcG9uZW50IiwiJHJvb3QiLCJub2RlIiwiY3JlYXRlV3JhcHBlZENvbXBvbmVudCIsInBpY2tlciIsInByZXBhcmVFbGVtZW50Um9vdCIsImZvcm1hdFN1Ym1pdCIsInByZXBhcmVFbGVtZW50SGlkZGVuIiwicHJlcGFyZUVsZW1lbnQiLCJvblN0YXJ0IiwicmVuZGVyIiwib25SZW5kZXIiLCJvblN0b3AiLCJvblNldCIsImlzVXNpbmdEZWZhdWx0VGhlbWUiLCJlbnRpcmVDb21wb25lbnQiLCJub2RlcyIsIl9oaWRkZW4iLCJkb250R2l2ZUZvY3VzIiwiYWN0aXZlIiwiYXJpYSIsIm9wZW5lZCIsImdldFNjcm9sbGJhcldpZHRoIiwia2V5Y29kZSIsImtleWNvZGVUb01vdmUiLCJnbyIsImhpZ2hsaWdodGVkIiwiZGlzYWJsZWQiLCJnaXZlRm9jdXMiLCJoYW5kbGVGb2N1c1RvT3BlbkV2ZW50IiwiZm9jdXNlZCIsImNsZWFyIiwidGhpbmciLCJ0aGluZ0l0ZW0iLCJ0aGluZ1ZhbHVlIiwidGhpbmdJc09iamVjdCIsInRoaW5nT2JqZWN0IiwiZm9ybWF0IiwibXV0ZWQiLCJmb3JtYXRzIiwibWV0aG9kIiwiaW50ZXJuYWwiLCJ0aGluZ05hbWUiLCJ0aGluZ01ldGhvZCIsIm5hbWVzQ291bnQiLCJfdHJpZ2dlciIsIm1ldGhvZExpc3QiLCJtYXAiLCJmcmFtZSIsImhvbGRlciIsImhhbmRsZUtleWRvd25FdmVudCIsImhhc3BvcHVwIiwiZXhwYW5kZWQiLCJyZWFkb25seSIsIm93bnMiLCJrZXlkb3duIiwiZm9jdXNpbiIsInRhcmdldERhdGEiLCJ0YXJnZXREaXNhYmxlZCIsIm5hdkRpc2FibGVkIiwiYWN0aXZlRWxlbWVudCIsImhyZWYiLCJuYXYiLCJwaWNrIiwiaGlkZGVuTmFtZSIsImhpZGRlblByZWZpeCIsImhpZGRlblN1ZmZpeCIsImlzS2V5Y29kZURlbGV0ZSIsInByZWZpeCIsInRoZW1lIiwiY3VycmVudFN0eWxlIiwiJG91dGVyIiwid2lkdGhXaXRob3V0U2Nyb2xsIiwiJGlubmVyIiwid2lkdGhXaXRoU2Nyb2xsIiwiZ3JvdXAiLCJncm91cE9iamVjdCIsImxvb3BPYmplY3RTY29wZSIsIm5vZGVzTGlzdCIsImNvdW50ZXIiLCJhdHRyaWJ1dGUiLCJsZWFkIiwibnVtYmVyIiwic2NvcGUiLCJkaWdpdHMiLCJpc0RhdGUiLCJpc0ludGVnZXIiLCJnZXREYXRlIiwiYXJpYUF0dHIiLCJDb21wb25lbnQiLCJhY3Rpb24iLCJjb21wb25lbnREYXRhIiwiYXJpYVNldCIsImF0dHJWYWwiLCJlcnIiLCJEQVlTX0lOX1dFRUsiLCJXRUVLU19JTl9DQUxFTkRBUiIsIkRhdGVQaWNrZXIiLCJzZXR0aW5ncyIsImNhbGVuZGFyIiwiZWxlbWVudFZhbHVlIiwiZWxlbWVudERhdGFWYWx1ZSIsInZhbHVlU3RyaW5nIiwiZm9ybWF0U3RyaW5nIiwiaXNSVEwiLCJ2aWV3IiwiZGlzYWJsZSIsImNvbGxlY3Rpb25EaXNhYmxlZCIsInRpbWVDaGFuZ2UiLCJoaWdobGlnaHRlZE9iamVjdCIsInRhcmdldERhdGUiLCJ5ZWFyIiwibW9udGgiLCJkYXRlIiwic2VsZWN0TW9udGgiLCJzZWxlY3RZZWFyIiwiaW5jbHVkZVRvZGF5IiwiYnV0dG9uVG9kYXkiLCJjYWxlbmRhckl0ZW0iLCJwb3AiLCJpc0luZmluaXRlVmFsdWUiLCJub3JtYWxpemUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZGF5IiwiZ2V0RGF5IiwiY3JlYXRlUmFuZ2UiLCJmcm9tIiwidG8iLCJjcmVhdGVEYXRlIiwid2l0aGluUmFuZ2UiLCJkYXRlVW5pdCIsIm92ZXJsYXBSYW5nZXMiLCJ0d28iLCJyZWwiLCJzZXREYXRlIiwibmF2aWdhdGUiLCJ0YXJnZXREYXRlT2JqZWN0IiwidGFyZ2V0WWVhciIsInRhcmdldE1vbnRoIiwiaXNUYXJnZXRBcnJheSIsImlzVGFyZ2V0T2JqZWN0Iiwidmlld3NldE9iamVjdCIsInNldEhvdXJzIiwibWVhc3VyZSIsInBhcnNlIiwidmlld3NldCIsImRhdGVPYmplY3QiLCJ2YWxpZGF0ZSIsIm9yaWdpbmFsRGF0ZU9iamVjdCIsImlzRmxpcHBlZEJhc2UiLCJoYXNFbmFibGVkQmVmb3JlVGFyZ2V0IiwiaGFzRW5hYmxlZEFmdGVyVGFyZ2V0IiwibWluTGltaXRPYmplY3QiLCJtYXhMaW1pdE9iamVjdCIsInJlYWNoZWRNaW4iLCJyZWFjaGVkTWF4IiwiaGFzRW5hYmxlZFdlZWtkYXlzIiwiZGF0ZVRpbWUiLCJkYXRlVG9WZXJpZnkiLCJpc0Rpc2FibGVkTWF0Y2giLCJkYXRlVG9EaXNhYmxlIiwiZmlyc3REYXkiLCJpbnZlcnRlZCIsInBhcnNpbmdPYmplY3QiLCJ0b0FycmF5IiwiZm9ybWF0dGluZ0xhYmVsIiwiZm9ybWF0TGVuZ3RoIiwieXl5eSIsInl5IiwibW0iLCJkZCIsImdldFdvcmRMZW5ndGhGcm9tQ29sbGVjdGlvbiIsIndvcmQiLCJnZXRGaXJzdFdvcmRMZW5ndGgiLCJkZGQiLCJ3ZWVrZGF5c1Nob3J0IiwiZGRkZCIsIndlZWtkYXlzRnVsbCIsIm1tbSIsIm1vbnRoc1Nob3J0IiwibW1tbSIsIm1vbnRoc0Z1bGwiLCJpdGVtT2JqZWN0IiwiaXNEYXRlRXhhY3QiLCJpc0RhdGVPdmVybGFwIiwiZmxpcEVuYWJsZSIsImRlYWN0aXZhdGUiLCJkYXRlc1RvRGlzYWJsZSIsImRpc2FibGVkSXRlbXMiLCJ1bml0VG9EaXNhYmxlIiwibWF0Y2hGb3VuZCIsImFjdGl2YXRlIiwiZGF0ZXNUb0VuYWJsZSIsImRpc2FibGVkSXRlbXNDb3VudCIsInVuaXRUb0VuYWJsZSIsImRpc2FibGVkVW5pdCIsImlzRXhhY3RSYW5nZSIsImlzT3BlbiIsIm5vd09iamVjdCIsInNlbGVjdGVkT2JqZWN0IiwiZGlzYWJsZWRDb2xsZWN0aW9uIiwidGFibGVIZWFkIiwiZnVsbENvbGxlY3Rpb24iLCJ3ZWVrZGF5cyIsInNob3dXZWVrZGF5c0Z1bGwiLCJ3ZWVrZGF5c0xldHRlciIsImNyZWF0ZU1vbnRoTmF2Iiwicm9sZSIsImNvbnRyb2xzIiwibGFiZWxNb250aE5leHQiLCJsYWJlbE1vbnRoUHJldiIsImNyZWF0ZU1vbnRoTGFiZWwiLCJvdmVycmlkZSIsIm1vbnRoc0NvbGxlY3Rpb24iLCJzaG93TW9udGhzU2hvcnQiLCJzZWxlY3RNb250aHMiLCJsb29wZWRNb250aCIsImxhYmVsTW9udGhTZWxlY3QiLCJjcmVhdGVZZWFyTGFiZWwiLCJmb2N1c2VkWWVhciIsIm51bWJlclllYXJzIiwic2VsZWN0WWVhcnMiLCJtaW5ZZWFyIiwibWF4WWVhciIsImxvd2VzdFllYXIiLCJoaWdoZXN0WWVhciIsImF2YWlsYWJsZVllYXJzIiwibmVlZGVkWWVhcnMiLCJsb29wZWRZZWFyIiwibGFiZWxZZWFyU2VsZWN0IiwiY3JlYXRlRGF5TGFiZWwiLCJjcmVhdGVXZWVrZGF5TGFiZWwiLCJkaXNwbGF5X2RheSIsIndlZWtkYXkiLCJtb250aF9kaXNwbGF5IiwiZGF5X2Rpc3BsYXkiLCJ5ZWFyX2Rpc3BsYXkiLCJkYXRlX2Rpc3BsYXkiLCJoZWFkZXIiLCJyb3dDb3VudGVyIiwic2hpZnREYXRlQnkiLCJpc1NlbGVjdGVkIiwiaXNIaWdobGlnaHRlZCIsImlzRGlzYWJsZWQiLCJmb3JtYXR0ZWREYXRlIiwiaW5mb2N1cyIsIm91dGZvY3VzIiwiYWN0aXZlZGVzY2VuZGFudCIsInRhYmxlIiwiY2FsZW5kYXJfY29udGFpbmVyIiwidG9kYXkiLCJmb290ZXIiLCJuYXZQcmV2IiwibmF2TmV4dCIsImJ1dHRvbkNsZWFyIiwiYnV0dG9uQ2xvc2UiLCJjaGFyYWN0ZXJDb3VudGVyIiwiJGNvdW50ZXJFbGVtZW50IiwiaXRIYXNMZW5ndGhBdHRyaWJ1dGUiLCJ1cGRhdGVDb3VudGVyIiwicmVtb3ZlQ291bnRlckVsZW1lbnQiLCJhZGRDb3VudGVyRWxlbWVudCIsIm1heExlbmd0aCIsImFjdHVhbExlbmd0aCIsImlzVmFsaWRMZW5ndGgiLCJhZGRJbnB1dFN0eWxlIiwiaW5wdXRIYXNJbnZhbGlkQ2xhc3MiLCJkaXN0IiwiaW1hZ2VzIiwiaXRlbV93aWR0aCIsIml0ZW1faGVpZ2h0IiwiZGltIiwicmVmZXJlbmNlIiwicmVmZXJlbmNlWSIsImFtcGxpdHVkZSIsInNjcm9sbGluZyIsInhmb3JtIiwidGltZXN0YW1wIiwidGlja2VyIiwiZHJhZ2dlZCIsInZlcnRpY2FsX2RyYWdnZWQiLCJzY3JvbGxpbmdUaW1lb3V0Iiwic2hvd0luZGljYXRvcnMiLCJzZXRDYXJvdXNlbEhlaWdodCIsImZpcnN0SW1hZ2UiLCJpbWFnZUhlaWdodCIsImN5Y2xlVG8iLCJzZXR1cEV2ZW50cyIsIm9udG91Y2hzdGFydCIsInRhcCIsInJlbGVhc2UiLCJ4cG9zIiwidGFyZ2V0VG91Y2hlcyIsInlwb3MiLCJoYWxmIiwiZGVsdGEiLCJkaXIiLCJ0d2VlbiIsInhUcmFuc2xhdGlvbiIsImxhc3RDZW50ZXIiLCJhY3RpdmVJbmRpY2F0b3IiLCJ6SW5kZXgiLCJ0d2VlbmVkT3BhY2l0eSIsInpUcmFuc2xhdGlvbiIsIiRjdXJyX2l0ZW0iLCJ0cmFjayIsImVsYXBzZWQiLCJhdXRvU2Nyb2xsIiwiY2xpY2tlZEluZGV4IiwiZXZlcnkiLCJzY3JlZW4iLCJ0YXBUYXJnZXRFbCIsInRhcFRhcmdldFdyYXBwZXIiLCJ0YXBUYXJnZXRXYXZlIiwidGFwVGFyZ2V0T3JpZ2luRWwiLCJ0YXBUYXJnZXRDb250ZW50RWwiLCJjbG9uZSIsIm9wZW5UYXBUYXJnZXQiLCJjbG9zZVRhcFRhcmdldCIsInRocm90dGxlZENhbGMiLCJjYWxjdWxhdGVUYXBUYXJnZXQiLCJvcmlnaW5Ub3AiLCJvcmlnaW5MZWZ0IiwiY2VudGVyWCIsImNlbnRlclkiLCJpc0xlZnQiLCJpc1JpZ2h0IiwiaXNUb3AiLCJpc0JvdHRvbSIsImlzQ2VudGVyWCIsImlzQ2VudGVyWSIsInRhcFRhcmdldFdpZHRoIiwidGFwVGFyZ2V0SGVpZ2h0IiwidGFwVGFyZ2V0VG9wIiwidGFwVGFyZ2V0TGVmdCIsInRhcFRhcmdldFBvc2l0aW9uIiwidGFwVGFyZ2V0VGV4dFdpZHRoIiwidGFwVGFyZ2V0VGV4dEhlaWdodCIsInRhcFRhcmdldFRleHRUb3AiLCJ0YXBUYXJnZXRUZXh0Qm90dG9tIiwidGFwVGFyZ2V0VGV4dExlZnQiLCJ0YXBUYXJnZXRUZXh0UmlnaHQiLCJ0YXBUYXJnZXRUZXh0UGFkZGluZyIsInRhcFRhcmdldFRleHRBbGlnbiIsInRhcFRhcmdldFdhdmVXaWR0aCIsInRhcFRhcmdldFdhdmVIZWlnaHQiLCJ0YXBUYXJnZXRXYXZlVG9wIiwidGFwVGFyZ2V0V2F2ZUxlZnQiLCJ0YXBUYXJnZXRXcmFwcGVyQ3NzT2JqIiwidmVydGljYWxBbGlnbiIsInRhcFRhcmdldCIsIkRhdGFUYWJsZSIsInJvb3QiLCJzU2VsZWN0b3IiLCJvT3B0cyIsImFwaSIsInJvd3MiLCJ0cmFkaXRpb25hbCIsIl9BcGkiLCJfZm5TZXR0aW5nc0Zyb21Ob2RlIiwiX2V4dCIsImlBcGlJbmRleCIsImZuQWRkRGF0YSIsInJlZHJhdyIsInJvdyIsImRyYXciLCJmbGF0dGVuIiwiZm5BZGp1c3RDb2x1bW5TaXppbmciLCJiUmVkcmF3IiwiY29sdW1ucyIsImFkanVzdCIsIm9TY3JvbGwiLCJzWCIsInNZIiwiX2ZuU2Nyb2xsRHJhdyIsImZuQ2xlYXJUYWJsZSIsImZuQ2xvc2UiLCJuVHIiLCJjaGlsZCIsImZuRGVsZXRlUm93IiwiYW9EYXRhIiwiZm5EZXN0cm95IiwiZm5EcmF3IiwiZm5GaWx0ZXIiLCJzSW5wdXQiLCJpQ29sdW1uIiwiYlJlZ2V4IiwiYlNtYXJ0IiwiYlNob3dHbG9iYWwiLCJiQ2FzZUluc2Vuc2l0aXZlIiwic2VhcmNoIiwiY29sdW1uIiwiZm5HZXREYXRhIiwic3JjIiwiY29sIiwiY2VsbCIsImZuR2V0Tm9kZXMiLCJpUm93IiwiZm5HZXRQb3NpdGlvbiIsImNvbHVtblZpc2libGUiLCJmbklzT3BlbiIsImlzU2hvd24iLCJmbk9wZW4iLCJtSHRtbCIsInNDbGFzcyIsImZuUGFnZUNoYW5nZSIsIm1BY3Rpb24iLCJwYWdlIiwiZm5TZXRDb2x1bW5WaXMiLCJpQ29sIiwiYlNob3ciLCJmblNldHRpbmdzIiwiZm5Tb3J0IiwiYWFTb3J0Iiwib3JkZXIiLCJmblNvcnRMaXN0ZW5lciIsIm5Ob2RlIiwiZm5DYWxsYmFjayIsImxpc3RlbmVyIiwiZm5VcGRhdGUiLCJtRGF0YSIsIm1Sb3ciLCJiQWN0aW9uIiwiZm5WZXJzaW9uQ2hlY2siLCJfdGhhdCIsImVtcHR5SW5pdCIsIm9BcGkiLCJleHQiLCJfZm5FeHRlcm5BcGlGdW5jIiwib0luaXQiLCJfZm5FeHRlbmQiLCJpTGVuIiwiakxlbiIsImtMZW4iLCJzSWQiLCJiSW5pdEhhbmRlZE9mZiIsIl9mbkxvZyIsIl9mbkNvbXBhdE9wdHMiLCJfZm5Db21wYXRDb2xzIiwiX2ZuQ2FtZWxUb0h1bmdhcmlhbiIsImFsbFNldHRpbmdzIiwiblRhYmxlIiwiblRIZWFkIiwiblRGb290IiwiYlJldHJpZXZlIiwiYkRlc3Ryb3kiLCJvSW5zdGFuY2UiLCJzVGFibGVJZCIsIl91bmlxdWUiLCJvU2V0dGluZ3MiLCJtb2RlbHMiLCJkYXRhVGFibGUiLCJvTGFuZ3VhZ2UiLCJfZm5MYW5ndWFnZUNvbXBhdCIsImFMZW5ndGhNZW51IiwiaURpc3BsYXlMZW5ndGgiLCJfZm5NYXAiLCJvRmVhdHVyZXMiLCJfZm5DYWxsYmFja1JlZyIsImZuRHJhd0NhbGxiYWNrIiwiZm5TZXJ2ZXJQYXJhbXMiLCJmblN0YXRlU2F2ZVBhcmFtcyIsImZuU3RhdGVMb2FkUGFyYW1zIiwiZm5TdGF0ZUxvYWRlZCIsImZuUm93Q2FsbGJhY2siLCJmbkNyZWF0ZWRSb3ciLCJmbkhlYWRlckNhbGxiYWNrIiwiZm5Gb290ZXJDYWxsYmFjayIsImZuSW5pdENvbXBsZXRlIiwiZm5QcmVEcmF3Q2FsbGJhY2siLCJyb3dJZEZuIiwiX2ZuR2V0T2JqZWN0RGF0YUZuIiwicm93SWQiLCJfZm5Ccm93c2VyRGV0ZWN0Iiwib0NsYXNzZXMiLCJiSlF1ZXJ5VUkiLCJvSlVJQ2xhc3NlcyIsInNEb20iLCJyZW5kZXJlciIsInNUYWJsZSIsImlJbml0RGlzcGxheVN0YXJ0IiwiaURpc3BsYXlTdGFydCIsIl9pRGlzcGxheVN0YXJ0IiwiaURlZmVyTG9hZGluZyIsImJEZWZlckxvYWRpbmciLCJ0bXAiLCJfaVJlY29yZHNEaXNwbGF5IiwiX2lSZWNvcmRzVG90YWwiLCJzVXJsIiwiYWpheCIsImRhdGFUeXBlIiwidXJsIiwic3VjY2VzcyIsImpzb24iLCJfZm5Jbml0aWFsaXNlIiwiYXNTdHJpcGVDbGFzc2VzIiwic1N0cmlwZU9kZCIsInNTdHJpcGVFdmVuIiwic3RyaXBlQ2xhc3NlcyIsInJvd09uZSIsImluQXJyYXkiLCJhc0Rlc3Ryb3lTdHJpcGVzIiwiYW5UaHMiLCJhb0NvbHVtbnNJbml0IiwiblRoZWFkIiwiX2ZuRGV0ZWN0SGVhZGVyIiwiYW9IZWFkZXIiLCJfZm5HZXRVbmlxdWVUaHMiLCJhb0NvbHVtbnMiLCJfZm5BZGRDb2x1bW4iLCJfZm5BcHBseUNvbHVtbkRlZnMiLCJhb0NvbHVtbkRlZnMiLCJvRGVmIiwiX2ZuQ29sdW1uT3B0aW9ucyIsImZlYXR1cmVzIiwibG9hZGVkSW5pdCIsImFhU29ydGluZyIsInNvcnRpbmciLCJhc1NvcnRpbmciLCJfZm5Tb3J0aW5nQ2xhc3NlcyIsImJTb3J0IiwiYlNvcnRlZCIsImFTb3J0IiwiX2ZuU29ydEZsYXR0ZW4iLCJzb3J0ZWRDb2x1bW5zIiwiX2ZuQ2FsbGJhY2tGaXJlIiwiX2ZuU29ydEFyaWEiLCJfZm5EYXRhU291cmNlIiwiYkRlZmVyUmVuZGVyIiwiY2FwdGlvbnMiLCJfY2FwdGlvblNpZGUiLCJ0aGVhZCIsInRib2R5IiwiblRCb2R5IiwidGZvb3QiLCJzTm9Gb290ZXIiLCJhb0Zvb3RlciIsImFhRGF0YSIsIl9mbkFkZERhdGEiLCJfZm5BZGRUciIsImFpRGlzcGxheSIsImFpRGlzcGxheU1hc3RlciIsImJJbml0aWFsaXNlZCIsImJTdGF0ZVNhdmUiLCJfZm5TYXZlU3RhdGUiLCJfZm5Mb2FkU3RhdGUiLCJfYXBpX3JlZ2lzdGVyIiwiX2FwaV9yZWdpc3RlclBsdXJhbCIsIl9yZV9kaWMiLCJfcmVfbmV3X2xpbmVzIiwiX3JlX2h0bWwiLCJfcmVfZGF0ZSIsIl9yZV9lc2NhcGVfcmVnZXgiLCJfcmVfZm9ybWF0dGVkX251bWVyaWMiLCJfZW1wdHkiLCJfaW50VmFsIiwiaW50ZWdlciIsIl9udW1Ub0RlY2ltYWwiLCJudW0iLCJkZWNpbWFsUG9pbnQiLCJfZm5Fc2NhcGVSZWdleCIsIl9pc051bWJlciIsImZvcm1hdHRlZCIsInN0clR5cGUiLCJfaXNIdG1sIiwiX2h0bWxOdW1lcmljIiwiX3N0cmlwSHRtbCIsIl9wbHVjayIsInByb3AyIiwib3V0IiwiaWVuIiwiX3BsdWNrX29yZGVyIiwiX3JhbmdlIiwiZW5kIiwiX3JlbW92ZUVtcHR5IiwiX2FyZUFsbFVuaXF1ZSIsInNvcnRlZCIsImFnYWluIiwidXRpbCIsImZyZXEiLCJmcmVxdWVuY3kiLCJ0aW1lciIsInRoYXQiLCJlc2NhcGVSZWdleCIsIl9mbkh1bmdhcmlhbk1hcCIsImh1bmdhcmlhbiIsIm5ld0tleSIsIl9odW5nYXJpYW5NYXAiLCJ1c2VyIiwiZm9yY2UiLCJodW5nYXJpYW5LZXkiLCJjaGFyQXQiLCJsYW5nIiwiemVyb1JlY29yZHMiLCJzWmVyb1JlY29yZHMiLCJzRW1wdHlUYWJsZSIsInNMb2FkaW5nUmVjb3JkcyIsInNJbmZvVGhvdXNhbmRzIiwic1Rob3VzYW5kcyIsImRlY2ltYWwiLCJzRGVjaW1hbCIsIl9hZGROdW1lcmljU29ydCIsIl9mbkNvbXBhdE1hcCIsImtuZXciLCJvbGQiLCJzU2Nyb2xsWCIsInNjcm9sbFgiLCJzZWFyY2hDb2xzIiwiYW9TZWFyY2hDb2xzIiwib1NlYXJjaCIsImRhdGFTb3J0IiwiYURhdGFTb3J0IiwiX19icm93c2VyIiwiYnJvd3NlciIsIm91dGVyIiwiaW5uZXIiLCJiYXJXaWR0aCIsImJTY3JvbGxPdmVyc2l6ZSIsImJTY3JvbGxiYXJMZWZ0IiwiYkJvdW5kaW5nIiwib0Jyb3dzZXIiLCJpQmFyV2lkdGgiLCJfZm5SZWR1Y2UiLCJpbmMiLCJpc1NldCIsIm5UaCIsIm9EZWZhdWx0cyIsIm9Db2wiLCJvQ29sdW1uIiwic1RpdGxlIiwiaWR4IiwiYW9QcmVTZWFyY2hDb2xzIiwib09wdGlvbnMiLCJ0aCIsInNXaWR0aE9yaWciLCJtRGF0YVByb3AiLCJzVHlwZSIsIl9zTWFudWFsVHlwZSIsImlEYXRhU29ydCIsIm1EYXRhU3JjIiwibVJlbmRlciIsIl9iQXR0clNyYyIsIl9zZXR0ZXIiLCJyb3dEYXRhIiwibWV0YSIsImlubmVyRGF0YSIsImZuU2V0RGF0YSIsIl9mblNldE9iamVjdERhdGFGbiIsIl9yb3dSZWFkT2JqZWN0IiwiYlNvcnRhYmxlIiwic1NvcnRhYmxlTm9uZSIsImJBc2MiLCJiRGVzYyIsInNTb3J0aW5nQ2xhc3MiLCJzU29ydGluZ0NsYXNzSlVJIiwic1NvcnRhYmxlQXNjIiwic1NvcnRKVUlBc2NBbGxvd2VkIiwic1NvcnRhYmxlRGVzYyIsInNTb3J0SlVJRGVzY0FsbG93ZWQiLCJzU29ydGFibGUiLCJzU29ydEpVSSIsIl9mbkFkanVzdENvbHVtblNpemluZyIsImJBdXRvV2lkdGgiLCJfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMiLCJzV2lkdGgiLCJfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCIsImlNYXRjaCIsImFpVmlzIiwiX2ZuR2V0Q29sdW1ucyIsIl9mbkNvbHVtbkluZGV4VG9WaXNpYmxlIiwiaVBvcyIsIl9mblZpc2JsZUNvbHVtbnMiLCJ2aXMiLCJiVmlzaWJsZSIsInNQYXJhbSIsIl9mbkNvbHVtblR5cGVzIiwidHlwZXMiLCJkZXRlY3QiLCJqZW4iLCJrZW4iLCJkZXRlY3RlZFR5cGUiLCJjYWNoZSIsIl9mbkdldENlbGxEYXRhIiwiYW9Db2xEZWZzIiwiYW9Db2xzIiwiYVRhcmdldHMiLCJ0YXJnZXRzIiwiYURhdGFJbiIsImFuVGRzIiwib0RhdGEiLCJvUm93IiwiX2FEYXRhIiwiblRkIiwic1RoaXNUeXBlIiwiYUlkcyIsIl9mbkNyZWF0ZVRyIiwidHJzIiwiX2ZuR2V0Um93RWxlbWVudHMiLCJjZWxscyIsIl9mbk5vZGVUb0RhdGFJbmRleCIsIl9EVF9Sb3dJbmRleCIsIl9mbk5vZGVUb0NvbHVtbkluZGV4IiwiYW5DZWxscyIsInJvd0lkeCIsImNvbElkeCIsImlEcmF3IiwiZGVmYXVsdENvbnRlbnQiLCJzRGVmYXVsdENvbnRlbnQiLCJjZWxsRGF0YSIsImlEcmF3RXJyb3IiLCJfZm5TZXRDZWxsRGF0YSIsIl9fcmVBcnJheSIsIl9fcmVGbiIsIl9mblNwbGl0T2JqTm90YXRpb24iLCJzdHIiLCJtU291cmNlIiwiZmV0Y2hEYXRhIiwiYXJyYXlOb3RhdGlvbiIsImZ1bmNOb3RhdGlvbiIsImlubmVyU3JjIiwic2V0RGF0YSIsImFMYXN0IiwiX2ZuR2V0RGF0YU1hc3RlciIsIl9mbkNsZWFyVGFibGUiLCJfZm5EZWxldGVJbmRleCIsImlUYXJnZXQiLCJpVGFyZ2V0SW5kZXgiLCJfZm5JbnZhbGlkYXRlIiwiY2VsbFdyaXRlIiwiY2hpbGROb2RlcyIsImZpcnN0Q2hpbGQiLCJfYVNvcnREYXRhIiwiX2FGaWx0ZXJEYXRhIiwiY29scyIsIl9mblJvd0F0dHJpYnV0ZXMiLCJ0ZHMiLCJ0ZCIsImNvbnRlbnRzIiwib2JqZWN0UmVhZCIsInNldHRlciIsImNlbGxQcm9jZXNzIiwibmV4dFNpYmxpbmciLCJyb3dOb2RlIiwiblRySW4iLCJzQ2VsbFR5cGUiLCJfRFRfQ2VsbEluZGV4IiwiZm5DcmVhdGVkQ2VsbCIsInRyIiwiRFRfUm93Q2xhc3MiLCJfX3Jvd2MiLCJEVF9Sb3dBdHRyIiwiRFRfUm93RGF0YSIsIl9mbkJ1aWxkSGVhZCIsImNyZWF0ZUhlYWRlciIsImlUYWJJbmRleCIsIl9mblNvcnRBdHRhY2hMaXN0ZW5lciIsIl9mblJlbmRlcmVyIiwic0hlYWRlclRIIiwic0Zvb3RlclRIIiwiblRmIiwiX2ZuRHJhd0hlYWQiLCJhb1NvdXJjZSIsImJJbmNsdWRlSGlkZGVuIiwibkxvY2FsVHIiLCJhb0xvY2FsIiwiYUFwcGxpZWQiLCJpQ29sdW1ucyIsImlSb3dzcGFuIiwiaUNvbHNwYW4iLCJfZm5EcmF3IiwiYVByZURyYXciLCJfZm5Qcm9jZXNzaW5nRGlzcGxheSIsImFuUm93cyIsImlSb3dDb3VudCIsImlTdHJpcGVzIiwiaU9wZW5Sb3dzIiwiYW9PcGVuUm93cyIsIm9MYW5nIiwiYlNlcnZlclNpZGUiLCJiRHJhd2luZyIsImZuUmVjb3Jkc0Rpc3BsYXkiLCJpRGlzcGxheUVuZCIsImZuRGlzcGxheUVuZCIsImJEZXN0cm95aW5nIiwiX2ZuQWpheFVwZGF0ZSIsImlTdGFydCIsImlFbmQiLCJpRGF0YUluZGV4IiwiblJvdyIsInNTdHJpcGUiLCJfc1Jvd1N0cmlwZSIsInNaZXJvIiwiZm5SZWNvcmRzVG90YWwiLCJzUm93RW1wdHkiLCJkZXRhY2giLCJiRmlsdGVyZWQiLCJfZm5SZURyYXciLCJob2xkUG9zaXRpb24iLCJiRmlsdGVyIiwiX2ZuU29ydCIsIl9mbkZpbHRlckNvbXBsZXRlIiwib1ByZXZpb3VzU2VhcmNoIiwiX2RyYXdIb2xkIiwiX2ZuQWRkT3B0aW9uc0h0bWwiLCJob2xkaW5nIiwiaW5zZXJ0Iiwic1dyYXBwZXIiLCJuSG9sZGluZyIsIm5UYWJsZVdyYXBwZXIiLCJuVGFibGVSZWluc2VydEJlZm9yZSIsImFEb20iLCJmZWF0dXJlTm9kZSIsImNPcHRpb24iLCJuTmV3Tm9kZSIsImNOZXh0Iiwic0F0dHIiLCJzSlVJSGVhZGVyIiwic0pVSUZvb3RlciIsImFTcGxpdCIsImJQYWdpbmF0ZSIsImJMZW5ndGhDaGFuZ2UiLCJfZm5GZWF0dXJlSHRtbExlbmd0aCIsIl9mbkZlYXR1cmVIdG1sRmlsdGVyIiwiYlByb2Nlc3NpbmciLCJfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmciLCJfZm5GZWF0dXJlSHRtbFRhYmxlIiwiYkluZm8iLCJfZm5GZWF0dXJlSHRtbEluZm8iLCJfZm5GZWF0dXJlSHRtbFBhZ2luYXRlIiwiZmVhdHVyZSIsImFvRmVhdHVyZXMiLCJjRmVhdHVyZSIsImZuSW5pdCIsImFhbkZlYXR1cmVzIiwicmVwbGFjZVdpdGgiLCJhTGF5b3V0IiwiblRycyIsIm5DZWxsIiwiaUNvbFNoaWZ0ZWQiLCJiVW5pcXVlIiwiZm5TaGlmdENvbCIsIm5IZWFkZXIiLCJhUmV0dXJuIiwidW5pcXVlIiwiYlNvcnRDZWxsc1RvcCIsIl9mbkJ1aWxkQWpheCIsInJicmFja2V0IiwiYWpheERhdGEiLCJpbnN0YW5jZSIsImpxWEhSIiwiYmFzZUFqYXgiLCJzRXJyb3IiLCJzU2VydmVyTWV0aG9kIiwieGhyIiwidGhyb3duIiwicmV0IiwicmVhZHlTdGF0ZSIsIm9BamF4RGF0YSIsImZuU2VydmVyRGF0YSIsInNBamF4U291cmNlIiwiYkFqYXhEYXRhR2V0IiwiX2ZuQWpheFBhcmFtZXRlcnMiLCJfZm5BamF4VXBkYXRlRHJhdyIsImNvbHVtbkNvdW50IiwicHJlU2VhcmNoIiwicHJlQ29sU2VhcmNoIiwiZGF0YVByb3AiLCJjb2x1bW5TZWFyY2giLCJkaXNwbGF5U3RhcnQiLCJfaURpc3BsYXlMZW5ndGgiLCJwYXJhbSIsInNTZWFyY2giLCJyZWdleCIsInNOYW1lIiwic2VhcmNoYWJsZSIsImJTZWFyY2hhYmxlIiwib3JkZXJhYmxlIiwibGVnYWN5IiwiY29tcGF0IiwibW9kZXJuIiwiX2ZuQWpheERhdGFTcmMiLCJyZWNvcmRzVG90YWwiLCJyZWNvcmRzRmlsdGVyZWQiLCJfYkluaXRDb21wbGV0ZSIsIl9mbkluaXRDb21wbGV0ZSIsImRhdGFTcmMiLCJzQWpheERhdGFQcm9wIiwidGFibGVJZCIsImxhbmd1YWdlIiwicHJldmlvdXNTZWFyY2giLCJzRmlsdGVySW5wdXQiLCJzRmlsdGVyIiwic2VhcmNoRm4iLCJzZWFyY2hEZWxheSIsImpxRmlsdGVyIiwic1NlYXJjaFBsYWNlaG9sZGVyIiwiX2ZuVGhyb3R0bGUiLCJldiIsIm9JbnB1dCIsImlGb3JjZSIsIm9QcmV2U2VhcmNoIiwiYW9QcmV2U2VhcmNoIiwiZm5TYXZlRmlsdGVyIiwib0ZpbHRlciIsImZuUmVnZXgiLCJiRXNjYXBlUmVnZXgiLCJfZm5GaWx0ZXIiLCJfZm5GaWx0ZXJDb2x1bW4iLCJfZm5GaWx0ZXJDdXN0b20iLCJmaWx0ZXJzIiwiZGlzcGxheVJvd3MiLCJzZWFyY2hTdHIiLCJzbWFydCIsImNhc2VJbnNlbnNpdGl2ZSIsInJwU2VhcmNoIiwiX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoIiwicHJldlNlYXJjaCIsImRpc3BsYXlNYXN0ZXIiLCJpbnZhbGlkYXRlZCIsImZpbHRlcmVkIiwiX2ZuRmlsdGVyRGF0YSIsIl9zRmlsdGVyUm93IiwiX19maWx0ZXJfZGl2IiwiX19maWx0ZXJfZGl2X3RleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJmaWx0ZXJEYXRhIiwiZm9tYXR0ZXJzIiwid2FzSW52YWxpZGF0ZWQiLCJpbm5lclRleHQiLCJfZm5TZWFyY2hUb0NhbWVsIiwiX2ZuU2VhcmNoVG9IdW5nIiwidGlkIiwic0luZm8iLCJhb0RyYXdDYWxsYmFjayIsIl9mblVwZGF0ZUluZm8iLCJ0b3RhbCIsInNJbmZvRW1wdHkiLCJzSW5mb0ZpbHRlcmVkIiwic0luZm9Qb3N0Rml4IiwiX2ZuSW5mb01hY3JvcyIsImZuSW5mb0NhbGxiYWNrIiwiZm9ybWF0dGVyIiwiZm5Gb3JtYXROdW1iZXIiLCJhbGwiLCJpQWpheFN0YXJ0IiwiZGVmZXJMb2FkaW5nIiwiX2ZuU3RyaW5nVG9Dc3MiLCJhRGF0YSIsIl9mbkxlbmd0aENoYW5nZSIsIl9mbkxlbmd0aE92ZXJmbG93IiwiZDIiLCJsZW5ndGhzIiwic0xlbmd0aFNlbGVjdCIsIk9wdGlvbiIsImRpdiIsInNMZW5ndGgiLCJzTGVuZ3RoTWVudSIsIm91dGVySFRNTCIsInNQYWdpbmF0aW9uVHlwZSIsInBsdWdpbiIsInBhZ2VyIiwic1BhZ2luZyIsInZpc1JlY29yZHMiLCJwYWdlcyIsImJ1dHRvbnMiLCJfZm5QYWdlQ2hhbmdlIiwicmVjb3JkcyIsImNoYW5nZWQiLCJzUHJvY2Vzc2luZyIsInNjcm9sbFkiLCJjYXB0aW9uU2lkZSIsImhlYWRlckNsb25lIiwiY2xvbmVOb2RlIiwiZm9vdGVyQ2xvbmUiLCJfZGl2Iiwic2l6ZSIsInNjcm9sbGVyIiwic1Njcm9sbFdyYXBwZXIiLCJzU2Nyb2xsSGVhZCIsImJvcmRlciIsInNTY3JvbGxIZWFkSW5uZXIiLCJzWElubmVyIiwic1Njcm9sbEJvZHkiLCJzU2Nyb2xsRm9vdCIsInNTY3JvbGxGb290SW5uZXIiLCJzY3JvbGxIZWFkIiwic2Nyb2xsQm9keSIsInNjcm9sbEZvb3QiLCJiQ29sbGFwc2UiLCJuU2Nyb2xsSGVhZCIsIm5TY3JvbGxCb2R5IiwiblNjcm9sbEZvb3QiLCJzY3JvbGxYSW5uZXIiLCJkaXZIZWFkZXIiLCJkaXZIZWFkZXJTdHlsZSIsImRpdkhlYWRlcklubmVyIiwiZGl2SGVhZGVySW5uZXJTdHlsZSIsImRpdkhlYWRlclRhYmxlIiwiZGl2Qm9keUVsIiwiZGl2Qm9keSIsImRpdkJvZHlTdHlsZSIsImRpdkZvb3RlciIsImRpdkZvb3RlcklubmVyIiwiZGl2Rm9vdGVyVGFibGUiLCJ0YWJsZUVsIiwidGFibGVTdHlsZSIsImllNjciLCJkdEhlYWRlckNlbGxzIiwiaGVhZGVyVHJnRWxzIiwiZm9vdGVyVHJnRWxzIiwiaGVhZGVyU3JjRWxzIiwiZm9vdGVyU3JjRWxzIiwiaGVhZGVyQ29weSIsImZvb3RlckNvcHkiLCJoZWFkZXJXaWR0aHMiLCJmb290ZXJXaWR0aHMiLCJoZWFkZXJDb250ZW50IiwiZm9vdGVyQ29udGVudCIsImNvcnJlY3Rpb24iLCJzYW5pdHlXaWR0aCIsInplcm9PdXQiLCJuU2l6ZXIiLCJib3JkZXJCb3R0b21XaWR0aCIsInNjcm9sbEJhclZpcyIsInByZXBlbmRUbyIsIl9mbkFwcGx5VG9DaGlsZHJlbiIsIm5Ub1NpemUiLCJpT3V0ZXJXaWR0aCIsImJTY3JvbGxpbmciLCJhbjEiLCJhbjIiLCJuTm9kZTEiLCJuTm9kZTIiLCJfX3JlX2h0bWxfcmVtb3ZlIiwidmlzaWJsZUNvbHVtbnMiLCJoZWFkZXJDZWxscyIsInRhYmxlV2lkdGhBdHRyIiwidGFibGVDb250YWluZXIiLCJ1c2VySW5wdXRzIiwiY29sdW1uSWR4Iiwic3R5bGVXaWR0aCIsIl9mbkNvbnZlcnRUb1dpZHRoIiwidG1wVGFibGUiLCJfZm5HZXRXaWRlc3ROb2RlIiwic0NvbnRlbnRQYWRkaW5nIiwiYm91bmRpbmciLCJfcmVzekV2dCIsImJpbmRSZXNpemUiLCJzSW5zdGFuY2UiLCJfZm5HZXRNYXhMZW5TdHJpbmciLCJtYXhJZHgiLCJhaU9yaWciLCJzcmNDb2wiLCJmaXhlZCIsImFhU29ydGluZ0ZpeGVkIiwiZml4ZWRPYmoiLCJuZXN0ZWRTb3J0IiwicHJlIiwicG9zdCIsIl9pZHgiLCJzRGF0YVR5cGUiLCJvRXh0U29ydCIsIm9Tb3J0IiwiZm9ybWF0dGVycyIsInNvcnRDb2wiLCJfZm5Tb3J0RGF0YSIsImRhdGFBIiwiZGF0YUIiLCJuZXh0U29ydCIsIm9BcmlhIiwic1NvcnRBc2NlbmRpbmciLCJzU29ydERlc2NlbmRpbmciLCJfZm5Tb3J0TGlzdGVuZXIiLCJuZXh0U29ydElkeCIsImJTb3J0TXVsdGkiLCJzb3J0SWR4IiwiYXR0YWNoVG8iLCJfZm5CaW5kQWN0aW9uIiwic2hpZnRLZXkiLCJvbGRTb3J0IiwiYUxhc3RTb3J0Iiwic29ydENsYXNzIiwic1NvcnRDb2x1bW4iLCJiU29ydENsYXNzZXMiLCJjdXN0b21Tb3J0Iiwic1NvcnREYXRhVHlwZSIsImN1c3RvbURhdGEiLCJvU2F2ZWRTdGF0ZSIsImZuU3RhdGVTYXZlQ2FsbGJhY2siLCJsb2FkZWQiLCJhYlN0YXRlTG9hZCIsImlTdGF0ZUR1cmF0aW9uIiwib0xvYWRlZFN0YXRlIiwiZm5TdGF0ZUxvYWRDYWxsYmFjayIsImxldmVsIiwibXNnIiwidG4iLCJzRXJyTW9kZSIsImVyck1vZGUiLCJhbGVydCIsIm1hcHBlZE5hbWUiLCJleHRlbmRlciIsImJyZWFrUmVmcyIsInNTdG9yZSIsImNhbGxiYWNrQXJyIiwiZXZlbnROYW1lIiwiRXZlbnQiLCJob3N0IiwiX19hcGlTdHJ1Y3QiLCJfX2FycmF5UHJvdG8iLCJfdG9TZXR0aW5ncyIsIm1peGVkIiwianEiLCJ0YWJsZXMiLCJjdHhTZXR0aW5ncyIsIkFwaSIsImFueSIsImN0eCIsIml0ZXJhdG9yIiwiYWx3YXlzTmV3IiwiaXRlbXMiLCJhcGlJbnN0IiwiX3NlbGVjdG9yX3Jvd19pbmRleGVzIiwiYXBpU2VsZWN0b3IiLCJsYXN0SW5kZXhPZiIsInBsdWNrIiwicmVkdWNlIiwicmVkdWNlUmlnaHQiLCJ0byQiLCJ0b0pRdWVyeSIsIl9fZHRfd3JhcHBlciIsInN0cnVjdCIsIm1ldGhvZFNjb3BpbmciLCJzdHJ1YyIsIm1ldGhvZEV4dCIsInByb3BFeHQiLCJoZWlyIiwicmVnaXN0ZXJQbHVyYWwiLCJwbHVyYWxOYW1lIiwic2luZ3VsYXJOYW1lIiwiX190YWJsZV9zZWxlY3RvciIsInBhZ2luZyIsImluZm8iLCJfX3JlbG9hZCIsImFib3J0IiwicmVzZXRQYWdpbmciLCJfc2VsZWN0b3JfcnVuIiwic2VsZWN0Rm4iLCJyZXMiLCJzZWxlY3RvclR5cGUiLCJfc2VsZWN0b3Jfb3B0cyIsIl9zZWxlY3Rvcl9maXJzdCIsImluc3QiLCJkaXNwbGF5RmlsdGVyZWQiLCJfX3Jvd19zZWxlY3RvciIsInJ1biIsInNlbCIsInNlbEludCIsInJvd09iaiIsInRoYXRJZHgiLCJsb29wUm93IiwibG9vcENlbGxzIiwibmV3Um93cyIsIm1vZFJvd3MiLCJfX2RldGFpbHNfYWRkIiwiYWRkUm93IiwiY3JlYXRlZCIsImNvbFNwYW4iLCJfZGV0YWlscyIsIl9kZXRhaWxzU2hvdyIsImluc2VydEFmdGVyIiwiX19kZXRhaWxzX3JlbW92ZSIsIl9fZGV0YWlsc19kaXNwbGF5IiwiX19kZXRhaWxzX2V2ZW50cyIsImRyYXdFdmVudCIsImNvbHZpc0V2ZW50IiwiZGVzdHJveUV2ZW50IiwiX2VtcCIsIl9jaGlsZF9vYmoiLCJfY2hpbGRfbXRoIiwiX19yZV9jb2x1bW5fc2VsZWN0b3IiLCJfX2NvbHVtbkRhdGEiLCJyMSIsInIyIiwiX19jb2x1bW5fc2VsZWN0b3IiLCJ2aXNDb2x1bW5zIiwianFSZXN1bHQiLCJfX3NldENvbHVtblZpcyIsImNhbGMiLCJfX2NlbGxfc2VsZWN0b3IiLCJhbGxDZWxscyIsImZuU2VsZWN0b3IiLCJyb3dTZWxlY3RvciIsImNvbHVtblNlbGVjdG9yIiwiY2FzZUluc2VuIiwidmVyc2lvbkNoZWNrIiwiYVRoaXMiLCJhVGhhdCIsImlUaGlzIiwiaVRoYXQiLCJpc0RhdGFUYWJsZSIsImZuSXNEYXRhVGFibGUiLCJoZWFkIiwiZm9vdCIsImZuVGFibGVzIiwiY2FtZWxUb0h1bmdhcmlhbiIsImpxUm93cyIsIm9yaWciLCJqcVRhYmxlIiwianFUYm9keSIsImpxV3JhcHBlciIsImJKVUkiLCJzU29ydEljb24iLCJzU29ydEpVSVdyYXBwZXIiLCJyZW1vdmVkTWV0aG9kIiwic0Rlc3Ryb3lXaWR0aCIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFyZzQiLCJ0b2tlbiIsInBsdXJhbCIsInJlc29sdmVkIiwidG9Gb3JtYXQiLCJzZXNzaW9uU3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXRobmFtZSIsInNldEl0ZW0iLCJwYWdpbmF0ZSIsImJ1aWxkZXIiLCJwYWdlQnV0dG9uIiwic1ZlcnNpb24iLCJhZm5GaWx0ZXJpbmciLCJhVHlwZXMiLCJvZm5TZWFyY2giLCJhZm5Tb3J0RGF0YSIsIm9TdGRDbGFzc2VzIiwib1BhZ2luYXRpb24iLCJfc3RhdGVEZWZhdWx0IiwiX3NvcnRJY29uIiwiX2hlYWRlckZvb3RlciIsImV4dFBhZ2luYXRpb24iLCJfbnVtYmVycyIsIm51bWJlcnMiLCJudW1iZXJzX2xlbmd0aCIsIkRUX2VsIiwic2ltcGxlIiwiZnVsbCIsInNpbXBsZV9udW1iZXJzIiwiZnVsbF9udW1iZXJzIiwiZmlyc3RfbGFzdF9udW1iZXJzIiwib1BhZ2luYXRlIiwiYnRuRGlzcGxheSIsImJ0bkNsYXNzIiwiY2xpY2tIYW5kbGVyIiwic0ZpcnN0Iiwic1BhZ2VCdXR0b25EaXNhYmxlZCIsInNQcmV2aW91cyIsInNOZXh0Iiwic0xhc3QiLCJzUGFnZUJ1dHRvbkFjdGl2ZSIsInNQYWdlQnV0dG9uIiwiYWN0aXZlRWwiLCJwYXJzZWQiLCJfX251bWVyaWNSZXBsYWNlIiwiZGVjaW1hbFBsYWNlIiwicmUxIiwicmUyIiwic1NvcnRBc2MiLCJzU29ydERlc2MiLCJqcXVlcnl1aSIsInNTb3J0SlVJQXNjIiwic1NvcnRKVUlEZXNjIiwiX19odG1sRXNjYXBlRW50aXRpZXMiLCJ0aG91c2FuZHMiLCJwcmVjaXNpb24iLCJwb3N0Zml4IiwibmVnYXRpdmUiLCJmbG8iLCJ0b0ZpeGVkIiwiaW50UGFydCIsImZsb2F0UGFydCIsIl9mbkNhbGN1bGF0ZUVuZCIsImRhdGFUYWJsZVNldHRpbmdzIiwiZGF0YVRhYmxlRXh0Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDZCQUE2QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FB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QUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQiwwQkFBMEIsd0JBQXdCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw4QkFBOEI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCLGNBQWM7QUFDcEMsZ0JBQWdCLFdBQVcsWUFBWTtBQUN2QyxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsVUFBVSxTQUFTLE1BQU0sYUFBYTtBQUMzRSxhQUFhLGVBQWU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFF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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUEsV0FBVztBQUNYLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkIsNERBQTRELGVBQWU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxzREFBc0Q7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxjQUFjLG1DQUFtQztBQUNqRCxlQUFlLDZEQUE2RDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFBQTtBQUNGOzs7OztBQUtBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxDQUFDOzs7Ozs7Ozs7QUM1Z1VEOzs7OztBQUtBO0FBQ0EsSUFBSSxPQUFPQSxNQUFQLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ2xDLE1BQUlBLE1BQUo7QUFDQTtBQUNBLE1BQUksSUFBSixFQUFvQztBQUNsQ0EsYUFBU0MsSUFBSSxtQkFBQUMsQ0FBUSxDQUFSLENBQWI7QUFDRjtBQUNDLEdBSEQsTUFHTztBQUNMRixhQUFTQyxDQUFUO0FBQ0Q7QUFDRjtBQUNELEMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDRDtBQUNBRCxPQUFPRyxNQUFQLENBQWMsUUFBZCxJQUEwQkgsT0FBT0csTUFBUCxDQUFjLE9BQWQsQ0FBMUI7O0FBRUFILE9BQU9JLE1BQVAsQ0FBZUosT0FBT0csTUFBdEIsRUFDQTtBQUNDRSxPQUFLLGFBRE47QUFFQ0MsU0FBTyxlQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDL0I7QUFDQSxXQUFPWCxPQUFPRyxNQUFQLENBQWNILE9BQU9HLE1BQVAsQ0FBY0UsR0FBNUIsRUFBaUNFLENBQWpDLEVBQW9DQyxDQUFwQyxFQUF1Q0MsQ0FBdkMsRUFBMENDLENBQTFDLEVBQTZDQyxDQUE3QyxDQUFQO0FBQ0EsR0FMRjtBQU1DQyxjQUFZLG9CQUFVTCxDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDcEMsV0FBT0QsS0FBR0YsS0FBR0csQ0FBTixJQUFTSCxDQUFULEdBQWFDLENBQXBCO0FBQ0EsR0FSRjtBQVNDSSxlQUFhLHFCQUFVTixDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDckMsV0FBTyxDQUFDRCxDQUFELElBQUtGLEtBQUdHLENBQVIsS0FBWUgsSUFBRSxDQUFkLElBQW1CQyxDQUExQjtBQUNBLEdBWEY7QUFZQ0ssaUJBQWUsdUJBQVVQLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN2QyxRQUFJLENBQUNILEtBQUdHLElBQUUsQ0FBTixJQUFXLENBQWYsRUFBa0IsT0FBT0QsSUFBRSxDQUFGLEdBQUlGLENBQUosR0FBTUEsQ0FBTixHQUFVQyxDQUFqQjtBQUNsQixXQUFPLENBQUNDLENBQUQsR0FBRyxDQUFILElBQVMsRUFBRUYsQ0FBSCxJQUFPQSxJQUFFLENBQVQsSUFBYyxDQUF0QixJQUEyQkMsQ0FBbEM7QUFDQSxHQWZGO0FBZ0JDTSxlQUFhLHFCQUFVUixDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDckMsV0FBT0QsS0FBR0YsS0FBR0csQ0FBTixJQUFTSCxDQUFULEdBQVdBLENBQVgsR0FBZUMsQ0FBdEI7QUFDQSxHQWxCRjtBQW1CQ08sZ0JBQWMsc0JBQVVULENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN0QyxXQUFPRCxLQUFHLENBQUNGLElBQUVBLElBQUVHLENBQUYsR0FBSSxDQUFQLElBQVVILENBQVYsR0FBWUEsQ0FBWixHQUFnQixDQUFuQixJQUF3QkMsQ0FBL0I7QUFDQSxHQXJCRjtBQXNCQ1Esa0JBQWdCLHdCQUFVVixDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDeEMsUUFBSSxDQUFDSCxLQUFHRyxJQUFFLENBQU4sSUFBVyxDQUFmLEVBQWtCLE9BQU9ELElBQUUsQ0FBRixHQUFJRixDQUFKLEdBQU1BLENBQU4sR0FBUUEsQ0FBUixHQUFZQyxDQUFuQjtBQUNsQixXQUFPQyxJQUFFLENBQUYsSUFBSyxDQUFDRixLQUFHLENBQUosSUFBT0EsQ0FBUCxHQUFTQSxDQUFULEdBQWEsQ0FBbEIsSUFBdUJDLENBQTlCO0FBQ0EsR0F6QkY7QUEwQkNTLGVBQWEscUJBQVVYLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUNyQyxXQUFPRCxLQUFHRixLQUFHRyxDQUFOLElBQVNILENBQVQsR0FBV0EsQ0FBWCxHQUFhQSxDQUFiLEdBQWlCQyxDQUF4QjtBQUNBLEdBNUJGO0FBNkJDVSxnQkFBYyxzQkFBVVosQ0FBVixFQUFhQyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQkMsQ0FBbkIsRUFBc0JDLENBQXRCLEVBQXlCO0FBQ3RDLFdBQU8sQ0FBQ0QsQ0FBRCxJQUFNLENBQUNGLElBQUVBLElBQUVHLENBQUYsR0FBSSxDQUFQLElBQVVILENBQVYsR0FBWUEsQ0FBWixHQUFjQSxDQUFkLEdBQWtCLENBQXhCLElBQTZCQyxDQUFwQztBQUNBLEdBL0JGO0FBZ0NDVyxrQkFBZ0Isd0JBQVViLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN4QyxRQUFJLENBQUNILEtBQUdHLElBQUUsQ0FBTixJQUFXLENBQWYsRUFBa0IsT0FBT0QsSUFBRSxDQUFGLEdBQUlGLENBQUosR0FBTUEsQ0FBTixHQUFRQSxDQUFSLEdBQVVBLENBQVYsR0FBY0MsQ0FBckI7QUFDbEIsV0FBTyxDQUFDQyxDQUFELEdBQUcsQ0FBSCxJQUFRLENBQUNGLEtBQUcsQ0FBSixJQUFPQSxDQUFQLEdBQVNBLENBQVQsR0FBV0EsQ0FBWCxHQUFlLENBQXZCLElBQTRCQyxDQUFuQztBQUNBLEdBbkNGO0FBb0NDWSxlQUFhLHFCQUFVZCxDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDckMsV0FBT0QsS0FBR0YsS0FBR0csQ0FBTixJQUFTSCxDQUFULEdBQVdBLENBQVgsR0FBYUEsQ0FBYixHQUFlQSxDQUFmLEdBQW1CQyxDQUExQjtBQUNBLEdBdENGO0FBdUNDYSxnQkFBYyxzQkFBVWYsQ0FBVixFQUFhQyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQkMsQ0FBbkIsRUFBc0JDLENBQXRCLEVBQXlCO0FBQ3RDLFdBQU9ELEtBQUcsQ0FBQ0YsSUFBRUEsSUFBRUcsQ0FBRixHQUFJLENBQVAsSUFBVUgsQ0FBVixHQUFZQSxDQUFaLEdBQWNBLENBQWQsR0FBZ0JBLENBQWhCLEdBQW9CLENBQXZCLElBQTRCQyxDQUFuQztBQUNBLEdBekNGO0FBMENDYyxrQkFBZ0Isd0JBQVVoQixDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDeEMsUUFBSSxDQUFDSCxLQUFHRyxJQUFFLENBQU4sSUFBVyxDQUFmLEVBQWtCLE9BQU9ELElBQUUsQ0FBRixHQUFJRixDQUFKLEdBQU1BLENBQU4sR0FBUUEsQ0FBUixHQUFVQSxDQUFWLEdBQVlBLENBQVosR0FBZ0JDLENBQXZCO0FBQ2xCLFdBQU9DLElBQUUsQ0FBRixJQUFLLENBQUNGLEtBQUcsQ0FBSixJQUFPQSxDQUFQLEdBQVNBLENBQVQsR0FBV0EsQ0FBWCxHQUFhQSxDQUFiLEdBQWlCLENBQXRCLElBQTJCQyxDQUFsQztBQUNBLEdBN0NGO0FBOENDZSxjQUFZLG9CQUFVakIsQ0FBVixFQUFhQyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQkMsQ0FBbkIsRUFBc0JDLENBQXRCLEVBQXlCO0FBQ3BDLFdBQU8sQ0FBQ0QsQ0FBRCxHQUFLZSxLQUFLQyxHQUFMLENBQVNsQixJQUFFRyxDQUFGLElBQU9jLEtBQUtFLEVBQUwsR0FBUSxDQUFmLENBQVQsQ0FBTCxHQUFtQ2pCLENBQW5DLEdBQXVDRCxDQUE5QztBQUNBLEdBaERGO0FBaURDbUIsZUFBYSxxQkFBVXJCLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUNyQyxXQUFPRCxJQUFJZSxLQUFLSSxHQUFMLENBQVNyQixJQUFFRyxDQUFGLElBQU9jLEtBQUtFLEVBQUwsR0FBUSxDQUFmLENBQVQsQ0FBSixHQUFrQ2xCLENBQXpDO0FBQ0EsR0FuREY7QUFvRENxQixpQkFBZSx1QkFBVXZCLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN2QyxXQUFPLENBQUNELENBQUQsR0FBRyxDQUFILElBQVFlLEtBQUtDLEdBQUwsQ0FBU0QsS0FBS0UsRUFBTCxHQUFRbkIsQ0FBUixHQUFVRyxDQUFuQixJQUF3QixDQUFoQyxJQUFxQ0YsQ0FBNUM7QUFDQSxHQXRERjtBQXVEQ3NCLGNBQVksb0JBQVV4QixDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDcEMsV0FBUUgsS0FBRyxDQUFKLEdBQVNDLENBQVQsR0FBYUMsSUFBSWUsS0FBS08sR0FBTCxDQUFTLENBQVQsRUFBWSxNQUFNeEIsSUFBRUcsQ0FBRixHQUFNLENBQVosQ0FBWixDQUFKLEdBQWtDRixDQUF0RDtBQUNBLEdBekRGO0FBMERDd0IsZUFBYSxxQkFBVTFCLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUNyQyxXQUFRSCxLQUFHRyxDQUFKLEdBQVNGLElBQUVDLENBQVgsR0FBZUEsS0FBSyxDQUFDZSxLQUFLTyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBRCxHQUFNeEIsQ0FBTixHQUFRRyxDQUFwQixDQUFELEdBQTBCLENBQS9CLElBQW9DRixDQUExRDtBQUNBLEdBNURGO0FBNkRDeUIsaUJBQWUsdUJBQVUzQixDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDdkMsUUFBSUgsS0FBRyxDQUFQLEVBQVUsT0FBT0MsQ0FBUDtBQUNWLFFBQUlELEtBQUdHLENBQVAsRUFBVSxPQUFPRixJQUFFQyxDQUFUO0FBQ1YsUUFBSSxDQUFDRixLQUFHRyxJQUFFLENBQU4sSUFBVyxDQUFmLEVBQWtCLE9BQU9ELElBQUUsQ0FBRixHQUFNZSxLQUFLTyxHQUFMLENBQVMsQ0FBVCxFQUFZLE1BQU14QixJQUFJLENBQVYsQ0FBWixDQUFOLEdBQWtDQyxDQUF6QztBQUNsQixXQUFPQyxJQUFFLENBQUYsSUFBTyxDQUFDZSxLQUFLTyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBRCxHQUFNLEVBQUV4QixDQUFwQixDQUFELEdBQTBCLENBQWpDLElBQXNDQyxDQUE3QztBQUNBLEdBbEVGO0FBbUVDMEIsY0FBWSxvQkFBVTVCLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUNwQyxXQUFPLENBQUNELENBQUQsSUFBTWUsS0FBS1csSUFBTCxDQUFVLElBQUksQ0FBQzVCLEtBQUdHLENBQUosSUFBT0gsQ0FBckIsSUFBMEIsQ0FBaEMsSUFBcUNDLENBQTVDO0FBQ0EsR0FyRUY7QUFzRUM0QixlQUFhLHFCQUFVOUIsQ0FBVixFQUFhQyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQkMsQ0FBbkIsRUFBc0JDLENBQXRCLEVBQXlCO0FBQ3JDLFdBQU9ELElBQUllLEtBQUtXLElBQUwsQ0FBVSxJQUFJLENBQUM1QixJQUFFQSxJQUFFRyxDQUFGLEdBQUksQ0FBUCxJQUFVSCxDQUF4QixDQUFKLEdBQWlDQyxDQUF4QztBQUNBLEdBeEVGO0FBeUVDNkIsaUJBQWUsdUJBQVUvQixDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDdkMsUUFBSSxDQUFDSCxLQUFHRyxJQUFFLENBQU4sSUFBVyxDQUFmLEVBQWtCLE9BQU8sQ0FBQ0QsQ0FBRCxHQUFHLENBQUgsSUFBUWUsS0FBS1csSUFBTCxDQUFVLElBQUk1QixJQUFFQSxDQUFoQixJQUFxQixDQUE3QixJQUFrQ0MsQ0FBekM7QUFDbEIsV0FBT0MsSUFBRSxDQUFGLElBQU9lLEtBQUtXLElBQUwsQ0FBVSxJQUFJLENBQUM1QixLQUFHLENBQUosSUFBT0EsQ0FBckIsSUFBMEIsQ0FBakMsSUFBc0NDLENBQTdDO0FBQ0EsR0E1RUY7QUE2RUM4QixpQkFBZSx1QkFBVWhDLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN2QyxRQUFJNkIsSUFBRSxPQUFOLENBQWMsSUFBSUMsSUFBRSxDQUFOLENBQVEsSUFBSUMsSUFBRWhDLENBQU47QUFDdEIsUUFBSUYsS0FBRyxDQUFQLEVBQVUsT0FBT0MsQ0FBUCxDQUFXLElBQUksQ0FBQ0QsS0FBR0csQ0FBSixLQUFRLENBQVosRUFBZSxPQUFPRixJQUFFQyxDQUFULENBQWEsSUFBSSxDQUFDK0IsQ0FBTCxFQUFRQSxJQUFFOUIsSUFBRSxFQUFKO0FBQ3pELFFBQUkrQixJQUFJakIsS0FBS2tCLEdBQUwsQ0FBU2pDLENBQVQsQ0FBUixFQUFxQjtBQUFFZ0MsVUFBRWhDLENBQUYsQ0FBSyxJQUFJOEIsSUFBRUMsSUFBRSxDQUFSO0FBQVksS0FBeEMsTUFDSyxJQUFJRCxJQUFJQyxLQUFHLElBQUVoQixLQUFLRSxFQUFWLElBQWdCRixLQUFLbUIsSUFBTCxDQUFXbEMsSUFBRWdDLENBQWIsQ0FBeEI7QUFDTCxXQUFPLEVBQUVBLElBQUVqQixLQUFLTyxHQUFMLENBQVMsQ0FBVCxFQUFXLE1BQUl4QixLQUFHLENBQVAsQ0FBWCxDQUFGLEdBQTBCaUIsS0FBS0ksR0FBTCxDQUFVLENBQUNyQixJQUFFRyxDQUFGLEdBQUk2QixDQUFMLEtBQVMsSUFBRWYsS0FBS0UsRUFBaEIsSUFBb0JjLENBQTlCLENBQTVCLElBQWlFaEMsQ0FBeEU7QUFDQSxHQW5GRjtBQW9GQ29DLGtCQUFnQix3QkFBVXRDLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN4QyxRQUFJNkIsSUFBRSxPQUFOLENBQWMsSUFBSUMsSUFBRSxDQUFOLENBQVEsSUFBSUMsSUFBRWhDLENBQU47QUFDdEIsUUFBSUYsS0FBRyxDQUFQLEVBQVUsT0FBT0MsQ0FBUCxDQUFXLElBQUksQ0FBQ0QsS0FBR0csQ0FBSixLQUFRLENBQVosRUFBZSxPQUFPRixJQUFFQyxDQUFULENBQWEsSUFBSSxDQUFDK0IsQ0FBTCxFQUFRQSxJQUFFOUIsSUFBRSxFQUFKO0FBQ3pELFFBQUkrQixJQUFJakIsS0FBS2tCLEdBQUwsQ0FBU2pDLENBQVQsQ0FBUixFQUFxQjtBQUFFZ0MsVUFBRWhDLENBQUYsQ0FBSyxJQUFJOEIsSUFBRUMsSUFBRSxDQUFSO0FBQVksS0FBeEMsTUFDSyxJQUFJRCxJQUFJQyxLQUFHLElBQUVoQixLQUFLRSxFQUFWLElBQWdCRixLQUFLbUIsSUFBTCxDQUFXbEMsSUFBRWdDLENBQWIsQ0FBeEI7QUFDTCxXQUFPQSxJQUFFakIsS0FBS08sR0FBTCxDQUFTLENBQVQsRUFBVyxDQUFDLEVBQUQsR0FBSXhCLENBQWYsQ0FBRixHQUFzQmlCLEtBQUtJLEdBQUwsQ0FBVSxDQUFDckIsSUFBRUcsQ0FBRixHQUFJNkIsQ0FBTCxLQUFTLElBQUVmLEtBQUtFLEVBQWhCLElBQW9CYyxDQUE5QixDQUF0QixHQUEwRC9CLENBQTFELEdBQThERCxDQUFyRTtBQUNBLEdBMUZGO0FBMkZDcUMsb0JBQWtCLDBCQUFVdkMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQkMsQ0FBbkIsRUFBc0JDLENBQXRCLEVBQXlCO0FBQzFDLFFBQUk2QixJQUFFLE9BQU4sQ0FBYyxJQUFJQyxJQUFFLENBQU4sQ0FBUSxJQUFJQyxJQUFFaEMsQ0FBTjtBQUN0QixRQUFJRixLQUFHLENBQVAsRUFBVSxPQUFPQyxDQUFQLENBQVcsSUFBSSxDQUFDRCxLQUFHRyxJQUFFLENBQU4sS0FBVSxDQUFkLEVBQWlCLE9BQU9GLElBQUVDLENBQVQsQ0FBYSxJQUFJLENBQUMrQixDQUFMLEVBQVFBLElBQUU5QixLQUFHLEtBQUcsR0FBTixDQUFGO0FBQzNELFFBQUkrQixJQUFJakIsS0FBS2tCLEdBQUwsQ0FBU2pDLENBQVQsQ0FBUixFQUFxQjtBQUFFZ0MsVUFBRWhDLENBQUYsQ0FBSyxJQUFJOEIsSUFBRUMsSUFBRSxDQUFSO0FBQVksS0FBeEMsTUFDSyxJQUFJRCxJQUFJQyxLQUFHLElBQUVoQixLQUFLRSxFQUFWLElBQWdCRixLQUFLbUIsSUFBTCxDQUFXbEMsSUFBRWdDLENBQWIsQ0FBeEI7QUFDTCxRQUFJbEMsSUFBSSxDQUFSLEVBQVcsT0FBTyxDQUFDLEVBQUQsSUFBS2tDLElBQUVqQixLQUFLTyxHQUFMLENBQVMsQ0FBVCxFQUFXLE1BQUl4QixLQUFHLENBQVAsQ0FBWCxDQUFGLEdBQTBCaUIsS0FBS0ksR0FBTCxDQUFVLENBQUNyQixJQUFFRyxDQUFGLEdBQUk2QixDQUFMLEtBQVMsSUFBRWYsS0FBS0UsRUFBaEIsSUFBb0JjLENBQTlCLENBQS9CLElBQW9FaEMsQ0FBM0U7QUFDWCxXQUFPaUMsSUFBRWpCLEtBQUtPLEdBQUwsQ0FBUyxDQUFULEVBQVcsQ0FBQyxFQUFELElBQUt4QixLQUFHLENBQVIsQ0FBWCxDQUFGLEdBQTJCaUIsS0FBS0ksR0FBTCxDQUFVLENBQUNyQixJQUFFRyxDQUFGLEdBQUk2QixDQUFMLEtBQVMsSUFBRWYsS0FBS0UsRUFBaEIsSUFBb0JjLENBQTlCLENBQTNCLEdBQTZELEVBQTdELEdBQWtFL0IsQ0FBbEUsR0FBc0VELENBQTdFO0FBQ0EsR0FsR0Y7QUFtR0NzQyxjQUFZLG9CQUFVeEMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQkMsQ0FBbkIsRUFBc0JDLENBQXRCLEVBQXlCNkIsQ0FBekIsRUFBNEI7QUFDdkMsUUFBSUEsS0FBS1EsU0FBVCxFQUFvQlIsSUFBSSxPQUFKO0FBQ3BCLFdBQU85QixLQUFHRixLQUFHRyxDQUFOLElBQVNILENBQVQsSUFBWSxDQUFDZ0MsSUFBRSxDQUFILElBQU1oQyxDQUFOLEdBQVVnQyxDQUF0QixJQUEyQi9CLENBQWxDO0FBQ0EsR0F0R0Y7QUF1R0N3QyxlQUFhLHFCQUFVMUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQkMsQ0FBbkIsRUFBc0JDLENBQXRCLEVBQXlCNkIsQ0FBekIsRUFBNEI7QUFDeEMsUUFBSUEsS0FBS1EsU0FBVCxFQUFvQlIsSUFBSSxPQUFKO0FBQ3BCLFdBQU85QixLQUFHLENBQUNGLElBQUVBLElBQUVHLENBQUYsR0FBSSxDQUFQLElBQVVILENBQVYsSUFBYSxDQUFDZ0MsSUFBRSxDQUFILElBQU1oQyxDQUFOLEdBQVVnQyxDQUF2QixJQUE0QixDQUEvQixJQUFvQy9CLENBQTNDO0FBQ0EsR0ExR0Y7QUEyR0N5QyxpQkFBZSx1QkFBVTNDLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjZCLENBQXpCLEVBQTRCO0FBQzFDLFFBQUlBLEtBQUtRLFNBQVQsRUFBb0JSLElBQUksT0FBSjtBQUNwQixRQUFJLENBQUNoQyxLQUFHRyxJQUFFLENBQU4sSUFBVyxDQUFmLEVBQWtCLE9BQU9ELElBQUUsQ0FBRixJQUFLRixJQUFFQSxDQUFGLElBQUssQ0FBQyxDQUFDZ0MsS0FBSSxLQUFMLElBQWEsQ0FBZCxJQUFpQmhDLENBQWpCLEdBQXFCZ0MsQ0FBMUIsQ0FBTCxJQUFxQy9CLENBQTVDO0FBQ2xCLFdBQU9DLElBQUUsQ0FBRixJQUFLLENBQUNGLEtBQUcsQ0FBSixJQUFPQSxDQUFQLElBQVUsQ0FBQyxDQUFDZ0MsS0FBSSxLQUFMLElBQWEsQ0FBZCxJQUFpQmhDLENBQWpCLEdBQXFCZ0MsQ0FBL0IsSUFBb0MsQ0FBekMsSUFBOEMvQixDQUFyRDtBQUNBLEdBL0dGO0FBZ0hDMEMsZ0JBQWMsc0JBQVU1QyxDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUI7QUFDdEMsV0FBT0QsSUFBSVYsT0FBT0csTUFBUCxDQUFjaUQsYUFBZCxDQUE2QjdDLENBQTdCLEVBQWdDSSxJQUFFSCxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3Q0UsQ0FBeEMsRUFBMkNDLENBQTNDLENBQUosR0FBb0RGLENBQTNEO0FBQ0EsR0FsSEY7QUFtSEMyQyxpQkFBZSx1QkFBVTdDLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN2QyxRQUFJLENBQUNILEtBQUdHLENBQUosSUFBVSxJQUFFLElBQWhCLEVBQXVCO0FBQ3RCLGFBQU9ELEtBQUcsU0FBT0YsQ0FBUCxHQUFTQSxDQUFaLElBQWlCQyxDQUF4QjtBQUNBLEtBRkQsTUFFTyxJQUFJRCxJQUFLLElBQUUsSUFBWCxFQUFrQjtBQUN4QixhQUFPRSxLQUFHLFVBQVFGLEtBQUksTUFBSSxJQUFoQixJQUF1QkEsQ0FBdkIsR0FBMkIsR0FBOUIsSUFBcUNDLENBQTVDO0FBQ0EsS0FGTSxNQUVBLElBQUlELElBQUssTUFBSSxJQUFiLEVBQW9CO0FBQzFCLGFBQU9FLEtBQUcsVUFBUUYsS0FBSSxPQUFLLElBQWpCLElBQXdCQSxDQUF4QixHQUE0QixLQUEvQixJQUF3Q0MsQ0FBL0M7QUFDQSxLQUZNLE1BRUE7QUFDTixhQUFPQyxLQUFHLFVBQVFGLEtBQUksUUFBTSxJQUFsQixJQUF5QkEsQ0FBekIsR0FBNkIsT0FBaEMsSUFBMkNDLENBQWxEO0FBQ0E7QUFDRCxHQTdIRjtBQThIQzRDLG1CQUFpQix5QkFBVTlDLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN6QyxRQUFJSCxJQUFJRyxJQUFFLENBQVYsRUFBYSxPQUFPWCxPQUFPRyxNQUFQLENBQWNnRCxZQUFkLENBQTRCNUMsQ0FBNUIsRUFBK0JDLElBQUUsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUNFLENBQXZDLEVBQTBDQyxDQUExQyxJQUErQyxFQUEvQyxHQUFvREYsQ0FBM0Q7QUFDYixXQUFPVCxPQUFPRyxNQUFQLENBQWNpRCxhQUFkLENBQTZCN0MsQ0FBN0IsRUFBZ0NDLElBQUUsQ0FBRixHQUFJRyxDQUFwQyxFQUF1QyxDQUF2QyxFQUEwQ0QsQ0FBMUMsRUFBNkNDLENBQTdDLElBQWtELEVBQWxELEdBQXVERCxJQUFFLEVBQXpELEdBQThERCxDQUFyRTtBQUNBO0FBaklGLENBREE7O0FBcUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBK0JHLEMsQ0FBQztBQUNKVCxPQUFPSSxNQUFQLENBQWVKLE9BQU9HLE1BQXRCLEVBQ0E7QUFDRW1ELHFCQUFtQiwyQkFBVS9DLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUMxQyxRQUFJLENBQUNILEtBQUdHLElBQUUsQ0FBTixJQUFXLENBQWYsRUFBa0IsT0FBT0QsSUFBRSxDQUFGLEdBQUlGLENBQUosR0FBTUEsQ0FBTixHQUFVQyxDQUFqQjtBQUNsQixXQUFPQyxJQUFFLENBQUYsSUFBSyxDQUFDRixLQUFHLENBQUosSUFBT0EsQ0FBUCxHQUFTQSxDQUFULEdBQWEsQ0FBbEIsSUFBdUJDLENBQTlCO0FBQ0Q7QUFKSCxDQURBLEVBTUcsQyxDQUFDO0FBQ0o7QUFDQTtBQUNBVCxPQUFPdUQsUUFBUCxHQUFnQkMsUUFBUUMsR0FBUixDQUFZLHNIQUFaLENBQWhCLElBQXFKLENBQUMsVUFBU0MsQ0FBVCxFQUFXO0FBQUMsV0FBU2xELENBQVQsQ0FBV2tELENBQVgsRUFBYTtBQUFDLFFBQUlsRCxJQUFFa0QsRUFBRUMsTUFBUjtBQUFBLFFBQWVqQixJQUFFa0IsRUFBRUMsSUFBRixDQUFPSCxDQUFQLENBQWpCLENBQTJCLE9BQU0sZUFBYWhCLENBQWIsSUFBZ0JrQixFQUFFRSxRQUFGLENBQVdKLENBQVgsQ0FBaEIsR0FBOEIsQ0FBQyxDQUEvQixHQUFpQyxNQUFJQSxFQUFFSyxRQUFOLElBQWdCdkQsQ0FBaEIsR0FBa0IsQ0FBQyxDQUFuQixHQUFxQixZQUFVa0MsQ0FBVixJQUFhLE1BQUlsQyxDQUFqQixJQUFvQixZQUFVLE9BQU9BLENBQWpCLElBQW9CQSxJQUFFLENBQXRCLElBQXlCQSxJQUFFLENBQUYsSUFBT2tELENBQWhIO0FBQWtILE9BQUcsQ0FBQ0EsRUFBRTFELE1BQU4sRUFBYTtBQUFDLFFBQUk0RCxJQUFFLFNBQUZBLENBQUUsQ0FBU0YsQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhO0FBQUMsYUFBTyxJQUFJb0QsRUFBRUksRUFBRixDQUFLQyxJQUFULENBQWNQLENBQWQsRUFBZ0JsRCxDQUFoQixDQUFQO0FBQTBCLEtBQTlDLENBQStDb0QsRUFBRUUsUUFBRixHQUFXLFVBQVNKLENBQVQsRUFBVztBQUFDLGFBQU8sUUFBTUEsQ0FBTixJQUFTQSxLQUFHQSxFQUFFUSxNQUFyQjtBQUE0QixLQUFuRCxFQUFvRE4sRUFBRUMsSUFBRixHQUFPLFVBQVNILENBQVQsRUFBVztBQUFDLGFBQU8sUUFBTUEsQ0FBTixHQUFRQSxJQUFFLEVBQVYsR0FBYSxvQkFBaUJBLENBQWpCLHlDQUFpQkEsQ0FBakIsTUFBb0IsY0FBWSxPQUFPQSxDQUF2QyxHQUF5Q1MsRUFBRUMsRUFBRUMsSUFBRixDQUFPWCxDQUFQLENBQUYsS0FBYyxRQUF2RCxVQUF1RUEsQ0FBdkUseUNBQXVFQSxDQUF2RSxDQUFwQjtBQUE2RixLQUFwSyxFQUFxS0UsRUFBRVUsT0FBRixHQUFVQyxNQUFNRCxPQUFOLElBQWUsVUFBU1osQ0FBVCxFQUFXO0FBQUMsYUFBTSxZQUFVRSxFQUFFQyxJQUFGLENBQU9ILENBQVAsQ0FBaEI7QUFBMEIsS0FBcE8sRUFBcU9FLEVBQUVZLGFBQUYsR0FBZ0IsVUFBU2QsQ0FBVCxFQUFXO0FBQUMsVUFBSWxELENBQUosQ0FBTSxJQUFHLENBQUNrRCxDQUFELElBQUksYUFBV0UsRUFBRUMsSUFBRixDQUFPSCxDQUFQLENBQWYsSUFBMEJBLEVBQUVLLFFBQTVCLElBQXNDSCxFQUFFRSxRQUFGLENBQVdKLENBQVgsQ0FBekMsRUFBdUQsT0FBTSxDQUFDLENBQVAsQ0FBUyxJQUFHO0FBQUMsWUFBR0EsRUFBRWUsV0FBRixJQUFlLENBQUNDLEVBQUVMLElBQUYsQ0FBT1gsQ0FBUCxFQUFTLGFBQVQsQ0FBaEIsSUFBeUMsQ0FBQ2dCLEVBQUVMLElBQUYsQ0FBT1gsRUFBRWUsV0FBRixDQUFjRSxTQUFyQixFQUErQixlQUEvQixDQUE3QyxFQUE2RixPQUFNLENBQUMsQ0FBUDtBQUFTLE9BQTFHLENBQTBHLE9BQU1qQyxDQUFOLEVBQVE7QUFBQyxlQUFNLENBQUMsQ0FBUDtBQUFTLFlBQUlsQyxDQUFKLElBQVNrRCxDQUFULElBQVksT0FBTyxLQUFLLENBQUwsS0FBU2xELENBQVQsSUFBWWtFLEVBQUVMLElBQUYsQ0FBT1gsQ0FBUCxFQUFTbEQsQ0FBVCxDQUFuQjtBQUErQixLQUE5ZSxFQUErZW9ELEVBQUVnQixJQUFGLEdBQU8sVUFBU2xCLENBQVQsRUFBV0UsQ0FBWCxFQUFhbEIsQ0FBYixFQUFlO0FBQUMsVUFBSXlCLENBQUo7QUFBQSxVQUFNTyxJQUFFLENBQVI7QUFBQSxVQUFVTixJQUFFVixFQUFFQyxNQUFkO0FBQUEsVUFBcUJuQixJQUFFaEMsRUFBRWtELENBQUYsQ0FBdkIsQ0FBNEIsSUFBR2hCLENBQUgsRUFBSztBQUFDLFlBQUdGLENBQUgsRUFBSyxPQUFLNEIsSUFBRU0sQ0FBRixLQUFNUCxJQUFFUCxFQUFFaUIsS0FBRixDQUFRbkIsRUFBRWdCLENBQUYsQ0FBUixFQUFhaEMsQ0FBYixDQUFGLEVBQWtCeUIsTUFBSSxDQUFDLENBQTdCLENBQUwsRUFBcUNPLEdBQXJDLElBQUwsTUFBb0QsS0FBSUEsQ0FBSixJQUFTaEIsQ0FBVDtBQUFXLGNBQUdTLElBQUVQLEVBQUVpQixLQUFGLENBQVFuQixFQUFFZ0IsQ0FBRixDQUFSLEVBQWFoQyxDQUFiLENBQUYsRUFBa0J5QixNQUFJLENBQUMsQ0FBMUIsRUFBNEI7QUFBdkM7QUFBNkMsT0FBdkcsTUFBNEcsSUFBRzNCLENBQUgsRUFBSyxPQUFLNEIsSUFBRU0sQ0FBRixLQUFNUCxJQUFFUCxFQUFFUyxJQUFGLENBQU9YLEVBQUVnQixDQUFGLENBQVAsRUFBWUEsQ0FBWixFQUFjaEIsRUFBRWdCLENBQUYsQ0FBZCxDQUFGLEVBQXNCUCxNQUFJLENBQUMsQ0FBakMsQ0FBTCxFQUF5Q08sR0FBekMsSUFBTCxNQUF3RCxLQUFJQSxDQUFKLElBQVNoQixDQUFUO0FBQVcsWUFBR1MsSUFBRVAsRUFBRVMsSUFBRixDQUFPWCxFQUFFZ0IsQ0FBRixDQUFQLEVBQVlBLENBQVosRUFBY2hCLEVBQUVnQixDQUFGLENBQWQsQ0FBRixFQUFzQlAsTUFBSSxDQUFDLENBQTlCLEVBQWdDO0FBQTNDLE9BQWlELE9BQU9ULENBQVA7QUFBUyxLQUFod0IsRUFBaXdCRSxFQUFFa0IsSUFBRixHQUFPLFVBQVNwQixDQUFULEVBQVdsRCxDQUFYLEVBQWEyRCxDQUFiLEVBQWU7QUFBQyxVQUFHLEtBQUssQ0FBTCxLQUFTQSxDQUFaLEVBQWM7QUFBQyxZQUFJTyxJQUFFaEIsRUFBRUUsRUFBRW1CLE9BQUosQ0FBTjtBQUFBLFlBQW1CWCxJQUFFTSxLQUFHaEMsRUFBRWdDLENBQUYsQ0FBeEIsQ0FBNkIsSUFBRyxLQUFLLENBQUwsS0FBU2xFLENBQVosRUFBYyxPQUFPNEQsQ0FBUCxDQUFTLElBQUdBLEtBQUc1RCxLQUFLNEQsQ0FBWCxFQUFhLE9BQU9BLEVBQUU1RCxDQUFGLENBQVA7QUFBWSxPQUE1RixNQUFpRyxJQUFHLEtBQUssQ0FBTCxLQUFTQSxDQUFaLEVBQWM7QUFBQyxZQUFJa0UsSUFBRWhCLEVBQUVFLEVBQUVtQixPQUFKLE1BQWVyQixFQUFFRSxFQUFFbUIsT0FBSixJQUFhLEVBQUVuQixFQUFFb0IsSUFBaEMsQ0FBTixDQUE0QyxPQUFPdEMsRUFBRWdDLENBQUYsSUFBS2hDLEVBQUVnQyxDQUFGLEtBQU0sRUFBWCxFQUFjaEMsRUFBRWdDLENBQUYsRUFBS2xFLENBQUwsSUFBUTJELENBQXRCLEVBQXdCQSxDQUEvQjtBQUFpQztBQUFDLEtBQXQ5QixFQUF1OUJQLEVBQUVxQixVQUFGLEdBQWEsVUFBU3ZCLENBQVQsRUFBV2xELENBQVgsRUFBYTtBQUFDLFVBQUkyRCxJQUFFVCxFQUFFRSxFQUFFbUIsT0FBSixDQUFOO0FBQUEsVUFBbUJMLElBQUVQLEtBQUd6QixFQUFFeUIsQ0FBRixDQUF4QixDQUE2Qk8sS0FBR2QsRUFBRWdCLElBQUYsQ0FBT3BFLENBQVAsRUFBUyxVQUFTa0QsQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhO0FBQUMsZUFBT2tFLEVBQUVsRSxDQUFGLENBQVA7QUFBWSxPQUFuQyxDQUFIO0FBQXdDLEtBQXZqQyxFQUF3akNvRCxFQUFFeEQsTUFBRixHQUFTLFlBQVU7QUFBQyxVQUFJc0QsQ0FBSjtBQUFBLFVBQU1sRCxDQUFOO0FBQUEsVUFBUWtDLENBQVI7QUFBQSxVQUFVeUIsQ0FBVjtBQUFBLFVBQVlPLENBQVo7QUFBQSxVQUFjTixDQUFkO0FBQUEsVUFBZ0I1QixJQUFFMEMsVUFBVSxDQUFWLEtBQWMsRUFBaEM7QUFBQSxVQUFtQ0MsSUFBRSxDQUFyQztBQUFBLFVBQXVDQyxJQUFFRixVQUFVdkIsTUFBbkQ7QUFBQSxVQUEwRGpELElBQUUsQ0FBQyxDQUE3RCxDQUErRCxLQUFJLGFBQVcsT0FBTzhCLENBQWxCLEtBQXNCOUIsSUFBRThCLENBQUYsRUFBSUEsSUFBRTBDLFVBQVVDLENBQVYsS0FBYyxFQUFwQixFQUF1QkEsR0FBN0MsR0FBa0Qsb0JBQWlCM0MsQ0FBakIseUNBQWlCQSxDQUFqQixNQUFvQixlQUFhb0IsRUFBRUMsSUFBRixDQUFPckIsQ0FBUCxDQUFqQyxLQUE2Q0EsSUFBRSxFQUEvQyxDQUFsRCxFQUFxRzJDLE1BQUlDLENBQUosS0FBUTVDLElBQUUsSUFBRixFQUFPMkMsR0FBZixDQUF6RyxFQUE2SEMsSUFBRUQsQ0FBL0gsRUFBaUlBLEdBQWpJO0FBQXFJLFlBQUcsU0FBT1QsSUFBRVEsVUFBVUMsQ0FBVixDQUFULENBQUgsRUFBMEIsS0FBSWhCLENBQUosSUFBU08sQ0FBVDtBQUFXaEIsY0FBRWxCLEVBQUUyQixDQUFGLENBQUYsRUFBT3pCLElBQUVnQyxFQUFFUCxDQUFGLENBQVQsRUFBYzNCLE1BQUlFLENBQUosS0FBUWhDLEtBQUdnQyxDQUFILEtBQU9rQixFQUFFWSxhQUFGLENBQWdCOUIsQ0FBaEIsTUFBcUJsQyxJQUFFb0QsRUFBRVUsT0FBRixDQUFVNUIsQ0FBVixDQUF2QixDQUFQLEtBQThDbEMsS0FBR0EsSUFBRSxDQUFDLENBQUgsRUFBSzRELElBQUVWLEtBQUdFLEVBQUVVLE9BQUYsQ0FBVVosQ0FBVixDQUFILEdBQWdCQSxDQUFoQixHQUFrQixFQUE1QixJQUFnQ1UsSUFBRVYsS0FBR0UsRUFBRVksYUFBRixDQUFnQmQsQ0FBaEIsQ0FBSCxHQUFzQkEsQ0FBdEIsR0FBd0IsRUFBMUQsRUFBNkRsQixFQUFFMkIsQ0FBRixJQUFLUCxFQUFFeEQsTUFBRixDQUFTTSxDQUFULEVBQVcwRCxDQUFYLEVBQWExQixDQUFiLENBQWhILElBQWlJLEtBQUssQ0FBTCxLQUFTQSxDQUFULEtBQWFGLEVBQUUyQixDQUFGLElBQUt6QixDQUFsQixDQUF6SSxDQUFkO0FBQVg7QUFBL0osT0FBdVYsT0FBT0YsQ0FBUDtBQUFTLEtBQTMrQyxFQUE0K0NvQixFQUFFeUIsS0FBRixHQUFRLFVBQVMzQixDQUFULEVBQVdoQixDQUFYLEVBQWF5QixDQUFiLEVBQWU7QUFBQyxlQUFTTyxDQUFULENBQVdoQixDQUFYLEVBQWFFLENBQWIsRUFBZTtBQUFDLFlBQUlsQixJQUFFa0IsS0FBRyxFQUFULENBQVksT0FBTyxRQUFNRixDQUFOLEtBQVVsRCxFQUFFOEUsT0FBTzVCLENBQVAsQ0FBRixJQUFhLENBQUMsVUFBU0EsQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhO0FBQUMsZUFBSSxJQUFJb0QsSUFBRSxDQUFDcEQsRUFBRW1ELE1BQVQsRUFBZ0JqQixJQUFFLENBQWxCLEVBQW9CeUIsSUFBRVQsRUFBRUMsTUFBNUIsRUFBbUNDLElBQUVsQixDQUFyQztBQUF3Q2dCLGNBQUVTLEdBQUYsSUFBTzNELEVBQUVrQyxHQUFGLENBQVA7QUFBeEMsV0FBc0QsSUFBR2tCLE1BQUlBLENBQVAsRUFBUyxPQUFLLEtBQUssQ0FBTCxLQUFTcEQsRUFBRWtDLENBQUYsQ0FBZDtBQUFvQmdCLGNBQUVTLEdBQUYsSUFBTzNELEVBQUVrQyxHQUFGLENBQVA7QUFBcEIsV0FBa0MsT0FBT2dCLEVBQUVDLE1BQUYsR0FBU1EsQ0FBVCxFQUFXVCxDQUFsQjtBQUFvQixTQUFuSSxDQUFvSWhCLENBQXBJLEVBQXNJLFlBQVUsT0FBT2dCLENBQWpCLEdBQW1CLENBQUNBLENBQUQsQ0FBbkIsR0FBdUJBLENBQTdKLENBQWQsR0FBOEssR0FBRzZCLElBQUgsQ0FBUWxCLElBQVIsQ0FBYTNCLENBQWIsRUFBZWdCLENBQWYsQ0FBeEwsR0FBMk1oQixDQUFsTjtBQUFvTixXQUFHZ0IsQ0FBSCxFQUFLO0FBQUNoQixZQUFFLENBQUNBLEtBQUcsSUFBSixJQUFVLE9BQVosQ0FBb0IsSUFBSTBCLElBQUVSLEVBQUVrQixJQUFGLENBQU9wQixDQUFQLEVBQVNoQixDQUFULENBQU4sQ0FBa0IsT0FBT3lCLEtBQUcsQ0FBQ0MsQ0FBRCxJQUFJUixFQUFFVSxPQUFGLENBQVVILENBQVYsQ0FBSixHQUFpQkMsSUFBRVIsRUFBRWtCLElBQUYsQ0FBT3BCLENBQVAsRUFBU2hCLENBQVQsRUFBV2dDLEVBQUVQLENBQUYsQ0FBWCxDQUFuQixHQUFvQ0MsRUFBRW1CLElBQUYsQ0FBT3BCLENBQVAsQ0FBcEMsRUFBOENDLENBQWpELElBQW9EQSxLQUFHLEVBQTlEO0FBQWlFO0FBQUMsS0FBbDJELEVBQW0yRFIsRUFBRTRCLE9BQUYsR0FBVSxVQUFTOUIsQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhO0FBQUNvRCxRQUFFZ0IsSUFBRixDQUFPbEIsRUFBRUssUUFBRixHQUFXLENBQUNMLENBQUQsQ0FBWCxHQUFlQSxDQUF0QixFQUF3QixVQUFTQSxDQUFULEVBQVdoQixDQUFYLEVBQWE7QUFBQ2xDLFlBQUVBLEtBQUcsSUFBTCxDQUFVLElBQUkyRCxJQUFFUCxFQUFFeUIsS0FBRixDQUFRM0MsQ0FBUixFQUFVbEMsQ0FBVixDQUFOO0FBQUEsWUFBbUJrRSxJQUFFUCxFQUFFc0IsS0FBRixFQUFyQixDQUErQixpQkFBZWYsQ0FBZixLQUFtQkEsSUFBRVAsRUFBRXNCLEtBQUYsRUFBckIsR0FBZ0NmLE1BQUksU0FBT2xFLENBQVAsSUFBVTJELEVBQUV1QixPQUFGLENBQVUsWUFBVixDQUFWLEVBQWtDaEIsRUFBRUwsSUFBRixDQUFPM0IsQ0FBUCxFQUFTLFlBQVU7QUFBQ2tCLFlBQUU0QixPQUFGLENBQVU5QyxDQUFWLEVBQVlsQyxDQUFaO0FBQWUsU0FBbkMsQ0FBdEMsQ0FBaEM7QUFBNEcsT0FBM0w7QUFBNkwsS0FBeGpFLEVBQXlqRW9ELEVBQUVJLEVBQUYsR0FBS0osRUFBRWUsU0FBRixHQUFZLEVBQUNWLE1BQUssY0FBU1AsQ0FBVCxFQUFXO0FBQUMsWUFBR0EsRUFBRUssUUFBTCxFQUFjLE9BQU8sS0FBSyxDQUFMLElBQVFMLENBQVIsRUFBVSxJQUFqQixDQUFzQixNQUFNLElBQUlpQyxLQUFKLENBQVUsaUJBQVYsQ0FBTjtBQUFtQyxPQUF6RixFQUEwRkMsUUFBTyxrQkFBVTtBQUFDLFlBQUlwRixJQUFFLEtBQUssQ0FBTCxFQUFRcUYscUJBQVIsR0FBOEIsS0FBSyxDQUFMLEVBQVFBLHFCQUFSLEVBQTlCLEdBQThELEVBQUNDLEtBQUksQ0FBTCxFQUFPQyxNQUFLLENBQVosRUFBcEUsQ0FBbUYsT0FBTSxFQUFDRCxLQUFJdEYsRUFBRXNGLEdBQUYsSUFBT3BDLEVBQUVzQyxXQUFGLElBQWVDLFNBQVNDLFNBQXhCLElBQW1DLENBQTFDLEtBQThDRCxTQUFTRSxTQUFULElBQW9CLENBQWxFLENBQUwsRUFBMEVKLE1BQUt2RixFQUFFdUYsSUFBRixJQUFRckMsRUFBRTBDLFdBQUYsSUFBZUgsU0FBU0ksVUFBeEIsSUFBb0MsQ0FBNUMsS0FBZ0RKLFNBQVNLLFVBQVQsSUFBcUIsQ0FBckUsQ0FBL0UsRUFBTjtBQUE4SixPQUE3VixFQUE4VkMsVUFBUyxvQkFBVTtBQUFDLGlCQUFTN0MsQ0FBVCxHQUFZO0FBQUMsZUFBSSxJQUFJQSxJQUFFLEtBQUs4QyxZQUFMLElBQW1CUCxRQUE3QixFQUFzQ3ZDLEtBQUcsV0FBUyxDQUFDQSxFQUFFSyxRQUFGLENBQVcwQyxXQUF4QixJQUFxQyxhQUFXL0MsRUFBRWdELEtBQUYsQ0FBUUgsUUFBOUY7QUFBd0c3QyxnQkFBRUEsRUFBRThDLFlBQUo7QUFBeEcsV0FBeUgsT0FBTzlDLEtBQUd1QyxRQUFWO0FBQW1CLGFBQUl6RixJQUFFLEtBQUssQ0FBTCxDQUFOO0FBQUEsWUFBY2tELElBQUVBLEVBQUVtQixLQUFGLENBQVFyRSxDQUFSLENBQWhCO0FBQUEsWUFBMkJrQyxJQUFFLEtBQUtrRCxNQUFMLEVBQTdCO0FBQUEsWUFBMkN6QixJQUFFLG1CQUFtQndDLElBQW5CLENBQXdCakQsRUFBRWtELFFBQTFCLElBQW9DLEVBQUNkLEtBQUksQ0FBTCxFQUFPQyxNQUFLLENBQVosRUFBcEMsR0FBbURuQyxFQUFFRixDQUFGLEVBQUtrQyxNQUFMLEVBQWhHLENBQThHLE9BQU9sRCxFQUFFb0QsR0FBRixJQUFPZSxXQUFXckcsRUFBRWtHLEtBQUYsQ0FBUUksU0FBbkIsS0FBK0IsQ0FBdEMsRUFBd0NwRSxFQUFFcUQsSUFBRixJQUFRYyxXQUFXckcsRUFBRWtHLEtBQUYsQ0FBUUssVUFBbkIsS0FBZ0MsQ0FBaEYsRUFBa0ZyRCxFQUFFZ0QsS0FBRixLQUFVdkMsRUFBRTJCLEdBQUYsSUFBT2UsV0FBV25ELEVBQUVnRCxLQUFGLENBQVFNLGNBQW5CLEtBQW9DLENBQTNDLEVBQTZDN0MsRUFBRTRCLElBQUYsSUFBUWMsV0FBV25ELEVBQUVnRCxLQUFGLENBQVFPLGVBQW5CLEtBQXFDLENBQXBHLENBQWxGLEVBQXlMLEVBQUNuQixLQUFJcEQsRUFBRW9ELEdBQUYsR0FBTTNCLEVBQUUyQixHQUFiLEVBQWlCQyxNQUFLckQsRUFBRXFELElBQUYsR0FBTzVCLEVBQUU0QixJQUEvQixFQUFoTTtBQUFxTyxPQUE5MUIsRUFBMWtFLENBQTA2RixJQUFJckQsSUFBRSxFQUFOLENBQVNrQixFQUFFbUIsT0FBRixHQUFVLGFBQVksSUFBSW1DLElBQUosRUFBRCxDQUFXQyxPQUFYLEVBQXJCLEVBQTBDdkQsRUFBRW9CLElBQUYsR0FBTyxDQUFqRCxDQUFtRCxLQUFJLElBQUliLElBQUUsRUFBTixFQUFTTyxJQUFFUCxFQUFFaUQsY0FBYixFQUE0QmhELElBQUVELEVBQUVrRCxRQUFoQyxFQUF5QzdFLElBQUUsZ0VBQWdFOEUsS0FBaEUsQ0FBc0UsR0FBdEUsQ0FBM0MsRUFBc0huQyxJQUFFLENBQTVILEVBQThIQSxJQUFFM0MsRUFBRW1CLE1BQWxJLEVBQXlJd0IsR0FBekk7QUFBNkloQixRQUFFLGFBQVczQixFQUFFMkMsQ0FBRixDQUFYLEdBQWdCLEdBQWxCLElBQXVCM0MsRUFBRTJDLENBQUYsRUFBS3NCLFdBQUwsRUFBdkI7QUFBN0ksS0FBdUw3QyxFQUFFSSxFQUFGLENBQUtDLElBQUwsQ0FBVVUsU0FBVixHQUFvQmYsRUFBRUksRUFBdEIsRUFBeUJOLEVBQUVILFFBQUYsR0FBVyxFQUFDZ0UsV0FBVTNELENBQVgsRUFBcEM7QUFBa0Q7QUFBQyxDQUFwN0csQ0FBcTdHTSxNQUFyN0csQ0FBRCxFQUE4N0csVUFBU1IsQ0FBVCxFQUFXO0FBQUMsOENBQWlCOEQsTUFBakIsTUFBeUIsb0JBQWlCQSxPQUFPQyxPQUF4QixDQUF6QixHQUF5REQsT0FBT0MsT0FBUCxHQUFlL0QsR0FBeEUsR0FBNEUsUUFBc0Msb0NBQU9BLENBQVA7QUFBQTtBQUFBO0FBQUE7QUFBQSxvR0FBdEMsR0FBZ0RBLEdBQTVIO0FBQWdJLENBQTVJLENBQTZJLFlBQVU7QUFBQyxTQUFPLFVBQVNBLENBQVQsRUFBV2xELENBQVgsRUFBYW9ELENBQWIsRUFBZWxCLENBQWYsRUFBaUI7QUFBQyxhQUFTeUIsQ0FBVCxDQUFXVCxDQUFYLEVBQWE7QUFBQyxXQUFJLElBQUlsRCxJQUFFLENBQUMsQ0FBUCxFQUFTb0QsSUFBRUYsSUFBRUEsRUFBRUMsTUFBSixHQUFXLENBQXRCLEVBQXdCakIsSUFBRSxFQUE5QixFQUFpQyxFQUFFbEMsQ0FBRixHQUFJb0QsQ0FBckMsR0FBd0M7QUFBQyxZQUFJTyxJQUFFVCxFQUFFbEQsQ0FBRixDQUFOLENBQVcyRCxLQUFHekIsRUFBRTZDLElBQUYsQ0FBT3BCLENBQVAsQ0FBSDtBQUFhLGNBQU96QixDQUFQO0FBQVMsY0FBU2dDLENBQVQsQ0FBV2hCLENBQVgsRUFBYTtBQUFDLGFBQU9nRSxFQUFFQyxTQUFGLENBQVlqRSxDQUFaLElBQWVBLElBQUUsR0FBR2tFLEtBQUgsQ0FBU3ZELElBQVQsQ0FBY1gsQ0FBZCxDQUFqQixHQUFrQ2dFLEVBQUVHLE1BQUYsQ0FBU25FLENBQVQsTUFBY0EsSUFBRSxDQUFDQSxDQUFELENBQWhCLENBQWxDLEVBQXVEQSxDQUE5RDtBQUFnRSxjQUFTVSxDQUFULENBQVdWLENBQVgsRUFBYTtBQUFDLFVBQUlsRCxJQUFFc0gsRUFBRWhELElBQUYsQ0FBT3BCLENBQVAsRUFBUyxVQUFULENBQU4sQ0FBMkIsT0FBTyxTQUFPbEQsQ0FBUCxHQUFTa0MsQ0FBVCxHQUFXbEMsQ0FBbEI7QUFBb0IsY0FBU2dDLENBQVQsQ0FBV2tCLENBQVgsRUFBYTtBQUFDLGFBQU8sVUFBU2xELENBQVQsRUFBVztBQUFDLGVBQU9pQixLQUFLc0csS0FBTCxDQUFXdkgsSUFBRWtELENBQWIsS0FBaUIsSUFBRUEsQ0FBbkIsQ0FBUDtBQUE2QixPQUFoRDtBQUFpRCxjQUFTeUIsQ0FBVCxDQUFXekIsQ0FBWCxFQUFhRSxDQUFiLEVBQWVsQixDQUFmLEVBQWlCeUIsQ0FBakIsRUFBbUI7QUFBQyxlQUFTTyxDQUFULENBQVdoQixDQUFYLEVBQWFsRCxDQUFiLEVBQWU7QUFBQyxlQUFPLElBQUUsSUFBRUEsQ0FBSixHQUFNLElBQUVrRCxDQUFmO0FBQWlCLGdCQUFTVSxDQUFULENBQVdWLENBQVgsRUFBYWxELENBQWIsRUFBZTtBQUFDLGVBQU8sSUFBRUEsQ0FBRixHQUFJLElBQUVrRCxDQUFiO0FBQWUsZ0JBQVNsQixDQUFULENBQVdrQixDQUFYLEVBQWE7QUFBQyxlQUFPLElBQUVBLENBQVQ7QUFBVyxnQkFBU3lCLENBQVQsQ0FBV3pCLENBQVgsRUFBYWxELENBQWIsRUFBZW9ELENBQWYsRUFBaUI7QUFBQyxlQUFNLENBQUMsQ0FBQ2MsRUFBRWxFLENBQUYsRUFBSW9ELENBQUosSUFBT0YsQ0FBUCxHQUFTVSxFQUFFNUQsQ0FBRixFQUFJb0QsQ0FBSixDQUFWLElBQWtCRixDQUFsQixHQUFvQmxCLEVBQUVoQyxDQUFGLENBQXJCLElBQTJCa0QsQ0FBakM7QUFBbUMsZ0JBQVMwQixDQUFULENBQVcxQixDQUFYLEVBQWFsRCxDQUFiLEVBQWVvRCxDQUFmLEVBQWlCO0FBQUMsZUFBTyxJQUFFYyxFQUFFbEUsQ0FBRixFQUFJb0QsQ0FBSixDQUFGLEdBQVNGLENBQVQsR0FBV0EsQ0FBWCxHQUFhLElBQUVVLEVBQUU1RCxDQUFGLEVBQUlvRCxDQUFKLENBQUYsR0FBU0YsQ0FBdEIsR0FBd0JsQixFQUFFaEMsQ0FBRixDQUEvQjtBQUFvQyxnQkFBU0UsQ0FBVCxDQUFXRixDQUFYLEVBQWFvRCxDQUFiLEVBQWU7QUFBQyxhQUFJLElBQUlPLElBQUUsQ0FBVixFQUFZdUQsSUFBRXZELENBQWQsRUFBZ0IsRUFBRUEsQ0FBbEIsRUFBb0I7QUFBQyxjQUFJTyxJQUFFVSxFQUFFeEIsQ0FBRixFQUFJRixDQUFKLEVBQU1oQixDQUFOLENBQU4sQ0FBZSxJQUFHLE1BQUlnQyxDQUFQLEVBQVMsT0FBT2QsQ0FBUCxDQUFTLElBQUlRLElBQUVlLEVBQUV2QixDQUFGLEVBQUlGLENBQUosRUFBTWhCLENBQU4sSUFBU2xDLENBQWYsQ0FBaUJvRCxLQUFHUSxJQUFFTSxDQUFMO0FBQU8sZ0JBQU9kLENBQVA7QUFBUyxnQkFBU25CLENBQVQsR0FBWTtBQUFDLGFBQUksSUFBSWpDLElBQUUsQ0FBVixFQUFZQyxJQUFFRCxDQUFkLEVBQWdCLEVBQUVBLENBQWxCO0FBQW9Cd0gsWUFBRXhILENBQUYsSUFBSzJFLEVBQUUzRSxJQUFFRCxDQUFKLEVBQU1tRCxDQUFOLEVBQVFoQixDQUFSLENBQUw7QUFBcEI7QUFBb0MsZ0JBQVNvRixDQUFULENBQVd0SCxDQUFYLEVBQWFvRCxDQUFiLEVBQWVPLENBQWYsRUFBaUI7QUFBQyxZQUFJTyxDQUFKO0FBQUEsWUFBTU4sQ0FBTjtBQUFBLFlBQVE1QixJQUFFLENBQVYsQ0FBWTtBQUFHNEIsY0FBRVIsSUFBRSxDQUFDTyxJQUFFUCxDQUFILElBQU0sQ0FBVixFQUFZYyxJQUFFUyxFQUFFZixDQUFGLEVBQUlWLENBQUosRUFBTWhCLENBQU4sSUFBU2xDLENBQXZCLEVBQXlCa0UsSUFBRSxDQUFGLEdBQUlQLElBQUVDLENBQU4sR0FBUVIsSUFBRVEsQ0FBbkM7QUFBSCxpQkFBOEMzQyxLQUFLa0IsR0FBTCxDQUFTK0IsQ0FBVCxJQUFZdUQsQ0FBWixJQUFlLEVBQUV6RixDQUFGLEdBQUkwRixDQUFqRSxFQUFvRSxPQUFPOUQsQ0FBUDtBQUFTLGdCQUFTekQsQ0FBVCxDQUFXSCxDQUFYLEVBQWE7QUFBQyxhQUFJLElBQUlvRCxJQUFFLENBQU4sRUFBUU8sSUFBRSxDQUFWLEVBQVlPLElBQUVqRSxJQUFFLENBQXBCLEVBQXNCMEQsS0FBR08sQ0FBSCxJQUFNc0QsRUFBRTdELENBQUYsS0FBTTNELENBQWxDLEVBQW9DLEVBQUUyRCxDQUF0QztBQUF3Q1AsZUFBR3JELENBQUg7QUFBeEMsU0FBNkMsRUFBRTRELENBQUYsQ0FBSSxJQUFJQyxJQUFFLENBQUM1RCxJQUFFd0gsRUFBRTdELENBQUYsQ0FBSCxLQUFVNkQsRUFBRTdELElBQUUsQ0FBSixJQUFPNkQsRUFBRTdELENBQUYsQ0FBakIsQ0FBTjtBQUFBLFlBQTZCM0IsSUFBRW9CLElBQUVRLElBQUU3RCxDQUFuQztBQUFBLFlBQXFDNEUsSUFBRUMsRUFBRTVDLENBQUYsRUFBSWtCLENBQUosRUFBTWhCLENBQU4sQ0FBdkMsQ0FBZ0QsT0FBT3lDLEtBQUdnRCxDQUFILEdBQUt6SCxFQUFFRixDQUFGLEVBQUlnQyxDQUFKLENBQUwsR0FBWSxLQUFHMkMsQ0FBSCxHQUFLM0MsQ0FBTCxHQUFPc0YsRUFBRXRILENBQUYsRUFBSW9ELENBQUosRUFBTUEsSUFBRXJELENBQVIsQ0FBMUI7QUFBcUMsZ0JBQVM2SCxDQUFULEdBQVk7QUFBQ0MsWUFBRSxDQUFDLENBQUgsRUFBSyxDQUFDM0UsS0FBR0UsQ0FBSCxJQUFNbEIsS0FBR3lCLENBQVYsS0FBYzFCLEdBQW5CO0FBQXVCLFdBQUlpRixJQUFFLENBQU47QUFBQSxVQUFRUyxJQUFFLElBQVY7QUFBQSxVQUFlRixJQUFFLElBQWpCO0FBQUEsVUFBc0JDLElBQUUsRUFBeEI7QUFBQSxVQUEyQnpILElBQUUsRUFBN0I7QUFBQSxVQUFnQ0YsSUFBRSxLQUFHRSxJQUFFLENBQUwsQ0FBbEM7QUFBQSxVQUEwQzZILElBQUUsa0JBQWlCOUgsQ0FBN0QsQ0FBK0QsSUFBRyxNQUFJMEUsVUFBVXZCLE1BQWpCLEVBQXdCLE9BQU0sQ0FBQyxDQUFQLENBQVMsS0FBSSxJQUFJNEUsSUFBRSxDQUFWLEVBQVksSUFBRUEsQ0FBZCxFQUFnQixFQUFFQSxDQUFsQjtBQUFvQixZQUFHLFlBQVUsT0FBT3JELFVBQVVxRCxDQUFWLENBQWpCLElBQStCQyxNQUFNdEQsVUFBVXFELENBQVYsQ0FBTixDQUEvQixJQUFvRCxDQUFDRSxTQUFTdkQsVUFBVXFELENBQVYsQ0FBVCxDQUF4RCxFQUErRSxPQUFNLENBQUMsQ0FBUDtBQUFuRyxPQUE0RzdFLElBQUVqQyxLQUFLaUgsR0FBTCxDQUFTaEYsQ0FBVCxFQUFXLENBQVgsQ0FBRixFQUFnQmhCLElBQUVqQixLQUFLaUgsR0FBTCxDQUFTaEcsQ0FBVCxFQUFXLENBQVgsQ0FBbEIsRUFBZ0NnQixJQUFFakMsS0FBS2tILEdBQUwsQ0FBU2pGLENBQVQsRUFBVyxDQUFYLENBQWxDLEVBQWdEaEIsSUFBRWpCLEtBQUtrSCxHQUFMLENBQVNqRyxDQUFULEVBQVcsQ0FBWCxDQUFsRCxDQUFnRSxJQUFJc0YsSUFBRU0sSUFBRSxJQUFJTSxZQUFKLENBQWlCbkksQ0FBakIsQ0FBRixHQUFzQixJQUFJOEQsS0FBSixDQUFVOUQsQ0FBVixDQUE1QjtBQUFBLFVBQXlDNEgsSUFBRSxDQUFDLENBQTVDO0FBQUEsVUFBOENRLElBQUUsU0FBRkEsQ0FBRSxDQUFTckksQ0FBVCxFQUFXO0FBQUMsZUFBTzZILEtBQUdELEdBQUgsRUFBTzFFLE1BQUlFLENBQUosSUFBT2xCLE1BQUl5QixDQUFYLEdBQWEzRCxDQUFiLEdBQWUsTUFBSUEsQ0FBSixHQUFNLENBQU4sR0FBUSxNQUFJQSxDQUFKLEdBQU0sQ0FBTixHQUFRMkUsRUFBRXhFLEVBQUVILENBQUYsQ0FBRixFQUFPb0QsQ0FBUCxFQUFTTyxDQUFULENBQTdDO0FBQXlELE9BQXJILENBQXNIMEUsRUFBRUMsZ0JBQUYsR0FBbUIsWUFBVTtBQUFDLGVBQU0sQ0FBQyxFQUFDdkksR0FBRW1ELENBQUgsRUFBS3lFLEdBQUV2RSxDQUFQLEVBQUQsRUFBVyxFQUFDckQsR0FBRW1DLENBQUgsRUFBS3lGLEdBQUVoRSxDQUFQLEVBQVgsQ0FBTjtBQUE0QixPQUExRCxDQUEyRCxJQUFJNEUsSUFBRSxvQkFBa0IsQ0FBQ3JGLENBQUQsRUFBR0UsQ0FBSCxFQUFLbEIsQ0FBTCxFQUFPeUIsQ0FBUCxDQUFsQixHQUE0QixHQUFsQyxDQUFzQyxPQUFPMEUsRUFBRXhCLFFBQUYsR0FBVyxZQUFVO0FBQUMsZUFBTzBCLENBQVA7QUFBUyxPQUEvQixFQUFnQ0YsQ0FBdkM7QUFBeUMsY0FBU3pELENBQVQsQ0FBVzFCLENBQVgsRUFBYWxELENBQWIsRUFBZTtBQUFDLFVBQUlvRCxJQUFFRixDQUFOLENBQVEsT0FBT2dFLEVBQUVzQixRQUFGLENBQVd0RixDQUFYLElBQWNqRCxFQUFFd0ksT0FBRixDQUFVdkYsQ0FBVixNQUFlRSxJQUFFLENBQUMsQ0FBbEIsQ0FBZCxHQUFtQ0EsSUFBRThELEVBQUVwRCxPQUFGLENBQVVaLENBQVYsS0FBYyxNQUFJQSxFQUFFQyxNQUFwQixHQUEyQm5CLEVBQUVxQyxLQUFGLENBQVEsSUFBUixFQUFhbkIsQ0FBYixDQUEzQixHQUEyQ2dFLEVBQUVwRCxPQUFGLENBQVVaLENBQVYsS0FBYyxNQUFJQSxFQUFFQyxNQUFwQixHQUEyQnBELEVBQUVzRSxLQUFGLENBQVEsSUFBUixFQUFhbkIsRUFBRXdGLE1BQUYsQ0FBUyxDQUFDMUksQ0FBRCxDQUFULENBQWIsQ0FBM0IsR0FBdURrSCxFQUFFcEQsT0FBRixDQUFVWixDQUFWLEtBQWMsTUFBSUEsRUFBRUMsTUFBcEIsR0FBMkJ3QixFQUFFTixLQUFGLENBQVEsSUFBUixFQUFhbkIsQ0FBYixDQUEzQixHQUEyQyxDQUFDLENBQW5MLEVBQXFMRSxNQUFJLENBQUMsQ0FBTCxLQUFTQSxJQUFFbkQsRUFBRXdJLE9BQUYsQ0FBVXhJLEVBQUUwSSxRQUFGLENBQVdoSixNQUFyQixJQUE2Qk0sRUFBRTBJLFFBQUYsQ0FBV2hKLE1BQXhDLEdBQStDK0gsQ0FBMUQsQ0FBckwsRUFBa1B0RSxDQUF6UDtBQUEyUCxjQUFTbEQsQ0FBVCxDQUFXZ0QsQ0FBWCxFQUFhO0FBQUMsVUFBR0EsQ0FBSCxFQUFLO0FBQUMsWUFBSWxELElBQUcsSUFBSTBHLElBQUosRUFBRCxDQUFXQyxPQUFYLEVBQU47QUFBQSxZQUEyQnZELElBQUVuRCxFQUFFMkksS0FBRixDQUFRQyxLQUFSLENBQWMxRixNQUEzQyxDQUFrREMsSUFBRSxHQUFGLEtBQVFuRCxFQUFFMkksS0FBRixDQUFRQyxLQUFSLEdBQWNsRixFQUFFMUQsRUFBRTJJLEtBQUYsQ0FBUUMsS0FBVixDQUF0QixFQUF3QyxLQUFJLElBQUkzRSxJQUFFLENBQVYsRUFBWWQsSUFBRWMsQ0FBZCxFQUFnQkEsR0FBaEI7QUFBb0IsY0FBR2pFLEVBQUUySSxLQUFGLENBQVFDLEtBQVIsQ0FBYzNFLENBQWQsQ0FBSCxFQUFvQjtBQUFDLGdCQUFJbEMsSUFBRS9CLEVBQUUySSxLQUFGLENBQVFDLEtBQVIsQ0FBYzNFLENBQWQsQ0FBTjtBQUFBLGdCQUF1QlMsSUFBRTNDLEVBQUUsQ0FBRixDQUF6QjtBQUFBLGdCQUE4QjRDLElBQUU1QyxFQUFFLENBQUYsQ0FBaEM7QUFBQSxnQkFBcUM3QixJQUFFNkIsRUFBRSxDQUFGLENBQXZDO0FBQUEsZ0JBQTRDNEYsSUFBRSxDQUFDLENBQUN6SCxDQUFoRDtBQUFBLGdCQUFrRHdILElBQUUsSUFBcEQsQ0FBeUR4SCxNQUFJQSxJQUFFRixFQUFFMkksS0FBRixDQUFRQyxLQUFSLENBQWMzRSxDQUFkLEVBQWlCLENBQWpCLElBQW9CbEUsSUFBRSxFQUE1QixFQUFnQyxLQUFJLElBQUl5SCxJQUFFeEcsS0FBS2lILEdBQUwsQ0FBUyxDQUFDbEksSUFBRUcsQ0FBSCxJQUFNeUUsRUFBRWtFLFFBQWpCLEVBQTBCLENBQTFCLENBQU4sRUFBbUNwQixJQUFFLENBQXJDLEVBQXVDM0gsSUFBRTRFLEVBQUV4QixNQUEvQyxFQUFzRHBELElBQUUySCxDQUF4RCxFQUEwREEsR0FBMUQsRUFBOEQ7QUFBQyxrQkFBSUssSUFBRXBELEVBQUUrQyxDQUFGLENBQU47QUFBQSxrQkFBV0csSUFBRUUsRUFBRWdCLE9BQWYsQ0FBdUIsSUFBR25GLEVBQUVpRSxDQUFGLENBQUgsRUFBUTtBQUFDLG9CQUFJUSxJQUFFLENBQUMsQ0FBUCxDQUFTLElBQUd6RCxFQUFFb0UsT0FBRixLQUFZOUcsQ0FBWixJQUFlLFNBQU8wQyxFQUFFb0UsT0FBeEIsSUFBaUMsV0FBU3BFLEVBQUVvRSxPQUEvQyxFQUF1RDtBQUFDLHNCQUFHLFdBQVNwRSxFQUFFb0UsT0FBZCxFQUFzQjtBQUFDLHdCQUFJVCxJQUFFLENBQUMsYUFBRCxFQUFlLFVBQWYsRUFBMEIsYUFBMUIsRUFBd0MsY0FBeEMsQ0FBTixDQUE4RGpCLEVBQUVsRCxJQUFGLENBQU9tRSxDQUFQLEVBQVMsVUFBU3JGLENBQVQsRUFBV2xELENBQVgsRUFBYTtBQUFDOEgsd0JBQUVtQixnQkFBRixDQUFtQnBCLENBQW5CLEVBQXFCLFNBQXJCLEVBQStCN0gsQ0FBL0I7QUFBa0MscUJBQXpEO0FBQTJELHFCQUFFaUosZ0JBQUYsQ0FBbUJwQixDQUFuQixFQUFxQixTQUFyQixFQUErQmpELEVBQUVvRSxPQUFqQztBQUEwQyxtQkFBRUUsVUFBRixLQUFlaEgsQ0FBZixJQUFrQixhQUFXMEMsRUFBRXNFLFVBQS9CLElBQTJDcEIsRUFBRW1CLGdCQUFGLENBQW1CcEIsQ0FBbkIsRUFBcUIsWUFBckIsRUFBa0NqRCxFQUFFc0UsVUFBcEMsQ0FBM0MsQ0FBMkYsS0FBSSxJQUFJQyxDQUFSLElBQWFwQixDQUFiO0FBQWUsc0JBQUcsY0FBWW9CLENBQWYsRUFBaUI7QUFBQyx3QkFBSUMsQ0FBSjtBQUFBLHdCQUFNQyxJQUFFdEIsRUFBRW9CLENBQUYsQ0FBUjtBQUFBLHdCQUFhRyxJQUFFcEMsRUFBRXNCLFFBQUYsQ0FBV2EsRUFBRTFKLE1BQWIsSUFBcUJNLEVBQUV3SSxPQUFGLENBQVVZLEVBQUUxSixNQUFaLENBQXJCLEdBQXlDMEosRUFBRTFKLE1BQTFELENBQWlFLElBQUcsTUFBSThILENBQVAsRUFBUzJCLElBQUVDLEVBQUVFLFFBQUosQ0FBVCxLQUEwQjtBQUFDLDBCQUFJQyxJQUFFSCxFQUFFRSxRQUFGLEdBQVdGLEVBQUVJLFVBQW5CLENBQThCLElBQUdMLElBQUVDLEVBQUVJLFVBQUYsR0FBYUQsSUFBRUYsRUFBRTdCLENBQUYsRUFBSTdDLENBQUosRUFBTTRFLENBQU4sQ0FBakIsRUFBMEIsQ0FBQzVCLENBQUQsSUFBSXdCLE1BQUlDLEVBQUVLLFlBQXZDLEVBQW9EO0FBQVMseUJBQUdMLEVBQUVLLFlBQUYsR0FBZU4sQ0FBZixFQUFpQixZQUFVRCxDQUE5QixFQUFnQ3hCLElBQUV5QixDQUFGLENBQWhDLEtBQXdDO0FBQUMsMEJBQUd0QixFQUFFNkIsS0FBRixDQUFRQyxVQUFSLENBQW1CVCxDQUFuQixDQUFILEVBQXlCO0FBQUMsNEJBQUlVLElBQUUvQixFQUFFNkIsS0FBRixDQUFRRyxPQUFSLENBQWdCWCxDQUFoQixDQUFOO0FBQUEsNEJBQXlCWSxJQUFFbkcsRUFBRWlFLENBQUYsRUFBS21DLHNCQUFMLENBQTRCSCxDQUE1QixDQUEzQixDQUEwREUsTUFBSVYsRUFBRVksaUJBQUYsR0FBb0JGLENBQXhCO0FBQTJCLDJCQUFJRyxJQUFFcEMsRUFBRW1CLGdCQUFGLENBQW1CcEIsQ0FBbkIsRUFBcUJzQixDQUFyQixFQUF1QkUsRUFBRUssWUFBRixJQUFnQixNQUFJckQsV0FBVytDLENBQVgsQ0FBSixHQUFrQixFQUFsQixHQUFxQkMsRUFBRWMsUUFBdkMsQ0FBdkIsRUFBd0VkLEVBQUVZLGlCQUExRSxFQUE0RlosRUFBRWUsVUFBOUYsQ0FBTixDQUFnSHRDLEVBQUU2QixLQUFGLENBQVFDLFVBQVIsQ0FBbUJULENBQW5CLE1BQXdCdkYsRUFBRWlFLENBQUYsRUFBS21DLHNCQUFMLENBQTRCSCxDQUE1QixJQUErQi9CLEVBQUV1QyxjQUFGLENBQWlCVCxVQUFqQixDQUE0QkMsQ0FBNUIsSUFBK0IvQixFQUFFdUMsY0FBRixDQUFpQlQsVUFBakIsQ0FBNEJDLENBQTVCLEVBQStCLFNBQS9CLEVBQXlDLElBQXpDLEVBQThDSyxFQUFFLENBQUYsQ0FBOUMsQ0FBL0IsR0FBbUZBLEVBQUUsQ0FBRixDQUExSSxHQUFnSixnQkFBY0EsRUFBRSxDQUFGLENBQWQsS0FBcUI3QixJQUFFLENBQUMsQ0FBeEIsQ0FBaEo7QUFBMks7QUFBQztBQUE1b0IsaUJBQTRvQnpELEVBQUUwRixRQUFGLElBQVkxRyxFQUFFaUUsQ0FBRixFQUFLMEMsY0FBTCxDQUFvQkMsV0FBcEIsS0FBa0N0SSxDQUE5QyxLQUFrRDBCLEVBQUVpRSxDQUFGLEVBQUswQyxjQUFMLENBQW9CQyxXQUFwQixHQUFnQyxpQkFBaEMsRUFBa0RuQyxJQUFFLENBQUMsQ0FBdkcsR0FBMEdBLEtBQUdQLEVBQUUyQyxtQkFBRixDQUFzQjVDLENBQXRCLENBQTdHO0FBQXNJO0FBQUMsZUFBRW1CLE9BQUYsS0FBWTlHLENBQVosSUFBZSxXQUFTMEMsRUFBRW9FLE9BQTFCLEtBQW9DL0ksRUFBRTJJLEtBQUYsQ0FBUUMsS0FBUixDQUFjM0UsQ0FBZCxFQUFpQixDQUFqQixFQUFvQjhFLE9BQXBCLEdBQTRCLENBQUMsQ0FBakUsR0FBb0VwRSxFQUFFc0UsVUFBRixLQUFlaEgsQ0FBZixJQUFrQixhQUFXMEMsRUFBRXNFLFVBQS9CLEtBQTRDakosRUFBRTJJLEtBQUYsQ0FBUUMsS0FBUixDQUFjM0UsQ0FBZCxFQUFpQixDQUFqQixFQUFvQmdGLFVBQXBCLEdBQStCLENBQUMsQ0FBNUUsQ0FBcEUsRUFBbUp0RSxFQUFFOEYsUUFBRixJQUFZOUYsRUFBRThGLFFBQUYsQ0FBVzdHLElBQVgsQ0FBZ0I3QixFQUFFLENBQUYsQ0FBaEIsRUFBcUJBLEVBQUUsQ0FBRixDQUFyQixFQUEwQnlGLENBQTFCLEVBQTRCeEcsS0FBS2tILEdBQUwsQ0FBUyxDQUFULEVBQVdoSSxJQUFFeUUsRUFBRWtFLFFBQUosR0FBYTlJLENBQXhCLENBQTVCLEVBQXVERyxDQUF2RCxFQUF5RHdILENBQXpELENBQS9KLEVBQTJOLE1BQUlGLENBQUosSUFBT3hGLEVBQUVpQyxDQUFGLENBQWxPO0FBQXVPO0FBQWpqRDtBQUFrakQsU0FBRTBFLEtBQUYsQ0FBUStCLFNBQVIsSUFBbUJuRCxFQUFFdEgsQ0FBRixDQUFuQjtBQUF3QixjQUFTK0IsQ0FBVCxDQUFXaUIsQ0FBWCxFQUFhbEQsQ0FBYixFQUFlO0FBQUMsVUFBRyxDQUFDQyxFQUFFMkksS0FBRixDQUFRQyxLQUFSLENBQWMzRixDQUFkLENBQUosRUFBcUIsT0FBTSxDQUFDLENBQVAsQ0FBUyxLQUFJLElBQUlFLElBQUVuRCxFQUFFMkksS0FBRixDQUFRQyxLQUFSLENBQWMzRixDQUFkLEVBQWlCLENBQWpCLENBQU4sRUFBMEJTLElBQUUxRCxFQUFFMkksS0FBRixDQUFRQyxLQUFSLENBQWMzRixDQUFkLEVBQWlCLENBQWpCLENBQTVCLEVBQWdEZ0IsSUFBRWpFLEVBQUUySSxLQUFGLENBQVFDLEtBQVIsQ0FBYzNGLENBQWQsRUFBaUIsQ0FBakIsQ0FBbEQsRUFBc0VsQixJQUFFL0IsRUFBRTJJLEtBQUYsQ0FBUUMsS0FBUixDQUFjM0YsQ0FBZCxFQUFpQixDQUFqQixDQUF4RSxFQUE0RnlCLElBQUUsQ0FBQyxDQUEvRixFQUFpR0MsSUFBRSxDQUFuRyxFQUFxRzFFLElBQUVrRCxFQUFFRCxNQUE3RyxFQUFvSGpELElBQUUwRSxDQUF0SCxFQUF3SEEsR0FBeEgsRUFBNEg7QUFBQyxZQUFJM0MsSUFBRW1CLEVBQUV3QixDQUFGLEVBQUttRSxPQUFYLENBQW1CLElBQUcvSSxLQUFHa0UsRUFBRTBHLElBQUwsS0FBWSxXQUFTMUcsRUFBRThFLE9BQVgsSUFBb0JsQixFQUFFbUIsZ0JBQUYsQ0FBbUJoSCxDQUFuQixFQUFxQixTQUFyQixFQUErQmlDLEVBQUU4RSxPQUFqQyxDQUFwQixFQUE4RCxhQUFXOUUsRUFBRWdGLFVBQWIsSUFBeUJwQixFQUFFbUIsZ0JBQUYsQ0FBbUJoSCxDQUFuQixFQUFxQixZQUFyQixFQUFrQ2lDLEVBQUVnRixVQUFwQyxDQUFuRyxHQUFvSmhGLEVBQUUwRyxJQUFGLEtBQVMsQ0FBQyxDQUFWLEtBQWN0RCxFQUFFekMsS0FBRixDQUFRNUMsQ0FBUixFQUFXLENBQVgsTUFBZ0JDLENBQWhCLElBQW1CLENBQUMsNEJBQTRCaUUsSUFBNUIsQ0FBaUNtQixFQUFFekMsS0FBRixDQUFRNUMsQ0FBUixFQUFXLENBQVgsQ0FBakMsQ0FBbEMsS0FBb0YyQixFQUFFM0IsQ0FBRixDQUEzTyxFQUFnUDtBQUFDMkIsWUFBRTNCLENBQUYsRUFBSzRJLFdBQUwsR0FBaUIsQ0FBQyxDQUFsQixFQUFvQmpILEVBQUUzQixDQUFGLEVBQUsrSCxzQkFBTCxHQUE0QixFQUFoRCxDQUFtRCxJQUFJN0osSUFBRSxDQUFDLENBQVAsQ0FBU21ILEVBQUVsRCxJQUFGLENBQU8wRCxFQUFFZ0QsS0FBRixDQUFRQyxZQUFmLEVBQTRCLFVBQVM3SCxDQUFULEVBQVdsRCxDQUFYLEVBQWE7QUFBQyxnQkFBSW9ELElBQUUsU0FBUytDLElBQVQsQ0FBY25HLENBQWQsSUFBaUIsQ0FBakIsR0FBbUIsQ0FBekI7QUFBQSxnQkFBMkIyRCxJQUFFQyxFQUFFM0IsQ0FBRixFQUFLc0ksY0FBTCxDQUFvQnZLLENBQXBCLENBQTdCLENBQW9ENEQsRUFBRTNCLENBQUYsRUFBS3NJLGNBQUwsQ0FBb0J2SyxDQUFwQixNQUF5QmtDLENBQXpCLElBQTRCLElBQUk4SSxNQUFKLENBQVcsU0FBTzVILENBQVAsR0FBUyxNQUFwQixFQUE0QitDLElBQTVCLENBQWlDeEMsQ0FBakMsQ0FBNUIsS0FBa0V4RCxJQUFFLENBQUMsQ0FBSCxFQUFLLE9BQU95RCxFQUFFM0IsQ0FBRixFQUFLc0ksY0FBTCxDQUFvQnZLLENBQXBCLENBQTlFO0FBQXNHLFdBQXBNLEdBQXNNa0UsRUFBRW9HLFFBQUYsS0FBYW5LLElBQUUsQ0FBQyxDQUFILEVBQUssT0FBT3lELEVBQUUzQixDQUFGLEVBQUtzSSxjQUFMLENBQW9CQyxXQUE3QyxDQUF0TSxFQUFnUXJLLEtBQUcySCxFQUFFMkMsbUJBQUYsQ0FBc0J4SSxDQUF0QixDQUFuUSxFQUE0UjZGLEVBQUVtRCxNQUFGLENBQVNDLFdBQVQsQ0FBcUJqSixDQUFyQixFQUF1QixvQkFBdkIsQ0FBNVI7QUFBeVUsYUFBRyxDQUFDakMsQ0FBRCxJQUFJa0UsRUFBRWlILFFBQU4sSUFBZ0IsQ0FBQ2pILEVBQUUwRyxJQUFuQixJQUF5QmhHLE1BQUkxRSxJQUFFLENBQWxDLEVBQW9DLElBQUc7QUFBQ2dFLFlBQUVpSCxRQUFGLENBQVd0SCxJQUFYLENBQWdCRixDQUFoQixFQUFrQkEsQ0FBbEI7QUFBcUIsU0FBekIsQ0FBeUIsT0FBTWlFLENBQU4sRUFBUTtBQUFDd0QscUJBQVcsWUFBVTtBQUFDLGtCQUFNeEQsQ0FBTjtBQUFRLFdBQTlCLEVBQStCLENBQS9CO0FBQWtDLGNBQUcxRCxFQUFFMEcsSUFBRixLQUFTLENBQUMsQ0FBYixJQUFnQjVJLEVBQUUyQixDQUFGLENBQWhCLEVBQXFCQyxFQUFFM0IsQ0FBRixLQUFNaUMsRUFBRTBHLElBQUYsS0FBUyxDQUFDLENBQWhCLElBQW1CLENBQUM1SyxDQUFwQixLQUF3QnNILEVBQUVsRCxJQUFGLENBQU9SLEVBQUUzQixDQUFGLEVBQUtvSixlQUFaLEVBQTRCLFVBQVNuSSxDQUFULEVBQVdsRCxDQUFYLEVBQWE7QUFBQyxvQkFBVW1HLElBQVYsQ0FBZWpELENBQWYsS0FBbUIsUUFBTW1ELFdBQVdyRyxFQUFFdUosUUFBYixDQUF6QixLQUFrRHZKLEVBQUV1SixRQUFGLEdBQVcsQ0FBWCxFQUFhdkosRUFBRXlKLFVBQUYsR0FBYSxHQUE1RSxHQUFpRixzQkFBc0J0RCxJQUF0QixDQUEyQmpELENBQTNCLEtBQStCLFFBQU1tRCxXQUFXckcsRUFBRXVKLFFBQWIsQ0FBckMsSUFBNkQsUUFBTXZKLEVBQUVtSyxRQUFyRSxLQUFnRm5LLEVBQUV1SixRQUFGLEdBQVcsQ0FBWCxFQUFhdkosRUFBRXlKLFVBQUYsR0FBYSxHQUExRyxDQUFqRjtBQUFnTSxTQUExTyxHQUE0T3hKLEVBQUVnQyxDQUFGLEVBQUksU0FBSixFQUFjLEVBQUMySSxNQUFLLENBQUMsQ0FBUCxFQUFTVSxPQUFNcEgsRUFBRW9ILEtBQWpCLEVBQWQsQ0FBcFEsQ0FBckIsRUFBaVVwSCxFQUFFVyxLQUFGLEtBQVUsQ0FBQyxDQUFYLElBQWN5QyxFQUFFdEMsT0FBRixDQUFVL0MsQ0FBVixFQUFZaUMsRUFBRVcsS0FBZCxDQUEvVTtBQUFvVyxTQUFFK0QsS0FBRixDQUFRQyxLQUFSLENBQWMzRixDQUFkLElBQWlCLENBQUMsQ0FBbEIsQ0FBb0IsS0FBSSxJQUFJZ0UsSUFBRSxDQUFOLEVBQVFTLElBQUUxSCxFQUFFMkksS0FBRixDQUFRQyxLQUFSLENBQWMxRixNQUE1QixFQUFtQ3dFLElBQUVULENBQXJDLEVBQXVDQSxHQUF2QztBQUEyQyxZQUFHakgsRUFBRTJJLEtBQUYsQ0FBUUMsS0FBUixDQUFjM0IsQ0FBZCxNQUFtQixDQUFDLENBQXZCLEVBQXlCO0FBQUN2QyxjQUFFLENBQUMsQ0FBSCxDQUFLO0FBQU07QUFBaEYsT0FBZ0ZBLE1BQUksQ0FBQyxDQUFMLEtBQVMxRSxFQUFFMkksS0FBRixDQUFRK0IsU0FBUixHQUFrQixDQUFDLENBQW5CLEVBQXFCLE9BQU8xSyxFQUFFMkksS0FBRixDQUFRQyxLQUFwQyxFQUEwQzVJLEVBQUUySSxLQUFGLENBQVFDLEtBQVIsR0FBYyxFQUFqRTtBQUFxRSxTQUFJdkIsQ0FBSjtBQUFBLFFBQU1uSCxJQUFFLFlBQVU7QUFBQyxVQUFHaUQsRUFBRW1JLFlBQUwsRUFBa0IsT0FBT25JLEVBQUVtSSxZQUFULENBQXNCLEtBQUksSUFBSXJJLElBQUUsQ0FBVixFQUFZQSxJQUFFLENBQWQsRUFBZ0JBLEdBQWhCLEVBQW9CO0FBQUMsWUFBSWxELElBQUVvRCxFQUFFb0ksYUFBRixDQUFnQixLQUFoQixDQUFOLENBQTZCLElBQUd4TCxFQUFFeUwsU0FBRixHQUFZLGdCQUFjdkksQ0FBZCxHQUFnQiw2QkFBNUIsRUFBMERsRCxFQUFFMEwsb0JBQUYsQ0FBdUIsTUFBdkIsRUFBK0J2SSxNQUE1RixFQUFtRyxPQUFPbkQsSUFBRSxJQUFGLEVBQU9rRCxDQUFkO0FBQWdCLGNBQU9oQixDQUFQO0FBQVMsS0FBak8sRUFBUjtBQUFBLFFBQTRPMEYsSUFBRSxZQUFVO0FBQUMsVUFBSTFFLElBQUUsQ0FBTixDQUFRLE9BQU9sRCxFQUFFMkwsMkJBQUYsSUFBK0IzTCxFQUFFNEwsd0JBQWpDLElBQTJELFVBQVM1TCxDQUFULEVBQVc7QUFBQyxZQUFJb0QsQ0FBSjtBQUFBLFlBQU1sQixJQUFHLElBQUl3RSxJQUFKLEVBQUQsQ0FBV0MsT0FBWCxFQUFSLENBQTZCLE9BQU92RCxJQUFFbkMsS0FBS2tILEdBQUwsQ0FBUyxDQUFULEVBQVcsTUFBSWpHLElBQUVnQixDQUFOLENBQVgsQ0FBRixFQUF1QkEsSUFBRWhCLElBQUVrQixDQUEzQixFQUE2QmdJLFdBQVcsWUFBVTtBQUFDcEwsWUFBRWtDLElBQUVrQixDQUFKO0FBQU8sU0FBN0IsRUFBOEJBLENBQTlCLENBQXBDO0FBQXFFLE9BQWhMO0FBQWlMLEtBQXBNLEVBQTlPO0FBQUEsUUFBcWI4RCxJQUFFLEVBQUNzQixVQUFTLGtCQUFTdEYsQ0FBVCxFQUFXO0FBQUMsZUFBTSxZQUFVLE9BQU9BLENBQXZCO0FBQXlCLE9BQS9DLEVBQWdEWSxTQUFRQyxNQUFNRCxPQUFOLElBQWUsVUFBU1osQ0FBVCxFQUFXO0FBQUMsZUFBTSxxQkFBbUI0QixPQUFPWCxTQUFQLENBQWlCMEMsUUFBakIsQ0FBMEJoRCxJQUExQixDQUErQlgsQ0FBL0IsQ0FBekI7QUFBMkQsT0FBOUksRUFBK0kySSxZQUFXLG9CQUFTM0ksQ0FBVCxFQUFXO0FBQUMsZUFBTSx3QkFBc0I0QixPQUFPWCxTQUFQLENBQWlCMEMsUUFBakIsQ0FBMEJoRCxJQUExQixDQUErQlgsQ0FBL0IsQ0FBNUI7QUFBOEQsT0FBcE8sRUFBcU9tRSxRQUFPLGdCQUFTbkUsQ0FBVCxFQUFXO0FBQUMsZUFBT0EsS0FBR0EsRUFBRUssUUFBWjtBQUFxQixPQUE3USxFQUE4UXVJLFlBQVcsb0JBQVM1SSxDQUFULEVBQVc7QUFBQyxlQUFNLG9CQUFpQkEsQ0FBakIseUNBQWlCQSxDQUFqQixNQUFvQixnREFBZ0RpRCxJQUFoRCxDQUFxRHJCLE9BQU9YLFNBQVAsQ0FBaUIwQyxRQUFqQixDQUEwQmhELElBQTFCLENBQStCWCxDQUEvQixDQUFyRCxDQUFwQixJQUE2R0EsRUFBRUMsTUFBRixLQUFXakIsQ0FBeEgsS0FBNEgsTUFBSWdCLEVBQUVDLE1BQU4sSUFBYyxvQkFBaUJELEVBQUUsQ0FBRixDQUFqQixLQUF1QkEsRUFBRSxDQUFGLEVBQUtLLFFBQUwsR0FBYyxDQUEvSyxDQUFOO0FBQXdMLE9BQTdkLEVBQThkNEQsV0FBVSxtQkFBU2pFLENBQVQsRUFBVztBQUFDLGVBQU9BLE1BQUlBLEVBQUU2SSxNQUFGLElBQVUvTCxFQUFFZ00sS0FBRixJQUFTaE0sRUFBRWdNLEtBQUYsQ0FBUUMsS0FBUixDQUFjQyxHQUFkLENBQWtCaEosQ0FBbEIsQ0FBdkIsQ0FBUDtBQUFvRCxPQUF4aUIsRUFBeWlCaUosT0FBTSxlQUFTakosQ0FBVCxFQUFXO0FBQUMsZUFBT2xELEVBQUVvTSxVQUFGLElBQWNsSixhQUFhbEQsRUFBRW9NLFVBQXBDO0FBQStDLE9BQTFtQixFQUEybUJDLGVBQWMsdUJBQVNuSixDQUFULEVBQVc7QUFBQyxhQUFJLElBQUlsRCxDQUFSLElBQWFrRCxDQUFiO0FBQWUsaUJBQU0sQ0FBQyxDQUFQO0FBQWYsU0FBd0IsT0FBTSxDQUFDLENBQVA7QUFBUyxPQUF0cUIsRUFBdmI7QUFBQSxRQUErbEN5RSxJQUFFLENBQUMsQ0FBbG1DLENBQW9tQyxJQUFHekUsRUFBRU0sRUFBRixJQUFNTixFQUFFTSxFQUFGLENBQUt1SSxNQUFYLElBQW1CekUsSUFBRXBFLENBQUYsRUFBSXlFLElBQUUsQ0FBQyxDQUExQixJQUE2QkwsSUFBRXRILEVBQUUrQyxRQUFGLENBQVdnRSxTQUExQyxFQUFvRCxLQUFHNUcsQ0FBSCxJQUFNLENBQUN3SCxDQUE5RCxFQUFnRSxNQUFNLElBQUl4QyxLQUFKLENBQVUsc0VBQVYsQ0FBTixDQUF3RixJQUFHLEtBQUdoRixDQUFOLEVBQVEsT0FBTyxNQUFLWCxPQUFPZ0UsRUFBUCxDQUFVOEksUUFBVixHQUFtQjlNLE9BQU9nRSxFQUFQLENBQVUrSSxPQUFsQyxDQUFQLENBQWtELElBQUk5RSxJQUFFLEdBQU47QUFBQSxRQUFVQyxJQUFFLE9BQVo7QUFBQSxRQUFvQnpILElBQUUsRUFBQzJJLE9BQU0sRUFBQzRELFVBQVMsaUVBQWlFckcsSUFBakUsQ0FBc0VzRyxVQUFVQyxTQUFoRixDQUFWLEVBQXFHQyxXQUFVLFdBQVd4RyxJQUFYLENBQWdCc0csVUFBVUMsU0FBMUIsQ0FBL0csRUFBb0pFLGVBQWMsdUJBQXVCekcsSUFBdkIsQ0FBNEJzRyxVQUFVQyxTQUF0QyxDQUFsSyxFQUFtTkcsVUFBUzdNLEVBQUU4TSxNQUE5TixFQUFxT0MsV0FBVSxXQUFXNUcsSUFBWCxDQUFnQnNHLFVBQVVDLFNBQTFCLENBQS9PLEVBQW9STSxlQUFjNUosRUFBRW9JLGFBQUYsQ0FBZ0IsS0FBaEIsQ0FBbFMsRUFBeVR5QixlQUFjLEVBQXZVLEVBQTBVQyxjQUFhLElBQXZWLEVBQTRWQyxvQkFBbUIsSUFBL1csRUFBb1hDLG1CQUFrQixJQUF0WSxFQUEyWXpDLFdBQVUsQ0FBQyxDQUF0WixFQUF3WjlCLE9BQU0sRUFBOVosRUFBUCxFQUF5YXdFLEtBQUksRUFBN2EsRUFBZ2J0RyxXQUFVTyxDQUExYixFQUE0YmdHLFdBQVUsRUFBdGMsRUFBeWM3RSxTQUFRLEVBQWpkLEVBQW9kOEUsU0FBUXZOLEVBQUV1TixPQUE5ZCxFQUFzZTVFLFVBQVMsRUFBQzlELE9BQU0sRUFBUCxFQUFVaUUsVUFBU3JCLENBQW5CLEVBQXFCOUgsUUFBTytILENBQTVCLEVBQThCOEYsT0FBTXRMLENBQXBDLEVBQXNDaUosVUFBU2pKLENBQS9DLEVBQWlEd0ksVUFBU3hJLENBQTFELEVBQTREOEcsU0FBUTlHLENBQXBFLEVBQXNFZ0gsWUFBV2hILENBQWpGLEVBQW1GMEksTUFBSyxDQUFDLENBQXpGLEVBQTJGVSxPQUFNLENBQUMsQ0FBbEcsRUFBb0doQixVQUFTLENBQUMsQ0FBOUcsRUFBZ0htRCxjQUFhLENBQUMsQ0FBOUgsRUFBL2UsRUFBZ25CaEssTUFBSyxjQUFTUCxDQUFULEVBQVc7QUFBQ29FLFVBQUVoRCxJQUFGLENBQU9wQixDQUFQLEVBQVMsVUFBVCxFQUFvQixFQUFDaUosT0FBTWpGLEVBQUVpRixLQUFGLENBQVFqSixDQUFSLENBQVAsRUFBa0IySCxhQUFZLENBQUMsQ0FBL0IsRUFBaUM2QyxlQUFjLElBQS9DLEVBQW9EckMsaUJBQWdCLElBQXBFLEVBQXlFckIsd0JBQXVCLEVBQWhHLEVBQW1HTyxnQkFBZSxFQUFsSCxFQUFwQjtBQUEySSxPQUE1d0IsRUFBNndCb0QsTUFBSyxJQUFseEIsRUFBdXhCQyxNQUFLLENBQUMsQ0FBN3hCLEVBQSt4QkMsU0FBUSxFQUFDQyxPQUFNLENBQVAsRUFBU0MsT0FBTSxDQUFmLEVBQWlCQyxPQUFNLENBQXZCLEVBQXZ5QixFQUFpMEJDLE9BQU0sQ0FBQyxDQUF4MEIsRUFBdEIsQ0FBaTJCak8sRUFBRXdGLFdBQUYsS0FBZ0J0RCxDQUFoQixJQUFtQmpDLEVBQUUySSxLQUFGLENBQVFzRSxZQUFSLEdBQXFCbE4sQ0FBckIsRUFBdUJDLEVBQUUySSxLQUFGLENBQVF1RSxrQkFBUixHQUEyQixhQUFsRCxFQUFnRWxOLEVBQUUySSxLQUFGLENBQVF3RSxpQkFBUixHQUEwQixhQUE3RyxLQUE2SG5OLEVBQUUySSxLQUFGLENBQVFzRSxZQUFSLEdBQXFCOUosRUFBRThLLGVBQUYsSUFBbUI5SyxFQUFFK0ssSUFBRixDQUFPQyxVQUExQixJQUFzQ2hMLEVBQUUrSyxJQUE3RCxFQUFrRWxPLEVBQUUySSxLQUFGLENBQVF1RSxrQkFBUixHQUEyQixZQUE3RixFQUEwR2xOLEVBQUUySSxLQUFGLENBQVF3RSxpQkFBUixHQUEwQixXQUFqUSxFQUE4USxJQUFJck4sSUFBRSxZQUFVO0FBQUMsZUFBU21ELENBQVQsQ0FBV0EsQ0FBWCxFQUFhO0FBQUMsZUFBTSxDQUFDQSxFQUFFbUwsT0FBSCxHQUFXbkwsRUFBRW5ELENBQWIsR0FBZW1ELEVBQUVvTCxRQUFGLEdBQVdwTCxFQUFFd0UsQ0FBbEM7QUFBb0MsZ0JBQVMxSCxDQUFULENBQVdBLENBQVgsRUFBYW9ELENBQWIsRUFBZWxCLENBQWYsRUFBaUI7QUFBQyxZQUFJeUIsSUFBRSxFQUFDNUQsR0FBRUMsRUFBRUQsQ0FBRixHQUFJbUMsRUFBRXFNLEVBQUYsR0FBS25MLENBQVosRUFBY3NFLEdBQUUxSCxFQUFFMEgsQ0FBRixHQUFJeEYsRUFBRXNNLEVBQUYsR0FBS3BMLENBQXpCLEVBQTJCaUwsU0FBUXJPLEVBQUVxTyxPQUFyQyxFQUE2Q0MsVUFBU3RPLEVBQUVzTyxRQUF4RCxFQUFOLENBQXdFLE9BQU0sRUFBQ0MsSUFBRzVLLEVBQUUrRCxDQUFOLEVBQVE4RyxJQUFHdEwsRUFBRVMsQ0FBRixDQUFYLEVBQU47QUFBdUIsZ0JBQVNQLENBQVQsQ0FBV0EsQ0FBWCxFQUFhbEIsQ0FBYixFQUFlO0FBQUMsWUFBSXlCLElBQUUsRUFBQzRLLElBQUduTCxFQUFFc0UsQ0FBTixFQUFROEcsSUFBR3RMLEVBQUVFLENBQUYsQ0FBWCxFQUFOO0FBQUEsWUFBdUJjLElBQUVsRSxFQUFFb0QsQ0FBRixFQUFJLEtBQUdsQixDQUFQLEVBQVN5QixDQUFULENBQXpCO0FBQUEsWUFBcUNDLElBQUU1RCxFQUFFb0QsQ0FBRixFQUFJLEtBQUdsQixDQUFQLEVBQVNnQyxDQUFULENBQXZDO0FBQUEsWUFBbURsQyxJQUFFaEMsRUFBRW9ELENBQUYsRUFBSWxCLENBQUosRUFBTTBCLENBQU4sQ0FBckQ7QUFBQSxZQUE4RGUsSUFBRSxJQUFFLENBQUYsSUFBS2hCLEVBQUU0SyxFQUFGLEdBQUssS0FBR3JLLEVBQUVxSyxFQUFGLEdBQUszSyxFQUFFMkssRUFBVixDQUFMLEdBQW1Cdk0sRUFBRXVNLEVBQTFCLENBQWhFO0FBQUEsWUFBOEYzSixJQUFFLElBQUUsQ0FBRixJQUFLakIsRUFBRTZLLEVBQUYsR0FBSyxLQUFHdEssRUFBRXNLLEVBQUYsR0FBSzVLLEVBQUU0SyxFQUFWLENBQUwsR0FBbUJ4TSxFQUFFd00sRUFBMUIsQ0FBaEcsQ0FBOEgsT0FBT3BMLEVBQUVyRCxDQUFGLEdBQUlxRCxFQUFFckQsQ0FBRixHQUFJNEUsSUFBRXpDLENBQVYsRUFBWWtCLEVBQUVzRSxDQUFGLEdBQUl0RSxFQUFFc0UsQ0FBRixHQUFJOUMsSUFBRTFDLENBQXRCLEVBQXdCa0IsQ0FBL0I7QUFBaUMsY0FBTyxTQUFTbEIsQ0FBVCxDQUFXZ0IsQ0FBWCxFQUFhbEQsQ0FBYixFQUFlMkQsQ0FBZixFQUFpQjtBQUFDLFlBQUlPLENBQUo7QUFBQSxZQUFNTixDQUFOO0FBQUEsWUFBUTVCLENBQVI7QUFBQSxZQUFVMkMsSUFBRSxFQUFDNUUsR0FBRSxDQUFDLENBQUosRUFBTTJILEdBQUUsQ0FBUixFQUFVMkcsU0FBUSxJQUFsQixFQUF1QkMsVUFBUyxJQUFoQyxFQUFaO0FBQUEsWUFBa0QxSixJQUFFLENBQUMsQ0FBRCxDQUFwRDtBQUFBLFlBQXdEMUUsSUFBRSxDQUExRDtBQUFBLFlBQTREK0IsSUFBRSxJQUE5RDtBQUFBLFlBQW1FcUYsSUFBRSxJQUFyRSxDQUEwRSxLQUFJcEUsSUFBRW1ELFdBQVduRCxDQUFYLEtBQWUsR0FBakIsRUFBcUJsRCxJQUFFcUcsV0FBV3JHLENBQVgsS0FBZSxFQUF0QyxFQUF5QzJELElBQUVBLEtBQUcsSUFBOUMsRUFBbURnQixFQUFFMEosT0FBRixHQUFVbkwsQ0FBN0QsRUFBK0R5QixFQUFFMkosUUFBRixHQUFXdE8sQ0FBMUUsRUFBNEVrRSxJQUFFLFNBQU9QLENBQXJGLEVBQXVGTyxLQUFHaEUsSUFBRWdDLEVBQUVnQixDQUFGLEVBQUlsRCxDQUFKLENBQUYsRUFBUzRELElBQUUxRCxJQUFFeUQsQ0FBRixHQUFJMkQsQ0FBbEIsSUFBcUIxRCxJQUFFMEQsQ0FBbEgsRUFBb0h0RixJQUFFb0IsRUFBRXBCLEtBQUcyQyxDQUFMLEVBQU9mLENBQVAsQ0FBRixFQUFZZ0IsRUFBRUcsSUFBRixDQUFPLElBQUUvQyxFQUFFakMsQ0FBWCxDQUFaLEVBQTBCRyxLQUFHLEVBQTdCLEVBQWdDZSxLQUFLa0IsR0FBTCxDQUFTSCxFQUFFakMsQ0FBWCxJQUFja0MsQ0FBZCxJQUFpQmhCLEtBQUtrQixHQUFMLENBQVNILEVBQUUwRixDQUFYLElBQWN6RixDQUFuTCxLQUF1TCxPQUFPaUMsSUFBRSxVQUFTaEIsQ0FBVCxFQUFXO0FBQUMsaUJBQU8wQixFQUFFMUIsS0FBRzBCLEVBQUV6QixNQUFGLEdBQVMsQ0FBWixJQUFlLENBQWpCLENBQVA7QUFBMkIsU0FBekMsR0FBMENqRCxDQUFqRDtBQUFtRCxPQUE3VTtBQUE4VSxLQUEzcUIsRUFBTixDQUFvckJELEVBQUV3SSxPQUFGLEdBQVUsRUFBQ2dHLFFBQU8sZ0JBQVN2TCxDQUFULEVBQVc7QUFBQyxlQUFPQSxDQUFQO0FBQVMsT0FBN0IsRUFBOEJwRCxPQUFNLGVBQVNvRCxDQUFULEVBQVc7QUFBQyxlQUFNLEtBQUdqQyxLQUFLQyxHQUFMLENBQVNnQyxJQUFFakMsS0FBS0UsRUFBaEIsSUFBb0IsQ0FBN0I7QUFBK0IsT0FBL0UsRUFBZ0Z1TixRQUFPLGdCQUFTeEwsQ0FBVCxFQUFXO0FBQUMsZUFBTyxJQUFFakMsS0FBS0MsR0FBTCxDQUFTLE1BQUlnQyxDQUFKLEdBQU1qQyxLQUFLRSxFQUFwQixJQUF3QkYsS0FBSzBOLEdBQUwsQ0FBUyxJQUFFLENBQUN6TCxDQUFaLENBQWpDO0FBQWdELE9BQW5KLEVBQVYsRUFBK0pvRSxFQUFFbEQsSUFBRixDQUFPLENBQUMsQ0FBQyxNQUFELEVBQVEsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEdBQVIsRUFBWSxDQUFaLENBQVIsQ0FBRCxFQUF5QixDQUFDLFNBQUQsRUFBVyxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsQ0FBWCxDQUF6QixFQUFpRCxDQUFDLFVBQUQsRUFBWSxDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssR0FBTCxFQUFTLENBQVQsQ0FBWixDQUFqRCxFQUEwRSxDQUFDLGFBQUQsRUFBZSxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sR0FBUCxFQUFXLENBQVgsQ0FBZixDQUExRSxFQUF3RyxDQUFDLFlBQUQsRUFBYyxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sSUFBUCxFQUFZLElBQVosQ0FBZCxDQUF4RyxFQUF5SSxDQUFDLGFBQUQsRUFBZSxDQUFDLEdBQUQsRUFBSyxJQUFMLEVBQVUsSUFBVixFQUFlLENBQWYsQ0FBZixDQUF6SSxFQUEySyxDQUFDLGVBQUQsRUFBaUIsQ0FBQyxJQUFELEVBQU0sR0FBTixFQUFVLEdBQVYsRUFBYyxHQUFkLENBQWpCLENBQTNLLEVBQWdOLENBQUMsWUFBRCxFQUFjLENBQUMsR0FBRCxFQUFLLElBQUwsRUFBVSxHQUFWLEVBQWMsR0FBZCxDQUFkLENBQWhOLEVBQWtQLENBQUMsYUFBRCxFQUFlLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsR0FBYixDQUFmLENBQWxQLEVBQW9SLENBQUMsZUFBRCxFQUFpQixDQUFDLElBQUQsRUFBTSxHQUFOLEVBQVUsSUFBVixFQUFlLElBQWYsQ0FBakIsQ0FBcFIsRUFBMlQsQ0FBQyxhQUFELEVBQWUsQ0FBQyxHQUFELEVBQUssSUFBTCxFQUFVLElBQVYsRUFBZSxHQUFmLENBQWYsQ0FBM1QsRUFBK1YsQ0FBQyxjQUFELEVBQWdCLENBQUMsSUFBRCxFQUFNLEdBQU4sRUFBVSxJQUFWLEVBQWUsQ0FBZixDQUFoQixDQUEvVixFQUFrWSxDQUFDLGdCQUFELEVBQWtCLENBQUMsSUFBRCxFQUFNLElBQU4sRUFBVyxJQUFYLEVBQWdCLENBQWhCLENBQWxCLENBQWxZLEVBQXdhLENBQUMsYUFBRCxFQUFlLENBQUMsSUFBRCxFQUFNLEdBQU4sRUFBVSxJQUFWLEVBQWUsR0FBZixDQUFmLENBQXhhLEVBQTRjLENBQUMsY0FBRCxFQUFnQixDQUFDLElBQUQsRUFBTSxHQUFOLEVBQVUsR0FBVixFQUFjLENBQWQsQ0FBaEIsQ0FBNWMsRUFBOGUsQ0FBQyxnQkFBRCxFQUFrQixDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sSUFBUCxFQUFZLENBQVosQ0FBbEIsQ0FBOWUsRUFBZ2hCLENBQUMsYUFBRCxFQUFlLENBQUMsSUFBRCxFQUFNLEdBQU4sRUFBVSxJQUFWLEVBQWUsR0FBZixDQUFmLENBQWhoQixFQUFvakIsQ0FBQyxjQUFELEVBQWdCLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLEVBQVcsQ0FBWCxDQUFoQixDQUFwakIsRUFBbWxCLENBQUMsZ0JBQUQsRUFBa0IsQ0FBQyxHQUFELEVBQUssQ0FBTCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBQWxCLENBQW5sQixFQUFvbkIsQ0FBQyxZQUFELEVBQWMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLElBQVQsRUFBYyxJQUFkLENBQWQsQ0FBcG5CLEVBQXVwQixDQUFDLGFBQUQsRUFBZSxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sR0FBUCxFQUFXLENBQVgsQ0FBZixDQUF2cEIsRUFBcXJCLENBQUMsZUFBRCxFQUFpQixDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssQ0FBTCxFQUFPLENBQVAsQ0FBakIsQ0FBcnJCLEVBQWl0QixDQUFDLFlBQUQsRUFBYyxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsR0FBUixFQUFZLElBQVosQ0FBZCxDQUFqdEIsRUFBa3ZCLENBQUMsYUFBRCxFQUFlLENBQUMsSUFBRCxFQUFNLEdBQU4sRUFBVSxJQUFWLEVBQWUsQ0FBZixDQUFmLENBQWx2QixFQUFveEIsQ0FBQyxlQUFELEVBQWlCLENBQUMsSUFBRCxFQUFNLElBQU4sRUFBVyxHQUFYLEVBQWUsR0FBZixDQUFqQixDQUFweEIsQ0FBUCxFQUFrMEIsVUFBU2xCLENBQVQsRUFBV2xELENBQVgsRUFBYTtBQUFDQyxRQUFFd0ksT0FBRixDQUFVekksRUFBRSxDQUFGLENBQVYsSUFBZ0IyRSxFQUFFTixLQUFGLENBQVEsSUFBUixFQUFhckUsRUFBRSxDQUFGLENBQWIsQ0FBaEI7QUFBbUMsS0FBbjNCLENBQS9KLENBQW9oQyxJQUFJOEgsSUFBRTdILEVBQUVvTixHQUFGLEdBQU0sRUFBQ3VCLE9BQU0sRUFBQ0MsT0FBTSx1QkFBUCxFQUErQkMsYUFBWSxtQkFBM0MsRUFBK0RDLDhCQUE2QixvQ0FBNUYsRUFBaUlDLFlBQVcsNENBQTVJLEVBQVAsRUFBaU1sRSxPQUFNLEVBQUNtRSxRQUFPLENBQUMsTUFBRCxFQUFRLFFBQVIsRUFBaUIsV0FBakIsRUFBNkIsT0FBN0IsRUFBcUMsaUJBQXJDLEVBQXVELGFBQXZELEVBQXFFLGdCQUFyRSxFQUFzRixrQkFBdEYsRUFBeUcsbUJBQXpHLEVBQTZILGlCQUE3SCxFQUErSSxjQUEvSSxDQUFSLEVBQXVLQyxnQkFBZSxDQUFDLFlBQUQsRUFBYyxZQUFkLEVBQTJCLE9BQTNCLEVBQW1DLFFBQW5DLEVBQTRDLFFBQTVDLEVBQXFELE9BQXJELEVBQTZELE9BQTdELEVBQXFFLFNBQXJFLENBQXRMLEVBQXNRbkUsY0FBYSxDQUFDLHNCQUFELEVBQXdCLFlBQXhCLEVBQXFDLFFBQXJDLEVBQThDLFNBQTlDLEVBQXdELFNBQXhELENBQW5SLEVBQXZNLEVBQThoQnBCLE9BQU0sRUFBQ3dGLFdBQVUsRUFBQ0MsWUFBVyxDQUFDLGdCQUFELEVBQWtCLG1CQUFsQixDQUFaLEVBQW1EQyxXQUFVLENBQUMsdUJBQUQsRUFBeUIsdUJBQXpCLENBQTdELEVBQStHQyxNQUFLLENBQUMsdUJBQUQsRUFBeUIsaUJBQXpCLENBQXBILEVBQWdLQyxvQkFBbUIsQ0FBQyxLQUFELEVBQU8sT0FBUCxDQUFuTCxFQUFtTUMsaUJBQWdCLENBQUMsT0FBRCxFQUFTLGFBQVQsQ0FBbk4sRUFBMk9DLG1CQUFrQixDQUFDLEtBQUQsRUFBTyxTQUFQLENBQTdQLEVBQVgsRUFBMlI3RixZQUFXLEVBQXRTLEVBQXlTOEYsVUFBUyxvQkFBVTtBQUFDLGVBQUksSUFBSXhNLElBQUUsQ0FBVixFQUFZQSxJQUFFNEUsRUFBRWdELEtBQUYsQ0FBUW1FLE1BQVIsQ0FBZTlMLE1BQTdCLEVBQW9DRCxHQUFwQyxFQUF3QztBQUFDLGdCQUFJbEQsSUFBRSxZQUFVOEgsRUFBRWdELEtBQUYsQ0FBUW1FLE1BQVIsQ0FBZS9MLENBQWYsQ0FBVixHQUE0QixTQUE1QixHQUFzQyxlQUE1QyxDQUE0RDRFLEVBQUU2QixLQUFGLENBQVF3RixTQUFSLENBQWtCckgsRUFBRWdELEtBQUYsQ0FBUW1FLE1BQVIsQ0FBZS9MLENBQWYsQ0FBbEIsSUFBcUMsQ0FBQyxzQkFBRCxFQUF3QmxELENBQXhCLENBQXJDO0FBQWdFLGVBQUlvRCxDQUFKLEVBQU1sQixDQUFOLEVBQVF5QixDQUFSLENBQVUsSUFBR3hELENBQUgsRUFBSyxLQUFJaUQsQ0FBSixJQUFTMEUsRUFBRTZCLEtBQUYsQ0FBUXdGLFNBQWpCLEVBQTJCO0FBQUNqTixnQkFBRTRGLEVBQUU2QixLQUFGLENBQVF3RixTQUFSLENBQWtCL0wsQ0FBbEIsQ0FBRixFQUF1Qk8sSUFBRXpCLEVBQUUsQ0FBRixFQUFLNEUsS0FBTCxDQUFXLEdBQVgsQ0FBekIsQ0FBeUMsSUFBSTVDLElBQUVoQyxFQUFFLENBQUYsRUFBS3lOLEtBQUwsQ0FBVzdILEVBQUU4RyxLQUFGLENBQVFJLFVBQW5CLENBQU4sQ0FBcUMsWUFBVXJMLEVBQUUsQ0FBRixDQUFWLEtBQWlCQSxFQUFFb0IsSUFBRixDQUFPcEIsRUFBRXNCLEtBQUYsRUFBUCxHQUFrQmYsRUFBRWEsSUFBRixDQUFPYixFQUFFZSxLQUFGLEVBQVAsQ0FBbEIsRUFBb0M2QyxFQUFFNkIsS0FBRixDQUFRd0YsU0FBUixDQUFrQi9MLENBQWxCLElBQXFCLENBQUNPLEVBQUVpTSxJQUFGLENBQU8sR0FBUCxDQUFELEVBQWExTCxFQUFFMEwsSUFBRixDQUFPLEdBQVAsQ0FBYixDQUExRTtBQUFxRyxnQkFBSXhNLENBQUosSUFBUzBFLEVBQUU2QixLQUFGLENBQVF3RixTQUFqQixFQUEyQjtBQUFDak4sZ0JBQUU0RixFQUFFNkIsS0FBRixDQUFRd0YsU0FBUixDQUFrQi9MLENBQWxCLENBQUYsRUFBdUJPLElBQUV6QixFQUFFLENBQUYsRUFBSzRFLEtBQUwsQ0FBVyxHQUFYLENBQXpCLENBQXlDLEtBQUksSUFBSTVELENBQVIsSUFBYVMsQ0FBYixFQUFlO0FBQUMsa0JBQUlDLElBQUVSLElBQUVPLEVBQUVULENBQUYsQ0FBUjtBQUFBLGtCQUFhbEIsSUFBRWtCLENBQWYsQ0FBaUI0RSxFQUFFNkIsS0FBRixDQUFRQyxVQUFSLENBQW1CaEcsQ0FBbkIsSUFBc0IsQ0FBQ1IsQ0FBRCxFQUFHcEIsQ0FBSCxDQUF0QjtBQUE0QjtBQUFDO0FBQUMsU0FBcDBCLEVBQXEwQjhILFNBQVEsaUJBQVM1RyxDQUFULEVBQVc7QUFBQyxjQUFJbEQsSUFBRThILEVBQUU2QixLQUFGLENBQVFDLFVBQVIsQ0FBbUIxRyxDQUFuQixDQUFOLENBQTRCLE9BQU9sRCxJQUFFQSxFQUFFLENBQUYsQ0FBRixHQUFPa0QsQ0FBZDtBQUFnQixTQUFyNEIsRUFBczRCMk0sd0JBQXVCLGdDQUFTM00sQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhO0FBQUMsaUJBQU84SCxFQUFFOEcsS0FBRixDQUFRRSxXQUFSLENBQW9CM0ksSUFBcEIsQ0FBeUJuRyxDQUF6QixNQUE4QkEsSUFBRUEsRUFBRTJQLEtBQUYsQ0FBUTdILEVBQUU4RyxLQUFGLENBQVFFLFdBQWhCLEVBQTZCLENBQTdCLENBQWhDLEdBQWlFaEgsRUFBRW1ELE1BQUYsQ0FBUzZFLGNBQVQsQ0FBd0I5UCxDQUF4QixNQUE2QkEsSUFBRThILEVBQUU2QixLQUFGLENBQVF3RixTQUFSLENBQWtCak0sQ0FBbEIsRUFBcUIsQ0FBckIsQ0FBL0IsQ0FBakUsRUFBeUhsRCxDQUFoSTtBQUFrSSxTQUE3aUMsRUFBOGlDK1AsY0FBYSxzQkFBUzdNLENBQVQsRUFBV2xELENBQVgsRUFBYTtBQUFDLGNBQUlvRCxJQUFFMEUsRUFBRTZCLEtBQUYsQ0FBUUMsVUFBUixDQUFtQjFHLENBQW5CLENBQU4sQ0FBNEIsSUFBR0UsQ0FBSCxFQUFLO0FBQUMsZ0JBQUlsQixJQUFFa0IsRUFBRSxDQUFGLENBQU47QUFBQSxnQkFBV08sSUFBRVAsRUFBRSxDQUFGLENBQWIsQ0FBa0IsT0FBT3BELElBQUU4SCxFQUFFNkIsS0FBRixDQUFRa0csc0JBQVIsQ0FBK0IzTixDQUEvQixFQUFpQ2xDLENBQWpDLENBQUYsRUFBc0NBLEVBQUU2RyxRQUFGLEdBQWE4SSxLQUFiLENBQW1CN0gsRUFBRThHLEtBQUYsQ0FBUUksVUFBM0IsRUFBdUNyTCxDQUF2QyxDQUE3QztBQUF1RixrQkFBTzNELENBQVA7QUFBUyxTQUE3dEMsRUFBOHRDZ1EsYUFBWSxxQkFBUzlNLENBQVQsRUFBV2xELENBQVgsRUFBYW9ELENBQWIsRUFBZTtBQUFDLGNBQUlsQixJQUFFNEYsRUFBRTZCLEtBQUYsQ0FBUUMsVUFBUixDQUFtQjFHLENBQW5CLENBQU4sQ0FBNEIsSUFBR2hCLENBQUgsRUFBSztBQUFDLGdCQUFJeUIsQ0FBSjtBQUFBLGdCQUFNTyxDQUFOO0FBQUEsZ0JBQVFOLElBQUUxQixFQUFFLENBQUYsQ0FBVjtBQUFBLGdCQUFlRixJQUFFRSxFQUFFLENBQUYsQ0FBakIsQ0FBc0IsT0FBT2tCLElBQUUwRSxFQUFFNkIsS0FBRixDQUFRa0csc0JBQVIsQ0FBK0JqTSxDQUEvQixFQUFpQ1IsQ0FBakMsQ0FBRixFQUFzQ08sSUFBRVAsRUFBRXlELFFBQUYsR0FBYThJLEtBQWIsQ0FBbUI3SCxFQUFFOEcsS0FBRixDQUFRSSxVQUEzQixDQUF4QyxFQUErRXJMLEVBQUUzQixDQUFGLElBQUtoQyxDQUFwRixFQUFzRmtFLElBQUVQLEVBQUVpTSxJQUFGLENBQU8sR0FBUCxDQUEvRjtBQUEyRyxrQkFBT3hNLENBQVA7QUFBUyxTQUF0NkMsRUFBcGlCLEVBQTQ4RGlILGdCQUFlLEVBQUNULFlBQVcsRUFBQzBGLE1BQUssY0FBU3BNLENBQVQsRUFBV2xELENBQVgsRUFBYW9ELENBQWIsRUFBZTtBQUFDLG9CQUFPRixDQUFQLEdBQVUsS0FBSSxNQUFKO0FBQVcsdUJBQU0sTUFBTixDQUFhLEtBQUksU0FBSjtBQUFjLG9CQUFJaEIsQ0FBSixDQUFNLE9BQU80RixFQUFFOEcsS0FBRixDQUFRRyw0QkFBUixDQUFxQzVJLElBQXJDLENBQTBDL0MsQ0FBMUMsSUFBNkNsQixJQUFFa0IsQ0FBL0MsSUFBa0RsQixJQUFFa0IsRUFBRXlELFFBQUYsR0FBYThJLEtBQWIsQ0FBbUI3SCxFQUFFOEcsS0FBRixDQUFRRSxXQUEzQixDQUFGLEVBQTBDNU0sSUFBRUEsSUFBRUEsRUFBRSxDQUFGLEVBQUsrTixPQUFMLENBQWEsVUFBYixFQUF3QixHQUF4QixDQUFGLEdBQStCN00sQ0FBN0gsR0FBZ0lsQixDQUF2SSxDQUF5SSxLQUFJLFFBQUo7QUFBYSx1QkFBTSxVQUFRa0IsQ0FBUixHQUFVLEdBQWhCLENBQTVNO0FBQWlPLFdBQXZQLEVBQXdQOE0sTUFBSyxjQUFTaE4sQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhb0QsQ0FBYixFQUFlO0FBQUMsb0JBQU9GLENBQVAsR0FBVSxLQUFJLE1BQUo7QUFBVyx1QkFBT2pELEVBQUUySSxLQUFGLENBQVFtRSxTQUFSLEdBQWtCLFFBQWxCLEdBQTJCLGdCQUFsQyxDQUFtRCxLQUFJLFNBQUo7QUFBYyxvQkFBSTdLLElBQUVtRSxXQUFXakQsQ0FBWCxDQUFOLENBQW9CLElBQUcsQ0FBQ2xCLENBQUQsSUFBSSxNQUFJQSxDQUFYLEVBQWE7QUFBQyxzQkFBSXlCLElBQUVQLEVBQUV5RCxRQUFGLEdBQWE4SSxLQUFiLENBQW1CLHlCQUFuQixDQUFOLENBQW9Eek4sSUFBRXlCLElBQUVBLEVBQUUsQ0FBRixDQUFGLEdBQU8sQ0FBVDtBQUFXLHdCQUFPekIsQ0FBUCxDQUFTLEtBQUksUUFBSjtBQUFhLHVCQUFPbUUsV0FBV2pELENBQVgsSUFBYyxVQUFRQSxDQUFSLEdBQVUsR0FBeEIsR0FBNEIsTUFBbkMsQ0FBN007QUFBd1AsV0FBcmdCLEVBQXNnQitNLFNBQVEsaUJBQVNqTixDQUFULEVBQVdsRCxDQUFYLEVBQWFvRCxDQUFiLEVBQWU7QUFBQyxnQkFBRyxLQUFHakQsQ0FBTixFQUFRLFFBQU8rQyxDQUFQLEdBQVUsS0FBSSxNQUFKO0FBQVcsdUJBQU0sUUFBTixDQUFlLEtBQUksU0FBSjtBQUFjLG9CQUFJaEIsSUFBRWtCLEVBQUV5RCxRQUFGLEdBQWE4SSxLQUFiLENBQW1CLHdCQUFuQixDQUFOLENBQW1ELE9BQU92TSxJQUFFbEIsSUFBRUEsRUFBRSxDQUFGLElBQUssR0FBUCxHQUFXLENBQXBCLENBQXNCLEtBQUksUUFBSjtBQUFhLHVCQUFPbEMsRUFBRWtHLEtBQUYsQ0FBUWtLLElBQVIsR0FBYSxDQUFiLEVBQWUvSixXQUFXakQsQ0FBWCxLQUFlLENBQWYsR0FBaUIsRUFBakIsR0FBb0IsbUJBQWlCaU4sU0FBUyxNQUFJaEssV0FBV2pELENBQVgsQ0FBYixFQUEyQixFQUEzQixDQUFqQixHQUFnRCxHQUExRixDQUF4SSxDQUFSLE1BQW1QLFFBQU9GLENBQVAsR0FBVSxLQUFJLE1BQUo7QUFBVyx1QkFBTSxTQUFOLENBQWdCLEtBQUksU0FBSjtBQUFjLHVCQUFPRSxDQUFQLENBQVMsS0FBSSxRQUFKO0FBQWEsdUJBQU9BLENBQVAsQ0FBekU7QUFBbUYsV0FBcDJCLEVBQVosRUFBazNCc00sVUFBUyxvQkFBVTtBQUFDLGVBQUd2UCxDQUFILElBQU1GLEVBQUUySSxLQUFGLENBQVFnRSxhQUFkLEtBQThCOUUsRUFBRWdELEtBQUYsQ0FBUW9FLGNBQVIsR0FBdUJwSCxFQUFFZ0QsS0FBRixDQUFRb0UsY0FBUixDQUF1QnhHLE1BQXZCLENBQThCWixFQUFFZ0QsS0FBRixDQUFRQyxZQUF0QyxDQUFyRCxFQUEwRyxLQUFJLElBQUk3SCxJQUFFLENBQVYsRUFBWUEsSUFBRTRFLEVBQUVnRCxLQUFGLENBQVFvRSxjQUFSLENBQXVCL0wsTUFBckMsRUFBNENELEdBQTVDO0FBQWdELGFBQUMsWUFBVTtBQUFDLGtCQUFJbEQsSUFBRThILEVBQUVnRCxLQUFGLENBQVFvRSxjQUFSLENBQXVCaE0sQ0FBdkIsQ0FBTixDQUFnQzRFLEVBQUV1QyxjQUFGLENBQWlCVCxVQUFqQixDQUE0QjVKLENBQTVCLElBQStCLFVBQVNrRCxDQUFULEVBQVdFLENBQVgsRUFBYU8sQ0FBYixFQUFlO0FBQUMsd0JBQU9ULENBQVAsR0FBVSxLQUFJLE1BQUo7QUFBVywyQkFBTSxXQUFOLENBQWtCLEtBQUksU0FBSjtBQUFjLDJCQUFPVSxFQUFFUixDQUFGLE1BQU9sQixDQUFQLElBQVUwQixFQUFFUixDQUFGLEVBQUttSCxjQUFMLENBQW9CdkssQ0FBcEIsTUFBeUJrQyxDQUFuQyxHQUFxQyxVQUFVaUUsSUFBVixDQUFlbkcsQ0FBZixJQUFrQixDQUFsQixHQUFvQixDQUF6RCxHQUEyRDRELEVBQUVSLENBQUYsRUFBS21ILGNBQUwsQ0FBb0J2SyxDQUFwQixFQUF1QmlRLE9BQXZCLENBQStCLE9BQS9CLEVBQXVDLEVBQXZDLENBQWxFLENBQTZHLEtBQUksUUFBSjtBQUFhLHdCQUFJL0wsSUFBRSxDQUFDLENBQVAsQ0FBUyxRQUFPbEUsRUFBRXNRLE1BQUYsQ0FBUyxDQUFULEVBQVd0USxFQUFFbUQsTUFBRixHQUFTLENBQXBCLENBQVAsR0FBK0IsS0FBSSxXQUFKO0FBQWdCZSw0QkFBRSxDQUFDLDJCQUEyQmlDLElBQTNCLENBQWdDeEMsQ0FBaEMsQ0FBSCxDQUFzQyxNQUFNLEtBQUksTUFBSixDQUFXLEtBQUksT0FBSjtBQUFZMUQsMEJBQUUySSxLQUFGLENBQVErRCxTQUFSLElBQW1CL0ksRUFBRVIsQ0FBRixFQUFLbUgsY0FBTCxDQUFvQnZLLENBQXBCLE1BQXlCa0MsQ0FBNUMsSUFBK0MsSUFBRXlCLENBQWpELEtBQXFEQSxJQUFFLENBQXZELEdBQTBETyxJQUFFLENBQUMsU0FBU2lDLElBQVQsQ0FBY3hDLENBQWQsQ0FBN0QsQ0FBOEUsTUFBTSxLQUFJLE1BQUo7QUFBV08sNEJBQUUsQ0FBQyxhQUFhaUMsSUFBYixDQUFrQnhDLENBQWxCLENBQUgsQ0FBd0IsTUFBTSxLQUFJLFFBQUo7QUFBYU8sNEJBQUUsQ0FBQyxhQUFhaUMsSUFBYixDQUFrQnhDLENBQWxCLENBQUgsQ0FBNVAsQ0FBb1IsT0FBT08sTUFBSU4sRUFBRVIsQ0FBRixFQUFLbUgsY0FBTCxDQUFvQnZLLENBQXBCLElBQXVCLE1BQUkyRCxDQUFKLEdBQU0sR0FBakMsR0FBc0NDLEVBQUVSLENBQUYsRUFBS21ILGNBQUwsQ0FBb0J2SyxDQUFwQixDQUE3QyxDQUE1YztBQUFpaEIsZUFBaGtCO0FBQWlrQixhQUE1bUIsRUFBRDtBQUFoRCxXQUFncUIsS0FBSSxJQUFJa0QsSUFBRSxDQUFWLEVBQVlBLElBQUU0RSxFQUFFZ0QsS0FBRixDQUFRbUUsTUFBUixDQUFlOUwsTUFBN0IsRUFBb0NELEdBQXBDO0FBQXdDLGFBQUMsWUFBVTtBQUFDLGtCQUFJbEQsSUFBRThILEVBQUVnRCxLQUFGLENBQVFtRSxNQUFSLENBQWUvTCxDQUFmLENBQU4sQ0FBd0I0RSxFQUFFdUMsY0FBRixDQUFpQlQsVUFBakIsQ0FBNEI1SixDQUE1QixJQUErQixVQUFTa0QsQ0FBVCxFQUFXRSxDQUFYLEVBQWFPLENBQWIsRUFBZTtBQUFDLHdCQUFPVCxDQUFQLEdBQVUsS0FBSSxNQUFKO0FBQVcsMkJBQU9sRCxDQUFQLENBQVMsS0FBSSxTQUFKO0FBQWMsd0JBQUlrRSxDQUFKLENBQU0sSUFBRzRELEVBQUU4RyxLQUFGLENBQVFHLDRCQUFSLENBQXFDNUksSUFBckMsQ0FBMEN4QyxDQUExQyxDQUFILEVBQWdETyxJQUFFUCxDQUFGLENBQWhELEtBQXdEO0FBQUMsMEJBQUlDLENBQUo7QUFBQSwwQkFBTTVCLElBQUUsRUFBQ3VPLE9BQU0sY0FBUCxFQUFzQkMsTUFBSyxnQkFBM0IsRUFBNENDLE1BQUssb0JBQWpELEVBQXNFQyxPQUFNLGdCQUE1RSxFQUE2RkMsS0FBSSxnQkFBakcsRUFBa0hDLE9BQU0sb0JBQXhILEVBQVIsQ0FBc0osWUFBWXpLLElBQVosQ0FBaUJ4QyxDQUFqQixJQUFvQkMsSUFBRTVCLEVBQUUyQixDQUFGLE1BQU96QixDQUFQLEdBQVNGLEVBQUUyQixDQUFGLENBQVQsR0FBYzNCLEVBQUV1TyxLQUF0QyxHQUE0Q3pJLEVBQUU4RyxLQUFGLENBQVFDLEtBQVIsQ0FBYzFJLElBQWQsQ0FBbUJ4QyxDQUFuQixJQUFzQkMsSUFBRSxTQUFPa0UsRUFBRW1ELE1BQUYsQ0FBUzRGLFFBQVQsQ0FBa0JsTixDQUFsQixFQUFxQmlNLElBQXJCLENBQTBCLEdBQTFCLENBQVAsR0FBc0MsR0FBOUQsR0FBa0UsWUFBWXpKLElBQVosQ0FBaUJ4QyxDQUFqQixNQUFzQkMsSUFBRTVCLEVBQUV1TyxLQUExQixDQUE5RyxFQUErSXJNLElBQUUsQ0FBQ04sS0FBR0QsQ0FBSixFQUFPa0QsUUFBUCxHQUFrQjhJLEtBQWxCLENBQXdCN0gsRUFBRThHLEtBQUYsQ0FBUUUsV0FBaEMsRUFBNkMsQ0FBN0MsRUFBZ0RtQixPQUFoRCxDQUF3RCxVQUF4RCxFQUFtRSxHQUFuRSxDQUFqSjtBQUF5Tiw0QkFBTyxLQUFHOVAsQ0FBSCxJQUFNLE1BQUkrRCxFQUFFNEMsS0FBRixDQUFRLEdBQVIsRUFBYTNELE1BQXZCLEtBQWdDZSxLQUFHLElBQW5DLEdBQXlDQSxDQUFoRCxDQUFrRCxLQUFJLFFBQUo7QUFBYSwyQkFBTyxLQUFHL0QsQ0FBSCxHQUFLLE1BQUl3RCxFQUFFbUQsS0FBRixDQUFRLEdBQVIsRUFBYTNELE1BQWpCLEtBQTBCUSxJQUFFQSxFQUFFbUQsS0FBRixDQUFRLEtBQVIsRUFBZU0sS0FBZixDQUFxQixDQUFyQixFQUF1QixDQUF2QixFQUEwQndJLElBQTFCLENBQStCLEdBQS9CLENBQTVCLENBQUwsR0FBc0UsTUFBSWpNLEVBQUVtRCxLQUFGLENBQVEsR0FBUixFQUFhM0QsTUFBakIsS0FBMEJRLEtBQUcsSUFBN0IsQ0FBdEUsRUFBeUcsQ0FBQyxLQUFHeEQsQ0FBSCxHQUFLLEtBQUwsR0FBVyxNQUFaLElBQW9CLEdBQXBCLEdBQXdCd0QsRUFBRXNNLE9BQUYsQ0FBVSxNQUFWLEVBQWlCLEdBQWpCLEVBQXNCQSxPQUF0QixDQUE4QixlQUE5QixFQUE4QyxFQUE5QyxDQUF4QixHQUEwRSxHQUExTCxDQUF6aEI7QUFBd3RCLGVBQXZ3QjtBQUF3d0IsYUFBM3lCLEVBQUQ7QUFBeEM7QUFBdTFCLFNBQXYrRSxFQUEzOUQsRUFBbzhJYSxPQUFNLEVBQUNDLFdBQVUsbUJBQVM3TixDQUFULEVBQVc7QUFBQyxpQkFBT0EsRUFBRStNLE9BQUYsQ0FBVSxRQUFWLEVBQW1CLFVBQVMvTSxDQUFULEVBQVdsRCxDQUFYLEVBQWE7QUFBQyxtQkFBT0EsRUFBRWdSLFdBQUYsRUFBUDtBQUF1QixXQUF4RCxDQUFQO0FBQWlFLFNBQXhGLEVBQXlGQyxjQUFhLHNCQUFTL04sQ0FBVCxFQUFXO0FBQUMsY0FBSWxELElBQUUsNENBQU4sQ0FBbUQsT0FBTSxDQUFDRyxLQUFHRixFQUFFMkksS0FBRixDQUFRK0QsU0FBUixJQUFtQixDQUFDMU0sRUFBRTJJLEtBQUYsQ0FBUWlFLFFBQWhDLE1BQTRDN00sS0FBRyxZQUEvQyxHQUE2RCxJQUFJZ0wsTUFBSixDQUFXLE9BQUtoTCxDQUFMLEdBQU8sSUFBbEIsRUFBdUIsR0FBdkIsRUFBNEJtRyxJQUE1QixDQUFpQ2pELENBQWpDLENBQW5FO0FBQXVHLFNBQTVRLEVBQTZRZ08sYUFBWSxxQkFBU2hPLENBQVQsRUFBVztBQUFDLGNBQUdqRCxFQUFFMkksS0FBRixDQUFRcUUsYUFBUixDQUFzQi9KLENBQXRCLENBQUgsRUFBNEIsT0FBTSxDQUFDakQsRUFBRTJJLEtBQUYsQ0FBUXFFLGFBQVIsQ0FBc0IvSixDQUF0QixDQUFELEVBQTBCLENBQUMsQ0FBM0IsQ0FBTixDQUFvQyxLQUFJLElBQUlsRCxJQUFFLENBQUMsRUFBRCxFQUFJLFFBQUosRUFBYSxLQUFiLEVBQW1CLElBQW5CLEVBQXdCLEdBQXhCLENBQU4sRUFBbUNvRCxJQUFFLENBQXJDLEVBQXVDbEIsSUFBRWxDLEVBQUVtRCxNQUEvQyxFQUFzRGpCLElBQUVrQixDQUF4RCxFQUEwREEsR0FBMUQsRUFBOEQ7QUFBQyxnQkFBSU8sQ0FBSixDQUFNLElBQUdBLElBQUUsTUFBSVAsQ0FBSixHQUFNRixDQUFOLEdBQVFsRCxFQUFFb0QsQ0FBRixJQUFLRixFQUFFK00sT0FBRixDQUFVLEtBQVYsRUFBZ0IsVUFBUy9NLENBQVQsRUFBVztBQUFDLHFCQUFPQSxFQUFFOE4sV0FBRixFQUFQO0FBQXVCLGFBQW5ELENBQWYsRUFBb0U5SixFQUFFc0IsUUFBRixDQUFXdkksRUFBRTJJLEtBQUYsQ0FBUW9FLGFBQVIsQ0FBc0I5RyxLQUF0QixDQUE0QnZDLENBQTVCLENBQVgsQ0FBdkUsRUFBa0gsT0FBTzFELEVBQUUySSxLQUFGLENBQVFxRSxhQUFSLENBQXNCL0osQ0FBdEIsSUFBeUJTLENBQXpCLEVBQTJCLENBQUNBLENBQUQsRUFBRyxDQUFDLENBQUosQ0FBbEM7QUFBeUMsa0JBQU0sQ0FBQ1QsQ0FBRCxFQUFHLENBQUMsQ0FBSixDQUFOO0FBQWEsU0FBbGxCLEVBQTE4SSxFQUE4aEsrSCxRQUFPLEVBQUM0RixVQUFTLGtCQUFTM04sQ0FBVCxFQUFXO0FBQUMsY0FBSWxELENBQUo7QUFBQSxjQUFNb0QsSUFBRSxrQ0FBUjtBQUFBLGNBQTJDbEIsSUFBRSwyQ0FBN0MsQ0FBeUYsT0FBT2dCLElBQUVBLEVBQUUrTSxPQUFGLENBQVU3TSxDQUFWLEVBQVksVUFBU0YsQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhb0QsQ0FBYixFQUFlbEIsQ0FBZixFQUFpQjtBQUFDLG1CQUFPbEMsSUFBRUEsQ0FBRixHQUFJb0QsQ0FBSixHQUFNQSxDQUFOLEdBQVFsQixDQUFSLEdBQVVBLENBQWpCO0FBQW1CLFdBQWpELENBQUYsRUFBcURsQyxJQUFFa0MsRUFBRWlQLElBQUYsQ0FBT2pPLENBQVAsQ0FBdkQsRUFBaUVsRCxJQUFFLENBQUNxUSxTQUFTclEsRUFBRSxDQUFGLENBQVQsRUFBYyxFQUFkLENBQUQsRUFBbUJxUSxTQUFTclEsRUFBRSxDQUFGLENBQVQsRUFBYyxFQUFkLENBQW5CLEVBQXFDcVEsU0FBU3JRLEVBQUUsQ0FBRixDQUFULEVBQWMsRUFBZCxDQUFyQyxDQUFGLEdBQTBELENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMLENBQWxJO0FBQTBJLFNBQXpQLEVBQTBQOFAsZ0JBQWUsd0JBQVM1TSxDQUFULEVBQVc7QUFBQyxpQkFBTyxLQUFHQSxDQUFILElBQU0scURBQXFEaUQsSUFBckQsQ0FBMERqRCxDQUExRCxDQUFiO0FBQTBFLFNBQS9WLEVBQWdXa08sYUFBWSxxQkFBU2xPLENBQVQsRUFBVztBQUFDLGlCQUFNLG1CQUFrQmlELElBQWxCLENBQXVCakQsQ0FBdkIsSUFBMEIsS0FBMUIsR0FBZ0Msa0hBQWtIaUQsSUFBbEgsQ0FBdUhqRCxDQUF2SCxJQUEwSCxFQUExSCxHQUE2SDtBQUFuSztBQUF3SyxTQUFoaUIsRUFBaWlCbU8sZ0JBQWUsd0JBQVNuTyxDQUFULEVBQVc7QUFBQyxjQUFJbEQsSUFBRWtELEtBQUdBLEVBQUVvTyxPQUFGLENBQVV6SyxRQUFWLEdBQXFCWixXQUFyQixFQUFULENBQTRDLE9BQU0sNEpBQTJKRSxJQUEzSixDQUFnS25HLENBQWhLLElBQW1LLFFBQW5LLEdBQTRLLFVBQVVtRyxJQUFWLENBQWVuRyxDQUFmLElBQWtCLFdBQWxCLEdBQThCLFVBQVVtRyxJQUFWLENBQWVuRyxDQUFmLElBQWtCLFdBQWxCLEdBQThCLGFBQWFtRyxJQUFiLENBQWtCbkcsQ0FBbEIsSUFBcUIsT0FBckIsR0FBNkIsYUFBYW1HLElBQWIsQ0FBa0JuRyxDQUFsQixJQUFxQixpQkFBckIsR0FBdUM7QUFBbFQ7QUFBMFQsU0FBbDZCLEVBQW02QnVSLFVBQVMsa0JBQVNyTyxDQUFULEVBQVdsRCxDQUFYLEVBQWE7QUFBQ2tELFlBQUVzTyxTQUFGLEdBQVl0TyxFQUFFc08sU0FBRixDQUFZQyxHQUFaLENBQWdCelIsQ0FBaEIsQ0FBWixHQUErQmtELEVBQUV3TyxTQUFGLElBQWEsQ0FBQ3hPLEVBQUV3TyxTQUFGLENBQVl2TyxNQUFaLEdBQW1CLEdBQW5CLEdBQXVCLEVBQXhCLElBQTRCbkQsQ0FBeEU7QUFBMEUsU0FBcGdDLEVBQXFnQ2tMLGFBQVkscUJBQVNoSSxDQUFULEVBQVdsRCxDQUFYLEVBQWE7QUFBQ2tELFlBQUVzTyxTQUFGLEdBQVl0TyxFQUFFc08sU0FBRixDQUFZRyxNQUFaLENBQW1CM1IsQ0FBbkIsQ0FBWixHQUFrQ2tELEVBQUV3TyxTQUFGLEdBQVl4TyxFQUFFd08sU0FBRixDQUFZN0ssUUFBWixHQUF1Qm9KLE9BQXZCLENBQStCLElBQUlqRixNQUFKLENBQVcsWUFBVWhMLEVBQUU4RyxLQUFGLENBQVEsR0FBUixFQUFhOEksSUFBYixDQUFrQixHQUFsQixDQUFWLEdBQWlDLFNBQTVDLEVBQXNELElBQXRELENBQS9CLEVBQTJGLEdBQTNGLENBQTlDO0FBQThJLFNBQTdxQyxFQUFyaUssRUFBb3RNZ0Msa0JBQWlCLDBCQUFTMU8sQ0FBVCxFQUFXRSxDQUFYLEVBQWFPLENBQWIsRUFBZU8sQ0FBZixFQUFpQjtBQUFDLGlCQUFTbEMsQ0FBVCxDQUFXa0IsQ0FBWCxFQUFhRSxDQUFiLEVBQWU7QUFBQyxtQkFBU08sQ0FBVCxHQUFZO0FBQUNpQixpQkFBR2tELEVBQUVtQixnQkFBRixDQUFtQi9GLENBQW5CLEVBQXFCLFNBQXJCLEVBQStCLE1BQS9CLENBQUg7QUFBMEMsZUFBSXlCLElBQUUsQ0FBTixDQUFRLElBQUcsS0FBR3hFLENBQU4sRUFBUXdFLElBQUUyQyxFQUFFdUssR0FBRixDQUFNM08sQ0FBTixFQUFRRSxDQUFSLENBQUYsQ0FBUixLQUF5QjtBQUFDLGdCQUFJd0IsSUFBRSxDQUFDLENBQVAsQ0FBUyxJQUFHLG1CQUFtQnVCLElBQW5CLENBQXdCL0MsQ0FBeEIsS0FBNEIsTUFBSTBFLEVBQUU4SixnQkFBRixDQUFtQjFPLENBQW5CLEVBQXFCLFNBQXJCLENBQWhDLEtBQWtFMEIsSUFBRSxDQUFDLENBQUgsRUFBS2tELEVBQUVtQixnQkFBRixDQUFtQi9GLENBQW5CLEVBQXFCLFNBQXJCLEVBQStCNEUsRUFBRW1ELE1BQUYsQ0FBU29HLGNBQVQsQ0FBd0JuTyxDQUF4QixDQUEvQixDQUF2RSxHQUFtSSxDQUFDZ0IsQ0FBdkksRUFBeUk7QUFBQyxrQkFBRyxhQUFXZCxDQUFYLElBQWMsaUJBQWUwRSxFQUFFOEosZ0JBQUYsQ0FBbUIxTyxDQUFuQixFQUFxQixXQUFyQixFQUFrQzJELFFBQWxDLEdBQTZDWixXQUE3QyxFQUFoQyxFQUEyRjtBQUFDLG9CQUFJL0YsSUFBRWdELEVBQUU0TyxZQUFGLElBQWdCekwsV0FBV3lCLEVBQUU4SixnQkFBRixDQUFtQjFPLENBQW5CLEVBQXFCLGdCQUFyQixDQUFYLEtBQW9ELENBQXBFLEtBQXdFbUQsV0FBV3lCLEVBQUU4SixnQkFBRixDQUFtQjFPLENBQW5CLEVBQXFCLG1CQUFyQixDQUFYLEtBQXVELENBQS9ILEtBQW1JbUQsV0FBV3lCLEVBQUU4SixnQkFBRixDQUFtQjFPLENBQW5CLEVBQXFCLFlBQXJCLENBQVgsS0FBZ0QsQ0FBbkwsS0FBdUxtRCxXQUFXeUIsRUFBRThKLGdCQUFGLENBQW1CMU8sQ0FBbkIsRUFBcUIsZUFBckIsQ0FBWCxLQUFtRCxDQUExTyxDQUFOLENBQW1QLE9BQU9TLEtBQUl6RCxDQUFYO0FBQWEsbUJBQUcsWUFBVWtELENBQVYsSUFBYSxpQkFBZTBFLEVBQUU4SixnQkFBRixDQUFtQjFPLENBQW5CLEVBQXFCLFdBQXJCLEVBQWtDMkQsUUFBbEMsR0FBNkNaLFdBQTdDLEVBQS9CLEVBQTBGO0FBQUMsb0JBQUloRSxJQUFFaUIsRUFBRTZPLFdBQUYsSUFBZTFMLFdBQVd5QixFQUFFOEosZ0JBQUYsQ0FBbUIxTyxDQUFuQixFQUFxQixpQkFBckIsQ0FBWCxLQUFxRCxDQUFwRSxLQUF3RW1ELFdBQVd5QixFQUFFOEosZ0JBQUYsQ0FBbUIxTyxDQUFuQixFQUFxQixrQkFBckIsQ0FBWCxLQUFzRCxDQUE5SCxLQUFrSW1ELFdBQVd5QixFQUFFOEosZ0JBQUYsQ0FBbUIxTyxDQUFuQixFQUFxQixhQUFyQixDQUFYLEtBQWlELENBQW5MLEtBQXVMbUQsV0FBV3lCLEVBQUU4SixnQkFBRixDQUFtQjFPLENBQW5CLEVBQXFCLGNBQXJCLENBQVgsS0FBa0QsQ0FBek8sQ0FBTixDQUFrUCxPQUFPUyxLQUFJMUIsQ0FBWDtBQUFhO0FBQUMsaUJBQUkyRixDQUFKLENBQU1BLElBQUVoRSxFQUFFVixDQUFGLE1BQU9oQixDQUFQLEdBQVNsQyxFQUFFZ1MsZ0JBQUYsQ0FBbUI5TyxDQUFuQixFQUFxQixJQUFyQixDQUFULEdBQW9DVSxFQUFFVixDQUFGLEVBQUt3SyxhQUFMLEdBQW1COUosRUFBRVYsQ0FBRixFQUFLd0ssYUFBeEIsR0FBc0M5SixFQUFFVixDQUFGLEVBQUt3SyxhQUFMLEdBQW1CMU4sRUFBRWdTLGdCQUFGLENBQW1COU8sQ0FBbkIsRUFBcUIsSUFBckIsQ0FBL0YsRUFBMEgsa0JBQWdCRSxDQUFoQixLQUFvQkEsSUFBRSxnQkFBdEIsQ0FBMUgsRUFBa0t1QixJQUFFLE1BQUl4RSxDQUFKLElBQU8sYUFBV2lELENBQWxCLEdBQW9Cd0UsRUFBRWdLLGdCQUFGLENBQW1CeE8sQ0FBbkIsQ0FBcEIsR0FBMEN3RSxFQUFFeEUsQ0FBRixDQUE5TSxFQUFtTixDQUFDLE9BQUt1QixDQUFMLElBQVEsU0FBT0EsQ0FBaEIsTUFBcUJBLElBQUV6QixFQUFFZ0QsS0FBRixDQUFROUMsQ0FBUixDQUF2QixDQUFuTixFQUFzUE8sR0FBdFA7QUFBMFAsZUFBRyxXQUFTZ0IsQ0FBVCxJQUFZLDZCQUE2QndCLElBQTdCLENBQWtDL0MsQ0FBbEMsQ0FBZixFQUFvRDtBQUFDLGdCQUFJOEQsSUFBRWxGLEVBQUVrQixDQUFGLEVBQUksVUFBSixDQUFOLENBQXNCLENBQUMsWUFBVWdFLENBQVYsSUFBYSxlQUFhQSxDQUFiLElBQWdCLFlBQVlmLElBQVosQ0FBaUIvQyxDQUFqQixDQUE5QixNQUFxRHVCLElBQUUyQyxFQUFFcEUsQ0FBRixFQUFLNkMsUUFBTCxHQUFnQjNDLENBQWhCLElBQW1CLElBQTFFO0FBQWdGLGtCQUFPdUIsQ0FBUDtBQUFTLGFBQUlBLENBQUosQ0FBTSxJQUFHbUQsRUFBRTZCLEtBQUYsQ0FBUUMsVUFBUixDQUFtQnhHLENBQW5CLENBQUgsRUFBeUI7QUFBQyxjQUFJd0IsSUFBRXhCLENBQU47QUFBQSxjQUFRbEQsSUFBRTRILEVBQUU2QixLQUFGLENBQVFHLE9BQVIsQ0FBZ0JsRixDQUFoQixDQUFWLENBQTZCakIsTUFBSXpCLENBQUosS0FBUXlCLElBQUVtRSxFQUFFOEosZ0JBQUYsQ0FBbUIxTyxDQUFuQixFQUFxQjRFLEVBQUVnSixLQUFGLENBQVFJLFdBQVIsQ0FBb0JoUixDQUFwQixFQUF1QixDQUF2QixDQUFyQixDQUFWLEdBQTJENEgsRUFBRXVDLGNBQUYsQ0FBaUJULFVBQWpCLENBQTRCMUosQ0FBNUIsTUFBaUN5RCxJQUFFbUUsRUFBRXVDLGNBQUYsQ0FBaUJULFVBQWpCLENBQTRCMUosQ0FBNUIsRUFBK0IsU0FBL0IsRUFBeUNnRCxDQUF6QyxFQUEyQ1MsQ0FBM0MsQ0FBbkMsQ0FBM0QsRUFBNklnQixJQUFFbUQsRUFBRTZCLEtBQUYsQ0FBUW9HLFlBQVIsQ0FBcUJuTCxDQUFyQixFQUF1QmpCLENBQXZCLENBQS9JO0FBQXlLLFNBQWhPLE1BQXFPLElBQUdtRSxFQUFFdUMsY0FBRixDQUFpQlQsVUFBakIsQ0FBNEJ4RyxDQUE1QixDQUFILEVBQWtDO0FBQUMsY0FBSW5CLENBQUosRUFBTTJGLENBQU4sQ0FBUTNGLElBQUU2RixFQUFFdUMsY0FBRixDQUFpQlQsVUFBakIsQ0FBNEJ4RyxDQUE1QixFQUErQixNQUEvQixFQUFzQ0YsQ0FBdEMsQ0FBRixFQUEyQyxnQkFBY2pCLENBQWQsS0FBa0IyRixJQUFFNUYsRUFBRWtCLENBQUYsRUFBSTRFLEVBQUVnSixLQUFGLENBQVFJLFdBQVIsQ0FBb0JqUCxDQUFwQixFQUF1QixDQUF2QixDQUFKLENBQUYsRUFBaUM2RixFQUFFbUQsTUFBRixDQUFTNkUsY0FBVCxDQUF3QmxJLENBQXhCLEtBQTRCRSxFQUFFNkIsS0FBRixDQUFRd0YsU0FBUixDQUFrQi9MLENBQWxCLENBQTVCLEtBQW1Ed0UsSUFBRUUsRUFBRTZCLEtBQUYsQ0FBUXdGLFNBQVIsQ0FBa0IvTCxDQUFsQixFQUFxQixDQUFyQixDQUFyRCxDQUFuRCxDQUEzQyxFQUE2S3VCLElBQUVtRCxFQUFFdUMsY0FBRixDQUFpQlQsVUFBakIsQ0FBNEJ4RyxDQUE1QixFQUErQixTQUEvQixFQUF5Q0YsQ0FBekMsRUFBMkMwRSxDQUEzQyxDQUEvSztBQUE2TixhQUFHLENBQUMsU0FBU3pCLElBQVQsQ0FBY3hCLENBQWQsQ0FBSixFQUFxQixJQUFHZixFQUFFVixDQUFGLEtBQU1VLEVBQUVWLENBQUYsRUFBS2lKLEtBQVgsSUFBa0JyRSxFQUFFZ0osS0FBRixDQUFRRyxZQUFSLENBQXFCN04sQ0FBckIsQ0FBckI7QUFBNkMsY0FBRyxvQkFBb0IrQyxJQUFwQixDQUF5Qi9DLENBQXpCLENBQUgsRUFBK0IsSUFBRztBQUFDdUIsZ0JBQUV6QixFQUFFK08sT0FBRixHQUFZN08sQ0FBWixDQUFGO0FBQWlCLFdBQXJCLENBQXFCLE9BQU04RCxDQUFOLEVBQVE7QUFBQ3ZDLGdCQUFFLENBQUY7QUFBSSxXQUFqRSxNQUFzRUEsSUFBRXpCLEVBQUVnUCxZQUFGLENBQWU5TyxDQUFmLENBQUY7QUFBbkgsZUFBNEl1QixJQUFFM0MsRUFBRWtCLENBQUYsRUFBSTRFLEVBQUVnSixLQUFGLENBQVFJLFdBQVIsQ0FBb0I5TixDQUFwQixFQUF1QixDQUF2QixDQUFKLENBQUYsQ0FBaUMsT0FBTzBFLEVBQUVtRCxNQUFGLENBQVM2RSxjQUFULENBQXdCbkwsQ0FBeEIsTUFBNkJBLElBQUUsQ0FBL0IsR0FBa0MxRSxFQUFFZ08sS0FBRixJQUFTLENBQVQsSUFBWWpMLFFBQVFDLEdBQVIsQ0FBWSxTQUFPRyxDQUFQLEdBQVMsSUFBVCxHQUFjdUIsQ0FBMUIsQ0FBOUMsRUFBMkVBLENBQWxGO0FBQW9GLE9BQXYxUSxFQUF3MVFzRSxrQkFBaUIsMEJBQVMvRixDQUFULEVBQVdFLENBQVgsRUFBYWxCLENBQWIsRUFBZXlCLENBQWYsRUFBaUJPLENBQWpCLEVBQW1CO0FBQUMsWUFBSWxDLElBQUVvQixDQUFOLENBQVEsSUFBRyxhQUFXQSxDQUFkLEVBQWdCYyxFQUFFaU8sU0FBRixHQUFZak8sRUFBRWlPLFNBQUYsQ0FBWSxXQUFTak8sRUFBRWtPLFNBQXZCLElBQWtDbFEsQ0FBOUMsR0FBZ0QsV0FBU2dDLEVBQUVrTyxTQUFYLEdBQXFCcFMsRUFBRXFTLFFBQUYsQ0FBV25RLENBQVgsRUFBYWdDLEVBQUVvTyxjQUFmLENBQXJCLEdBQW9EdFMsRUFBRXFTLFFBQUYsQ0FBV25PLEVBQUVvTyxjQUFiLEVBQTRCcFEsQ0FBNUIsQ0FBcEcsQ0FBaEIsS0FBd0osSUFBRzRGLEVBQUV1QyxjQUFGLENBQWlCVCxVQUFqQixDQUE0QnhHLENBQTVCLEtBQWdDLGdCQUFjMEUsRUFBRXVDLGNBQUYsQ0FBaUJULFVBQWpCLENBQTRCeEcsQ0FBNUIsRUFBK0IsTUFBL0IsRUFBc0NGLENBQXRDLENBQWpELEVBQTBGNEUsRUFBRXVDLGNBQUYsQ0FBaUJULFVBQWpCLENBQTRCeEcsQ0FBNUIsRUFBK0IsUUFBL0IsRUFBd0NGLENBQXhDLEVBQTBDaEIsQ0FBMUMsR0FBNkNGLElBQUUsV0FBL0MsRUFBMkRFLElBQUUwQixFQUFFVixDQUFGLEVBQUtxSCxjQUFMLENBQW9CbkgsQ0FBcEIsQ0FBN0QsQ0FBMUYsS0FBa0w7QUFBQyxjQUFHMEUsRUFBRTZCLEtBQUYsQ0FBUUMsVUFBUixDQUFtQnhHLENBQW5CLENBQUgsRUFBeUI7QUFBQyxnQkFBSXVCLElBQUV2QixDQUFOO0FBQUEsZ0JBQVF3QixJQUFFa0QsRUFBRTZCLEtBQUYsQ0FBUUcsT0FBUixDQUFnQjFHLENBQWhCLENBQVYsQ0FBNkJPLElBQUVBLEtBQUdtRSxFQUFFOEosZ0JBQUYsQ0FBbUIxTyxDQUFuQixFQUFxQjBCLENBQXJCLENBQUwsRUFBNkIxQyxJQUFFNEYsRUFBRTZCLEtBQUYsQ0FBUXFHLFdBQVIsQ0FBb0JyTCxDQUFwQixFQUFzQnpDLENBQXRCLEVBQXdCeUIsQ0FBeEIsQ0FBL0IsRUFBMERQLElBQUV3QixDQUE1RDtBQUE4RCxlQUFHa0QsRUFBRXVDLGNBQUYsQ0FBaUJULFVBQWpCLENBQTRCeEcsQ0FBNUIsTUFBaUNsQixJQUFFNEYsRUFBRXVDLGNBQUYsQ0FBaUJULFVBQWpCLENBQTRCeEcsQ0FBNUIsRUFBK0IsUUFBL0IsRUFBd0NGLENBQXhDLEVBQTBDaEIsQ0FBMUMsQ0FBRixFQUErQ2tCLElBQUUwRSxFQUFFdUMsY0FBRixDQUFpQlQsVUFBakIsQ0FBNEJ4RyxDQUE1QixFQUErQixNQUEvQixFQUFzQ0YsQ0FBdEMsQ0FBbEYsR0FBNEhsQixJQUFFOEYsRUFBRWdKLEtBQUYsQ0FBUUksV0FBUixDQUFvQjlOLENBQXBCLEVBQXVCLENBQXZCLENBQTlILEVBQXdKLEtBQUdqRCxDQUE5SixFQUFnSyxJQUFHO0FBQUMrQyxjQUFFZ0QsS0FBRixDQUFRbEUsQ0FBUixJQUFXRSxDQUFYO0FBQWEsV0FBakIsQ0FBaUIsT0FBTWhDLENBQU4sRUFBUTtBQUFDRCxjQUFFZ08sS0FBRixJQUFTakwsUUFBUUMsR0FBUixDQUFZLCtCQUE2QmYsQ0FBN0IsR0FBK0IsU0FBL0IsR0FBeUNGLENBQXpDLEdBQTJDLEdBQXZELENBQVQ7QUFBcUUsV0FBL1AsTUFBb1E0QixFQUFFVixDQUFGLEtBQU1VLEVBQUVWLENBQUYsRUFBS2lKLEtBQVgsSUFBa0JyRSxFQUFFZ0osS0FBRixDQUFRRyxZQUFSLENBQXFCN04sQ0FBckIsQ0FBbEIsR0FBMENGLEVBQUVxUCxZQUFGLENBQWVuUCxDQUFmLEVBQWlCbEIsQ0FBakIsQ0FBMUMsR0FBOERnQixFQUFFZ0QsS0FBRixDQUFRbEUsQ0FBUixJQUFXRSxDQUF6RSxDQUEyRWpDLEVBQUVnTyxLQUFGLElBQVMsQ0FBVCxJQUFZakwsUUFBUUMsR0FBUixDQUFZLFNBQU9HLENBQVAsR0FBUyxJQUFULEdBQWNwQixDQUFkLEdBQWdCLEtBQWhCLEdBQXNCRSxDQUFsQyxDQUFaO0FBQWlELGdCQUFNLENBQUNGLENBQUQsRUFBR0UsQ0FBSCxDQUFOO0FBQVksT0FBanRTLEVBQWt0U3VJLHFCQUFvQiw2QkFBU3ZILENBQVQsRUFBVztBQUFDLGlCQUFTbEQsQ0FBVCxDQUFXQSxDQUFYLEVBQWE7QUFBQyxpQkFBT3FHLFdBQVd5QixFQUFFOEosZ0JBQUYsQ0FBbUIxTyxDQUFuQixFQUFxQmxELENBQXJCLENBQVgsQ0FBUDtBQUEyQyxhQUFJb0QsSUFBRSxFQUFOLENBQVMsSUFBRyxDQUFDakQsS0FBR0YsRUFBRTJJLEtBQUYsQ0FBUStELFNBQVIsSUFBbUIsQ0FBQzFNLEVBQUUySSxLQUFGLENBQVFpRSxRQUFoQyxLQUEyQ2pKLEVBQUVWLENBQUYsRUFBS2lKLEtBQW5ELEVBQXlEO0FBQUMsY0FBSWpLLElBQUUsRUFBQ3NRLFdBQVUsQ0FBQ3hTLEVBQUUsWUFBRixDQUFELEVBQWlCQSxFQUFFLFlBQUYsQ0FBakIsQ0FBWCxFQUE2Q3lTLE9BQU0sQ0FBQ3pTLEVBQUUsT0FBRixDQUFELENBQW5ELEVBQWdFMFMsT0FBTSxDQUFDMVMsRUFBRSxPQUFGLENBQUQsQ0FBdEUsRUFBbUYyUyxPQUFNLE1BQUkzUyxFQUFFLE9BQUYsQ0FBSixHQUFlLENBQUNBLEVBQUUsT0FBRixDQUFELEVBQVlBLEVBQUUsT0FBRixDQUFaLENBQWYsR0FBdUMsQ0FBQ0EsRUFBRSxRQUFGLENBQUQsRUFBYUEsRUFBRSxRQUFGLENBQWIsQ0FBaEksRUFBMEo0UyxRQUFPLENBQUM1UyxFQUFFLFNBQUYsQ0FBRCxFQUFjLENBQWQsRUFBZ0IsQ0FBaEIsQ0FBakssRUFBTixDQUEyTHNILEVBQUVsRCxJQUFGLENBQU9SLEVBQUVWLENBQUYsRUFBS3FILGNBQVosRUFBMkIsVUFBU3JILENBQVQsRUFBVztBQUFDLDBCQUFjaUQsSUFBZCxDQUFtQmpELENBQW5CLElBQXNCQSxJQUFFLFdBQXhCLEdBQW9DLFVBQVVpRCxJQUFWLENBQWVqRCxDQUFmLElBQWtCQSxJQUFFLE9BQXBCLEdBQTRCLFdBQVdpRCxJQUFYLENBQWdCakQsQ0FBaEIsTUFBcUJBLElBQUUsUUFBdkIsQ0FBaEUsRUFBaUdoQixFQUFFZ0IsQ0FBRixNQUFPRSxLQUFHRixJQUFFLEdBQUYsR0FBTWhCLEVBQUVnQixDQUFGLEVBQUswTSxJQUFMLENBQVUsR0FBVixDQUFOLEdBQXFCLElBQXhCLEVBQTZCLE9BQU8xTixFQUFFZ0IsQ0FBRixDQUEzQyxDQUFqRztBQUFrSixXQUF6TDtBQUEyTCxTQUFoYixNQUFvYjtBQUFDLGNBQUlTLENBQUosRUFBTU8sQ0FBTixDQUFRb0QsRUFBRWxELElBQUYsQ0FBT1IsRUFBRVYsQ0FBRixFQUFLcUgsY0FBWixFQUEyQixVQUFTdkssQ0FBVCxFQUFXO0FBQUMsbUJBQU8yRCxJQUFFQyxFQUFFVixDQUFGLEVBQUtxSCxjQUFMLENBQW9CdkssQ0FBcEIsQ0FBRixFQUF5QiwyQkFBeUJBLENBQXpCLElBQTRCa0UsSUFBRVAsQ0FBRixFQUFJLENBQUMsQ0FBakMsS0FBcUMsTUFBSXhELENBQUosSUFBTyxjQUFZSCxDQUFuQixLQUF1QkEsSUFBRSxRQUF6QixHQUFtQyxNQUFLb0QsS0FBR3BELElBQUUyRCxDQUFGLEdBQUksR0FBWixDQUF4RSxDQUFoQztBQUEwSCxXQUFqSyxHQUFtS08sTUFBSWQsSUFBRSxnQkFBY2MsQ0FBZCxHQUFnQixHQUFoQixHQUFvQmQsQ0FBMUIsQ0FBbks7QUFBZ00sV0FBRTZGLGdCQUFGLENBQW1CL0YsQ0FBbkIsRUFBcUIsV0FBckIsRUFBaUNFLENBQWpDO0FBQW9DLE9BQXI5VCxFQUFaLENBQW0rVDBFLEVBQUU2QixLQUFGLENBQVErRixRQUFSLElBQW1CNUgsRUFBRXVDLGNBQUYsQ0FBaUJxRixRQUFqQixFQUFuQixFQUErQ3pQLEVBQUUwTixJQUFGLEdBQU8sVUFBU3pLLENBQVQsRUFBV2xELENBQVgsRUFBYW9ELENBQWIsRUFBZTtBQUFDLFVBQUlPLElBQUV6QixDQUFOLENBQVEsT0FBT2dCLElBQUVnQixFQUFFaEIsQ0FBRixDQUFGLEVBQU9vRSxFQUFFbEQsSUFBRixDQUFPbEIsQ0FBUCxFQUFTLFVBQVNBLENBQVQsRUFBV2dCLENBQVgsRUFBYTtBQUFDLFlBQUdOLEVBQUVNLENBQUYsTUFBT2hDLENBQVAsSUFBVWpDLEVBQUV3RCxJQUFGLENBQU9TLENBQVAsQ0FBVixFQUFvQmQsTUFBSWxCLENBQTNCLEVBQTZCeUIsTUFBSXpCLENBQUosS0FBUXlCLElBQUUxRCxFQUFFb04sR0FBRixDQUFNdUUsZ0JBQU4sQ0FBdUIxTixDQUF2QixFQUF5QmxFLENBQXpCLENBQVYsRUFBN0IsS0FBd0U7QUFBQyxjQUFJZ0MsSUFBRS9CLEVBQUVvTixHQUFGLENBQU1wRSxnQkFBTixDQUF1Qi9FLENBQXZCLEVBQXlCbEUsQ0FBekIsRUFBMkJvRCxDQUEzQixDQUFOLENBQW9DLGdCQUFjcEIsRUFBRSxDQUFGLENBQWQsSUFBb0IvQixFQUFFb04sR0FBRixDQUFNNUMsbUJBQU4sQ0FBMEJ2RyxDQUExQixDQUFwQixFQUFpRFAsSUFBRTNCLENBQW5EO0FBQXFEO0FBQUMsT0FBMUwsQ0FBUCxFQUFtTTJCLENBQTFNO0FBQTRNLEtBQTFSLENBQTJSLElBQUlvRSxJQUFFLFNBQUZBLENBQUUsR0FBVTtBQUFDLGVBQVM3RSxDQUFULEdBQVk7QUFBQyxlQUFPbEIsSUFBRW1ILEVBQUUwSixPQUFGLElBQVcsSUFBYixHQUFrQmxPLENBQXpCO0FBQTJCLGdCQUFTaEIsQ0FBVCxHQUFZO0FBQUMsaUJBQVNULENBQVQsQ0FBV0EsQ0FBWCxFQUFhO0FBQUMsbUJBQVNqQixDQUFULENBQVdpQixDQUFYLEVBQWFsRCxDQUFiLEVBQWU7QUFBQyxnQkFBSW9ELElBQUVsQixDQUFOO0FBQUEsZ0JBQVF5QixJQUFFekIsQ0FBVjtBQUFBLGdCQUFZMEIsSUFBRTFCLENBQWQsQ0FBZ0IsT0FBT2dGLEVBQUVwRCxPQUFGLENBQVVaLENBQVYsS0FBY0UsSUFBRUYsRUFBRSxDQUFGLENBQUYsRUFBTyxDQUFDZ0UsRUFBRXBELE9BQUYsQ0FBVVosRUFBRSxDQUFGLENBQVYsQ0FBRCxJQUFrQixTQUFTaUQsSUFBVCxDQUFjakQsRUFBRSxDQUFGLENBQWQsQ0FBbEIsSUFBdUNnRSxFQUFFMkUsVUFBRixDQUFhM0ksRUFBRSxDQUFGLENBQWIsQ0FBdkMsSUFBMkQ0RSxFQUFFOEcsS0FBRixDQUFRQyxLQUFSLENBQWMxSSxJQUFkLENBQW1CakQsRUFBRSxDQUFGLENBQW5CLENBQTNELEdBQW9GVSxJQUFFVixFQUFFLENBQUYsQ0FBdEYsR0FBMkYsQ0FBQ2dFLEVBQUVzQixRQUFGLENBQVd0RixFQUFFLENBQUYsQ0FBWCxLQUFrQixDQUFDNEUsRUFBRThHLEtBQUYsQ0FBUUMsS0FBUixDQUFjMUksSUFBZCxDQUFtQmpELEVBQUUsQ0FBRixDQUFuQixDQUFuQixJQUE2Q2dFLEVBQUVwRCxPQUFGLENBQVVaLEVBQUUsQ0FBRixDQUFWLENBQTlDLE1BQWlFUyxJQUFFM0QsSUFBRWtELEVBQUUsQ0FBRixDQUFGLEdBQU8wQixFQUFFMUIsRUFBRSxDQUFGLENBQUYsRUFBT2xCLEVBQUU4RyxRQUFULENBQVQsRUFBNEI1RixFQUFFLENBQUYsTUFBT2hCLENBQVAsS0FBVzBCLElBQUVWLEVBQUUsQ0FBRixDQUFiLENBQTdGLENBQWhILElBQWtPRSxJQUFFRixDQUFwTyxFQUFzT2xELE1BQUkyRCxJQUFFQSxLQUFHM0IsRUFBRXJDLE1BQVgsQ0FBdE8sRUFBeVB1SCxFQUFFMkUsVUFBRixDQUFhekksQ0FBYixNQUFrQkEsSUFBRUEsRUFBRVMsSUFBRixDQUFPSyxDQUFQLEVBQVMyRCxDQUFULEVBQVdMLENBQVgsQ0FBcEIsQ0FBelAsRUFBNFJOLEVBQUUyRSxVQUFGLENBQWFqSSxDQUFiLE1BQWtCQSxJQUFFQSxFQUFFQyxJQUFGLENBQU9LLENBQVAsRUFBUzJELENBQVQsRUFBV0wsQ0FBWCxDQUFwQixDQUE1UixFQUErVCxDQUFDcEUsS0FBRyxDQUFKLEVBQU1PLENBQU4sRUFBUUMsQ0FBUixDQUF0VTtBQUFpVixvQkFBU3pELENBQVQsQ0FBVytDLENBQVgsRUFBYWxELENBQWIsRUFBZTtBQUFDLGdCQUFJb0QsQ0FBSixFQUFNbEIsQ0FBTixDQUFRLE9BQU9BLElBQUUsQ0FBQ2xDLEtBQUcsR0FBSixFQUFTNkcsUUFBVCxHQUFvQlosV0FBcEIsR0FBa0NnSyxPQUFsQyxDQUEwQyxVQUExQyxFQUFxRCxVQUFTL00sQ0FBVCxFQUFXO0FBQUMscUJBQU9FLElBQUVGLENBQUYsRUFBSSxFQUFYO0FBQWMsYUFBL0UsQ0FBRixFQUFtRkUsTUFBSUEsSUFBRTBFLEVBQUVtRCxNQUFGLENBQVNtRyxXQUFULENBQXFCbE8sQ0FBckIsQ0FBTixDQUFuRixFQUFrSCxDQUFDaEIsQ0FBRCxFQUFHa0IsQ0FBSCxDQUF6SDtBQUErSCxvQkFBU3FFLENBQVQsR0FBWTtBQUFDLGdCQUFJdkUsSUFBRSxFQUFDNFAsVUFBUzVPLEVBQUVrSyxVQUFGLElBQWNoTCxFQUFFK0ssSUFBMUIsRUFBK0JwSSxVQUFTK0IsRUFBRThKLGdCQUFGLENBQW1CMU4sQ0FBbkIsRUFBcUIsVUFBckIsQ0FBeEMsRUFBeUU2TyxVQUFTakwsRUFBRThKLGdCQUFGLENBQW1CMU4sQ0FBbkIsRUFBcUIsVUFBckIsQ0FBbEYsRUFBTjtBQUFBLGdCQUEwSGhDLElBQUVnQixFQUFFNkMsUUFBRixLQUFhbUUsRUFBRThJLFlBQWYsSUFBNkI5UCxFQUFFNFAsUUFBRixLQUFhNUksRUFBRStJLFVBQXhLO0FBQUEsZ0JBQW1MdFAsSUFBRVQsRUFBRTZQLFFBQUYsS0FBYTdJLEVBQUVnSixZQUFwTSxDQUFpTmhKLEVBQUUrSSxVQUFGLEdBQWEvUCxFQUFFNFAsUUFBZixFQUF3QjVJLEVBQUU4SSxZQUFGLEdBQWU5UCxFQUFFNkMsUUFBekMsRUFBa0RtRSxFQUFFZ0osWUFBRixHQUFlaFEsRUFBRTZQLFFBQW5FLENBQTRFLElBQUkvUSxJQUFFLEdBQU47QUFBQSxnQkFBVTJDLElBQUUsRUFBWixDQUFlLElBQUdoQixLQUFHekIsQ0FBTixFQUFReUMsRUFBRXdPLE1BQUYsR0FBU2pKLEVBQUVrSixVQUFYLEVBQXNCek8sRUFBRTBPLGdCQUFGLEdBQW1CbkosRUFBRW9KLG9CQUEzQyxFQUFnRTNPLEVBQUU0TyxpQkFBRixHQUFvQnJKLEVBQUVzSixxQkFBdEYsQ0FBUixLQUF3SDtBQUFDLGtCQUFJNU8sSUFBRWhCLEVBQUVNLENBQUYsRUFBS2lJLEtBQUwsR0FBVy9JLEVBQUVxUSxlQUFGLENBQWtCLDRCQUFsQixFQUErQyxNQUEvQyxDQUFYLEdBQWtFclEsRUFBRW9JLGFBQUYsQ0FBZ0IsS0FBaEIsQ0FBeEUsQ0FBK0Z2TCxFQUFFd0QsSUFBRixDQUFPbUIsQ0FBUCxHQUFVMUIsRUFBRTRQLFFBQUYsQ0FBV1ksV0FBWCxDQUF1QjlPLENBQXZCLENBQVYsRUFBb0MwQyxFQUFFbEQsSUFBRixDQUFPLENBQUMsVUFBRCxFQUFZLFdBQVosRUFBd0IsV0FBeEIsQ0FBUCxFQUE0QyxVQUFTbEIsQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhO0FBQUNDLGtCQUFFb04sR0FBRixDQUFNcEUsZ0JBQU4sQ0FBdUJyRSxDQUF2QixFQUF5QjVFLENBQXpCLEVBQTJCLFFBQTNCO0FBQXFDLGVBQS9GLENBQXBDLEVBQXFJQyxFQUFFb04sR0FBRixDQUFNcEUsZ0JBQU4sQ0FBdUJyRSxDQUF2QixFQUF5QixVQUF6QixFQUFvQzFCLEVBQUU2QyxRQUF0QyxDQUFySSxFQUFxTDlGLEVBQUVvTixHQUFGLENBQU1wRSxnQkFBTixDQUF1QnJFLENBQXZCLEVBQXlCLFVBQXpCLEVBQW9DMUIsRUFBRTZQLFFBQXRDLENBQXJMLEVBQXFPOVMsRUFBRW9OLEdBQUYsQ0FBTXBFLGdCQUFOLENBQXVCckUsQ0FBdkIsRUFBeUIsV0FBekIsRUFBcUMsYUFBckMsQ0FBck8sRUFBeVIwQyxFQUFFbEQsSUFBRixDQUFPLENBQUMsVUFBRCxFQUFZLFVBQVosRUFBdUIsT0FBdkIsRUFBK0IsV0FBL0IsRUFBMkMsV0FBM0MsRUFBdUQsUUFBdkQsQ0FBUCxFQUF3RSxVQUFTbEIsQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhO0FBQUNDLGtCQUFFb04sR0FBRixDQUFNcEUsZ0JBQU4sQ0FBdUJyRSxDQUF2QixFQUF5QjVFLENBQXpCLEVBQTJCZ0MsSUFBRSxHQUE3QjtBQUFrQyxlQUF4SCxDQUF6UixFQUFtWi9CLEVBQUVvTixHQUFGLENBQU1wRSxnQkFBTixDQUF1QnJFLENBQXZCLEVBQXlCLGFBQXpCLEVBQXVDNUMsSUFBRSxJQUF6QyxDQUFuWixFQUFrYzJDLEVBQUUwTyxnQkFBRixHQUFtQm5KLEVBQUVvSixvQkFBRixHQUF1QixDQUFDak4sV0FBV3lCLEVBQUU4SixnQkFBRixDQUFtQmhOLENBQW5CLEVBQXFCLE9BQXJCLEVBQTZCLElBQTdCLEVBQWtDLENBQUMsQ0FBbkMsQ0FBWCxLQUFtRCxDQUFwRCxJQUF1RDVDLENBQW5pQixFQUFxaUIyQyxFQUFFNE8saUJBQUYsR0FBb0JySixFQUFFc0oscUJBQUYsR0FBd0IsQ0FBQ25OLFdBQVd5QixFQUFFOEosZ0JBQUYsQ0FBbUJoTixDQUFuQixFQUFxQixRQUFyQixFQUE4QixJQUE5QixFQUFtQyxDQUFDLENBQXBDLENBQVgsS0FBb0QsQ0FBckQsSUFBd0Q1QyxDQUF6b0IsRUFBMm9CMkMsRUFBRXdPLE1BQUYsR0FBU2pKLEVBQUVrSixVQUFGLEdBQWEsQ0FBQy9NLFdBQVd5QixFQUFFOEosZ0JBQUYsQ0FBbUJoTixDQUFuQixFQUFxQixhQUFyQixDQUFYLEtBQWlELENBQWxELElBQXFENUMsQ0FBdHRCLEVBQXd0QmtCLEVBQUU0UCxRQUFGLENBQVdhLFdBQVgsQ0FBdUIvTyxDQUF2QixDQUF4dEI7QUFBa3ZCLG9CQUFPLFNBQU9zRixFQUFFMEosT0FBVCxLQUFtQjFKLEVBQUUwSixPQUFGLEdBQVV2TixXQUFXeUIsRUFBRThKLGdCQUFGLENBQW1CeE8sRUFBRStLLElBQXJCLEVBQTBCLFVBQTFCLENBQVgsS0FBbUQsRUFBaEYsR0FBb0YsU0FBT2pFLEVBQUUySixNQUFULEtBQWtCM0osRUFBRTJKLE1BQUYsR0FBU3hOLFdBQVdyRyxFQUFFOFQsVUFBYixJQUF5QixHQUFsQyxFQUFzQzVKLEVBQUU2SixNQUFGLEdBQVMxTixXQUFXckcsRUFBRWdVLFdBQWIsSUFBMEIsR0FBM0YsQ0FBcEYsRUFBb0xyUCxFQUFFaVAsT0FBRixHQUFVMUosRUFBRTBKLE9BQWhNLEVBQXdNalAsRUFBRWtQLE1BQUYsR0FBUzNKLEVBQUUySixNQUFuTixFQUEwTmxQLEVBQUVvUCxNQUFGLEdBQVM3SixFQUFFNkosTUFBck8sRUFBNE85VCxFQUFFZ08sS0FBRixJQUFTLENBQVQsSUFBWWpMLFFBQVFDLEdBQVIsQ0FBWSxrQkFBZ0JnUixLQUFLQyxTQUFMLENBQWV2UCxDQUFmLENBQTVCLEVBQThDVCxDQUE5QyxDQUF4UCxFQUF5U1MsQ0FBaFQ7QUFBa1QsZUFBRzNDLEVBQUV3TCxLQUFGLElBQVMsTUFBSTNGLENBQWhCLEVBQWtCLElBQUc7QUFBQzdGLGNBQUV3TCxLQUFGLENBQVEzSixJQUFSLENBQWErRCxDQUFiLEVBQWVBLENBQWY7QUFBa0IsV0FBdEIsQ0FBc0IsT0FBTTdILENBQU4sRUFBUTtBQUFDcUwsdUJBQVcsWUFBVTtBQUFDLG9CQUFNckwsQ0FBTjtBQUFRLGFBQTlCLEVBQStCLENBQS9CO0FBQWtDLGVBQUcsYUFBV3FKLENBQWQsRUFBZ0I7QUFBQyxnQkFBSXJCLENBQUo7QUFBQSxnQkFBTU0sQ0FBTjtBQUFBLGdCQUFRRSxDQUFSO0FBQUEsZ0JBQVVjLElBQUUsT0FBT2xELElBQVAsQ0FBWW5FLEVBQUVtUyxJQUFkLElBQW9CLE1BQXBCLEdBQTJCLEtBQXZDO0FBQUEsZ0JBQTZDN0ssSUFBRWpELFdBQVdyRSxFQUFFb0QsTUFBYixLQUFzQixDQUFyRSxDQUF1RXBELEVBQUVtUSxTQUFGLEdBQVlqTCxFQUFFQyxTQUFGLENBQVluRixFQUFFbVEsU0FBZCxLQUEwQmpMLEVBQUVHLE1BQUYsQ0FBU3JGLEVBQUVtUSxTQUFYLENBQTFCLElBQWlEblEsRUFBRW1RLFNBQUYsR0FBWW5RLEVBQUVtUSxTQUFGLENBQVksQ0FBWixLQUFnQm5RLEVBQUVtUSxTQUE5QixFQUF3Q3BLLElBQUUvRixFQUFFbVEsU0FBRixDQUFZLFdBQVM5SSxDQUFyQixDQUExQyxFQUFrRWQsSUFBRVIsSUFBRVQsRUFBRXBELENBQUYsRUFBSzZCLFFBQUwsR0FBZ0JzRCxFQUFFcEQsV0FBRixFQUFoQixDQUFGLEdBQW1DcUQsQ0FBeEosSUFBMkp0SCxFQUFFbVEsU0FBRixHQUFZLElBQW5MLElBQXlMcEssSUFBRTlILEVBQUUySSxLQUFGLENBQVFzRSxZQUFSLENBQXFCak4sRUFBRTJJLEtBQUYsQ0FBUSxtQkFBaUJTLENBQXpCLENBQXJCLENBQUYsRUFBb0RoQixJQUFFcEksRUFBRTJJLEtBQUYsQ0FBUXNFLFlBQVIsQ0FBcUJqTixFQUFFMkksS0FBRixDQUFRLG9CQUFrQixXQUFTUyxDQUFULEdBQVcsS0FBWCxHQUFpQixNQUFuQyxDQUFSLENBQXJCLENBQXRELEVBQWdJZCxJQUFFakIsRUFBRXBELENBQUYsRUFBS2tCLE1BQUwsR0FBY2lFLEVBQUVwRCxXQUFGLEVBQWQsSUFBK0JxRCxDQUExVixHQUE2VjNFLElBQUUsRUFBQ3lQLFFBQU8sRUFBQ25LLG1CQUFrQixDQUFDLENBQXBCLEVBQXNCUixZQUFXMUIsQ0FBakMsRUFBbUMyQixjQUFhM0IsQ0FBaEQsRUFBa0R3QixVQUFTaEIsQ0FBM0QsRUFBNkQ0QixVQUFTLEVBQXRFLEVBQXlFeEssUUFBT3FDLEVBQUVyQyxNQUFsRixFQUF5RnlLLFlBQVcsRUFBQytILFdBQVVuUSxFQUFFbVEsU0FBYixFQUF1QkMsV0FBVS9JLENBQWpDLEVBQW1DaUosZ0JBQWVqSyxDQUFsRCxFQUFwRyxFQUFSLEVBQWtLVSxTQUFRN0UsQ0FBMUssRUFBL1YsRUFBNGdCakUsRUFBRWdPLEtBQUYsSUFBU2pMLFFBQVFDLEdBQVIsQ0FBWSw0QkFBWixFQUF5QzBCLEVBQUV5UCxNQUEzQyxFQUFrRGxRLENBQWxELENBQXJoQjtBQUEwa0IsV0FBbHFCLE1BQXVxQixJQUFHLGNBQVlrRixDQUFmLEVBQWlCO0FBQUMsZ0JBQUcsQ0FBQ3hGLEVBQUVNLENBQUYsRUFBS21ILGVBQVQsRUFBeUIsT0FBTyxLQUFLL0QsRUFBRXRDLE9BQUYsQ0FBVWQsQ0FBVixFQUFZbEMsRUFBRTZDLEtBQWQsQ0FBWixDQUFpQyxXQUFTakIsRUFBRU0sQ0FBRixFQUFLbVEsSUFBTCxDQUFVckwsT0FBbkIsS0FBNkJwRixFQUFFTSxDQUFGLEVBQUttUSxJQUFMLENBQVVyTCxPQUFWLEdBQWtCLE1BQS9DLEdBQXVELGFBQVdwRixFQUFFTSxDQUFGLEVBQUttUSxJQUFMLENBQVVuTCxVQUFyQixLQUFrQ3RGLEVBQUVNLENBQUYsRUFBS21RLElBQUwsQ0FBVW5MLFVBQVYsR0FBcUIsU0FBdkQsQ0FBdkQsRUFBeUh0RixFQUFFTSxDQUFGLEVBQUttUSxJQUFMLENBQVV6SixJQUFWLEdBQWUsQ0FBQyxDQUF6SSxFQUEySWhILEVBQUVNLENBQUYsRUFBS21RLElBQUwsQ0FBVTdHLEtBQVYsR0FBZ0IsSUFBM0osRUFBZ0s1SixFQUFFTSxDQUFGLEVBQUttUSxJQUFMLENBQVVsSixRQUFWLEdBQW1CLElBQW5MLEVBQXdMekQsRUFBRS9ILE1BQUYsSUFBVSxPQUFPcUMsRUFBRXJDLE1BQTNNLEVBQWtOK0gsRUFBRW9CLFFBQUYsSUFBWSxPQUFPOUcsRUFBRThHLFFBQXZPLEVBQWdQOUcsSUFBRXNGLEVBQUUxSCxNQUFGLENBQVMsRUFBVCxFQUFZZ0UsRUFBRU0sQ0FBRixFQUFLbVEsSUFBakIsRUFBc0JyUyxDQUF0QixDQUFsUCxDQUEyUSxJQUFJd0gsSUFBRWxDLEVBQUUxSCxNQUFGLENBQVMsQ0FBQyxDQUFWLEVBQVksRUFBWixFQUFlZ0UsRUFBRU0sQ0FBRixFQUFLbUgsZUFBcEIsQ0FBTixDQUEyQyxLQUFJLElBQUl4QixDQUFSLElBQWFMLENBQWI7QUFBZSxrQkFBRyxjQUFZSyxDQUFmLEVBQWlCO0FBQUMsb0JBQUlFLElBQUVQLEVBQUVLLENBQUYsRUFBS0osVUFBWCxDQUFzQkQsRUFBRUssQ0FBRixFQUFLSixVQUFMLEdBQWdCRCxFQUFFSyxDQUFGLEVBQUtILFlBQUwsR0FBa0JGLEVBQUVLLENBQUYsRUFBS04sUUFBdkMsRUFBZ0RDLEVBQUVLLENBQUYsRUFBS04sUUFBTCxHQUFjUSxDQUE5RCxFQUFnRTdDLEVBQUVtRixhQUFGLENBQWdCM0UsQ0FBaEIsTUFBcUI4QixFQUFFSyxDQUFGLEVBQUtsSyxNQUFMLEdBQVlxQyxFQUFFckMsTUFBbkMsQ0FBaEUsRUFBMkdNLEVBQUVnTyxLQUFGLElBQVNqTCxRQUFRQyxHQUFSLENBQVksOEJBQTRCNEcsQ0FBNUIsR0FBOEIsS0FBOUIsR0FBb0NvSyxLQUFLQyxTQUFMLENBQWUxSyxFQUFFSyxDQUFGLENBQWYsQ0FBaEQsRUFBcUUzRixDQUFyRSxDQUFwSDtBQUE0TDtBQUFuUCxhQUFtUFMsSUFBRTZFLENBQUY7QUFBSSxXQUF6bkIsTUFBOG5CLElBQUcsWUFBVUosQ0FBYixFQUFlO0FBQUMsZ0JBQUlJLENBQUosQ0FBTTVGLEVBQUVNLENBQUYsRUFBS21ILGVBQUwsSUFBc0J6SCxFQUFFTSxDQUFGLEVBQUsyRyxXQUFMLEtBQW1CLENBQUMsQ0FBMUMsS0FBOENyQixJQUFFNUYsRUFBRU0sQ0FBRixFQUFLbUgsZUFBckQsR0FBc0UvRCxFQUFFbEQsSUFBRixDQUFPdUQsQ0FBUCxFQUFTLFVBQVN6RSxDQUFULEVBQVdsRCxDQUFYLEVBQWE7QUFBQyxrQkFBR2dMLE9BQU8sTUFBSWxELEVBQUVnRCxLQUFGLENBQVFtRSxNQUFSLENBQWVXLElBQWYsQ0FBb0IsS0FBcEIsQ0FBSixHQUErQixHQUF0QyxFQUEyQ3pKLElBQTNDLENBQWdEakQsQ0FBaEQsQ0FBSCxFQUFzRDtBQUFDLG9CQUFJRSxJQUFFbkIsRUFBRWpDLENBQUYsRUFBSSxDQUFDLENBQUwsQ0FBTjtBQUFBLG9CQUFjMkQsSUFBRVAsRUFBRSxDQUFGLENBQWhCO0FBQUEsb0JBQXFCYyxJQUFFZCxFQUFFLENBQUYsQ0FBdkI7QUFBQSxvQkFBNEJRLElBQUVSLEVBQUUsQ0FBRixDQUE5QixDQUFtQyxJQUFHMEUsRUFBRThHLEtBQUYsQ0FBUUMsS0FBUixDQUFjMUksSUFBZCxDQUFtQnhDLENBQW5CLENBQUgsRUFBeUI7QUFBQyx1QkFBSSxJQUFJM0IsSUFBRSxDQUFDLEtBQUQsRUFBTyxPQUFQLEVBQWUsTUFBZixDQUFOLEVBQTZCMkMsSUFBRW1ELEVBQUVtRCxNQUFGLENBQVM0RixRQUFULENBQWtCbE4sQ0FBbEIsQ0FBL0IsRUFBb0RpQixJQUFFaEIsSUFBRWtFLEVBQUVtRCxNQUFGLENBQVM0RixRQUFULENBQWtCak4sQ0FBbEIsQ0FBRixHQUF1QjFCLENBQTdFLEVBQStFaEMsSUFBRSxDQUFyRixFQUF1RkEsSUFBRThCLEVBQUVtQixNQUEzRixFQUFrR2pELEdBQWxHLEVBQXNHO0FBQUMsd0JBQUlvSCxJQUFFLENBQUMzQyxFQUFFekUsQ0FBRixDQUFELENBQU4sQ0FBYWdFLEtBQUdvRCxFQUFFdkMsSUFBRixDQUFPYixDQUFQLENBQUgsRUFBYVUsTUFBSTFDLENBQUosSUFBT29GLEVBQUV2QyxJQUFGLENBQU9ILEVBQUUxRSxDQUFGLENBQVAsQ0FBcEIsRUFBaUN5SCxFQUFFekUsSUFBRWxCLEVBQUU5QixDQUFGLENBQUosSUFBVW9ILENBQTNDO0FBQTZDLDBCQUFPSyxFQUFFekUsQ0FBRixDQUFQO0FBQVk7QUFBQztBQUFDLGFBQTFULENBQXRFLENBQWtZLEtBQUksSUFBSW9SLENBQVIsSUFBYTNNLENBQWIsRUFBZTtBQUFDLGtCQUFJNE0sSUFBRXRTLEVBQUUwRixFQUFFMk0sQ0FBRixDQUFGLENBQU47QUFBQSxrQkFBY0UsSUFBRUQsRUFBRSxDQUFGLENBQWhCO0FBQUEsa0JBQXFCOVUsSUFBRThVLEVBQUUsQ0FBRixDQUF2QjtBQUFBLGtCQUE0QkUsSUFBRUYsRUFBRSxDQUFGLENBQTlCLENBQW1DRCxJQUFFeE0sRUFBRWdKLEtBQUYsQ0FBUUMsU0FBUixDQUFrQnVELENBQWxCLENBQUYsQ0FBdUIsSUFBSUksSUFBRTVNLEVBQUU2QixLQUFGLENBQVFHLE9BQVIsQ0FBZ0J3SyxDQUFoQixDQUFOO0FBQUEsa0JBQXlCSyxJQUFFLENBQUMsQ0FBNUIsQ0FBOEIsSUFBRy9RLEVBQUVNLENBQUYsRUFBS2lJLEtBQUwsSUFBWSxZQUFVdUksQ0FBdEIsSUFBeUI1TSxFQUFFZ0osS0FBRixDQUFRSSxXQUFSLENBQW9Cd0QsQ0FBcEIsRUFBdUIsQ0FBdkIsTUFBNEIsQ0FBQyxDQUF0RCxJQUF5RDVNLEVBQUV1QyxjQUFGLENBQWlCVCxVQUFqQixDQUE0QjhLLENBQTVCLE1BQWlDeFMsQ0FBN0YsRUFBK0Y7QUFBQyxpQkFBQ0YsRUFBRWdILE9BQUYsS0FBWTlHLENBQVosSUFBZSxTQUFPRixFQUFFZ0gsT0FBeEIsSUFBaUMsV0FBU2hILEVBQUVnSCxPQUE1QyxJQUFxRGhILEVBQUVrSCxVQUFGLEtBQWVoSCxDQUFmLElBQWtCLGFBQVdGLEVBQUVrSCxVQUFyRixLQUFrRyxpQkFBaUIvQyxJQUFqQixDQUFzQm1PLENBQXRCLENBQWxHLElBQTRILENBQUNHLENBQTdILElBQWdJLE1BQUlELENBQXBJLEtBQXdJQyxJQUFFLENBQTFJLEdBQTZJelMsRUFBRXlMLFlBQUYsSUFBZ0JqRSxDQUFoQixJQUFtQkEsRUFBRThLLENBQUYsQ0FBbkIsSUFBeUJHLE1BQUl2UyxDQUFKLEtBQVF1UyxJQUFFakwsRUFBRThLLENBQUYsRUFBSy9LLFFBQUwsR0FBY0MsRUFBRThLLENBQUYsRUFBS25LLFFBQTdCLEdBQXVDd0ssSUFBRS9RLEVBQUVNLENBQUYsRUFBSzhGLHNCQUFMLENBQTRCMEssQ0FBNUIsQ0FBbEUsSUFBa0c1TSxFQUFFNkIsS0FBRixDQUFRQyxVQUFSLENBQW1CMEssQ0FBbkIsSUFBc0JHLE1BQUl2UyxDQUFKLElBQU95UyxJQUFFN00sRUFBRThKLGdCQUFGLENBQW1CMU4sQ0FBbkIsRUFBcUJ3USxDQUFyQixDQUFGLEVBQTBCRCxJQUFFM00sRUFBRThKLGdCQUFGLENBQW1CMU4sQ0FBbkIsRUFBcUJvUSxDQUFyQixFQUF1QkssQ0FBdkIsQ0FBbkMsSUFBOERBLElBQUU3TSxFQUFFNkIsS0FBRixDQUFRd0YsU0FBUixDQUFrQnVGLENBQWxCLEVBQXFCLENBQXJCLENBQXRGLEdBQThHRCxNQUFJdlMsQ0FBSixLQUFRdVMsSUFBRTNNLEVBQUU4SixnQkFBRixDQUFtQjFOLENBQW5CLEVBQXFCb1EsQ0FBckIsQ0FBVixDQUE3VixDQUFnWSxJQUFJTSxDQUFKO0FBQUEsb0JBQU1DLENBQU47QUFBQSxvQkFBUUMsQ0FBUjtBQUFBLG9CQUFVQyxJQUFFLENBQUMsQ0FBYixDQUFlLElBQUdILElBQUV6VSxFQUFFbVUsQ0FBRixFQUFJRyxDQUFKLENBQUYsRUFBU0EsSUFBRUcsRUFBRSxDQUFGLENBQVgsRUFBZ0JFLElBQUVGLEVBQUUsQ0FBRixDQUFsQixFQUF1QkEsSUFBRXpVLEVBQUVtVSxDQUFGLEVBQUlFLENBQUosQ0FBekIsRUFBZ0NBLElBQUVJLEVBQUUsQ0FBRixFQUFLM0UsT0FBTCxDQUFhLGFBQWIsRUFBMkIsVUFBUy9NLENBQVQsRUFBV2xELENBQVgsRUFBYTtBQUFDLHlCQUFPK1UsSUFBRS9VLENBQUYsRUFBSSxFQUFYO0FBQWMsaUJBQXZELENBQWxDLEVBQTJGNlUsSUFBRUQsRUFBRSxDQUFGLENBQTdGLEVBQWtHSCxJQUFFcE8sV0FBV29PLENBQVgsS0FBZSxDQUFuSCxFQUFxSEQsSUFBRW5PLFdBQVdtTyxDQUFYLEtBQWUsQ0FBdEksRUFBd0ksUUFBTUssQ0FBTixLQUFVLDBCQUEwQjFPLElBQTFCLENBQStCbU8sQ0FBL0IsS0FBbUNFLEtBQUcsR0FBSCxFQUFPSyxJQUFFLElBQTVDLElBQWtELFNBQVMxTyxJQUFULENBQWNtTyxDQUFkLEtBQWtCRSxLQUFHLEdBQUgsRUFBT0ssSUFBRSxFQUEzQixJQUErQixxQkFBcUIxTyxJQUFyQixDQUEwQm1PLENBQTFCLE1BQStCRSxJQUFFQSxJQUFFLEdBQUYsR0FBTSxHQUFSLEVBQVlLLElBQUUsRUFBN0MsQ0FBM0YsQ0FBeEksRUFBcVIsUUFBUTFPLElBQVIsQ0FBYTRPLENBQWIsQ0FBeFIsRUFBd1NGLElBQUVDLENBQUYsQ0FBeFMsS0FBaVQsSUFBR0EsTUFBSUQsQ0FBSixJQUFPLE1BQUlKLENBQWQsRUFBZ0IsSUFBRyxNQUFJRCxDQUFQLEVBQVNLLElBQUVDLENBQUYsQ0FBVCxLQUFpQjtBQUFDblIsc0JBQUVBLEtBQUc4RCxHQUFMLENBQVMsSUFBSXVOLElBQUUsb0RBQW9EN08sSUFBcEQsQ0FBeURtTyxDQUF6RCxLQUE2RCxLQUFLbk8sSUFBTCxDQUFVbU8sQ0FBVixDQUE3RCxJQUEyRSxRQUFNQSxDQUFqRixHQUFtRixHQUFuRixHQUF1RixHQUE3RixDQUFpRyxRQUFPUSxDQUFQLEdBQVUsS0FBSSxHQUFKO0FBQVFMLDJCQUFHLFFBQU1PLENBQU4sR0FBUXJSLEVBQUUwUCxnQkFBVixHQUEyQjFQLEVBQUU0UCxpQkFBaEMsQ0FBa0QsTUFBTSxLQUFJLElBQUo7QUFBUyw0QkFBTTtBQUFRa0IsMkJBQUc5USxFQUFFbVIsSUFBRSxNQUFKLENBQUgsQ0FBakcsQ0FBZ0gsUUFBT0QsQ0FBUCxHQUFVLEtBQUksR0FBSjtBQUFRSiwyQkFBRyxLQUFHLFFBQU1PLENBQU4sR0FBUXJSLEVBQUUwUCxnQkFBVixHQUEyQjFQLEVBQUU0UCxpQkFBaEMsQ0FBSCxDQUFzRCxNQUFNLEtBQUksSUFBSjtBQUFTLDRCQUFNO0FBQVFrQiwyQkFBRyxJQUFFOVEsRUFBRWtSLElBQUUsTUFBSixDQUFMLENBQXJHO0FBQXVILHlCQUFPRSxDQUFQLEdBQVUsS0FBSSxHQUFKO0FBQVFQLHdCQUFFQyxJQUFFRCxDQUFKLENBQU0sTUFBTSxLQUFJLEdBQUo7QUFBUUEsd0JBQUVDLElBQUVELENBQUosQ0FBTSxNQUFNLEtBQUksR0FBSjtBQUFRQSx3QkFBRUMsSUFBRUQsQ0FBSixDQUFNLE1BQU0sS0FBSSxHQUFKO0FBQVFBLHdCQUFFQyxJQUFFRCxDQUFKLENBQTlFLENBQW9GN1AsRUFBRTJQLENBQUYsSUFBSyxFQUFDckssbUJBQWtCMEssQ0FBbkIsRUFBcUJsTCxZQUFXZ0wsQ0FBaEMsRUFBa0MvSyxjQUFhK0ssQ0FBL0MsRUFBaURsTCxVQUFTaUwsQ0FBMUQsRUFBNERySyxVQUFTMEssQ0FBckUsRUFBdUVsVixRQUFPRixDQUE5RSxFQUFMLEVBQXNGUSxFQUFFZ08sS0FBRixJQUFTakwsUUFBUUMsR0FBUixDQUFZLHNCQUFvQnFSLENBQXBCLEdBQXNCLEtBQXRCLEdBQTRCTCxLQUFLQyxTQUFMLENBQWV2UCxFQUFFMlAsQ0FBRixDQUFmLENBQXhDLEVBQTZEcFEsQ0FBN0QsQ0FBL0Y7QUFBK0osZUFBdDRDLE1BQTI0Q2pFLEVBQUVnTyxLQUFGLElBQVNqTCxRQUFRQyxHQUFSLENBQVksZUFBYXlSLENBQWIsR0FBZSxxQ0FBM0IsQ0FBVDtBQUEyRSxlQUFFM0wsT0FBRixHQUFVN0UsQ0FBVjtBQUFZLGFBQUU2RSxPQUFGLEtBQVlqQixFQUFFbUQsTUFBRixDQUFTc0csUUFBVCxDQUFrQnJOLENBQWxCLEVBQW9CLG9CQUFwQixHQUEwQytRLEVBQUVsUSxJQUFGLENBQU9KLENBQVAsQ0FBMUMsRUFBb0QsT0FBSzNDLEVBQUU2QyxLQUFQLEtBQWVqQixFQUFFTSxDQUFGLEVBQUttSCxlQUFMLEdBQXFCMUcsQ0FBckIsRUFBdUJmLEVBQUVNLENBQUYsRUFBS21RLElBQUwsR0FBVXJTLENBQWhELENBQXBELEVBQXVHNEIsRUFBRU0sQ0FBRixFQUFLMkcsV0FBTCxHQUFpQixDQUFDLENBQXpILEVBQTJIaEQsTUFBSUwsSUFBRSxDQUFOLElBQVN2SCxFQUFFMkksS0FBRixDQUFRQyxLQUFSLENBQWM5RCxJQUFkLENBQW1CLENBQUNrUSxDQUFELEVBQUdyTixDQUFILEVBQUs1RixDQUFMLEVBQU8sSUFBUCxFQUFZbUgsRUFBRStMLFFBQWQsQ0FBbkIsR0FBNENqVixFQUFFMkksS0FBRixDQUFRK0IsU0FBUixLQUFvQixDQUFDLENBQXJCLEtBQXlCMUssRUFBRTJJLEtBQUYsQ0FBUStCLFNBQVIsR0FBa0IsQ0FBQyxDQUFuQixFQUFxQnpLLEdBQTlDLENBQXJELElBQXlHMkgsR0FBaFA7QUFBcVAsYUFBSWxFLENBQUo7QUFBQSxZQUFNTyxJQUFFLElBQVI7QUFBQSxZQUFhbEMsSUFBRXNGLEVBQUUxSCxNQUFGLENBQVMsRUFBVCxFQUFZSyxFQUFFMEksUUFBZCxFQUF1QmpCLENBQXZCLENBQWY7QUFBQSxZQUF5Qy9DLElBQUUsRUFBM0MsQ0FBOEMsUUFBT2YsRUFBRU0sQ0FBRixNQUFPaEMsQ0FBUCxJQUFVakMsRUFBRXdELElBQUYsQ0FBT1MsQ0FBUCxDQUFWLEVBQW9CbUMsV0FBV3JFLEVBQUVzSixLQUFiLEtBQXFCdEosRUFBRTZDLEtBQUYsS0FBVSxDQUFDLENBQWhDLElBQW1DeUMsRUFBRXpDLEtBQUYsQ0FBUVgsQ0FBUixFQUFVbEMsRUFBRTZDLEtBQVosRUFBa0IsVUFBUzNCLENBQVQsRUFBVztBQUFDakQsWUFBRWtWLHNCQUFGLEdBQXlCLENBQUMsQ0FBMUIsRUFBNEJ2UixFQUFFTSxDQUFGLEVBQUtrUixVQUFMLEdBQWdCLEVBQUNoSyxZQUFXQSxXQUFXbEksQ0FBWCxFQUFhbUQsV0FBV3JFLEVBQUVzSixLQUFiLENBQWIsQ0FBWixFQUE4QytKLE1BQUtuUyxDQUFuRCxFQUE1QztBQUFrRyxTQUFoSSxDQUF2RCxFQUF5TGxCLEVBQUU4RyxRQUFGLENBQVdqQyxRQUFYLEdBQXNCWixXQUF0QixFQUFoTSxHQUFxTyxLQUFJLE1BQUo7QUFBV2pFLGNBQUU4RyxRQUFGLEdBQVcsR0FBWCxDQUFlLE1BQU0sS0FBSSxRQUFKO0FBQWE5RyxjQUFFOEcsUUFBRixHQUFXckIsQ0FBWCxDQUFhLE1BQU0sS0FBSSxNQUFKO0FBQVd6RixjQUFFOEcsUUFBRixHQUFXLEdBQVgsQ0FBZSxNQUFNO0FBQVE5RyxjQUFFOEcsUUFBRixHQUFXekMsV0FBV3JFLEVBQUU4RyxRQUFiLEtBQXdCLENBQW5DLENBQTdVLENBQWtYN0ksRUFBRTJOLElBQUYsS0FBUyxDQUFDLENBQVYsS0FBYzNOLEVBQUUyTixJQUFGLEtBQVMsQ0FBQyxDQUFWLEdBQVk1TCxFQUFFOEcsUUFBRixHQUFXOUcsRUFBRXNKLEtBQUYsR0FBUSxDQUEvQixJQUFrQ3RKLEVBQUU4RyxRQUFGLElBQVl6QyxXQUFXcEcsRUFBRTJOLElBQWIsS0FBb0IsQ0FBaEMsRUFBa0M1TCxFQUFFc0osS0FBRixJQUFTakYsV0FBV3BHLEVBQUUyTixJQUFiLEtBQW9CLENBQWpHLENBQWQsR0FBbUg1TCxFQUFFckMsTUFBRixHQUFTaUYsRUFBRTVDLEVBQUVyQyxNQUFKLEVBQVdxQyxFQUFFOEcsUUFBYixDQUE1SCxFQUFtSjlHLEVBQUV3TCxLQUFGLElBQVMsQ0FBQ3RHLEVBQUUyRSxVQUFGLENBQWE3SixFQUFFd0wsS0FBZixDQUFWLEtBQWtDeEwsRUFBRXdMLEtBQUYsR0FBUSxJQUExQyxDQUFuSixFQUFtTXhMLEVBQUUwSSxRQUFGLElBQVksQ0FBQ3hELEVBQUUyRSxVQUFGLENBQWE3SixFQUFFMEksUUFBZixDQUFiLEtBQXdDMUksRUFBRTBJLFFBQUYsR0FBVyxJQUFuRCxDQUFuTSxFQUE0UDFJLEVBQUVtSixRQUFGLElBQVksQ0FBQ2pFLEVBQUUyRSxVQUFGLENBQWE3SixFQUFFbUosUUFBZixDQUFiLEtBQXdDbkosRUFBRW1KLFFBQUYsR0FBVyxJQUFuRCxDQUE1UCxFQUFxVG5KLEVBQUVnSCxPQUFGLEtBQVk5RyxDQUFaLElBQWUsU0FBT0YsRUFBRWdILE9BQXhCLEtBQWtDaEgsRUFBRWdILE9BQUYsR0FBVWhILEVBQUVnSCxPQUFGLENBQVVuQyxRQUFWLEdBQXFCWixXQUFyQixFQUFWLEVBQTZDLFdBQVNqRSxFQUFFZ0gsT0FBWCxLQUFxQmhILEVBQUVnSCxPQUFGLEdBQVUvSSxFQUFFb04sR0FBRixDQUFNcEMsTUFBTixDQUFhb0csY0FBYixDQUE0Qm5OLENBQTVCLENBQS9CLENBQS9FLENBQXJULEVBQW9jbEMsRUFBRWtILFVBQUYsS0FBZWhILENBQWYsSUFBa0IsU0FBT0YsRUFBRWtILFVBQTNCLEtBQXdDbEgsRUFBRWtILFVBQUYsR0FBYWxILEVBQUVrSCxVQUFGLENBQWFyQyxRQUFiLEdBQXdCWixXQUF4QixFQUFyRCxDQUFwYyxFQUFnaUJqRSxFQUFFc0ksUUFBRixHQUFXdEksRUFBRXNJLFFBQUYsSUFBWXJLLEVBQUUySSxLQUFGLENBQVE0RCxRQUFwQixJQUE4QixDQUFDdk0sRUFBRTJJLEtBQUYsQ0FBUWdFLGFBQWxsQixFQUFnbUI1SyxFQUFFNkMsS0FBRixLQUFVLENBQUMsQ0FBWCxHQUFhN0MsRUFBRXNKLEtBQUYsR0FBUUYsV0FBV2xJLENBQVgsRUFBYWxCLEVBQUVzSixLQUFmLENBQVIsR0FBOEJwSSxHQUEzQyxHQUErQ29FLEVBQUV6QyxLQUFGLENBQVFYLENBQVIsRUFBVWxDLEVBQUU2QyxLQUFaLEVBQWtCLFVBQVM3RSxDQUFULEVBQVdvRCxDQUFYLEVBQWE7QUFBQyxpQkFBT0EsTUFBSSxDQUFDLENBQUwsSUFBUStGLEVBQUUwSixPQUFGLElBQVcxSixFQUFFK0wsUUFBRixDQUFXdE4sQ0FBWCxDQUFYLEVBQXlCLENBQUMsQ0FBbEMsS0FBc0MzSCxFQUFFa1Ysc0JBQUYsR0FBeUIsQ0FBQyxDQUExQixFQUE0QixLQUFLalMsRUFBRWxELENBQUYsQ0FBdkUsQ0FBUDtBQUFvRixTQUFwSCxDQUEvb0IsRUFBcXdCLE9BQUtnQyxFQUFFNkMsS0FBUCxJQUFjLFNBQU83QyxFQUFFNkMsS0FBdkIsSUFBOEIsaUJBQWV5QyxFQUFFekMsS0FBRixDQUFRWCxDQUFSLEVBQVcsQ0FBWCxDQUE3QyxJQUE0RG9ELEVBQUV0QyxPQUFGLENBQVVkLENBQVYsQ0FBajBCO0FBQTgwQixXQUFJbEMsQ0FBSjtBQUFBLFVBQU0yQyxDQUFOO0FBQUEsVUFBUXhFLENBQVI7QUFBQSxVQUFVeUgsQ0FBVjtBQUFBLFVBQVlELENBQVo7QUFBQSxVQUFjRCxDQUFkO0FBQUEsVUFBZ0IzSCxJQUFFMkUsVUFBVSxDQUFWLE1BQWVBLFVBQVUsQ0FBVixFQUFhekMsQ0FBYixJQUFnQnFGLEVBQUV0RCxhQUFGLENBQWdCVSxVQUFVLENBQVYsRUFBYTRRLFVBQTdCLEtBQTBDLENBQUM1USxVQUFVLENBQVYsRUFBYTRRLFVBQWIsQ0FBd0JDLEtBQW5GLElBQTBGck8sRUFBRXNCLFFBQUYsQ0FBVzlELFVBQVUsQ0FBVixFQUFhNFEsVUFBeEIsQ0FBekcsQ0FBbEIsQ0FBZ0ssSUFBR3BPLEVBQUVDLFNBQUYsQ0FBWSxJQUFaLEtBQW1CbkYsSUFBRSxDQUFDLENBQUgsRUFBSzdCLElBQUUsQ0FBUCxFQUFTeUgsSUFBRSxJQUFYLEVBQWdCakQsSUFBRSxJQUFyQyxLQUE0QzNDLElBQUUsQ0FBQyxDQUFILEVBQUs3QixJQUFFLENBQVAsRUFBU3lILElBQUU3SCxJQUFFMkUsVUFBVSxDQUFWLEVBQWE4USxRQUFiLElBQXVCOVEsVUFBVSxDQUFWLEVBQWF4QixDQUF0QyxHQUF3Q3dCLFVBQVUsQ0FBVixDQUEvRixHQUE2R2tELElBQUUxRCxFQUFFMEQsQ0FBRixDQUFsSCxFQUF1SDtBQUFDN0gsYUFBRzRILElBQUVqRCxVQUFVLENBQVYsRUFBYTRRLFVBQWIsSUFBeUI1USxVQUFVLENBQVYsRUFBYXpDLENBQXhDLEVBQTBDeUYsSUFBRWhELFVBQVUsQ0FBVixFQUFhK1EsT0FBYixJQUFzQi9RLFVBQVUsQ0FBVixFQUFhUixDQUFsRixLQUFzRnlELElBQUVqRCxVQUFVdkUsQ0FBVixDQUFGLEVBQWV1SCxJQUFFaEQsVUFBVXZFLElBQUUsQ0FBWixDQUF2RyxFQUF1SCxJQUFJcUgsSUFBRUksRUFBRXpFLE1BQVI7QUFBQSxZQUFlMEUsSUFBRSxDQUFqQixDQUFtQixJQUFHLENBQUMsbUJBQW1CMUIsSUFBbkIsQ0FBd0J3QixDQUF4QixDQUFELElBQTZCLENBQUNMLEVBQUV0RCxhQUFGLENBQWdCMEQsQ0FBaEIsQ0FBakMsRUFBb0Q7QUFBQyxjQUFJVyxJQUFFbEksSUFBRSxDQUFSLENBQVV1SCxJQUFFLEVBQUYsQ0FBSyxLQUFJLElBQUlhLElBQUVGLENBQVYsRUFBWUUsSUFBRTdELFVBQVV2QixNQUF4QixFQUErQm9GLEdBQS9CO0FBQW1DckIsY0FBRXBELE9BQUYsQ0FBVVksVUFBVTZELENBQVYsQ0FBVixLQUF5QixDQUFDLHdCQUF3QnBDLElBQXhCLENBQTZCekIsVUFBVTZELENBQVYsQ0FBN0IsQ0FBRCxJQUE2QyxDQUFDLE1BQU1wQyxJQUFOLENBQVd6QixVQUFVNkQsQ0FBVixDQUFYLENBQXZFLEdBQWdHckIsRUFBRXNCLFFBQUYsQ0FBVzlELFVBQVU2RCxDQUFWLENBQVgsS0FBMEJyQixFQUFFcEQsT0FBRixDQUFVWSxVQUFVNkQsQ0FBVixDQUFWLENBQTFCLEdBQWtEYixFQUFFL0gsTUFBRixHQUFTK0UsVUFBVTZELENBQVYsQ0FBM0QsR0FBd0VyQixFQUFFMkUsVUFBRixDQUFhbkgsVUFBVTZELENBQVYsQ0FBYixNQUE2QmIsRUFBRXlELFFBQUYsR0FBV3pHLFVBQVU2RCxDQUFWLENBQXhDLENBQXhLLEdBQThOYixFQUFFb0IsUUFBRixHQUFXcEUsVUFBVTZELENBQVYsQ0FBek87QUFBbkM7QUFBeVIsYUFBSVksSUFBRSxFQUFDMEosU0FBUSxJQUFULEVBQWNxQyxVQUFTLElBQXZCLEVBQTRCUSxVQUFTLElBQXJDLEVBQU4sQ0FBaUQxVCxLQUFHL0IsRUFBRXNOLE9BQUwsS0FBZXBFLEVBQUUwSixPQUFGLEdBQVUsSUFBSTVTLEVBQUVzTixPQUFOLENBQWMsVUFBU3JLLENBQVQsRUFBV2xELENBQVgsRUFBYTtBQUFDbUosWUFBRStMLFFBQUYsR0FBV2hTLENBQVgsRUFBYWlHLEVBQUV1TSxRQUFGLEdBQVcxVixDQUF4QjtBQUEwQixTQUF0RCxDQUF6QixFQUFrRixJQUFJb0osQ0FBSixDQUFNLFFBQU96QixDQUFQLEdBQVUsS0FBSSxRQUFKO0FBQWF5QixnQkFBRSxRQUFGLENBQVcsTUFBTSxLQUFJLFNBQUo7QUFBY0EsZ0JBQUUsU0FBRixDQUFZLE1BQU0sS0FBSSxRQUFKLENBQWEsS0FBSSxNQUFKO0FBQVc5QixjQUFFbEQsSUFBRixDQUFPd0QsQ0FBUCxFQUFTLFVBQVMxRSxDQUFULEVBQVdsRCxDQUFYLEVBQWE7QUFBQzRELGdCQUFFNUQsQ0FBRixLQUFNNEQsRUFBRTVELENBQUYsRUFBS29WLFVBQVgsS0FBd0JPLGFBQWEvUixFQUFFNUQsQ0FBRixFQUFLb1YsVUFBTCxDQUFnQmhLLFVBQTdCLEdBQXlDeEgsRUFBRTVELENBQUYsRUFBS29WLFVBQUwsQ0FBZ0JDLElBQWhCLElBQXNCelIsRUFBRTVELENBQUYsRUFBS29WLFVBQUwsQ0FBZ0JDLElBQWhCLEVBQS9ELEVBQXNGLE9BQU96UixFQUFFNUQsQ0FBRixFQUFLb1YsVUFBMUg7QUFBc0ksYUFBN0osRUFBK0osSUFBSS9MLElBQUUsRUFBTixDQUFTLE9BQU8vQixFQUFFbEQsSUFBRixDQUFPbkUsRUFBRTJJLEtBQUYsQ0FBUUMsS0FBZixFQUFxQixVQUFTM0YsQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhO0FBQUNBLG1CQUFHc0gsRUFBRWxELElBQUYsQ0FBT3BFLEVBQUUsQ0FBRixDQUFQLEVBQVksVUFBU29ELENBQVQsRUFBV08sQ0FBWCxFQUFhO0FBQUMsb0JBQUlPLElBQUV3RCxNQUFJeEYsQ0FBSixHQUFNLEVBQU4sR0FBU3dGLENBQWYsQ0FBaUIsT0FBT3hELE1BQUksQ0FBQyxDQUFMLElBQVFsRSxFQUFFLENBQUYsRUFBSzZFLEtBQUwsS0FBYVgsQ0FBckIsSUFBd0J3RCxNQUFJeEYsQ0FBSixJQUFPbEMsRUFBRSxDQUFGLEVBQUs2RSxLQUFMLEtBQWEsQ0FBQyxDQUE3QyxHQUErQyxLQUFLeUMsRUFBRWxELElBQUYsQ0FBT3dELENBQVAsRUFBUyxVQUFTeEUsQ0FBVCxFQUFXbEIsQ0FBWCxFQUFhO0FBQUNBLHdCQUFJeUIsQ0FBSixLQUFRLENBQUMrRCxNQUFJLENBQUMsQ0FBTCxJQUFRUixFQUFFc0IsUUFBRixDQUFXZCxDQUFYLENBQVQsTUFBMEJKLEVBQUVsRCxJQUFGLENBQU9rRCxFQUFFekMsS0FBRixDQUFRM0MsQ0FBUixFQUFVZ0YsRUFBRXNCLFFBQUYsQ0FBV2QsQ0FBWCxJQUFjQSxDQUFkLEdBQWdCLEVBQTFCLENBQVAsRUFBcUMsVUFBU3hFLENBQVQsRUFBV2xELENBQVgsRUFBYTtBQUNodytCa0gsc0JBQUUyRSxVQUFGLENBQWE3TCxDQUFiLEtBQWlCQSxFQUFFLElBQUYsRUFBTyxDQUFDLENBQVIsQ0FBakI7QUFBNEIsbUJBRGtyK0IsR0FDaHIrQnNILEVBQUV6QyxLQUFGLENBQVEzQyxDQUFSLEVBQVVnRixFQUFFc0IsUUFBRixDQUFXZCxDQUFYLElBQWNBLENBQWQsR0FBZ0IsRUFBMUIsRUFBNkIsRUFBN0IsQ0FEc3ArQixHQUNwbitCLFdBQVNDLENBQVQsSUFBWS9ELEVBQUUxQixDQUFGLEtBQU0wQixFQUFFMUIsQ0FBRixFQUFLbUosZUFBWCxJQUE0Qm5ILE1BQUksQ0FBQyxDQUFqQyxJQUFvQ29ELEVBQUVsRCxJQUFGLENBQU9SLEVBQUUxQixDQUFGLEVBQUttSixlQUFaLEVBQTRCLFVBQVNuSSxDQUFULEVBQVdsRCxDQUFYLEVBQWE7QUFBQ0Esc0JBQUV1SixRQUFGLEdBQVd2SixFQUFFMEosWUFBYjtBQUEwQixtQkFBcEUsQ0FBcEMsRUFBMEdMLEVBQUV0RSxJQUFGLENBQU83QixDQUFQLENBQXRILElBQWlJLGFBQVd5RSxDQUFYLEtBQWUzSCxFQUFFLENBQUYsRUFBSzhJLFFBQUwsR0FBYyxDQUE3QixDQUQyKzlCO0FBQzE4OUIsaUJBRG03OUIsQ0FBcEQsR0FDNzM5QixDQUFDLENBRHEzOUI7QUFDbjM5QixlQUR3MDlCLENBQUg7QUFDbjA5QixhQURneTlCLEdBQzl4OUIsV0FBU25CLENBQVQsS0FBYUwsRUFBRWxELElBQUYsQ0FBT2lGLENBQVAsRUFBUyxVQUFTbkcsQ0FBVCxFQUFXbEQsQ0FBWCxFQUFhO0FBQUNpQyxnQkFBRWpDLENBQUYsRUFBSSxDQUFDLENBQUw7QUFBUSxhQUEvQixHQUFpQ21KLEVBQUUwSixPQUFGLElBQVcxSixFQUFFK0wsUUFBRixDQUFXdE4sQ0FBWCxDQUF6RCxDQUQ4eDlCLEVBQ3R0OUIxRSxHQUQrczlCLENBQzNzOUI7QUFBUSxnQkFBRyxDQUFDb0UsRUFBRXRELGFBQUYsQ0FBZ0IyRCxDQUFoQixDQUFELElBQXFCVCxFQUFFbUYsYUFBRixDQUFnQjFFLENBQWhCLENBQXhCLEVBQTJDO0FBQUMsa0JBQUdULEVBQUVzQixRQUFGLENBQVdiLENBQVgsS0FBZTFILEVBQUVxTixTQUFGLENBQVkzRixDQUFaLENBQWxCLEVBQWlDO0FBQUMsb0JBQUkyQixJQUFFaEMsRUFBRTFILE1BQUYsQ0FBUyxFQUFULEVBQVk4SCxDQUFaLENBQU47QUFBQSxvQkFBcUI4QixJQUFFRixFQUFFUixRQUF6QjtBQUFBLG9CQUFrQ2UsSUFBRVAsRUFBRWdDLEtBQUYsSUFBUyxDQUE3QyxDQUErQyxPQUFPaEMsRUFBRXNNLFNBQUYsS0FBYyxDQUFDLENBQWYsS0FBbUJoTyxJQUFFTixFQUFFMUgsTUFBRixDQUFTLENBQUMsQ0FBVixFQUFZLEVBQVosRUFBZWdJLENBQWYsRUFBa0JpTyxPQUFsQixFQUFyQixHQUFrRHZPLEVBQUVsRCxJQUFGLENBQU93RCxDQUFQLEVBQVMsVUFBUzFFLENBQVQsRUFBV2xELENBQVgsRUFBYTtBQUFDcUcsNkJBQVdpRCxFQUFFd00sT0FBYixJQUFzQnhNLEVBQUVnQyxLQUFGLEdBQVF6QixJQUFFeEQsV0FBV2lELEVBQUV3TSxPQUFiLElBQXNCNVMsQ0FBdEQsR0FBd0RnRSxFQUFFMkUsVUFBRixDQUFhdkMsRUFBRXdNLE9BQWYsTUFBMEJ4TSxFQUFFZ0MsS0FBRixHQUFRekIsSUFBRVAsRUFBRXdNLE9BQUYsQ0FBVWpTLElBQVYsQ0FBZTdELENBQWYsRUFBaUJrRCxDQUFqQixFQUFtQnNFLENBQW5CLENBQXBDLENBQXhELEVBQW1IOEIsRUFBRXlNLElBQUYsS0FBU3pNLEVBQUVSLFFBQUYsR0FBV3pDLFdBQVdtRCxDQUFYLE1BQWdCLHdCQUF3QnJELElBQXhCLENBQTZCd0IsQ0FBN0IsSUFBZ0MsR0FBaEMsR0FBb0NGLENBQXBELENBQVgsRUFBa0U2QixFQUFFUixRQUFGLEdBQVc3SCxLQUFLa0gsR0FBTCxDQUFTbUIsRUFBRVIsUUFBRixJQUFZUSxFQUFFc00sU0FBRixHQUFZLElBQUUxUyxJQUFFc0UsQ0FBaEIsR0FBa0IsQ0FBQ3RFLElBQUUsQ0FBSCxJQUFNc0UsQ0FBcEMsQ0FBVCxFQUFnRCxNQUFJOEIsRUFBRVIsUUFBdEQsRUFBK0QsR0FBL0QsQ0FBdEYsQ0FBbkgsRUFBOFE3SSxFQUFFcU4sU0FBRixDQUFZM0YsQ0FBWixFQUFlOUQsSUFBZixDQUFvQjdELENBQXBCLEVBQXNCQSxDQUF0QixFQUF3QnNKLEtBQUcsRUFBM0IsRUFBOEJwRyxDQUE5QixFQUFnQ3NFLENBQWhDLEVBQWtDSSxDQUFsQyxFQUFvQ3VCLEVBQUUwSixPQUFGLEdBQVUxSixDQUFWLEdBQVlqSCxDQUFoRCxDQUE5UTtBQUFpVSxpQkFBeFYsQ0FBbEQsRUFBNFlnQixHQUFuWjtBQUF1WixtQkFBSTZHLElBQUUsK0JBQTZCcEMsQ0FBN0IsR0FBK0IsK0VBQXJDLENBQXFILE9BQU93QixFQUFFMEosT0FBRixHQUFVMUosRUFBRXVNLFFBQUYsQ0FBVyxJQUFJdlEsS0FBSixDQUFVNEUsQ0FBVixDQUFYLENBQVYsR0FBbUMvRyxRQUFRQyxHQUFSLENBQVk4RyxDQUFaLENBQW5DLEVBQWtEN0csR0FBekQ7QUFBNkQsaUJBQUUsT0FBRixDQURxdjdCLENBQzN1N0IsSUFBSWdILElBQUUsRUFBQytJLFlBQVcsSUFBWixFQUFpQkQsY0FBYSxJQUE5QixFQUFtQ0UsY0FBYSxJQUFoRCxFQUFxREksc0JBQXFCLElBQTFFLEVBQStFRSx1QkFBc0IsSUFBckcsRUFBMEdKLFlBQVcsSUFBckgsRUFBMEhRLFNBQVEsSUFBbEksRUFBdUlDLFFBQU8sSUFBOUksRUFBbUpFLFFBQU8sSUFBMUosRUFBTjtBQUFBLFlBQXNLa0IsSUFBRSxFQUF4SyxDQUEySzNOLEVBQUVsRCxJQUFGLENBQU93RCxDQUFQLEVBQVMsVUFBUzFFLENBQVQsRUFBV2xELENBQVgsRUFBYTtBQUFDa0gsWUFBRUcsTUFBRixDQUFTckgsQ0FBVCxLQUFhMkQsRUFBRUUsSUFBRixDQUFPN0QsQ0FBUCxDQUFiO0FBQXVCLFNBQTlDLEVBQWdELElBQUlzVSxDQUFKO0FBQUEsWUFBTWhMLElBQUVoQyxFQUFFMUgsTUFBRixDQUFTLEVBQVQsRUFBWUssRUFBRTBJLFFBQWQsRUFBdUJqQixDQUF2QixDQUFSLENBQWtDLElBQUc0QixFQUFFc0IsSUFBRixHQUFPeUYsU0FBUy9HLEVBQUVzQixJQUFYLENBQVAsRUFBd0IwSixJQUFFLElBQUVoTCxFQUFFc0IsSUFBSixHQUFTLENBQW5DLEVBQXFDdEIsRUFBRXNCLElBQTFDLEVBQStDLEtBQUksSUFBSTJKLElBQUUsQ0FBVixFQUFZRCxJQUFFQyxDQUFkLEVBQWdCQSxHQUFoQixFQUFvQjtBQUFDLGNBQUlDLElBQUUsRUFBQ2xKLE9BQU1oQyxFQUFFZ0MsS0FBVCxFQUFlWixVQUFTcEIsRUFBRW9CLFFBQTFCLEVBQU4sQ0FBMEM2SixNQUFJRCxJQUFFLENBQU4sS0FBVUUsRUFBRXhMLE9BQUYsR0FBVU0sRUFBRU4sT0FBWixFQUFvQndMLEVBQUV0TCxVQUFGLEdBQWFJLEVBQUVKLFVBQW5DLEVBQThDc0wsRUFBRXJKLFFBQUYsR0FBVzdCLEVBQUU2QixRQUFyRSxHQUErRXBELEVBQUVILENBQUYsRUFBSSxTQUFKLEVBQWM0TSxDQUFkLENBQS9FO0FBQWdHLGdCQUFPdFIsR0FBUDtBQUFXO0FBQUMsS0FEODdxQixDQUM3N3FCakQsSUFBRXFILEVBQUUxSCxNQUFGLENBQVNtSSxDQUFULEVBQVc5SCxDQUFYLENBQUYsRUFBZ0JBLEVBQUVzTSxPQUFGLEdBQVV4RSxDQUExQixDQUE0QixJQUFJUCxJQUFFeEgsRUFBRWdXLHFCQUFGLElBQXlCcE8sQ0FBL0IsQ0FBaUMsT0FBTzNILEVBQUUySSxLQUFGLENBQVE0RCxRQUFSLElBQWtCcEosRUFBRTZTLE1BQUYsS0FBVy9ULENBQTdCLElBQWdDa0IsRUFBRThTLGdCQUFGLENBQW1CLGtCQUFuQixFQUFzQyxZQUFVO0FBQUM5UyxRQUFFNlMsTUFBRixJQUFVek8sSUFBRSxXQUFTdEUsQ0FBVCxFQUFXO0FBQUMsZUFBT2tJLFdBQVcsWUFBVTtBQUFDbEksWUFBRSxDQUFDLENBQUg7QUFBTSxTQUE1QixFQUE2QixFQUE3QixDQUFQO0FBQXdDLE9BQXRELEVBQXVEaEQsR0FBakUsSUFBc0VzSCxJQUFFeEgsRUFBRWdXLHFCQUFGLElBQXlCcE8sQ0FBakc7QUFBbUcsS0FBcEosQ0FBaEMsRUFBc0wxRSxFQUFFSCxRQUFGLEdBQVc5QyxDQUFqTSxFQUFtTWlELE1BQUlsRCxDQUFKLEtBQVFrRCxFQUFFTSxFQUFGLENBQUs4SSxRQUFMLEdBQWN2RSxDQUFkLEVBQWdCN0UsRUFBRU0sRUFBRixDQUFLOEksUUFBTCxDQUFjM0QsUUFBZCxHQUF1QjFJLEVBQUUwSSxRQUFqRCxDQUFuTSxFQUE4UHJCLEVBQUVsRCxJQUFGLENBQU8sQ0FBQyxNQUFELEVBQVEsSUFBUixDQUFQLEVBQXFCLFVBQVNsQixDQUFULEVBQVdsRCxDQUFYLEVBQWE7QUFBQ0MsUUFBRXFOLFNBQUYsQ0FBWSxVQUFRdE4sQ0FBcEIsSUFBdUIsVUFBU2tELENBQVQsRUFBV0UsQ0FBWCxFQUFhTyxDQUFiLEVBQWVPLENBQWYsRUFBaUJOLENBQWpCLEVBQW1CNUIsQ0FBbkIsRUFBcUI7QUFBQyxZQUFJMkMsSUFBRTJDLEVBQUUxSCxNQUFGLENBQVMsRUFBVCxFQUFZd0QsQ0FBWixDQUFOO0FBQUEsWUFBcUJ3QixJQUFFRCxFQUFFNkksS0FBekI7QUFBQSxZQUErQnROLElBQUV5RSxFQUFFd0csUUFBbkM7QUFBQSxZQUE0Q2xKLElBQUUsRUFBQ2tVLFFBQU8sRUFBUixFQUFXN1AsV0FBVSxFQUFyQixFQUF3QjhQLGNBQWEsRUFBckMsRUFBd0NDLFlBQVcsRUFBbkQsRUFBc0RDLGVBQWMsRUFBcEUsRUFBOUM7QUFBQSxZQUFzSG5XLElBQUUsRUFBeEgsQ0FBMkh3RSxFQUFFcUUsT0FBRixLQUFZOUcsQ0FBWixLQUFnQnlDLEVBQUVxRSxPQUFGLEdBQVUsV0FBU2hKLENBQVQsR0FBVyxhQUFXQyxFQUFFb04sR0FBRixDQUFNcEMsTUFBTixDQUFhb0csY0FBYixDQUE0Qm5PLENBQTVCLENBQVgsR0FBMEMsY0FBMUMsR0FBeUQsT0FBcEUsR0FBNEUsTUFBdEcsR0FBOEd5QixFQUFFNkksS0FBRixHQUFRLFlBQVU7QUFBQzVJLGVBQUdBLEVBQUVmLElBQUYsQ0FBT0QsQ0FBUCxFQUFTQSxDQUFULENBQUgsQ0FBZSxLQUFJLElBQUlSLENBQVIsSUFBYW5CLENBQWIsRUFBZTtBQUFDOUIsY0FBRWlELENBQUYsSUFBS0YsRUFBRWdELEtBQUYsQ0FBUTlDLENBQVIsQ0FBTCxDQUFnQixJQUFJbEIsSUFBRWpDLEVBQUVvTixHQUFGLENBQU11RSxnQkFBTixDQUF1QjFPLENBQXZCLEVBQXlCRSxDQUF6QixDQUFOLENBQWtDbkIsRUFBRW1CLENBQUYsSUFBSyxXQUFTcEQsQ0FBVCxHQUFXLENBQUNrQyxDQUFELEVBQUcsQ0FBSCxDQUFYLEdBQWlCLENBQUMsQ0FBRCxFQUFHQSxDQUFILENBQXRCO0FBQTRCLGFBQUVxVSxRQUFGLEdBQVdyVCxFQUFFZ0QsS0FBRixDQUFRcVEsUUFBbkIsRUFBNEJyVCxFQUFFZ0QsS0FBRixDQUFRcVEsUUFBUixHQUFpQixRQUE3QztBQUFzRCxTQUFwUyxFQUFxUzVSLEVBQUV3RyxRQUFGLEdBQVcsWUFBVTtBQUFDLGVBQUksSUFBSW5MLENBQVIsSUFBYUcsQ0FBYjtBQUFlK0MsY0FBRWdELEtBQUYsQ0FBUWxHLENBQVIsSUFBV0csRUFBRUgsQ0FBRixDQUFYO0FBQWYsV0FBK0JFLEtBQUdBLEVBQUUyRCxJQUFGLENBQU9ELENBQVAsRUFBU0EsQ0FBVCxDQUFILEVBQWU1QixLQUFHQSxFQUFFa1QsUUFBRixDQUFXdFIsQ0FBWCxDQUFsQjtBQUFnQyxTQUExWCxFQUEyWDNELEVBQUVpRCxDQUFGLEVBQUlqQixDQUFKLEVBQU0wQyxDQUFOLENBQTNYO0FBQW9ZLE9BQTVpQjtBQUE2aUIsS0FBaGxCLENBQTlQLEVBQWcxQjJDLEVBQUVsRCxJQUFGLENBQU8sQ0FBQyxJQUFELEVBQU0sS0FBTixDQUFQLEVBQW9CLFVBQVNsQixDQUFULEVBQVdsRCxDQUFYLEVBQWE7QUFBQ0MsUUFBRXFOLFNBQUYsQ0FBWSxTQUFPdE4sQ0FBbkIsSUFBc0IsVUFBU2tELENBQVQsRUFBV0UsQ0FBWCxFQUFhTyxDQUFiLEVBQWVPLENBQWYsRUFBaUJOLENBQWpCLEVBQW1CNUIsQ0FBbkIsRUFBcUI7QUFBQyxZQUFJMkMsSUFBRTJDLEVBQUUxSCxNQUFGLENBQVMsRUFBVCxFQUFZd0QsQ0FBWixDQUFOO0FBQUEsWUFBcUJ3QixJQUFFLEVBQUN1TCxTQUFRLFNBQU9uUSxDQUFQLEdBQVMsQ0FBVCxHQUFXLENBQXBCLEVBQXZCO0FBQUEsWUFBOENFLElBQUV5RSxFQUFFd0csUUFBbEQsQ0FBMkR4RyxFQUFFd0csUUFBRixHQUFXeEgsTUFBSU8sSUFBRSxDQUFOLEdBQVFTLEVBQUU2SSxLQUFGLEdBQVEsSUFBaEIsR0FBcUIsWUFBVTtBQUFDdE4sZUFBR0EsRUFBRTJELElBQUYsQ0FBT0QsQ0FBUCxFQUFTQSxDQUFULENBQUgsRUFBZTVCLEtBQUdBLEVBQUVrVCxRQUFGLENBQVd0UixDQUFYLENBQWxCO0FBQWdDLFNBQTNFLEVBQTRFZSxFQUFFcUUsT0FBRixLQUFZOUcsQ0FBWixLQUFnQnlDLEVBQUVxRSxPQUFGLEdBQVUsU0FBT2hKLENBQVAsR0FBUyxNQUFULEdBQWdCLE1BQTFDLENBQTVFLEVBQThIQyxFQUFFLElBQUYsRUFBTzJFLENBQVAsRUFBU0QsQ0FBVCxDQUE5SDtBQUEwSSxPQUFqUDtBQUFrUCxLQUFwUixDQUFoMUIsRUFBc21DMUUsQ0FBN21DO0FBQSttQyxHQUQrbEMsQ0FDOWxDeUQsT0FBT2xFLE1BQVAsSUFBZWtFLE9BQU9zSSxLQUF0QixJQUE2QnRJLE1BRGlrQyxFQUMxakNBLE1BRDBqQyxFQUNuakMrQixRQURtakMsQ0FBUDtBQUNsaUMsQ0FEMDRCLENBQW5sSDtBQUVBLENBQUMsQ0FBQyxVQUFTdkQsQ0FBVCxFQUFXakMsQ0FBWCxFQUFhQyxDQUFiLEVBQWVDLENBQWYsRUFBaUI7QUFBQztBQUFhLFdBQVNnSixDQUFULENBQVdqSCxDQUFYLEVBQWFqQyxDQUFiLEVBQWVDLENBQWYsRUFBaUI7QUFBQyxXQUFPa0wsV0FBV29KLEVBQUV0UyxDQUFGLEVBQUloQyxDQUFKLENBQVgsRUFBa0JELENBQWxCLENBQVA7QUFBNEIsWUFBUzBFLENBQVQsQ0FBV3pDLENBQVgsRUFBYWpDLENBQWIsRUFBZUMsQ0FBZixFQUFpQjtBQUFDLFdBQU82RCxNQUFNRCxPQUFOLENBQWM1QixDQUFkLEtBQWtCZ0YsRUFBRWhGLENBQUYsRUFBSWhDLEVBQUVELENBQUYsQ0FBSixFQUFTQyxDQUFULEdBQVksQ0FBQyxDQUEvQixJQUFrQyxDQUFDLENBQTFDO0FBQTRDLFlBQVNnSCxDQUFULENBQVdoRixDQUFYLEVBQWFqQyxDQUFiLEVBQWVDLENBQWYsRUFBaUI7QUFBQyxRQUFJZ0QsQ0FBSixDQUFNLElBQUdoQixDQUFILEVBQUssSUFBR0EsRUFBRXNVLE9BQUwsRUFBYXRVLEVBQUVzVSxPQUFGLENBQVV2VyxDQUFWLEVBQVlDLENBQVosRUFBYixLQUFpQyxJQUFHZ0MsRUFBRWlCLE1BQUYsS0FBV2hELENBQWQsRUFBZ0IsS0FBSStDLElBQUUsQ0FBTixFQUFRQSxJQUFFaEIsRUFBRWlCLE1BQVo7QUFBb0JsRCxRQUFFNEQsSUFBRixDQUFPM0QsQ0FBUCxFQUFTZ0MsRUFBRWdCLENBQUYsQ0FBVCxFQUFjQSxDQUFkLEVBQWdCaEIsQ0FBaEIsR0FBbUJnQixHQUFuQjtBQUFwQixLQUFoQixNQUFnRSxLQUFJQSxDQUFKLElBQVNoQixDQUFUO0FBQVdBLFFBQUUwRSxjQUFGLENBQWlCMUQsQ0FBakIsS0FBcUJqRCxFQUFFNEQsSUFBRixDQUFPM0QsQ0FBUCxFQUFTZ0MsRUFBRWdCLENBQUYsQ0FBVCxFQUFjQSxDQUFkLEVBQWdCaEIsQ0FBaEIsQ0FBckI7QUFBWDtBQUFtRCxZQUFTeUIsQ0FBVCxDQUFXekIsQ0FBWCxFQUFhakMsQ0FBYixFQUFlQyxDQUFmLEVBQWlCO0FBQUMsU0FBSSxJQUFJZ0QsSUFBRTRCLE9BQU8yUixJQUFQLENBQVl4VyxDQUFaLENBQU4sRUFBcUJxSCxJQUFFLENBQTNCLEVBQTZCQSxJQUFFcEUsRUFBRUMsTUFBakM7QUFBeUMsT0FBQyxDQUFDakQsQ0FBRCxJQUFJQSxLQUFHZ0MsRUFBRWdCLEVBQUVvRSxDQUFGLENBQUYsTUFBVW5ILENBQWxCLE1BQXVCK0IsRUFBRWdCLEVBQUVvRSxDQUFGLENBQUYsSUFBUXJILEVBQUVpRCxFQUFFb0UsQ0FBRixDQUFGLENBQS9CLEdBQXdDQSxHQUF4QztBQUF6QyxLQUFxRixPQUFPcEYsQ0FBUDtBQUFTLFlBQVNnQyxDQUFULENBQVdoQyxDQUFYLEVBQWFqQyxDQUFiLEVBQWU7QUFBQyxXQUFPMEQsRUFBRXpCLENBQUYsRUFBSWpDLENBQUosRUFBTSxDQUFDLENBQVAsQ0FBUDtBQUFpQixZQUFTZ0MsQ0FBVCxDQUFXQyxDQUFYLEVBQWFqQyxDQUFiLEVBQWVDLENBQWYsRUFBaUI7QUFBQyxRQUFJZ0QsQ0FBSjtBQUFBLFFBQU0vQyxJQUFFRixFQUFFa0UsU0FBVixDQUFvQmpCLElBQUVoQixFQUFFaUMsU0FBRixHQUFZVyxPQUFPNFIsTUFBUCxDQUFjdlcsQ0FBZCxDQUFkLEVBQStCK0MsRUFBRWUsV0FBRixHQUFjL0IsQ0FBN0MsRUFBK0NnQixFQUFFeVQsTUFBRixHQUFTeFcsQ0FBeEQsRUFBMERELEtBQUd5RCxFQUFFVCxDQUFGLEVBQUloRCxDQUFKLENBQTdEO0FBQW9FLFlBQVNzVSxDQUFULENBQVd0UyxDQUFYLEVBQWFqQyxDQUFiLEVBQWU7QUFBQyxXQUFPLFlBQVU7QUFBQyxhQUFPaUMsRUFBRW1DLEtBQUYsQ0FBUXBFLENBQVIsRUFBVXlFLFNBQVYsQ0FBUDtBQUE0QixLQUE5QztBQUErQyxZQUFTdEIsQ0FBVCxDQUFXbEIsQ0FBWCxFQUFhakMsQ0FBYixFQUFlO0FBQUMsV0FBTyxRQUFPaUMsQ0FBUCx5Q0FBT0EsQ0FBUCxNQUFVMEYsQ0FBVixHQUFZMUYsRUFBRW1DLEtBQUYsQ0FBUXBFLElBQUVBLEVBQUUsQ0FBRixLQUFNRSxDQUFSLEdBQVVBLENBQWxCLEVBQW9CRixDQUFwQixDQUFaLEdBQW1DaUMsQ0FBMUM7QUFBNEMsWUFBU0YsQ0FBVCxDQUFXRSxDQUFYLEVBQWFqQyxDQUFiLEVBQWU7QUFBQyxXQUFPaUMsTUFBSS9CLENBQUosR0FBTUYsQ0FBTixHQUFRaUMsQ0FBZjtBQUFpQixZQUFTbEMsQ0FBVCxDQUFXa0MsQ0FBWCxFQUFhakMsQ0FBYixFQUFlQyxDQUFmLEVBQWlCO0FBQUNnSCxNQUFFbkgsRUFBRUUsQ0FBRixDQUFGLEVBQU8sVUFBU0EsQ0FBVCxFQUFXO0FBQUNpQyxRQUFFZ1UsZ0JBQUYsQ0FBbUJqVyxDQUFuQixFQUFxQkMsQ0FBckIsRUFBdUIsQ0FBQyxDQUF4QjtBQUEyQixLQUE5QztBQUFnRCxZQUFTMEUsQ0FBVCxDQUFXMUMsQ0FBWCxFQUFhakMsQ0FBYixFQUFlQyxDQUFmLEVBQWlCO0FBQUNnSCxNQUFFbkgsRUFBRUUsQ0FBRixDQUFGLEVBQU8sVUFBU0EsQ0FBVCxFQUFXO0FBQUNpQyxRQUFFMFUsbUJBQUYsQ0FBc0IzVyxDQUF0QixFQUF3QkMsQ0FBeEIsRUFBMEIsQ0FBQyxDQUEzQjtBQUE4QixLQUFqRDtBQUFtRCxZQUFTd0gsQ0FBVCxDQUFXeEYsQ0FBWCxFQUFhakMsQ0FBYixFQUFlO0FBQUMsV0FBS2lDLENBQUwsR0FBUTtBQUFDLFVBQUdBLEtBQUdqQyxDQUFOLEVBQVEsT0FBTSxDQUFDLENBQVAsQ0FBU2lDLElBQUVBLEVBQUVrTSxVQUFKO0FBQWUsWUFBTSxDQUFDLENBQVA7QUFBUyxZQUFTNUcsQ0FBVCxDQUFXdEYsQ0FBWCxFQUFhakMsQ0FBYixFQUFlO0FBQUMsV0FBT2lDLEVBQUUyVSxPQUFGLENBQVU1VyxDQUFWLElBQWEsQ0FBQyxDQUFyQjtBQUF1QixZQUFTRixDQUFULENBQVdtQyxDQUFYLEVBQWE7QUFBQyxXQUFPQSxFQUFFNFUsSUFBRixHQUFTaFEsS0FBVCxDQUFlLE1BQWYsQ0FBUDtBQUE4QixZQUFTYSxDQUFULENBQVd6RixDQUFYLEVBQWFqQyxDQUFiLEVBQWVDLENBQWYsRUFBaUI7QUFBQyxRQUFHZ0MsRUFBRTJVLE9BQUYsSUFBVyxDQUFDM1csQ0FBZixFQUFpQixPQUFPZ0MsRUFBRTJVLE9BQUYsQ0FBVTVXLENBQVYsQ0FBUCxDQUFvQixLQUFJLElBQUlFLElBQUUsQ0FBVixFQUFZQSxJQUFFK0IsRUFBRWlCLE1BQWhCLEdBQXdCO0FBQUMsVUFBR2pELEtBQUdnQyxFQUFFL0IsQ0FBRixFQUFLRCxDQUFMLEtBQVNELENBQVosSUFBZSxDQUFDQyxDQUFELElBQUlnQyxFQUFFL0IsQ0FBRixNQUFPRixDQUE3QixFQUErQixPQUFPRSxDQUFQLENBQVNBO0FBQUksWUFBTSxDQUFDLENBQVA7QUFBUyxZQUFTbVUsQ0FBVCxDQUFXcFMsQ0FBWCxFQUFhO0FBQUMsV0FBTzZCLE1BQU1JLFNBQU4sQ0FBZ0JpRCxLQUFoQixDQUFzQnZELElBQXRCLENBQTJCM0IsQ0FBM0IsRUFBNkIsQ0FBN0IsQ0FBUDtBQUF1QyxZQUFTa0gsQ0FBVCxDQUFXbEgsQ0FBWCxFQUFhakMsQ0FBYixFQUFlQyxDQUFmLEVBQWlCO0FBQUMsU0FBSSxJQUFJQyxJQUFFLEVBQU4sRUFBUytDLElBQUUsRUFBWCxFQUFjb0UsSUFBRSxDQUFwQixFQUFzQkEsSUFBRXBGLEVBQUVpQixNQUExQixHQUFrQztBQUFDLFVBQUl5RSxJQUFFM0gsSUFBRWlDLEVBQUVvRixDQUFGLEVBQUtySCxDQUFMLENBQUYsR0FBVWlDLEVBQUVvRixDQUFGLENBQWhCLENBQXFCSyxFQUFFekUsQ0FBRixFQUFJMEUsQ0FBSixJQUFPLENBQVAsSUFBVXpILEVBQUU0RSxJQUFGLENBQU83QyxFQUFFb0YsQ0FBRixDQUFQLENBQVYsRUFBdUJwRSxFQUFFb0UsQ0FBRixJQUFLTSxDQUE1QixFQUE4Qk4sR0FBOUI7QUFBa0MsWUFBT3BILE1BQUlDLElBQUVGLElBQUVFLEVBQUU0VyxJQUFGLENBQU8sVUFBUzdVLENBQVQsRUFBV2hDLENBQVgsRUFBYTtBQUFDLGFBQU9nQyxFQUFFakMsQ0FBRixJQUFLQyxFQUFFRCxDQUFGLENBQVo7QUFBaUIsS0FBdEMsQ0FBRixHQUEwQ0UsRUFBRTRXLElBQUYsRUFBaEQsR0FBMEQ1VyxDQUFqRTtBQUFtRSxZQUFTd1UsQ0FBVCxDQUFXelMsQ0FBWCxFQUFhakMsQ0FBYixFQUFlO0FBQUMsU0FBSSxJQUFJQyxDQUFKLEVBQU1vSCxDQUFOLEVBQVFNLElBQUUzSCxFQUFFLENBQUYsRUFBSytRLFdBQUwsS0FBbUIvUSxFQUFFbUgsS0FBRixDQUFRLENBQVIsQ0FBN0IsRUFBd0NLLElBQUUsQ0FBOUMsRUFBZ0RBLElBQUV2RSxFQUFFQyxNQUFwRCxHQUE0RDtBQUFDLFVBQUdqRCxJQUFFZ0QsRUFBRXVFLENBQUYsQ0FBRixFQUFPSCxJQUFFcEgsSUFBRUEsSUFBRTBILENBQUosR0FBTTNILENBQWYsRUFBaUJxSCxLQUFLcEYsQ0FBekIsRUFBMkIsT0FBT29GLENBQVAsQ0FBU0c7QUFBSSxZQUFPdEgsQ0FBUDtBQUFTLFlBQVM0VSxDQUFULEdBQVk7QUFBQyxXQUFPMU0sR0FBUDtBQUFXLFlBQVNtQixDQUFULENBQVd0SCxDQUFYLEVBQWE7QUFBQyxRQUFJakMsSUFBRWlDLEVBQUU4VSxhQUFSLENBQXNCLE9BQU8vVyxFQUFFZ1gsV0FBRixJQUFlaFgsRUFBRWlYLFlBQXhCO0FBQXFDLFlBQVNDLEVBQVQsQ0FBWWpWLENBQVosRUFBY2pDLENBQWQsRUFBZ0I7QUFBQyxRQUFJQyxJQUFFLElBQU4sQ0FBVyxLQUFLa1gsT0FBTCxHQUFhbFYsQ0FBYixFQUFlLEtBQUttVixRQUFMLEdBQWNwWCxDQUE3QixFQUErQixLQUFLOEksT0FBTCxHQUFhN0csRUFBRTZHLE9BQTlDLEVBQXNELEtBQUt1TyxNQUFMLEdBQVlwVixFQUFFdVQsT0FBRixDQUFVOEIsV0FBNUUsRUFBd0YsS0FBS0MsVUFBTCxHQUFnQixVQUFTdlgsQ0FBVCxFQUFXO0FBQUNtRCxRQUFFbEIsRUFBRXVULE9BQUYsQ0FBVWdDLE1BQVosRUFBbUIsQ0FBQ3ZWLENBQUQsQ0FBbkIsS0FBeUJoQyxFQUFFd1gsT0FBRixDQUFVelgsQ0FBVixDQUF6QjtBQUFzQyxLQUExSixFQUEySixLQUFLd0QsSUFBTCxFQUEzSjtBQUF1SyxZQUFTa1UsRUFBVCxDQUFZelYsQ0FBWixFQUFjO0FBQUMsUUFBSWpDLENBQUo7QUFBQSxRQUFNQyxJQUFFZ0MsRUFBRXVULE9BQUYsQ0FBVW1DLFVBQWxCLENBQTZCLE9BQU8zWCxJQUFFQyxJQUFFQSxDQUFGLEdBQUkySixJQUFFZ08sRUFBRixHQUFLbkQsSUFBRW9ELEVBQUYsR0FBS2pELElBQUVrRCxFQUFGLEdBQUtDLEVBQXJCLEVBQXdCLElBQUkvWCxDQUFKLENBQU1pQyxDQUFOLEVBQVErVixFQUFSLENBQS9CO0FBQTJDLFlBQVNBLEVBQVQsQ0FBWS9WLENBQVosRUFBY2pDLENBQWQsRUFBZ0JDLENBQWhCLEVBQWtCO0FBQUMsUUFBSUMsSUFBRUQsRUFBRWdZLFFBQUYsQ0FBVy9VLE1BQWpCO0FBQUEsUUFBd0JELElBQUVoRCxFQUFFaVksZUFBRixDQUFrQmhWLE1BQTVDO0FBQUEsUUFBbURtRSxJQUFFckgsSUFBRXNVLENBQUYsSUFBSyxNQUFJcFUsSUFBRStDLENBQWhFO0FBQUEsUUFBa0UwRSxJQUFFM0gsS0FBRytVLElBQUVDLENBQUwsS0FBUyxNQUFJOVUsSUFBRStDLENBQW5GLENBQXFGaEQsRUFBRWtZLE9BQUYsR0FBVSxDQUFDLENBQUM5USxDQUFaLEVBQWNwSCxFQUFFbVksT0FBRixHQUFVLENBQUMsQ0FBQ3pRLENBQTFCLEVBQTRCTixNQUFJcEYsRUFBRW9XLE9BQUYsR0FBVSxFQUFkLENBQTVCLEVBQThDcFksRUFBRXFZLFNBQUYsR0FBWXRZLENBQTFELEVBQTREdVksR0FBR3RXLENBQUgsRUFBS2hDLENBQUwsQ0FBNUQsRUFBb0VnQyxFQUFFdVcsSUFBRixDQUFPLGNBQVAsRUFBc0J2WSxDQUF0QixDQUFwRSxFQUE2RmdDLEVBQUV3VyxTQUFGLENBQVl4WSxDQUFaLENBQTdGLEVBQTRHZ0MsRUFBRW9XLE9BQUYsQ0FBVUssU0FBVixHQUFvQnpZLENBQWhJO0FBQWtJLFlBQVNzWSxFQUFULENBQVl0VyxDQUFaLEVBQWNqQyxDQUFkLEVBQWdCO0FBQUMsUUFBSUMsSUFBRWdDLEVBQUVvVyxPQUFSO0FBQUEsUUFBZ0JuWSxJQUFFRixFQUFFaVksUUFBcEI7QUFBQSxRQUE2QmhWLElBQUUvQyxFQUFFZ0QsTUFBakMsQ0FBd0NqRCxFQUFFMFksVUFBRixLQUFlMVksRUFBRTBZLFVBQUYsR0FBYUMsR0FBRzVZLENBQUgsQ0FBNUIsR0FBbUNpRCxJQUFFLENBQUYsSUFBSyxDQUFDaEQsRUFBRTRZLGFBQVIsR0FBc0I1WSxFQUFFNFksYUFBRixHQUFnQkQsR0FBRzVZLENBQUgsQ0FBdEMsR0FBNEMsTUFBSWlELENBQUosS0FBUWhELEVBQUU0WSxhQUFGLEdBQWdCLENBQUMsQ0FBekIsQ0FBL0UsQ0FBMkcsSUFBSXhSLElBQUVwSCxFQUFFMFksVUFBUjtBQUFBLFFBQW1CaFIsSUFBRTFILEVBQUU0WSxhQUF2QjtBQUFBLFFBQXFDclIsSUFBRUcsSUFBRUEsRUFBRW1SLE1BQUosR0FBV3pSLEVBQUV5UixNQUFwRDtBQUFBLFFBQTJEblYsSUFBRTNELEVBQUU4WSxNQUFGLEdBQVNDLEdBQUc3WSxDQUFILENBQXRFLENBQTRFRixFQUFFZ1osU0FBRixHQUFZM1AsR0FBWixFQUFnQnJKLEVBQUVpWixTQUFGLEdBQVlqWixFQUFFZ1osU0FBRixHQUFZM1IsRUFBRTJSLFNBQTFDLEVBQW9EaFosRUFBRWtaLEtBQUYsR0FBUUMsR0FBRzNSLENBQUgsRUFBSzdELENBQUwsQ0FBNUQsRUFBb0UzRCxFQUFFb1osUUFBRixHQUFXQyxHQUFHN1IsQ0FBSCxFQUFLN0QsQ0FBTCxDQUEvRSxFQUF1RjJWLEdBQUdyWixDQUFILEVBQUtELENBQUwsQ0FBdkYsRUFBK0ZBLEVBQUV1WixlQUFGLEdBQWtCQyxHQUFHeFosRUFBRXlaLE1BQUwsRUFBWXpaLEVBQUUwWixNQUFkLENBQWpILEVBQXVJMVosRUFBRTBTLEtBQUYsR0FBUS9LLElBQUVnUyxHQUFHaFMsRUFBRXNRLFFBQUwsRUFBYy9YLENBQWQsQ0FBRixHQUFtQixDQUFsSyxFQUFvS0YsRUFBRTRaLFFBQUYsR0FBV2pTLElBQUVrUyxHQUFHbFMsRUFBRXNRLFFBQUwsRUFBYy9YLENBQWQsQ0FBRixHQUFtQixDQUFsTSxFQUFvTTRaLEdBQUc3WixDQUFILEVBQUtELENBQUwsQ0FBcE0sQ0FBNE0sSUFBSWtKLElBQUVqSCxFQUFFNkcsT0FBUixDQUFnQnJCLEVBQUV6SCxFQUFFK1osUUFBRixDQUFXMUMsTUFBYixFQUFvQm5PLENBQXBCLE1BQXlCQSxJQUFFbEosRUFBRStaLFFBQUYsQ0FBVzFDLE1BQXRDLEdBQThDclgsRUFBRXFYLE1BQUYsR0FBU25PLENBQXZEO0FBQXlELFlBQVNvUSxFQUFULENBQVlyWCxDQUFaLEVBQWNqQyxDQUFkLEVBQWdCO0FBQUMsUUFBSUMsSUFBRUQsRUFBRThZLE1BQVI7QUFBQSxRQUFlNVksSUFBRStCLEVBQUUrWCxXQUFGLElBQWUsRUFBaEM7QUFBQSxRQUFtQy9XLElBQUVoQixFQUFFZ1ksU0FBRixJQUFhLEVBQWxEO0FBQUEsUUFBcUQ1UyxJQUFFcEYsRUFBRXlXLFNBQUYsSUFBYSxFQUFwRSxDQUF1RSxDQUFDMVksRUFBRXNZLFNBQUYsS0FBY2hFLENBQWQsSUFBaUJqTixFQUFFaVIsU0FBRixLQUFjdkQsQ0FBaEMsTUFBcUM5UixJQUFFaEIsRUFBRWdZLFNBQUYsR0FBWSxFQUFDbmEsR0FBRXVILEVBQUVvUyxNQUFGLElBQVUsQ0FBYixFQUFlL1IsR0FBRUwsRUFBRXFTLE1BQUYsSUFBVSxDQUEzQixFQUFkLEVBQTRDeFosSUFBRStCLEVBQUUrWCxXQUFGLEdBQWMsRUFBQ2xhLEdBQUVHLEVBQUVILENBQUwsRUFBTzRILEdBQUV6SCxFQUFFeUgsQ0FBWCxFQUFqRyxHQUFnSDFILEVBQUV5WixNQUFGLEdBQVN4VyxFQUFFbkQsQ0FBRixJQUFLRyxFQUFFSCxDQUFGLEdBQUlJLEVBQUVKLENBQVgsQ0FBekgsRUFBdUlFLEVBQUUwWixNQUFGLEdBQVN6VyxFQUFFeUUsQ0FBRixJQUFLekgsRUFBRXlILENBQUYsR0FBSXhILEVBQUV3SCxDQUFYLENBQWhKO0FBQThKLFlBQVNvUyxFQUFULENBQVk3WCxDQUFaLEVBQWNqQyxDQUFkLEVBQWdCO0FBQUMsUUFBSXFILENBQUo7QUFBQSxRQUFNTSxDQUFOO0FBQUEsUUFBUUgsQ0FBUjtBQUFBLFFBQVU2QixDQUFWO0FBQUEsUUFBWXBKLElBQUVnQyxFQUFFaVksWUFBRixJQUFnQmxhLENBQTlCO0FBQUEsUUFBZ0NpRCxJQUFFakQsRUFBRWdaLFNBQUYsR0FBWS9ZLEVBQUUrWSxTQUFoRCxDQUEwRCxJQUFHaFosRUFBRXNZLFNBQUYsSUFBYXRELENBQWIsS0FBaUIvUixJQUFFNkcsQ0FBRixJQUFLN0osRUFBRW9NLFFBQUYsS0FBYW5NLENBQW5DLENBQUgsRUFBeUM7QUFBQyxVQUFJZ0osSUFBRWpKLEVBQUV3WixNQUFGLEdBQVN6WixFQUFFeVosTUFBakI7QUFBQSxVQUF3Qi9VLElBQUV6RSxFQUFFeVosTUFBRixHQUFTMVosRUFBRTBaLE1BQXJDO0FBQUEsVUFBNEN6UyxJQUFFa1QsR0FBR2xYLENBQUgsRUFBS2lHLENBQUwsRUFBT3hFLENBQVAsQ0FBOUMsQ0FBd0RpRCxJQUFFVixFQUFFbkgsQ0FBSixFQUFNMEgsSUFBRVAsRUFBRVMsQ0FBVixFQUFZTCxJQUFFMUQsRUFBRXNELEVBQUVuSCxDQUFKLElBQU82RCxFQUFFc0QsRUFBRVMsQ0FBSixDQUFQLEdBQWNULEVBQUVuSCxDQUFoQixHQUFrQm1ILEVBQUVTLENBQWxDLEVBQW9DMkIsSUFBRW1RLEdBQUd0USxDQUFILEVBQUt4RSxDQUFMLENBQXRDLEVBQThDekMsRUFBRWlZLFlBQUYsR0FBZWxhLENBQTdEO0FBQStELEtBQWpLLE1BQXNLcUgsSUFBRXBILEVBQUVvTSxRQUFKLEVBQWExRSxJQUFFMUgsRUFBRW1hLFNBQWpCLEVBQTJCNVMsSUFBRXZILEVBQUVvYSxTQUEvQixFQUF5Q2hSLElBQUVwSixFQUFFa1MsU0FBN0MsQ0FBdURuUyxFQUFFcU0sUUFBRixHQUFXaEYsQ0FBWCxFQUFhckgsRUFBRW9hLFNBQUYsR0FBWXpTLENBQXpCLEVBQTJCM0gsRUFBRXFhLFNBQUYsR0FBWTdTLENBQXZDLEVBQXlDeEgsRUFBRW1TLFNBQUYsR0FBWTlJLENBQXJEO0FBQXVELFlBQVN1UCxFQUFULENBQVkzVyxDQUFaLEVBQWM7QUFBQyxTQUFJLElBQUlqQyxJQUFFLEVBQU4sRUFBU0MsSUFBRSxDQUFmLEVBQWlCQSxJQUFFZ0MsRUFBRWdXLFFBQUYsQ0FBVy9VLE1BQTlCO0FBQXNDbEQsUUFBRUMsQ0FBRixJQUFLLEVBQUNxYSxTQUFROVMsRUFBRXZGLEVBQUVnVyxRQUFGLENBQVdoWSxDQUFYLEVBQWNxYSxPQUFoQixDQUFULEVBQWtDQyxTQUFRL1MsRUFBRXZGLEVBQUVnVyxRQUFGLENBQVdoWSxDQUFYLEVBQWNzYSxPQUFoQixDQUExQyxFQUFMLEVBQXlFdGEsR0FBekU7QUFBdEMsS0FBbUgsT0FBTSxFQUFDK1ksV0FBVTNQLEdBQVgsRUFBZTRPLFVBQVNqWSxDQUF4QixFQUEwQjhZLFFBQU9DLEdBQUcvWSxDQUFILENBQWpDLEVBQXVDeVosUUFBT3hYLEVBQUV3WCxNQUFoRCxFQUF1REMsUUFBT3pYLEVBQUV5WCxNQUFoRSxFQUFOO0FBQThFLFlBQVNYLEVBQVQsQ0FBWTlXLENBQVosRUFBYztBQUFDLFFBQUlqQyxJQUFFaUMsRUFBRWlCLE1BQVIsQ0FBZSxJQUFHLE1BQUlsRCxDQUFQLEVBQVMsT0FBTSxFQUFDRixHQUFFMEgsRUFBRXZGLEVBQUUsQ0FBRixFQUFLcVksT0FBUCxDQUFILEVBQW1CNVMsR0FBRUYsRUFBRXZGLEVBQUUsQ0FBRixFQUFLc1ksT0FBUCxDQUFyQixFQUFOLENBQTRDLEtBQUksSUFBSXRhLElBQUUsQ0FBTixFQUFRQyxJQUFFLENBQVYsRUFBWStDLElBQUUsQ0FBbEIsRUFBb0JqRCxJQUFFaUQsQ0FBdEI7QUFBeUJoRCxXQUFHZ0MsRUFBRWdCLENBQUYsRUFBS3FYLE9BQVIsRUFBZ0JwYSxLQUFHK0IsRUFBRWdCLENBQUYsRUFBS3NYLE9BQXhCLEVBQWdDdFgsR0FBaEM7QUFBekIsS0FBNkQsT0FBTSxFQUFDbkQsR0FBRTBILEVBQUV2SCxJQUFFRCxDQUFKLENBQUgsRUFBVTBILEdBQUVGLEVBQUV0SCxJQUFFRixDQUFKLENBQVosRUFBTjtBQUEwQixZQUFTbWEsRUFBVCxDQUFZbFksQ0FBWixFQUFjakMsQ0FBZCxFQUFnQkMsQ0FBaEIsRUFBa0I7QUFBQyxXQUFNLEVBQUNILEdBQUVFLElBQUVpQyxDQUFGLElBQUssQ0FBUixFQUFVeUYsR0FBRXpILElBQUVnQyxDQUFGLElBQUssQ0FBakIsRUFBTjtBQUEwQixZQUFTdVgsRUFBVCxDQUFZdlgsQ0FBWixFQUFjakMsQ0FBZCxFQUFnQjtBQUFDLFdBQU9pQyxNQUFJakMsQ0FBSixHQUFNNkgsQ0FBTixHQUFRbEUsRUFBRTFCLENBQUYsS0FBTTBCLEVBQUUzRCxDQUFGLENBQU4sR0FBV2lDLElBQUUsQ0FBRixHQUFJcUcsQ0FBSixHQUFNa1MsQ0FBakIsR0FBbUJ4YSxJQUFFLENBQUYsR0FBSTRILENBQUosR0FBTStNLENBQXhDO0FBQTBDLFlBQVMwRSxFQUFULENBQVlwWCxDQUFaLEVBQWNqQyxDQUFkLEVBQWdCQyxDQUFoQixFQUFrQjtBQUFDQSxVQUFJQSxJQUFFVCxDQUFOLEVBQVMsSUFBSVUsSUFBRUYsRUFBRUMsRUFBRSxDQUFGLENBQUYsSUFBUWdDLEVBQUVoQyxFQUFFLENBQUYsQ0FBRixDQUFkO0FBQUEsUUFBc0JnRCxJQUFFakQsRUFBRUMsRUFBRSxDQUFGLENBQUYsSUFBUWdDLEVBQUVoQyxFQUFFLENBQUYsQ0FBRixDQUFoQyxDQUF3QyxPQUFPZSxLQUFLVyxJQUFMLENBQVV6QixJQUFFQSxDQUFGLEdBQUkrQyxJQUFFQSxDQUFoQixDQUFQO0FBQTBCLFlBQVNrVyxFQUFULENBQVlsWCxDQUFaLEVBQWNqQyxDQUFkLEVBQWdCQyxDQUFoQixFQUFrQjtBQUFDQSxVQUFJQSxJQUFFVCxDQUFOLEVBQVMsSUFBSVUsSUFBRUYsRUFBRUMsRUFBRSxDQUFGLENBQUYsSUFBUWdDLEVBQUVoQyxFQUFFLENBQUYsQ0FBRixDQUFkO0FBQUEsUUFBc0JnRCxJQUFFakQsRUFBRUMsRUFBRSxDQUFGLENBQUYsSUFBUWdDLEVBQUVoQyxFQUFFLENBQUYsQ0FBRixDQUFoQyxDQUF3QyxPQUFPLE1BQUllLEtBQUt5WixLQUFMLENBQVd4WCxDQUFYLEVBQWEvQyxDQUFiLENBQUosR0FBb0JjLEtBQUtFLEVBQWhDO0FBQW1DLFlBQVMyWSxFQUFULENBQVk1WCxDQUFaLEVBQWNqQyxDQUFkLEVBQWdCO0FBQUMsV0FBT21aLEdBQUduWixFQUFFLENBQUYsQ0FBSCxFQUFRQSxFQUFFLENBQUYsQ0FBUixFQUFhMGEsQ0FBYixJQUFnQnZCLEdBQUdsWCxFQUFFLENBQUYsQ0FBSCxFQUFRQSxFQUFFLENBQUYsQ0FBUixFQUFheVksQ0FBYixDQUF2QjtBQUF1QyxZQUFTZixFQUFULENBQVkxWCxDQUFaLEVBQWNqQyxDQUFkLEVBQWdCO0FBQUMsV0FBT3FaLEdBQUdyWixFQUFFLENBQUYsQ0FBSCxFQUFRQSxFQUFFLENBQUYsQ0FBUixFQUFhMGEsQ0FBYixJQUFnQnJCLEdBQUdwWCxFQUFFLENBQUYsQ0FBSCxFQUFRQSxFQUFFLENBQUYsQ0FBUixFQUFheVksQ0FBYixDQUF2QjtBQUF1QyxZQUFTM0MsRUFBVCxHQUFhO0FBQUMsU0FBSzRDLElBQUwsR0FBVUMsRUFBVixFQUFhLEtBQUtDLEtBQUwsR0FBV0MsRUFBeEIsRUFBMkIsS0FBS0MsS0FBTCxHQUFXLENBQUMsQ0FBdkMsRUFBeUMsS0FBS0MsT0FBTCxHQUFhLENBQUMsQ0FBdkQsRUFBeUQ5RCxHQUFHOVMsS0FBSCxDQUFTLElBQVQsRUFBY0ssU0FBZCxDQUF6RDtBQUFrRixZQUFTbVQsRUFBVCxHQUFhO0FBQUMsU0FBSytDLElBQUwsR0FBVU0sRUFBVixFQUFhLEtBQUtKLEtBQUwsR0FBV0ssRUFBeEIsRUFBMkJoRSxHQUFHOVMsS0FBSCxDQUFTLElBQVQsRUFBY0ssU0FBZCxDQUEzQixFQUFvRCxLQUFLMFcsS0FBTCxHQUFXLEtBQUtoRSxPQUFMLENBQWFrQixPQUFiLENBQXFCK0MsYUFBckIsR0FBbUMsRUFBbEc7QUFBcUcsWUFBU0MsRUFBVCxHQUFhO0FBQUMsU0FBS0MsUUFBTCxHQUFjQyxFQUFkLEVBQWlCLEtBQUtWLEtBQUwsR0FBV1csRUFBNUIsRUFBK0IsS0FBS0MsT0FBTCxHQUFhLENBQUMsQ0FBN0MsRUFBK0N2RSxHQUFHOVMsS0FBSCxDQUFTLElBQVQsRUFBY0ssU0FBZCxDQUEvQztBQUF3RSxZQUFTaVgsRUFBVCxDQUFZelosQ0FBWixFQUFjakMsQ0FBZCxFQUFnQjtBQUFDLFFBQUlDLElBQUVvVSxFQUFFcFMsRUFBRTBaLE9BQUosQ0FBTjtBQUFBLFFBQW1CemIsSUFBRW1VLEVBQUVwUyxFQUFFMlosY0FBSixDQUFyQixDQUF5QyxPQUFPNWIsS0FBRytVLElBQUVDLENBQUwsTUFBVS9VLElBQUVrSixFQUFFbEosRUFBRXdJLE1BQUYsQ0FBU3ZJLENBQVQsQ0FBRixFQUFjLFlBQWQsRUFBMkIsQ0FBQyxDQUE1QixDQUFaLEdBQTRDLENBQUNELENBQUQsRUFBR0MsQ0FBSCxDQUFuRDtBQUF5RCxZQUFTMlgsRUFBVCxHQUFhO0FBQUMsU0FBS3lELFFBQUwsR0FBY08sRUFBZCxFQUFpQixLQUFLQyxTQUFMLEdBQWUsRUFBaEMsRUFBbUM1RSxHQUFHOVMsS0FBSCxDQUFTLElBQVQsRUFBY0ssU0FBZCxDQUFuQztBQUE0RCxZQUFTc1gsRUFBVCxDQUFZOVosQ0FBWixFQUFjakMsQ0FBZCxFQUFnQjtBQUFDLFFBQUlDLElBQUVvVSxFQUFFcFMsRUFBRTBaLE9BQUosQ0FBTjtBQUFBLFFBQW1CemIsSUFBRSxLQUFLNGIsU0FBMUIsQ0FBb0MsSUFBRzliLEtBQUdzVSxJQUFFeE0sQ0FBTCxLQUFTLE1BQUk3SCxFQUFFaUQsTUFBbEIsRUFBeUIsT0FBT2hELEVBQUVELEVBQUUsQ0FBRixFQUFLK2IsVUFBUCxJQUFtQixDQUFDLENBQXBCLEVBQXNCLENBQUMvYixDQUFELEVBQUdBLENBQUgsQ0FBN0IsQ0FBbUMsSUFBSWdELENBQUo7QUFBQSxRQUFNb0UsQ0FBTjtBQUFBLFFBQVFNLElBQUUwTSxFQUFFcFMsRUFBRTJaLGNBQUosQ0FBVjtBQUFBLFFBQThCcFUsSUFBRSxFQUFoQztBQUFBLFFBQW1DN0QsSUFBRSxLQUFLMFQsTUFBMUMsQ0FBaUQsSUFBR2hRLElBQUVwSCxFQUFFZ2MsTUFBRixDQUFTLFVBQVNoYSxDQUFULEVBQVc7QUFBQyxhQUFPd0YsRUFBRXhGLEVBQUVvVixNQUFKLEVBQVcxVCxDQUFYLENBQVA7QUFBcUIsS0FBMUMsQ0FBRixFQUE4QzNELE1BQUlzVSxDQUFyRCxFQUF1RCxLQUFJclIsSUFBRSxDQUFOLEVBQVFBLElBQUVvRSxFQUFFbkUsTUFBWjtBQUFvQmhELFFBQUVtSCxFQUFFcEUsQ0FBRixFQUFLK1ksVUFBUCxJQUFtQixDQUFDLENBQXBCLEVBQXNCL1ksR0FBdEI7QUFBcEIsS0FBOEMsS0FBSUEsSUFBRSxDQUFOLEVBQVFBLElBQUUwRSxFQUFFekUsTUFBWjtBQUFvQmhELFFBQUV5SCxFQUFFMUUsQ0FBRixFQUFLK1ksVUFBUCxLQUFvQnhVLEVBQUUxQyxJQUFGLENBQU82QyxFQUFFMUUsQ0FBRixDQUFQLENBQXBCLEVBQWlDakQsS0FBRytVLElBQUVDLENBQUwsS0FBUyxPQUFPOVUsRUFBRXlILEVBQUUxRSxDQUFGLEVBQUsrWSxVQUFQLENBQWpELEVBQW9FL1ksR0FBcEU7QUFBcEIsS0FBNEYsT0FBT3VFLEVBQUV0RSxNQUFGLEdBQVMsQ0FBQ2lHLEVBQUU5QixFQUFFb0IsTUFBRixDQUFTakIsQ0FBVCxDQUFGLEVBQWMsWUFBZCxFQUEyQixDQUFDLENBQTVCLENBQUQsRUFBZ0NBLENBQWhDLENBQVQsR0FBNEMsS0FBSyxDQUF4RDtBQUEwRCxZQUFTc1EsRUFBVCxHQUFhO0FBQUNaLE9BQUc5UyxLQUFILENBQVMsSUFBVCxFQUFjSyxTQUFkLEVBQXlCLElBQUl4QyxJQUFFc1MsRUFBRSxLQUFLa0QsT0FBUCxFQUFlLElBQWYsQ0FBTixDQUEyQixLQUFLeUUsS0FBTCxHQUFXLElBQUlyRSxFQUFKLENBQU8sS0FBS1YsT0FBWixFQUFvQmxWLENBQXBCLENBQVgsRUFBa0MsS0FBS2thLEtBQUwsR0FBVyxJQUFJcEUsRUFBSixDQUFPLEtBQUtaLE9BQVosRUFBb0JsVixDQUFwQixDQUE3QztBQUFvRSxZQUFTbWEsRUFBVCxDQUFZbmEsQ0FBWixFQUFjakMsQ0FBZCxFQUFnQjtBQUFDLFNBQUttWCxPQUFMLEdBQWFsVixDQUFiLEVBQWUsS0FBS29hLEdBQUwsQ0FBU3JjLENBQVQsQ0FBZjtBQUEyQixZQUFTc2MsRUFBVCxDQUFZcmEsQ0FBWixFQUFjO0FBQUMsUUFBR3NGLEVBQUV0RixDQUFGLEVBQUlzYSxFQUFKLENBQUgsRUFBVyxPQUFPQSxFQUFQLENBQVUsSUFBSXZjLElBQUV1SCxFQUFFdEYsQ0FBRixFQUFJdWEsRUFBSixDQUFOO0FBQUEsUUFBY3ZjLElBQUVzSCxFQUFFdEYsQ0FBRixFQUFJd2EsRUFBSixDQUFoQixDQUF3QixPQUFPemMsS0FBR0MsQ0FBSCxHQUFLdWMsS0FBRyxHQUFILEdBQU9DLEVBQVosR0FBZXpjLEtBQUdDLENBQUgsR0FBS0QsSUFBRXdjLEVBQUYsR0FBS0MsRUFBVixHQUFhbFYsRUFBRXRGLENBQUYsRUFBSXlhLEVBQUosSUFBUUEsRUFBUixHQUFXQyxFQUE5QztBQUFpRCxZQUFTQyxFQUFULENBQVkzYSxDQUFaLEVBQWM7QUFBQyxTQUFLNGEsRUFBTCxHQUFRL0gsR0FBUixFQUFZLEtBQUtxQyxPQUFMLEdBQWEsSUFBekIsRUFBOEIsS0FBSzNCLE9BQUwsR0FBYXZSLEVBQUVoQyxLQUFHLEVBQUwsRUFBUSxLQUFLeUcsUUFBYixDQUEzQyxFQUFrRSxLQUFLOE0sT0FBTCxDQUFhZ0MsTUFBYixHQUFvQnpWLEVBQUUsS0FBS3lULE9BQUwsQ0FBYWdDLE1BQWYsRUFBc0IsQ0FBQyxDQUF2QixDQUF0RixFQUFnSCxLQUFLc0YsS0FBTCxHQUFXQyxFQUEzSCxFQUE4SCxLQUFLQyxZQUFMLEdBQWtCLEVBQWhKLEVBQW1KLEtBQUtDLFdBQUwsR0FBaUIsRUFBcEs7QUFBdUssWUFBU0MsRUFBVCxDQUFZamIsQ0FBWixFQUFjO0FBQUMsV0FBT0EsSUFBRWtiLEVBQUYsR0FBSyxRQUFMLEdBQWNsYixJQUFFbWIsRUFBRixHQUFLLEtBQUwsR0FBV25iLElBQUVvYixFQUFGLEdBQUssTUFBTCxHQUFZcGIsSUFBRXFiLEVBQUYsR0FBSyxPQUFMLEdBQWEsRUFBekQ7QUFBNEQsWUFBU0MsRUFBVCxDQUFZdGIsQ0FBWixFQUFjO0FBQUMsV0FBT0EsS0FBRzBTLENBQUgsR0FBSyxNQUFMLEdBQVkxUyxLQUFHMkYsQ0FBSCxHQUFLLElBQUwsR0FBVTNGLEtBQUdxRyxDQUFILEdBQUssTUFBTCxHQUFZckcsS0FBR3VZLENBQUgsR0FBSyxPQUFMLEdBQWEsRUFBdEQ7QUFBeUQsWUFBU2dELEVBQVQsQ0FBWXZiLENBQVosRUFBY2pDLENBQWQsRUFBZ0I7QUFBQyxRQUFJQyxJQUFFRCxFQUFFbVgsT0FBUixDQUFnQixPQUFPbFgsSUFBRUEsRUFBRXdkLEdBQUYsQ0FBTXhiLENBQU4sQ0FBRixHQUFXQSxDQUFsQjtBQUFvQixZQUFTeWIsRUFBVCxHQUFhO0FBQUNkLE9BQUd4WSxLQUFILENBQVMsSUFBVCxFQUFjSyxTQUFkO0FBQXlCLFlBQVNrWixFQUFULEdBQWE7QUFBQ0QsT0FBR3RaLEtBQUgsQ0FBUyxJQUFULEVBQWNLLFNBQWQsR0FBeUIsS0FBS21aLEVBQUwsR0FBUSxJQUFqQyxFQUFzQyxLQUFLQyxFQUFMLEdBQVEsSUFBOUM7QUFBbUQsWUFBU0MsRUFBVCxHQUFhO0FBQUNKLE9BQUd0WixLQUFILENBQVMsSUFBVCxFQUFjSyxTQUFkO0FBQXlCLFlBQVNzWixFQUFULEdBQWE7QUFBQ25CLE9BQUd4WSxLQUFILENBQVMsSUFBVCxFQUFjSyxTQUFkLEdBQXlCLEtBQUt1WixNQUFMLEdBQVksSUFBckMsRUFBMEMsS0FBS0MsTUFBTCxHQUFZLElBQXREO0FBQTJELFlBQVNDLEVBQVQsR0FBYTtBQUFDUixPQUFHdFosS0FBSCxDQUFTLElBQVQsRUFBY0ssU0FBZDtBQUF5QixZQUFTMFosRUFBVCxHQUFhO0FBQUNULE9BQUd0WixLQUFILENBQVMsSUFBVCxFQUFjSyxTQUFkO0FBQXlCLFlBQVMyWixFQUFULEdBQWE7QUFBQ3hCLE9BQUd4WSxLQUFILENBQVMsSUFBVCxFQUFjSyxTQUFkLEdBQXlCLEtBQUs0WixLQUFMLEdBQVcsQ0FBQyxDQUFyQyxFQUF1QyxLQUFLQyxPQUFMLEdBQWEsQ0FBQyxDQUFyRCxFQUF1RCxLQUFLTixNQUFMLEdBQVksSUFBbkUsRUFBd0UsS0FBS0MsTUFBTCxHQUFZLElBQXBGLEVBQXlGLEtBQUtNLEtBQUwsR0FBVyxDQUFwRztBQUFzRyxZQUFTQyxFQUFULENBQVl2YyxDQUFaLEVBQWNqQyxDQUFkLEVBQWdCO0FBQUMsV0FBT0EsSUFBRUEsS0FBRyxFQUFMLEVBQVFBLEVBQUV5ZSxXQUFGLEdBQWMxYyxFQUFFL0IsRUFBRXllLFdBQUosRUFBZ0JELEdBQUc5VixRQUFILENBQVlnVyxNQUE1QixDQUF0QixFQUEwRCxJQUFJQyxFQUFKLENBQU8xYyxDQUFQLEVBQVNqQyxDQUFULENBQWpFO0FBQTZFLFlBQVMyZSxFQUFULENBQVkxYyxDQUFaLEVBQWNqQyxDQUFkLEVBQWdCO0FBQUNBLFFBQUVBLEtBQUcsRUFBTCxFQUFRLEtBQUt3VixPQUFMLEdBQWF2UixFQUFFakUsQ0FBRixFQUFJd2UsR0FBRzlWLFFBQVAsQ0FBckIsRUFBc0MsS0FBSzhNLE9BQUwsQ0FBYThCLFdBQWIsR0FBeUIsS0FBSzlCLE9BQUwsQ0FBYThCLFdBQWIsSUFBMEJyVixDQUF6RixFQUEyRixLQUFLMmMsUUFBTCxHQUFjLEVBQXpHLEVBQTRHLEtBQUt2RyxPQUFMLEdBQWEsRUFBekgsRUFBNEgsS0FBS29HLFdBQUwsR0FBaUIsRUFBN0ksRUFBZ0osS0FBSzNWLE9BQUwsR0FBYTdHLENBQTdKLEVBQStKLEtBQUs0YyxLQUFMLEdBQVduSCxHQUFHLElBQUgsQ0FBMUssRUFBbUwsS0FBS29ILFdBQUwsR0FBaUIsSUFBSTFDLEVBQUosQ0FBTyxJQUFQLEVBQVksS0FBSzVHLE9BQUwsQ0FBYXNKLFdBQXpCLENBQXBNLEVBQTBPQyxHQUFHLElBQUgsRUFBUSxDQUFDLENBQVQsQ0FBMU8sRUFBc1A5WCxFQUFFakgsRUFBRXllLFdBQUosRUFBZ0IsVUFBU3hjLENBQVQsRUFBVztBQUFDLFVBQUlqQyxJQUFFLEtBQUt3UixHQUFMLENBQVMsSUFBSXZQLEVBQUUsQ0FBRixDQUFKLENBQVNBLEVBQUUsQ0FBRixDQUFULENBQVQsQ0FBTixDQUErQkEsRUFBRSxDQUFGLEtBQU1qQyxFQUFFZ2YsYUFBRixDQUFnQi9jLEVBQUUsQ0FBRixDQUFoQixDQUFOLEVBQTRCQSxFQUFFLENBQUYsS0FBTWpDLEVBQUVpZixjQUFGLENBQWlCaGQsRUFBRSxDQUFGLENBQWpCLENBQWxDO0FBQXlELEtBQXBILEVBQXFILElBQXJILENBQXRQO0FBQWlYLFlBQVM4YyxFQUFULENBQVk5YyxDQUFaLEVBQWNqQyxDQUFkLEVBQWdCO0FBQUMsUUFBSUMsSUFBRWdDLEVBQUU2RyxPQUFSLENBQWdCN0IsRUFBRWhGLEVBQUV1VCxPQUFGLENBQVUwSixRQUFaLEVBQXFCLFVBQVNqZCxDQUFULEVBQVcvQixDQUFYLEVBQWE7QUFBQ0QsUUFBRWdHLEtBQUYsQ0FBUXlPLEVBQUV6VSxFQUFFZ0csS0FBSixFQUFVL0YsQ0FBVixDQUFSLElBQXNCRixJQUFFaUMsQ0FBRixHQUFJLEVBQTFCO0FBQTZCLEtBQWhFO0FBQWtFLFlBQVNrZCxFQUFULENBQVlsZCxDQUFaLEVBQWNoQyxDQUFkLEVBQWdCO0FBQUMsUUFBSUMsSUFBRUYsRUFBRW9mLFdBQUYsQ0FBYyxPQUFkLENBQU4sQ0FBNkJsZixFQUFFbWYsU0FBRixDQUFZcGQsQ0FBWixFQUFjLENBQUMsQ0FBZixFQUFpQixDQUFDLENBQWxCLEdBQXFCL0IsRUFBRW9mLE9BQUYsR0FBVXJmLENBQS9CLEVBQWlDQSxFQUFFb1gsTUFBRixDQUFTa0ksYUFBVCxDQUF1QnJmLENBQXZCLENBQWpDO0FBQTJELE9BQUkrQyxJQUFFLENBQUMsRUFBRCxFQUFJLFFBQUosRUFBYSxLQUFiLEVBQW1CLElBQW5CLEVBQXdCLElBQXhCLEVBQTZCLEdBQTdCLENBQU47QUFBQSxNQUF3Q29FLElBQUVySCxFQUFFdUwsYUFBRixDQUFnQixLQUFoQixDQUExQztBQUFBLE1BQWlFNUQsSUFBRSxVQUFuRTtBQUFBLE1BQThFSCxJQUFFeEcsS0FBS3NHLEtBQXJGO0FBQUEsTUFBMkYzRCxJQUFFM0MsS0FBS2tCLEdBQWxHO0FBQUEsTUFBc0dtSCxJQUFFNUMsS0FBSytZLEdBQTdHO0FBQUEsTUFBaUhwWCxJQUFFLENBQW5IO0FBQUEsTUFBcUhnQixJQUFFLHVDQUF2SDtBQUFBLE1BQStKd0wsSUFBRSxrQkFBaUIzUyxDQUFsTDtBQUFBLE1BQW9MMkgsSUFBRThLLEVBQUV6UyxDQUFGLEVBQUksY0FBSixNQUFzQi9CLENBQTVNO0FBQUEsTUFBOE11VSxJQUFFRyxLQUFHeEwsRUFBRWxELElBQUYsQ0FBT3NHLFVBQVVDLFNBQWpCLENBQW5OO0FBQUEsTUFBK09nVCxJQUFFLE9BQWpQO0FBQUEsTUFBeVBDLElBQUUsS0FBM1A7QUFBQSxNQUFpUXpWLElBQUUsT0FBblE7QUFBQSxNQUEyUXVLLElBQUUsUUFBN1E7QUFBQSxNQUFzUjFLLElBQUUsRUFBeFI7QUFBQSxNQUEyUndLLElBQUUsQ0FBN1I7QUFBQSxNQUErUnhNLElBQUUsQ0FBalM7QUFBQSxNQUFtU2lOLElBQUUsQ0FBclM7QUFBQSxNQUF1U0MsSUFBRSxDQUF6UztBQUFBLE1BQTJTbk4sSUFBRSxDQUE3UztBQUFBLE1BQStTUyxJQUFFLENBQWpUO0FBQUEsTUFBbVRrUyxJQUFFLENBQXJUO0FBQUEsTUFBdVQ1UyxJQUFFLENBQXpUO0FBQUEsTUFBMlQrTSxJQUFFLEVBQTdUO0FBQUEsTUFBZ1VnTCxJQUFFclgsSUFBRWtTLENBQXBVO0FBQUEsTUFBc1UzRixJQUFFak4sSUFBRStNLENBQTFVO0FBQUEsTUFBNFVpTCxJQUFFRCxJQUFFOUssQ0FBaFY7QUFBQSxNQUFrVnJWLElBQUUsQ0FBQyxHQUFELEVBQUssR0FBTCxDQUFwVjtBQUFBLE1BQThWa2IsSUFBRSxDQUFDLFNBQUQsRUFBVyxTQUFYLENBQWhXLENBQXNYeEQsR0FBR2hULFNBQUgsR0FBYSxFQUFDdVQsU0FBUSxtQkFBVSxDQUFFLENBQXJCLEVBQXNCalUsTUFBSyxnQkFBVTtBQUFDLFdBQUttWCxJQUFMLElBQVc1YSxFQUFFLEtBQUsrSSxPQUFQLEVBQWUsS0FBSzZSLElBQXBCLEVBQXlCLEtBQUtwRCxVQUE5QixDQUFYLEVBQXFELEtBQUsrRCxRQUFMLElBQWV2YixFQUFFLEtBQUtzWCxNQUFQLEVBQWMsS0FBS2lFLFFBQW5CLEVBQTRCLEtBQUsvRCxVQUFqQyxDQUFwRSxFQUFpSCxLQUFLc0QsS0FBTCxJQUFZOWEsRUFBRXdKLEVBQUUsS0FBS1QsT0FBUCxDQUFGLEVBQWtCLEtBQUsrUixLQUF2QixFQUE2QixLQUFLdEQsVUFBbEMsQ0FBN0g7QUFBMkssS0FBak4sRUFBa05zSSxTQUFRLG1CQUFVO0FBQUMsV0FBS2xGLElBQUwsSUFBV2hXLEVBQUUsS0FBS21FLE9BQVAsRUFBZSxLQUFLNlIsSUFBcEIsRUFBeUIsS0FBS3BELFVBQTlCLENBQVgsRUFBcUQsS0FBSytELFFBQUwsSUFBZTNXLEVBQUUsS0FBSzBTLE1BQVAsRUFBYyxLQUFLaUUsUUFBbkIsRUFBNEIsS0FBSy9ELFVBQWpDLENBQXBFLEVBQWlILEtBQUtzRCxLQUFMLElBQVlsVyxFQUFFNEUsRUFBRSxLQUFLVCxPQUFQLENBQUYsRUFBa0IsS0FBSytSLEtBQXZCLEVBQTZCLEtBQUt0RCxVQUFsQyxDQUE3SDtBQUEySyxLQUFoWixFQUFiLENBQStaLElBQUl1SSxLQUFHLEVBQUNDLFdBQVV6TCxDQUFYLEVBQWEwTCxXQUFVbFksQ0FBdkIsRUFBeUJtWSxTQUFRbEwsQ0FBakMsRUFBUDtBQUFBLE1BQTJDNkYsS0FBRyxXQUE5QztBQUFBLE1BQTBERSxLQUFHLG1CQUE3RCxDQUFpRjlZLEVBQUUrVixFQUFGLEVBQUtiLEVBQUwsRUFBUSxFQUFDTyxTQUFRLGlCQUFTeFYsQ0FBVCxFQUFXO0FBQUMsVUFBSWpDLElBQUU4ZixHQUFHN2QsRUFBRW1CLElBQUwsQ0FBTixDQUFpQnBELElBQUVzVSxDQUFGLElBQUssTUFBSXJTLEVBQUVpZSxNQUFYLEtBQW9CLEtBQUtsRixPQUFMLEdBQWEsQ0FBQyxDQUFsQyxHQUFxQ2hiLElBQUU4SCxDQUFGLElBQUssTUFBSTdGLEVBQUVrZSxLQUFYLEtBQW1CbmdCLElBQUUrVSxDQUFyQixDQUFyQyxFQUE2RCxLQUFLaUcsT0FBTCxJQUFjLEtBQUtELEtBQW5CLEtBQTJCL2EsSUFBRStVLENBQUYsS0FBTSxLQUFLaUcsT0FBTCxHQUFhLENBQUMsQ0FBcEIsR0FBdUIsS0FBSzVELFFBQUwsQ0FBYyxLQUFLRCxPQUFuQixFQUEyQm5YLENBQTNCLEVBQTZCLEVBQUNpWSxVQUFTLENBQUNoVyxDQUFELENBQVYsRUFBY2lXLGlCQUFnQixDQUFDalcsQ0FBRCxDQUE5QixFQUFrQ21lLGFBQVluVyxDQUE5QyxFQUFnRDhQLFVBQVM5WCxDQUF6RCxFQUE3QixDQUFsRCxDQUE3RDtBQUEwTSxLQUFoUCxFQUFSLEVBQTJQLElBQUlvZSxLQUFHLEVBQUNDLGFBQVloTSxDQUFiLEVBQWVpTSxhQUFZelksQ0FBM0IsRUFBNkIwWSxXQUFVekwsQ0FBdkMsRUFBeUMwTCxlQUFjekwsQ0FBdkQsRUFBeUQwTCxZQUFXMUwsQ0FBcEUsRUFBUDtBQUFBLE1BQThFMkwsS0FBRyxFQUFDLEdBQUVsQixDQUFILEVBQUssR0FBRUMsQ0FBUCxFQUFTLEdBQUV6VixDQUFYLEVBQWEsR0FBRXVLLENBQWYsRUFBakY7QUFBQSxNQUFtR3lHLEtBQUcsYUFBdEc7QUFBQSxNQUFvSEMsS0FBRyxxQ0FBdkgsQ0FBNkpqWixFQUFFMmUsY0FBRixLQUFtQjNGLEtBQUcsZUFBSCxFQUFtQkMsS0FBRywyQ0FBekMsR0FBc0ZsWixFQUFFNFYsRUFBRixFQUFLVixFQUFMLEVBQVEsRUFBQ08sU0FBUSxpQkFBU3hWLENBQVQsRUFBVztBQUFDLFVBQUlqQyxJQUFFLEtBQUttYixLQUFYO0FBQUEsVUFBaUJsYixJQUFFLENBQUMsQ0FBcEI7QUFBQSxVQUFzQkMsSUFBRStCLEVBQUVtQixJQUFGLENBQU80QyxXQUFQLEdBQXFCZ0ssT0FBckIsQ0FBNkIsSUFBN0IsRUFBa0MsRUFBbEMsQ0FBeEI7QUFBQSxVQUE4RC9NLElBQUVvZCxHQUFHbmdCLENBQUgsQ0FBaEU7QUFBQSxVQUFzRW1ILElBQUVzWixHQUFHMWUsRUFBRW1lLFdBQUwsS0FBbUJuZSxFQUFFbWUsV0FBN0Y7QUFBQSxVQUF5R3pZLElBQUVOLEtBQUdvWSxDQUE5RztBQUFBLFVBQWdIalksSUFBRUUsRUFBRTFILENBQUYsRUFBSWlDLEVBQUU0ZSxTQUFOLEVBQWdCLFdBQWhCLENBQWxILENBQStJNWQsSUFBRXFSLENBQUYsS0FBTSxNQUFJclMsRUFBRWllLE1BQU4sSUFBY3ZZLENBQXBCLElBQXVCLElBQUVILENBQUYsS0FBTXhILEVBQUU4RSxJQUFGLENBQU83QyxDQUFQLEdBQVV1RixJQUFFeEgsRUFBRWtELE1BQUYsR0FBUyxDQUEzQixDQUF2QixHQUFxREQsS0FBRzhSLElBQUVDLENBQUwsTUFBVS9VLElBQUUsQ0FBQyxDQUFiLENBQXJELEVBQXFFLElBQUV1SCxDQUFGLEtBQU14SCxFQUFFd0gsQ0FBRixJQUFLdkYsQ0FBTCxFQUFPLEtBQUttVixRQUFMLENBQWMsS0FBS0QsT0FBbkIsRUFBMkJsVSxDQUEzQixFQUE2QixFQUFDZ1YsVUFBU2pZLENBQVYsRUFBWWtZLGlCQUFnQixDQUFDalcsQ0FBRCxDQUE1QixFQUFnQ21lLGFBQVkvWSxDQUE1QyxFQUE4QzBTLFVBQVM5WCxDQUF2RCxFQUE3QixDQUFQLEVBQStGaEMsS0FBR0QsRUFBRThnQixNQUFGLENBQVN0WixDQUFULEVBQVcsQ0FBWCxDQUF4RyxDQUFyRTtBQUE0TCxLQUFoVyxFQUFSLENBQXRGLENBQWljLElBQUl1WixLQUFHLEVBQUNDLFlBQVcxTSxDQUFaLEVBQWMyTSxXQUFVblosQ0FBeEIsRUFBMEJvWixVQUFTbk0sQ0FBbkMsRUFBcUNvTSxhQUFZbk0sQ0FBakQsRUFBUDtBQUFBLE1BQTJEdUcsS0FBRyxZQUE5RDtBQUFBLE1BQTJFQyxLQUFHLDJDQUE5RSxDQUEwSHhaLEVBQUVxWixFQUFGLEVBQUtuRSxFQUFMLEVBQVEsRUFBQ08sU0FBUSxpQkFBU3hWLENBQVQsRUFBVztBQUFDLFVBQUlqQyxJQUFFK2dCLEdBQUc5ZSxFQUFFbUIsSUFBTCxDQUFOLENBQWlCLElBQUdwRCxNQUFJc1UsQ0FBSixLQUFRLEtBQUttSCxPQUFMLEdBQWEsQ0FBQyxDQUF0QixHQUF5QixLQUFLQSxPQUFqQyxFQUF5QztBQUFDLFlBQUl4YixJQUFFeWIsR0FBRzlYLElBQUgsQ0FBUSxJQUFSLEVBQWEzQixDQUFiLEVBQWVqQyxDQUFmLENBQU4sQ0FBd0JBLEtBQUcrVSxJQUFFQyxDQUFMLEtBQVMsTUFBSS9VLEVBQUUsQ0FBRixFQUFLaUQsTUFBTCxHQUFZakQsRUFBRSxDQUFGLEVBQUtpRCxNQUE5QixLQUF1QyxLQUFLdVksT0FBTCxHQUFhLENBQUMsQ0FBckQsR0FBd0QsS0FBS3JFLFFBQUwsQ0FBYyxLQUFLRCxPQUFuQixFQUEyQm5YLENBQTNCLEVBQTZCLEVBQUNpWSxVQUFTaFksRUFBRSxDQUFGLENBQVYsRUFBZWlZLGlCQUFnQmpZLEVBQUUsQ0FBRixDQUEvQixFQUFvQ21nQixhQUFZWCxDQUFoRCxFQUFrRDFGLFVBQVM5WCxDQUEzRCxFQUE3QixDQUF4RDtBQUFvSjtBQUFDLEtBQTdQLEVBQVIsRUFBd1EsSUFBSW1mLEtBQUcsRUFBQ0osWUFBVzFNLENBQVosRUFBYzJNLFdBQVVuWixDQUF4QixFQUEwQm9aLFVBQVNuTSxDQUFuQyxFQUFxQ29NLGFBQVluTSxDQUFqRCxFQUFQO0FBQUEsTUFBMkQ2RyxLQUFHLDJDQUE5RCxDQUEwRzdaLEVBQUU2VixFQUFGLEVBQUtYLEVBQUwsRUFBUSxFQUFDTyxTQUFRLGlCQUFTeFYsQ0FBVCxFQUFXO0FBQUMsVUFBSWpDLElBQUVvaEIsR0FBR25mLEVBQUVtQixJQUFMLENBQU47QUFBQSxVQUFpQm5ELElBQUU4YixHQUFHblksSUFBSCxDQUFRLElBQVIsRUFBYTNCLENBQWIsRUFBZWpDLENBQWYsQ0FBbkIsQ0FBcUNDLEtBQUcsS0FBS21YLFFBQUwsQ0FBYyxLQUFLRCxPQUFuQixFQUEyQm5YLENBQTNCLEVBQTZCLEVBQUNpWSxVQUFTaFksRUFBRSxDQUFGLENBQVYsRUFBZWlZLGlCQUFnQmpZLEVBQUUsQ0FBRixDQUEvQixFQUFvQ21nQixhQUFZWCxDQUFoRCxFQUFrRDFGLFVBQVM5WCxDQUEzRCxFQUE3QixDQUFIO0FBQStGLEtBQXpKLEVBQVIsR0FBb0tELEVBQUU4VixFQUFGLEVBQUtaLEVBQUwsRUFBUSxFQUFDTyxTQUFRLGlCQUFTeFYsQ0FBVCxFQUFXakMsQ0FBWCxFQUFhQyxDQUFiLEVBQWU7QUFBQyxVQUFJQyxJQUFFRCxFQUFFbWdCLFdBQUYsSUFBZVgsQ0FBckI7QUFBQSxVQUF1QnhjLElBQUVoRCxFQUFFbWdCLFdBQUYsSUFBZW5XLENBQXhDLENBQTBDLElBQUcvSixDQUFILEVBQUssS0FBS2ljLEtBQUwsQ0FBV3BCLEtBQVgsR0FBaUIsQ0FBQyxDQUFsQixDQUFMLEtBQThCLElBQUc5WCxLQUFHLENBQUMsS0FBS2taLEtBQUwsQ0FBV3BCLEtBQWxCLEVBQXdCLE9BQU8vYSxLQUFHK1UsSUFBRUMsQ0FBTCxNQUFVLEtBQUttSCxLQUFMLENBQVdwQixLQUFYLEdBQWlCLENBQUMsQ0FBNUIsR0FBK0IsS0FBSzNELFFBQUwsQ0FBY25WLENBQWQsRUFBZ0JqQyxDQUFoQixFQUFrQkMsQ0FBbEIsQ0FBL0I7QUFBb0QsS0FBcEwsRUFBcUw0ZixTQUFRLG1CQUFVO0FBQUMsV0FBSzNELEtBQUwsQ0FBVzJELE9BQVgsSUFBcUIsS0FBSzFELEtBQUwsQ0FBVzBELE9BQVgsRUFBckI7QUFBMEMsS0FBbFAsRUFBUixDQUFwSyxDQUFpYSxJQUFJd0IsS0FBRzNNLEVBQUVyTixFQUFFcEIsS0FBSixFQUFVLGFBQVYsQ0FBUDtBQUFBLE1BQWdDcWIsS0FBR0QsT0FBS25oQixDQUF4QztBQUFBLE1BQTBDcWhCLEtBQUcsU0FBN0M7QUFBQSxNQUF1RDVFLEtBQUcsTUFBMUQ7QUFBQSxNQUFpRUQsS0FBRyxjQUFwRTtBQUFBLE1BQW1GSCxLQUFHLE1BQXRGO0FBQUEsTUFBNkZDLEtBQUcsT0FBaEc7QUFBQSxNQUF3R0MsS0FBRyxPQUEzRyxDQUFtSEwsR0FBR2xZLFNBQUgsR0FBYSxFQUFDbVksS0FBSSxhQUFTcGEsQ0FBVCxFQUFXO0FBQUNBLFdBQUdzZixFQUFILEtBQVF0ZixJQUFFLEtBQUt1ZixPQUFMLEVBQVYsR0FBMEJGLE9BQUssS0FBS25LLE9BQUwsQ0FBYXJPLE9BQWIsQ0FBcUI3QyxLQUFyQixDQUEyQm9iLEVBQTNCLElBQStCcGYsQ0FBcEMsQ0FBMUIsRUFBaUUsS0FBS3dmLE9BQUwsR0FBYXhmLEVBQUUrRCxXQUFGLEdBQWdCNlEsSUFBaEIsRUFBOUU7QUFBcUcsS0FBdEgsRUFBdUg2SyxRQUFPLGtCQUFVO0FBQUMsV0FBS3JGLEdBQUwsQ0FBUyxLQUFLbEYsT0FBTCxDQUFhM0IsT0FBYixDQUFxQnNKLFdBQTlCO0FBQTJDLEtBQXBMLEVBQXFMMEMsU0FBUSxtQkFBVTtBQUFDLFVBQUl2ZixJQUFFLEVBQU4sQ0FBUyxPQUFPZ0YsRUFBRSxLQUFLa1EsT0FBTCxDQUFhc0gsV0FBZixFQUEyQixVQUFTemUsQ0FBVCxFQUFXO0FBQUNtRCxVQUFFbkQsRUFBRXdWLE9BQUYsQ0FBVWdDLE1BQVosRUFBbUIsQ0FBQ3hYLENBQUQsQ0FBbkIsTUFBMEJpQyxJQUFFQSxFQUFFd0csTUFBRixDQUFTekksRUFBRTJoQixjQUFGLEVBQVQsQ0FBNUI7QUFBMEQsT0FBakcsR0FBbUdyRixHQUFHcmEsRUFBRTBOLElBQUYsQ0FBTyxHQUFQLENBQUgsQ0FBMUc7QUFBMEgsS0FBM1UsRUFBNFVpUyxpQkFBZ0IseUJBQVMzZixDQUFULEVBQVc7QUFBQyxVQUFHLENBQUNxZixFQUFKLEVBQU87QUFBQyxZQUFJdGhCLElBQUVpQyxFQUFFOFgsUUFBUjtBQUFBLFlBQWlCOVosSUFBRWdDLEVBQUVzWCxlQUFyQixDQUFxQyxJQUFHLEtBQUtwQyxPQUFMLENBQWFrQixPQUFiLENBQXFCd0osU0FBeEIsRUFBa0MsT0FBTzdoQixFQUFFOGhCLGNBQUYsSUFBbUIsS0FBSyxDQUEvQixDQUFpQyxJQUFJNWhCLElBQUUsS0FBS3VoQixPQUFYO0FBQUEsWUFBbUJ4ZSxJQUFFc0UsRUFBRXJILENBQUYsRUFBSXFjLEVBQUosQ0FBckI7QUFBQSxZQUE2QmxWLElBQUVFLEVBQUVySCxDQUFGLEVBQUl1YyxFQUFKLENBQS9CO0FBQUEsWUFBdUM5VSxJQUFFSixFQUFFckgsQ0FBRixFQUFJc2MsRUFBSixDQUF6QyxDQUFpRCxPQUFPdlosS0FBR29FLEtBQUdwSCxJQUFFMGYsQ0FBUixJQUFXaFksS0FBRzFILElBQUU0VSxDQUFoQixHQUFrQixLQUFLa04sVUFBTCxDQUFnQi9oQixDQUFoQixDQUFsQixHQUFxQyxLQUFLLENBQWpEO0FBQW1EO0FBQUMsS0FBN2pCLEVBQThqQitoQixZQUFXLG9CQUFTOWYsQ0FBVCxFQUFXO0FBQUMsV0FBS2tWLE9BQUwsQ0FBYWtCLE9BQWIsQ0FBcUJ3SixTQUFyQixHQUErQixDQUFDLENBQWhDLEVBQWtDNWYsRUFBRTZmLGNBQUYsRUFBbEM7QUFBcUQsS0FBMW9CLEVBQWIsQ0FBeXBCLElBQUkvRSxLQUFHLENBQVA7QUFBQSxNQUFTTyxLQUFHLENBQVo7QUFBQSxNQUFjRCxLQUFHLENBQWpCO0FBQUEsTUFBbUJELEtBQUcsQ0FBdEI7QUFBQSxNQUF3QjRFLEtBQUc1RSxFQUEzQjtBQUFBLE1BQThCRCxLQUFHLEVBQWpDO0FBQUEsTUFBb0M4RSxLQUFHLEVBQXZDLENBQTBDckYsR0FBRzFZLFNBQUgsR0FBYSxFQUFDd0UsVUFBUyxFQUFWLEVBQWEyVCxLQUFJLGFBQVNwYSxDQUFULEVBQVc7QUFBQyxhQUFPeUIsRUFBRSxLQUFLOFIsT0FBUCxFQUFldlQsQ0FBZixHQUFrQixLQUFLa1YsT0FBTCxJQUFjLEtBQUtBLE9BQUwsQ0FBYTJILFdBQWIsQ0FBeUI0QyxNQUF6QixFQUFoQyxFQUFrRSxJQUF6RTtBQUE4RSxLQUEzRyxFQUE0RzFDLGVBQWMsdUJBQVMvYyxDQUFULEVBQVc7QUFBQyxVQUFHeUMsRUFBRXpDLENBQUYsRUFBSSxlQUFKLEVBQW9CLElBQXBCLENBQUgsRUFBNkIsT0FBTyxJQUFQLENBQVksSUFBSWpDLElBQUUsS0FBS2dkLFlBQVgsQ0FBd0IsT0FBTy9hLElBQUV1YixHQUFHdmIsQ0FBSCxFQUFLLElBQUwsQ0FBRixFQUFhakMsRUFBRWlDLEVBQUU0YSxFQUFKLE1BQVU3YyxFQUFFaUMsRUFBRTRhLEVBQUosSUFBUTVhLENBQVIsRUFBVUEsRUFBRStjLGFBQUYsQ0FBZ0IsSUFBaEIsQ0FBcEIsQ0FBYixFQUF3RCxJQUEvRDtBQUFvRSxLQUEzUSxFQUE0UWtELG1CQUFrQiwyQkFBU2pnQixDQUFULEVBQVc7QUFBQyxhQUFPeUMsRUFBRXpDLENBQUYsRUFBSSxtQkFBSixFQUF3QixJQUF4QixJQUE4QixJQUE5QixJQUFvQ0EsSUFBRXViLEdBQUd2YixDQUFILEVBQUssSUFBTCxDQUFGLEVBQWEsT0FBTyxLQUFLK2EsWUFBTCxDQUFrQi9hLEVBQUU0YSxFQUFwQixDQUFwQixFQUE0QyxJQUFoRixDQUFQO0FBQTZGLEtBQXZZLEVBQXdZb0MsZ0JBQWUsd0JBQVNoZCxDQUFULEVBQVc7QUFBQyxVQUFHeUMsRUFBRXpDLENBQUYsRUFBSSxnQkFBSixFQUFxQixJQUFyQixDQUFILEVBQThCLE9BQU8sSUFBUCxDQUFZLElBQUlqQyxJQUFFLEtBQUtpZCxXQUFYLENBQXVCLE9BQU9oYixJQUFFdWIsR0FBR3ZiLENBQUgsRUFBSyxJQUFMLENBQUYsRUFBYSxDQUFDLENBQUQsS0FBS3lGLEVBQUUxSCxDQUFGLEVBQUlpQyxDQUFKLENBQUwsS0FBY2pDLEVBQUU4RSxJQUFGLENBQU83QyxDQUFQLEdBQVVBLEVBQUVnZCxjQUFGLENBQWlCLElBQWpCLENBQXhCLENBQWIsRUFBNkQsSUFBcEU7QUFBeUUsS0FBN2lCLEVBQThpQmtELG9CQUFtQiw0QkFBU2xnQixDQUFULEVBQVc7QUFBQyxVQUFHeUMsRUFBRXpDLENBQUYsRUFBSSxvQkFBSixFQUF5QixJQUF6QixDQUFILEVBQWtDLE9BQU8sSUFBUCxDQUFZQSxJQUFFdWIsR0FBR3ZiLENBQUgsRUFBSyxJQUFMLENBQUYsQ0FBYSxJQUFJakMsSUFBRTBILEVBQUUsS0FBS3VWLFdBQVAsRUFBbUJoYixDQUFuQixDQUFOLENBQTRCLE9BQU9qQyxJQUFFLENBQUMsQ0FBSCxJQUFNLEtBQUtpZCxXQUFMLENBQWlCNkQsTUFBakIsQ0FBd0I5Z0IsQ0FBeEIsRUFBMEIsQ0FBMUIsQ0FBTixFQUFtQyxJQUExQztBQUErQyxLQUFudEIsRUFBb3RCb2lCLG9CQUFtQiw4QkFBVTtBQUFDLGFBQU8sS0FBS25GLFdBQUwsQ0FBaUIvWixNQUFqQixHQUF3QixDQUEvQjtBQUFpQyxLQUFueEIsRUFBb3hCbWYsa0JBQWlCLDBCQUFTcGdCLENBQVQsRUFBVztBQUFDLGFBQU0sQ0FBQyxDQUFDLEtBQUsrYSxZQUFMLENBQWtCL2EsRUFBRTRhLEVBQXBCLENBQVI7QUFBZ0MsS0FBajFCLEVBQWsxQnJFLE1BQUssY0FBU3ZXLENBQVQsRUFBVztBQUFDLGVBQVMvQixDQUFULENBQVdBLENBQVgsRUFBYTtBQUFDRixVQUFFbVgsT0FBRixDQUFVcUIsSUFBVixDQUFleFksRUFBRXdWLE9BQUYsQ0FBVThNLEtBQVYsSUFBaUJwaUIsSUFBRWdkLEdBQUdqZCxDQUFILENBQUYsR0FBUSxFQUF6QixDQUFmLEVBQTRDZ0MsQ0FBNUM7QUFBK0MsV0FBSWpDLElBQUUsSUFBTjtBQUFBLFVBQVdDLElBQUUsS0FBSzZjLEtBQWxCLENBQXdCTSxLQUFHbmQsQ0FBSCxJQUFNQyxFQUFFLENBQUMsQ0FBSCxDQUFOLEVBQVlBLEdBQVosRUFBZ0JELEtBQUdtZCxFQUFILElBQU9sZCxFQUFFLENBQUMsQ0FBSCxDQUF2QjtBQUE2QixLQUFyOUIsRUFBczlCcWlCLFNBQVEsaUJBQVN0Z0IsQ0FBVCxFQUFXO0FBQUMsYUFBTyxLQUFLdWdCLE9BQUwsS0FBZSxLQUFLaEssSUFBTCxDQUFVdlcsQ0FBVixDQUFmLElBQTZCLEtBQUs2YSxLQUFMLEdBQVdtRixFQUFYLEVBQWMsS0FBSyxDQUFoRCxDQUFQO0FBQTBELEtBQXBpQyxFQUFxaUNPLFNBQVEsbUJBQVU7QUFBQyxXQUFJLElBQUl2Z0IsSUFBRSxDQUFWLEVBQVlBLElBQUUsS0FBS2diLFdBQUwsQ0FBaUIvWixNQUEvQixHQUF1QztBQUFDLFlBQUcsRUFBRSxLQUFLK1osV0FBTCxDQUFpQmhiLENBQWpCLEVBQW9CNmEsS0FBcEIsSUFBMkJtRixLQUFHbEYsRUFBOUIsQ0FBRixDQUFILEVBQXdDLE9BQU0sQ0FBQyxDQUFQLENBQVM5YTtBQUFJLGNBQU0sQ0FBQyxDQUFQO0FBQVMsS0FBOXBDLEVBQStwQ3dXLFdBQVUsbUJBQVN4VyxDQUFULEVBQVc7QUFBQyxVQUFJakMsSUFBRTBELEVBQUUsRUFBRixFQUFLekIsQ0FBTCxDQUFOLENBQWMsT0FBT2tCLEVBQUUsS0FBS3FTLE9BQUwsQ0FBYWdDLE1BQWYsRUFBc0IsQ0FBQyxJQUFELEVBQU14WCxDQUFOLENBQXRCLEtBQWlDLEtBQUs4YyxLQUFMLElBQVlrRixLQUFHN0UsRUFBSCxHQUFNOEUsRUFBbEIsTUFBd0IsS0FBS25GLEtBQUwsR0FBV0MsRUFBbkMsR0FBdUMsS0FBS0QsS0FBTCxHQUFXLEtBQUsyRixPQUFMLENBQWF6aUIsQ0FBYixDQUFsRCxFQUFrRSxLQUFLOGMsS0FBTCxJQUFZUSxLQUFHRCxFQUFILEdBQU1ELEVBQU4sR0FBU0QsRUFBckIsS0FBMEIsS0FBS29GLE9BQUwsQ0FBYXZpQixDQUFiLENBQTVGLEVBQTRHLEtBQUssQ0FBbEosS0FBc0osS0FBSzBpQixLQUFMLElBQWEsS0FBSzVGLEtBQUwsR0FBV21GLEVBQXhCLEVBQTJCLEtBQUssQ0FBdEwsQ0FBUDtBQUFnTSxLQUFuNEMsRUFBbzRDUSxTQUFRLG1CQUFVLENBQUUsQ0FBeDVDLEVBQXk1Q2QsZ0JBQWUsMEJBQVUsQ0FBRSxDQUFwN0MsRUFBcTdDZSxPQUFNLGlCQUFVLENBQUUsQ0FBdjhDLEVBQWIsRUFBczlDMWdCLEVBQUUwYixFQUFGLEVBQUtkLEVBQUwsRUFBUSxFQUFDbFUsVUFBUyxFQUFDdVAsVUFBUyxDQUFWLEVBQVYsRUFBdUIwSyxVQUFTLGtCQUFTMWdCLENBQVQsRUFBVztBQUFDLFVBQUlqQyxJQUFFLEtBQUt3VixPQUFMLENBQWF5QyxRQUFuQixDQUE0QixPQUFPLE1BQUlqWSxDQUFKLElBQU9pQyxFQUFFZ1csUUFBRixDQUFXL1UsTUFBWCxLQUFvQmxELENBQWxDO0FBQW9DLEtBQTVHLEVBQTZHeWlCLFNBQVEsaUJBQVN4Z0IsQ0FBVCxFQUFXO0FBQUMsVUFBSWpDLElBQUUsS0FBSzhjLEtBQVg7QUFBQSxVQUFpQjdjLElBQUVnQyxFQUFFcVcsU0FBckI7QUFBQSxVQUErQnBZLElBQUVGLEtBQUdzZCxLQUFHRCxFQUFOLENBQWpDO0FBQUEsVUFBMkNwYSxJQUFFLEtBQUswZixRQUFMLENBQWMxZ0IsQ0FBZCxDQUE3QyxDQUE4RCxPQUFPL0IsTUFBSUQsSUFBRStVLENBQUYsSUFBSyxDQUFDL1IsQ0FBVixJQUFhakQsSUFBRW1kLEVBQWYsR0FBa0JqZCxLQUFHK0MsQ0FBSCxHQUFLaEQsSUFBRThVLENBQUYsR0FBSS9VLElBQUVvZCxFQUFOLEdBQVNwZCxJQUFFc2QsRUFBRixHQUFLdGQsSUFBRXFkLEVBQVAsR0FBVUMsRUFBeEIsR0FBMkIyRSxFQUFwRDtBQUF1RCxLQUF0UCxFQUFSLENBQXQ5QyxFQUF1dERqZ0IsRUFBRTJiLEVBQUYsRUFBS0QsRUFBTCxFQUFRLEVBQUNoVixVQUFTLEVBQUM0WixPQUFNLEtBQVAsRUFBYU0sV0FBVSxFQUF2QixFQUEwQjNLLFVBQVMsQ0FBbkMsRUFBcUM5RixXQUFVeU4sQ0FBL0MsRUFBVixFQUE0RCtCLGdCQUFlLDBCQUFVO0FBQUMsVUFBSTFmLElBQUUsS0FBS3VULE9BQUwsQ0FBYXJELFNBQW5CO0FBQUEsVUFBNkJuUyxJQUFFLEVBQS9CLENBQWtDLE9BQU9pQyxJQUFFMGQsQ0FBRixJQUFLM2YsRUFBRThFLElBQUYsQ0FBTzJYLEVBQVAsQ0FBTCxFQUFnQnhhLElBQUU0UyxDQUFGLElBQUs3VSxFQUFFOEUsSUFBRixDQUFPMFgsRUFBUCxDQUFyQixFQUFnQ3hjLENBQXZDO0FBQXlDLEtBQWpLLEVBQWtLNmlCLGVBQWMsdUJBQVM1Z0IsQ0FBVCxFQUFXO0FBQUMsVUFBSWpDLElBQUUsS0FBS3dWLE9BQVg7QUFBQSxVQUFtQnZWLElBQUUsQ0FBQyxDQUF0QjtBQUFBLFVBQXdCQyxJQUFFK0IsRUFBRW1YLFFBQTVCO0FBQUEsVUFBcUNuVyxJQUFFaEIsRUFBRWtRLFNBQXpDO0FBQUEsVUFBbUQ5SyxJQUFFcEYsRUFBRXdYLE1BQXZEO0FBQUEsVUFBOEQ5UixJQUFFMUYsRUFBRXlYLE1BQWxFLENBQXlFLE9BQU96VyxJQUFFakQsRUFBRW1TLFNBQUosS0FBZ0JuUyxFQUFFbVMsU0FBRixHQUFZd04sQ0FBWixJQUFlMWMsSUFBRSxNQUFJb0UsQ0FBSixHQUFNUSxDQUFOLEdBQVEsSUFBRVIsQ0FBRixHQUFJaUIsQ0FBSixHQUFNa1MsQ0FBaEIsRUFBa0J2YSxJQUFFb0gsS0FBRyxLQUFLdVcsRUFBNUIsRUFBK0IxZCxJQUFFYyxLQUFLa0IsR0FBTCxDQUFTRCxFQUFFd1gsTUFBWCxDQUFoRCxLQUFxRXhXLElBQUUsTUFBSTBFLENBQUosR0FBTUUsQ0FBTixHQUFRLElBQUVGLENBQUYsR0FBSUMsQ0FBSixHQUFNK00sQ0FBaEIsRUFBa0IxVSxJQUFFMEgsS0FBRyxLQUFLa1csRUFBNUIsRUFBK0IzZCxJQUFFYyxLQUFLa0IsR0FBTCxDQUFTRCxFQUFFeVgsTUFBWCxDQUF0RyxDQUFoQixHQUEySXpYLEVBQUVrUSxTQUFGLEdBQVlsUCxDQUF2SixFQUF5SmhELEtBQUdDLElBQUVGLEVBQUU0aUIsU0FBUCxJQUFrQjNmLElBQUVqRCxFQUFFbVMsU0FBdEw7QUFBZ00sS0FBcmMsRUFBc2N3USxVQUFTLGtCQUFTMWdCLENBQVQsRUFBVztBQUFDLGFBQU95YixHQUFHeFosU0FBSCxDQUFheWUsUUFBYixDQUFzQi9lLElBQXRCLENBQTJCLElBQTNCLEVBQWdDM0IsQ0FBaEMsTUFBcUMsS0FBSzZhLEtBQUwsR0FBV1EsRUFBWCxJQUFlLEVBQUUsS0FBS1IsS0FBTCxHQUFXUSxFQUFiLEtBQWtCLEtBQUt1RixhQUFMLENBQW1CNWdCLENBQW5CLENBQXRFLENBQVA7QUFBb0csS0FBL2pCLEVBQWdrQnVXLE1BQUssY0FBU3ZXLENBQVQsRUFBVztBQUFDLFdBQUsyYixFQUFMLEdBQVEzYixFQUFFd1gsTUFBVixFQUFpQixLQUFLb0UsRUFBTCxHQUFRNWIsRUFBRXlYLE1BQTNCLENBQWtDLElBQUkxWixJQUFFdWQsR0FBR3RiLEVBQUVrUSxTQUFMLENBQU4sQ0FBc0JuUyxLQUFHLEtBQUttWCxPQUFMLENBQWFxQixJQUFiLENBQWtCLEtBQUtoRCxPQUFMLENBQWE4TSxLQUFiLEdBQW1CdGlCLENBQXJDLEVBQXVDaUMsQ0FBdkMsQ0FBSCxFQUE2QyxLQUFLeVUsTUFBTCxDQUFZOEIsSUFBWixDQUFpQjVVLElBQWpCLENBQXNCLElBQXRCLEVBQTJCM0IsQ0FBM0IsQ0FBN0M7QUFBMkUsS0FBcHRCLEVBQVIsQ0FBdnRELEVBQXM3RUQsRUFBRThiLEVBQUYsRUFBS0osRUFBTCxFQUFRLEVBQUNoVixVQUFTLEVBQUM0WixPQUFNLE9BQVAsRUFBZU0sV0FBVSxDQUF6QixFQUEyQjNLLFVBQVMsQ0FBcEMsRUFBVixFQUFpRDBKLGdCQUFlLDBCQUFVO0FBQUMsYUFBTSxDQUFDcEYsRUFBRCxDQUFOO0FBQVcsS0FBdEYsRUFBdUZvRyxVQUFTLGtCQUFTMWdCLENBQVQsRUFBVztBQUFDLGFBQU8sS0FBS3lVLE1BQUwsQ0FBWWlNLFFBQVosQ0FBcUIvZSxJQUFyQixDQUEwQixJQUExQixFQUErQjNCLENBQS9CLE1BQW9DakIsS0FBS2tCLEdBQUwsQ0FBU0QsRUFBRXlRLEtBQUYsR0FBUSxDQUFqQixJQUFvQixLQUFLOEMsT0FBTCxDQUFhb04sU0FBakMsSUFBNEMsS0FBSzlGLEtBQUwsR0FBV1EsRUFBM0YsQ0FBUDtBQUFzRyxLQUFsTixFQUFtTjlFLE1BQUssY0FBU3ZXLENBQVQsRUFBVztBQUFDLFVBQUcsS0FBS3lVLE1BQUwsQ0FBWThCLElBQVosQ0FBaUI1VSxJQUFqQixDQUFzQixJQUF0QixFQUEyQjNCLENBQTNCLEdBQThCLE1BQUlBLEVBQUV5USxLQUF2QyxFQUE2QztBQUFDLFlBQUkxUyxJQUFFaUMsRUFBRXlRLEtBQUYsR0FBUSxDQUFSLEdBQVUsSUFBVixHQUFlLEtBQXJCLENBQTJCLEtBQUt5RSxPQUFMLENBQWFxQixJQUFiLENBQWtCLEtBQUtoRCxPQUFMLENBQWE4TSxLQUFiLEdBQW1CdGlCLENBQXJDLEVBQXVDaUMsQ0FBdkM7QUFBMEM7QUFBQyxLQUF4VixFQUFSLENBQXQ3RSxFQUF5eEZELEVBQUUrYixFQUFGLEVBQUtuQixFQUFMLEVBQVEsRUFBQ2xVLFVBQVMsRUFBQzRaLE9BQU0sT0FBUCxFQUFlckssVUFBUyxDQUF4QixFQUEwQjZLLE1BQUssR0FBL0IsRUFBbUNGLFdBQVUsQ0FBN0MsRUFBVixFQUEwRGpCLGdCQUFlLDBCQUFVO0FBQUMsYUFBTSxDQUFDaEYsRUFBRCxDQUFOO0FBQVcsS0FBL0YsRUFBZ0c4RixTQUFRLGlCQUFTeGdCLENBQVQsRUFBVztBQUFDLFVBQUlqQyxJQUFFLEtBQUt3VixPQUFYO0FBQUEsVUFBbUJ2VixJQUFFZ0MsRUFBRWdXLFFBQUYsQ0FBVy9VLE1BQVgsS0FBb0JsRCxFQUFFaVksUUFBM0M7QUFBQSxVQUFvRC9YLElBQUUrQixFQUFFbVgsUUFBRixHQUFXcFosRUFBRTRpQixTQUFuRTtBQUFBLFVBQTZFM2YsSUFBRWhCLEVBQUVnWCxTQUFGLEdBQVlqWixFQUFFOGlCLElBQTdGLENBQWtHLElBQUcsS0FBSzdFLE1BQUwsR0FBWWhjLENBQVosRUFBYyxDQUFDL0IsQ0FBRCxJQUFJLENBQUNELENBQUwsSUFBUWdDLEVBQUVxVyxTQUFGLElBQWF2RCxJQUFFQyxDQUFmLEtBQW1CLENBQUMvUixDQUE3QyxFQUErQyxLQUFLeWYsS0FBTCxHQUEvQyxLQUFpRSxJQUFHemdCLEVBQUVxVyxTQUFGLEdBQVloRSxDQUFmLEVBQWlCLEtBQUtvTyxLQUFMLElBQWEsS0FBSzFFLE1BQUwsR0FBWTlVLEVBQUUsWUFBVTtBQUFDLGFBQUs0VCxLQUFMLEdBQVdrRixFQUFYLEVBQWMsS0FBS08sT0FBTCxFQUFkO0FBQTZCLE9BQTFDLEVBQTJDdmlCLEVBQUU4aUIsSUFBN0MsRUFBa0QsSUFBbEQsQ0FBekIsQ0FBakIsS0FBdUcsSUFBRzdnQixFQUFFcVcsU0FBRixHQUFZdkQsQ0FBZixFQUFpQixPQUFPaU4sRUFBUCxDQUFVLE9BQU9DLEVBQVA7QUFBVSxLQUFuYSxFQUFvYVMsT0FBTSxpQkFBVTtBQUFDaE4sbUJBQWEsS0FBS3NJLE1BQWxCO0FBQTBCLEtBQS9jLEVBQWdkeEYsTUFBSyxjQUFTdlcsQ0FBVCxFQUFXO0FBQUMsV0FBSzZhLEtBQUwsS0FBYWtGLEVBQWIsS0FBa0IvZixLQUFHQSxFQUFFcVcsU0FBRixHQUFZdkQsQ0FBZixHQUFpQixLQUFLb0MsT0FBTCxDQUFhcUIsSUFBYixDQUFrQixLQUFLaEQsT0FBTCxDQUFhOE0sS0FBYixHQUFtQixJQUFyQyxFQUEwQ3JnQixDQUExQyxDQUFqQixJQUErRCxLQUFLZ2MsTUFBTCxDQUFZakYsU0FBWixHQUFzQjNQLEdBQXRCLEVBQTBCLEtBQUs4TixPQUFMLENBQWFxQixJQUFiLENBQWtCLEtBQUtoRCxPQUFMLENBQWE4TSxLQUEvQixFQUFxQyxLQUFLckUsTUFBMUMsQ0FBekYsQ0FBbEI7QUFBK0osS0FBaG9CLEVBQVIsQ0FBenhGLEVBQW82R2pjLEVBQUVrYyxFQUFGLEVBQUtSLEVBQUwsRUFBUSxFQUFDaFYsVUFBUyxFQUFDNFosT0FBTSxRQUFQLEVBQWdCTSxXQUFVLENBQTFCLEVBQTRCM0ssVUFBUyxDQUFyQyxFQUFWLEVBQWtEMEosZ0JBQWUsMEJBQVU7QUFBQyxhQUFNLENBQUNwRixFQUFELENBQU47QUFBVyxLQUF2RixFQUF3Rm9HLFVBQVMsa0JBQVMxZ0IsQ0FBVCxFQUFXO0FBQUMsYUFBTyxLQUFLeVUsTUFBTCxDQUFZaU0sUUFBWixDQUFxQi9lLElBQXJCLENBQTBCLElBQTFCLEVBQStCM0IsQ0FBL0IsTUFBb0NqQixLQUFLa0IsR0FBTCxDQUFTRCxFQUFFMlgsUUFBWCxJQUFxQixLQUFLcEUsT0FBTCxDQUFhb04sU0FBbEMsSUFBNkMsS0FBSzlGLEtBQUwsR0FBV1EsRUFBNUYsQ0FBUDtBQUF1RyxLQUFwTixFQUFSLENBQXA2RyxFQUFtb0h0YixFQUFFbWMsRUFBRixFQUFLVCxFQUFMLEVBQVEsRUFBQ2hWLFVBQVMsRUFBQzRaLE9BQU0sT0FBUCxFQUFlTSxXQUFVLEVBQXpCLEVBQTRCdlcsVUFBUyxHQUFyQyxFQUF5QzhGLFdBQVV3TixJQUFFOUssQ0FBckQsRUFBdURvRCxVQUFTLENBQWhFLEVBQVYsRUFBNkUwSixnQkFBZSwwQkFBVTtBQUFDLGFBQU9oRSxHQUFHelosU0FBSCxDQUFheWQsY0FBYixDQUE0Qi9kLElBQTVCLENBQWlDLElBQWpDLENBQVA7QUFBOEMsS0FBckosRUFBc0orZSxVQUFTLGtCQUFTMWdCLENBQVQsRUFBVztBQUFDLFVBQUloQyxDQUFKO0FBQUEsVUFBTUQsSUFBRSxLQUFLd1YsT0FBTCxDQUFhckQsU0FBckIsQ0FBK0IsT0FBT25TLEtBQUcyZixJQUFFOUssQ0FBTCxJQUFRNVUsSUFBRWdDLEVBQUVvSyxRQUFaLEdBQXFCck0sSUFBRTJmLENBQUYsR0FBSTFmLElBQUVnQyxFQUFFbVksU0FBUixHQUFrQnBhLElBQUU2VSxDQUFGLEtBQU01VSxJQUFFZ0MsRUFBRW9ZLFNBQVYsQ0FBdkMsRUFBNEQsS0FBSzNELE1BQUwsQ0FBWWlNLFFBQVosQ0FBcUIvZSxJQUFyQixDQUEwQixJQUExQixFQUErQjNCLENBQS9CLEtBQW1DakMsSUFBRWlDLEVBQUVrUSxTQUF2QyxJQUFrRGxRLEVBQUVtWCxRQUFGLEdBQVcsS0FBSzVELE9BQUwsQ0FBYW9OLFNBQTFFLElBQXFGamYsRUFBRTFELENBQUYsSUFBSyxLQUFLdVYsT0FBTCxDQUFhbkosUUFBdkcsSUFBaUhwSyxFQUFFcVcsU0FBRixHQUFZdkQsQ0FBaE07QUFBa00sS0FBNVksRUFBNll5RCxNQUFLLGNBQVN2VyxDQUFULEVBQVc7QUFBQyxVQUFJakMsSUFBRXVkLEdBQUd0YixFQUFFa1EsU0FBTCxDQUFOLENBQXNCblMsS0FBRyxLQUFLbVgsT0FBTCxDQUFhcUIsSUFBYixDQUFrQixLQUFLaEQsT0FBTCxDQUFhOE0sS0FBYixHQUFtQnRpQixDQUFyQyxFQUF1Q2lDLENBQXZDLENBQUgsRUFBNkMsS0FBS2tWLE9BQUwsQ0FBYXFCLElBQWIsQ0FBa0IsS0FBS2hELE9BQUwsQ0FBYThNLEtBQS9CLEVBQXFDcmdCLENBQXJDLENBQTdDO0FBQXFGLEtBQXpnQixFQUFSLENBQW5vSCxFQUF1cElELEVBQUVvYyxFQUFGLEVBQUt4QixFQUFMLEVBQVEsRUFBQ2xVLFVBQVMsRUFBQzRaLE9BQU0sS0FBUCxFQUFhckssVUFBUyxDQUF0QixFQUF3QjhLLE1BQUssQ0FBN0IsRUFBK0JDLFVBQVMsR0FBeEMsRUFBNENGLE1BQUssR0FBakQsRUFBcURGLFdBQVUsQ0FBL0QsRUFBaUVLLGNBQWEsRUFBOUUsRUFBVixFQUE0RnRCLGdCQUFlLDBCQUFVO0FBQUMsYUFBTSxDQUFDakYsRUFBRCxDQUFOO0FBQVcsS0FBakksRUFBa0krRixTQUFRLGlCQUFTeGdCLENBQVQsRUFBVztBQUFDLFVBQUlqQyxJQUFFLEtBQUt3VixPQUFYO0FBQUEsVUFBbUJ2VixJQUFFZ0MsRUFBRWdXLFFBQUYsQ0FBVy9VLE1BQVgsS0FBb0JsRCxFQUFFaVksUUFBM0M7QUFBQSxVQUFvRC9YLElBQUUrQixFQUFFbVgsUUFBRixHQUFXcFosRUFBRTRpQixTQUFuRTtBQUFBLFVBQTZFM2YsSUFBRWhCLEVBQUVnWCxTQUFGLEdBQVlqWixFQUFFOGlCLElBQTdGLENBQWtHLElBQUcsS0FBS0osS0FBTCxJQUFhemdCLEVBQUVxVyxTQUFGLEdBQVloRSxDQUFaLElBQWUsTUFBSSxLQUFLaUssS0FBeEMsRUFBOEMsT0FBTyxLQUFLMkUsV0FBTCxFQUFQLENBQTBCLElBQUdoakIsS0FBRytDLENBQUgsSUFBTWhELENBQVQsRUFBVztBQUFDLFlBQUdnQyxFQUFFcVcsU0FBRixJQUFhdkQsQ0FBaEIsRUFBa0IsT0FBTyxLQUFLbU8sV0FBTCxFQUFQLENBQTBCLElBQUk3YixJQUFFLEtBQUtnWCxLQUFMLEdBQVdwYyxFQUFFK1csU0FBRixHQUFZLEtBQUtxRixLQUFqQixHQUF1QnJlLEVBQUVnakIsUUFBcEMsR0FBNkMsQ0FBQyxDQUFwRDtBQUFBLFlBQXNEcmIsSUFBRSxDQUFDLEtBQUsyVyxPQUFOLElBQWVqRixHQUFHLEtBQUtpRixPQUFSLEVBQWdCcmMsRUFBRTZXLE1BQWxCLElBQTBCOVksRUFBRWlqQixZQUFuRyxDQUFnSCxLQUFLNUUsS0FBTCxHQUFXcGMsRUFBRStXLFNBQWIsRUFBdUIsS0FBS3NGLE9BQUwsR0FBYXJjLEVBQUU2VyxNQUF0QyxFQUE2Q25SLEtBQUdOLENBQUgsR0FBSyxLQUFLa1gsS0FBTCxJQUFZLENBQWpCLEdBQW1CLEtBQUtBLEtBQUwsR0FBVyxDQUEzRSxFQUE2RSxLQUFLTixNQUFMLEdBQVloYyxDQUF6RixDQUEyRixJQUFJdUYsSUFBRSxLQUFLK1csS0FBTCxHQUFXdmUsRUFBRStpQixJQUFuQixDQUF3QixJQUFHLE1BQUl2YixDQUFQLEVBQVMsT0FBTyxLQUFLNGEsa0JBQUwsTUFBMkIsS0FBS3BFLE1BQUwsR0FBWTlVLEVBQUUsWUFBVTtBQUFDLGVBQUs0VCxLQUFMLEdBQVdrRixFQUFYLEVBQWMsS0FBS08sT0FBTCxFQUFkO0FBQTZCLFNBQTFDLEVBQTJDdmlCLEVBQUVnakIsUUFBN0MsRUFBc0QsSUFBdEQsQ0FBWixFQUF3RTFGLEVBQW5HLElBQXVHMEUsRUFBOUc7QUFBaUgsY0FBT0MsRUFBUDtBQUFVLEtBQS90QixFQUFndUJpQixhQUFZLHVCQUFVO0FBQUMsYUFBTyxLQUFLbEYsTUFBTCxHQUFZOVUsRUFBRSxZQUFVO0FBQUMsYUFBSzRULEtBQUwsR0FBV21GLEVBQVg7QUFBYyxPQUEzQixFQUE0QixLQUFLek0sT0FBTCxDQUFhd04sUUFBekMsRUFBa0QsSUFBbEQsQ0FBWixFQUFvRWYsRUFBM0U7QUFBOEUsS0FBcjBCLEVBQXMwQlMsT0FBTSxpQkFBVTtBQUFDaE4sbUJBQWEsS0FBS3NJLE1BQWxCO0FBQTBCLEtBQWozQixFQUFrM0J4RixNQUFLLGdCQUFVO0FBQUMsV0FBS3NFLEtBQUwsSUFBWWtGLEVBQVosS0FBaUIsS0FBSy9ELE1BQUwsQ0FBWWtGLFFBQVosR0FBcUIsS0FBSzVFLEtBQTFCLEVBQWdDLEtBQUtwSCxPQUFMLENBQWFxQixJQUFiLENBQWtCLEtBQUtoRCxPQUFMLENBQWE4TSxLQUEvQixFQUFxQyxLQUFLckUsTUFBMUMsQ0FBakQ7QUFBb0csS0FBdCtCLEVBQVIsQ0FBdnBJLEVBQXdvS08sR0FBRzRFLE9BQUgsR0FBVyxPQUFucEssRUFBMnBLNUUsR0FBRzlWLFFBQUgsR0FBWSxFQUFDMmEsV0FBVSxDQUFDLENBQVosRUFBY3ZFLGFBQVl5QyxFQUExQixFQUE2Qi9KLFFBQU8sQ0FBQyxDQUFyQyxFQUF1Q0YsYUFBWSxJQUFuRCxFQUF3REssWUFBVyxJQUFuRSxFQUF3RStHLFFBQU8sQ0FBQyxDQUFDUixFQUFELEVBQUksRUFBQzFHLFFBQU8sQ0FBQyxDQUFULEVBQUosQ0FBRCxFQUFrQixDQUFDc0csRUFBRCxFQUFJLEVBQUN0RyxRQUFPLENBQUMsQ0FBVCxFQUFKLEVBQWdCLENBQUMsUUFBRCxDQUFoQixDQUFsQixFQUE4QyxDQUFDMkcsRUFBRCxFQUFJLEVBQUNoTSxXQUFVd04sQ0FBWCxFQUFKLENBQTlDLEVBQWlFLENBQUNoQyxFQUFELEVBQUksRUFBQ3hMLFdBQVV3TixDQUFYLEVBQUosRUFBa0IsQ0FBQyxPQUFELENBQWxCLENBQWpFLEVBQThGLENBQUN2QixFQUFELENBQTlGLEVBQW1HLENBQUNBLEVBQUQsRUFBSSxFQUFDa0UsT0FBTSxXQUFQLEVBQW1CUyxNQUFLLENBQXhCLEVBQUosRUFBK0IsQ0FBQyxLQUFELENBQS9CLENBQW5HLEVBQTJJLENBQUNoRixFQUFELENBQTNJLENBQS9FLEVBQWdPbUIsVUFBUyxFQUFDb0UsWUFBVyxTQUFaLEVBQXNCQyxhQUFZLE1BQWxDLEVBQXlDQyxjQUFhLE1BQXRELEVBQTZEQyxnQkFBZSxNQUE1RSxFQUFtRkMsVUFBUyxNQUE1RixFQUFtR0MsbUJBQWtCLGVBQXJILEVBQXpPLEVBQXZxSyxDQUF1aEwsSUFBSUMsS0FBRyxDQUFQO0FBQUEsTUFBU0MsS0FBRyxDQUFaLENBQWNsRixHQUFHemEsU0FBSCxHQUFhLEVBQUNtWSxLQUFJLGFBQVNwYSxDQUFULEVBQVc7QUFBQyxhQUFPeUIsRUFBRSxLQUFLOFIsT0FBUCxFQUFldlQsQ0FBZixHQUFrQkEsRUFBRTZjLFdBQUYsSUFBZSxLQUFLQSxXQUFMLENBQWlCNEMsTUFBakIsRUFBakMsRUFBMkR6ZixFQUFFcVYsV0FBRixLQUFnQixLQUFLdUgsS0FBTCxDQUFXZ0IsT0FBWCxJQUFxQixLQUFLaEIsS0FBTCxDQUFXeEgsTUFBWCxHQUFrQnBWLEVBQUVxVixXQUF6QyxFQUFxRCxLQUFLdUgsS0FBTCxDQUFXcmIsSUFBWCxFQUFyRSxDQUEzRCxFQUFtSixJQUExSjtBQUErSixLQUFoTCxFQUFpTHNnQixNQUFLLGNBQVM3aEIsQ0FBVCxFQUFXO0FBQUMsV0FBS29XLE9BQUwsQ0FBYTBMLE9BQWIsR0FBcUI5aEIsSUFBRTRoQixFQUFGLEdBQUtELEVBQTFCO0FBQTZCLEtBQS9OLEVBQWdPbkwsV0FBVSxtQkFBU3hXLENBQVQsRUFBVztBQUFDLFVBQUlqQyxJQUFFLEtBQUtxWSxPQUFYLENBQW1CLElBQUcsQ0FBQ3JZLEVBQUUrakIsT0FBTixFQUFjO0FBQUMsYUFBS2pGLFdBQUwsQ0FBaUI4QyxlQUFqQixDQUFpQzNmLENBQWpDLEVBQW9DLElBQUloQyxDQUFKO0FBQUEsWUFBTUMsSUFBRSxLQUFLdWUsV0FBYjtBQUFBLFlBQXlCeGIsSUFBRWpELEVBQUVna0IsYUFBN0IsQ0FBMkMsQ0FBQyxDQUFDL2dCLENBQUQsSUFBSUEsS0FBR0EsRUFBRTZaLEtBQUYsR0FBUWtGLEVBQWhCLE1BQXNCL2UsSUFBRWpELEVBQUVna0IsYUFBRixHQUFnQixJQUF4QyxFQUE4QyxLQUFJLElBQUkzYyxJQUFFLENBQVYsRUFBWUEsSUFBRW5ILEVBQUVnRCxNQUFoQjtBQUF3QmpELGNBQUVDLEVBQUVtSCxDQUFGLENBQUYsRUFBT3JILEVBQUUrakIsT0FBRixLQUFZRixFQUFaLElBQWdCNWdCLEtBQUdoRCxLQUFHZ0QsQ0FBTixJQUFTLENBQUNoRCxFQUFFb2lCLGdCQUFGLENBQW1CcGYsQ0FBbkIsQ0FBMUIsR0FBZ0RoRCxFQUFFeWlCLEtBQUYsRUFBaEQsR0FBMER6aUIsRUFBRXdZLFNBQUYsQ0FBWXhXLENBQVosQ0FBakUsRUFBZ0YsQ0FBQ2dCLENBQUQsSUFBSWhELEVBQUU2YyxLQUFGLElBQVNRLEtBQUdELEVBQUgsR0FBTUQsRUFBZixDQUFKLEtBQXlCbmEsSUFBRWpELEVBQUVna0IsYUFBRixHQUFnQi9qQixDQUEzQyxDQUFoRixFQUE4SG9ILEdBQTlIO0FBQXhCO0FBQTBKO0FBQUMsS0FBaGpCLEVBQWlqQm9XLEtBQUksYUFBU3hiLENBQVQsRUFBVztBQUFDLFVBQUdBLGFBQWEyYSxFQUFoQixFQUFtQixPQUFPM2EsQ0FBUCxDQUFTLEtBQUksSUFBSWpDLElBQUUsS0FBS3llLFdBQVgsRUFBdUJ4ZSxJQUFFLENBQTdCLEVBQStCQSxJQUFFRCxFQUFFa0QsTUFBbkMsRUFBMENqRCxHQUExQztBQUE4QyxZQUFHRCxFQUFFQyxDQUFGLEVBQUt1VixPQUFMLENBQWE4TSxLQUFiLElBQW9CcmdCLENBQXZCLEVBQXlCLE9BQU9qQyxFQUFFQyxDQUFGLENBQVA7QUFBdkUsT0FBbUYsT0FBTyxJQUFQO0FBQVksS0FBNXJCLEVBQTZyQnVSLEtBQUksYUFBU3ZQLENBQVQsRUFBVztBQUFDLFVBQUd5QyxFQUFFekMsQ0FBRixFQUFJLEtBQUosRUFBVSxJQUFWLENBQUgsRUFBbUIsT0FBTyxJQUFQLENBQVksSUFBSWpDLElBQUUsS0FBS3lkLEdBQUwsQ0FBU3hiLEVBQUV1VCxPQUFGLENBQVU4TSxLQUFuQixDQUFOLENBQWdDLE9BQU90aUIsS0FBRyxLQUFLMFIsTUFBTCxDQUFZMVIsQ0FBWixDQUFILEVBQWtCLEtBQUt5ZSxXQUFMLENBQWlCM1osSUFBakIsQ0FBc0I3QyxDQUF0QixDQUFsQixFQUEyQ0EsRUFBRWtWLE9BQUYsR0FBVSxJQUFyRCxFQUEwRCxLQUFLMkgsV0FBTCxDQUFpQjRDLE1BQWpCLEVBQTFELEVBQW9GemYsQ0FBM0Y7QUFBNkYsS0FBejJCLEVBQTAyQnlQLFFBQU8sZ0JBQVN6UCxDQUFULEVBQVc7QUFBQyxVQUFHeUMsRUFBRXpDLENBQUYsRUFBSSxRQUFKLEVBQWEsSUFBYixDQUFILEVBQXNCLE9BQU8sSUFBUCxDQUFZLElBQUlqQyxJQUFFLEtBQUt5ZSxXQUFYLENBQXVCLE9BQU94YyxJQUFFLEtBQUt3YixHQUFMLENBQVN4YixDQUFULENBQUYsRUFBY2pDLEVBQUU4Z0IsTUFBRixDQUFTcFosRUFBRTFILENBQUYsRUFBSWlDLENBQUosQ0FBVCxFQUFnQixDQUFoQixDQUFkLEVBQWlDLEtBQUs2YyxXQUFMLENBQWlCNEMsTUFBakIsRUFBakMsRUFBMkQsSUFBbEU7QUFBdUUsS0FBNy9CLEVBQTgvQnVDLElBQUcsWUFBU2hpQixDQUFULEVBQVdqQyxDQUFYLEVBQWE7QUFBQyxVQUFJQyxJQUFFLEtBQUsyZSxRQUFYLENBQW9CLE9BQU8zWCxFQUFFbkgsRUFBRW1DLENBQUYsQ0FBRixFQUFPLFVBQVNBLENBQVQsRUFBVztBQUFDaEMsVUFBRWdDLENBQUYsSUFBS2hDLEVBQUVnQyxDQUFGLEtBQU0sRUFBWCxFQUFjaEMsRUFBRWdDLENBQUYsRUFBSzZDLElBQUwsQ0FBVTlFLENBQVYsQ0FBZDtBQUEyQixPQUE5QyxHQUFnRCxJQUF2RDtBQUE0RCxLQUEvbEMsRUFBZ21Da2tCLEtBQUksYUFBU2ppQixDQUFULEVBQVdqQyxDQUFYLEVBQWE7QUFBQyxVQUFJQyxJQUFFLEtBQUsyZSxRQUFYLENBQW9CLE9BQU8zWCxFQUFFbkgsRUFBRW1DLENBQUYsQ0FBRixFQUFPLFVBQVNBLENBQVQsRUFBVztBQUFDakMsWUFBRUMsRUFBRWdDLENBQUYsRUFBSzZlLE1BQUwsQ0FBWXBaLEVBQUV6SCxFQUFFZ0MsQ0FBRixDQUFGLEVBQU9qQyxDQUFQLENBQVosRUFBc0IsQ0FBdEIsQ0FBRixHQUEyQixPQUFPQyxFQUFFZ0MsQ0FBRixDQUFsQztBQUF1QyxPQUExRCxHQUE0RCxJQUFuRTtBQUF3RSxLQUE5c0MsRUFBK3NDdVcsTUFBSyxjQUFTdlcsQ0FBVCxFQUFXakMsQ0FBWCxFQUFhO0FBQUMsV0FBS3dWLE9BQUwsQ0FBYTZOLFNBQWIsSUFBd0JsRSxHQUFHbGQsQ0FBSCxFQUFLakMsQ0FBTCxDQUF4QixDQUFnQyxJQUFJQyxJQUFFLEtBQUsyZSxRQUFMLENBQWMzYyxDQUFkLEtBQWtCLEtBQUsyYyxRQUFMLENBQWMzYyxDQUFkLEVBQWlCa0YsS0FBakIsRUFBeEIsQ0FBaUQsSUFBR2xILEtBQUdBLEVBQUVpRCxNQUFSLEVBQWU7QUFBQ2xELFVBQUVvRCxJQUFGLEdBQU9uQixDQUFQLEVBQVNqQyxFQUFFOGhCLGNBQUYsR0FBaUIsWUFBVTtBQUFDOWhCLFlBQUUrWixRQUFGLENBQVcrSCxjQUFYO0FBQTRCLFNBQWpFLENBQWtFLEtBQUksSUFBSTVoQixJQUFFLENBQVYsRUFBWUEsSUFBRUQsRUFBRWlELE1BQWhCO0FBQXdCakQsWUFBRUMsQ0FBRixFQUFLRixDQUFMLEdBQVFFLEdBQVI7QUFBeEI7QUFBb0M7QUFBQyxLQUExNkMsRUFBMjZDMmYsU0FBUSxtQkFBVTtBQUFDLFdBQUsvVyxPQUFMLElBQWNpVyxHQUFHLElBQUgsRUFBUSxDQUFDLENBQVQsQ0FBZCxFQUEwQixLQUFLSCxRQUFMLEdBQWMsRUFBeEMsRUFBMkMsS0FBS3ZHLE9BQUwsR0FBYSxFQUF4RCxFQUEyRCxLQUFLd0csS0FBTCxDQUFXZ0IsT0FBWCxFQUEzRCxFQUFnRixLQUFLL1csT0FBTCxHQUFhLElBQTdGO0FBQWtHLEtBQWhpRCxFQUFiLEVBQStpRHBGLEVBQUU4YSxFQUFGLEVBQUssRUFBQzJGLGFBQVk3UCxDQUFiLEVBQWU4UCxZQUFXdGMsQ0FBMUIsRUFBNEJ1YyxXQUFVdFAsQ0FBdEMsRUFBd0N1UCxjQUFhdFAsQ0FBckQsRUFBdUR1UCxnQkFBZXhILEVBQXRFLEVBQXlFeUgsYUFBWWxILEVBQXJGLEVBQXdGbUgsZUFBY3BILEVBQXRHLEVBQXlHcUgsYUFBWXRILEVBQXJILEVBQXdIdUgsa0JBQWlCM0MsRUFBekksRUFBNEk0QyxpQkFBZ0J6SCxFQUE1SixFQUErSjBILGNBQWE1QyxFQUE1SyxFQUErSzZDLGdCQUFlamQsQ0FBOUwsRUFBZ01rZCxnQkFBZXpjLENBQS9NLEVBQWlOMGMsaUJBQWdCeEssQ0FBak8sRUFBbU95SyxjQUFhcmQsQ0FBaFAsRUFBa1BzZCxnQkFBZXZRLENBQWpRLEVBQW1Rd1Esc0JBQXFCeEYsQ0FBeFIsRUFBMFJ5RixvQkFBbUJ2USxDQUE3UyxFQUErU3dRLGVBQWN6RixDQUE3VCxFQUErVDBGLFNBQVEzRyxFQUF2VSxFQUEwVTRHLE9BQU1yTyxFQUFoVixFQUFtVnNPLGFBQVlwSixFQUEvVixFQUFrV3FKLFlBQVc1TixFQUE3VyxFQUFnWDZOLFlBQVczTixFQUEzWCxFQUE4WDROLG1CQUFrQi9OLEVBQWhaLEVBQW1aZ08saUJBQWdCOU4sRUFBbmEsRUFBc2ErTixrQkFBaUJ4SyxFQUF2YixFQUEwYnlLLFlBQVdsSixFQUFyYyxFQUF3Y21KLGdCQUFlckksRUFBdmQsRUFBMGRzSSxLQUFJNUgsRUFBOWQsRUFBaWU2SCxLQUFJdEksRUFBcmUsRUFBd2V1SSxPQUFNL0gsRUFBOWUsRUFBaWZnSSxPQUFNckksRUFBdmYsRUFBMGZzSSxRQUFPbEksRUFBamdCLEVBQW9nQm1JLE9BQU10SSxFQUExZ0IsRUFBNmdCa0csSUFBR2xrQixDQUFoaEIsRUFBa2hCbWtCLEtBQUl2ZixDQUF0aEIsRUFBd2hCUixNQUFLOEMsQ0FBN2hCLEVBQStoQnFmLE9BQU1yaUIsQ0FBcmlCLEVBQXVpQnRFLFFBQU8rRCxDQUE5aUIsRUFBZ2pCNmlCLFNBQVF2a0IsQ0FBeGpCLEVBQTBqQndrQixRQUFPalMsQ0FBamtCLEVBQW1rQmtTLFVBQVMvUixDQUE1a0IsRUFBTCxDQUEvaUQsRUFBb29FLGdDQUFPLHNCQUFQLE1BQWUvTSxDQUFmLElBQWtCLHNCQUFsQixHQUE2QixrQ0FBTyxZQUFVO0FBQUMsV0FBTzZXLEVBQVA7QUFBVSxHQUE1QjtBQUFBLG9HQUE3QixHQUEyRCxlQUFhLE9BQU96WCxNQUFwQixJQUE0QkEsT0FBT0MsT0FBbkMsR0FBMkNELE9BQU9DLE9BQVAsR0FBZXdYLEVBQTFELEdBQTZEdmMsRUFBRWhDLENBQUYsSUFBS3VlLEVBQWp3RTtBQUFvd0UsQ0FBN3JqQixDQUE4cmpCL2EsTUFBOXJqQixFQUFxc2pCK0IsUUFBcnNqQixFQUE4c2pCLFFBQTlzakIsQ0FBRCxDQUF5dGpCLENBQUUsV0FBU2toQixPQUFULEVBQWtCO0FBQzF1akIsTUFBSSxJQUFKLEVBQWdEO0FBQzVDQyxJQUFBLGlDQUFPLENBQUMsc0JBQUQsRUFBVyxzQkFBWCxDQUFQLG9DQUErQkQsT0FBL0I7QUFBQTtBQUFBO0FBQUE7QUFDSCxHQUZELE1BRU8sSUFBSSxRQUFPMWYsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQixRQUF2QixFQUFpQztBQUNwQzBmLFlBQVFqbkIsUUFBUSxRQUFSLENBQVIsRUFBMkJBLFFBQVEsVUFBUixDQUEzQjtBQUNILEdBRk0sTUFFQTtBQUNIaW5CLFlBQVFubkIsTUFBUixFQUFnQnFuQixNQUFoQjtBQUNIO0FBQ0osQ0FSMnRqQixFQVExdGpCLFVBQVNwbkIsQ0FBVCxFQUFZb25CLE1BQVosRUFBb0I7QUFDbEIsV0FBU0MsU0FBVCxDQUFtQkMsRUFBbkIsRUFBdUJ0UixPQUF2QixFQUFnQztBQUM1QixRQUFJdVIsTUFBTXZuQixFQUFFc25CLEVBQUYsQ0FBVjtBQUNBLFFBQUcsQ0FBQ0MsSUFBSTFpQixJQUFKLENBQVMsUUFBVCxDQUFKLEVBQXdCO0FBQ3BCMGlCLFVBQUkxaUIsSUFBSixDQUFTLFFBQVQsRUFBbUIsSUFBSXVpQixNQUFKLENBQVdHLElBQUksQ0FBSixDQUFYLEVBQW1CdlIsT0FBbkIsQ0FBbkI7QUFDSDtBQUNKOztBQUVEaFcsSUFBRStELEVBQUYsQ0FBS3lqQixNQUFMLEdBQWMsVUFBU3hSLE9BQVQsRUFBa0I7QUFDNUIsV0FBTyxLQUFLclIsSUFBTCxDQUFVLFlBQVc7QUFDeEIwaUIsZ0JBQVUsSUFBVixFQUFnQnJSLE9BQWhCO0FBQ0gsS0FGTSxDQUFQO0FBR0gsR0FKRDs7QUFNQTtBQUNBb1IsU0FBT3RCLE9BQVAsQ0FBZXBoQixTQUFmLENBQXlCc1UsSUFBekIsR0FBaUMsVUFBU3lPLFlBQVQsRUFBdUI7QUFDcEQsV0FBTyxVQUFTN2pCLElBQVQsRUFBZWlCLElBQWYsRUFBcUI7QUFDeEI0aUIsbUJBQWFyakIsSUFBYixDQUFrQixJQUFsQixFQUF3QlIsSUFBeEIsRUFBOEJpQixJQUE5QjtBQUNBN0UsUUFBRSxLQUFLc0osT0FBUCxFQUFnQm9lLE9BQWhCLENBQXdCO0FBQ3BCOWpCLGNBQU1BLElBRGM7QUFFcEJrYyxpQkFBU2piO0FBRlcsT0FBeEI7QUFJSCxLQU5EO0FBT0gsR0FSK0IsQ0FRN0J1aUIsT0FBT3RCLE9BQVAsQ0FBZXBoQixTQUFmLENBQXlCc1UsSUFSSSxDQUFoQztBQVNILENBaEMydGpCLENBQUQ7QUFpQzN0akIsQyxDQUFDO0FBQ0QsQ0FBQyxVQUFTL1UsTUFBVCxFQUFnQjtBQUNmLE1BQUdBLE9BQU8wakIsT0FBVixFQUFrQjtBQUNoQkMsa0JBQWMsRUFBZDtBQUNELEdBRkQsTUFFTztBQUNMM2pCLFdBQU8yakIsV0FBUCxHQUFxQixFQUFyQjtBQUNEO0FBQ0YsQ0FORCxFQU1HM2pCLE1BTkg7O0FBU0E7Ozs7Ozs7Ozs7QUFVQyxXQUFTQSxNQUFULEVBQWlCO0FBQ2hCLE1BQUk0akIsV0FBVyxDQUFmO0FBQUEsTUFDRUMsVUFBVSxDQUFDLFFBQUQsRUFBVyxLQUFYLENBRFo7QUFBQSxNQUVFdlIsd0JBQXdCdFMsT0FBT3NTLHFCQUZqQztBQUFBLE1BR0V3Uix1QkFBdUI5akIsT0FBTzhqQixvQkFIaEM7QUFBQSxNQUlFNWpCLElBQUkyakIsUUFBUXBrQixNQUpkOztBQU1BO0FBQ0EsU0FBTyxFQUFFUyxDQUFGLElBQU8sQ0FBUCxJQUFZLENBQUNvUyxxQkFBcEIsRUFBMkM7QUFDekNBLDRCQUF3QnRTLE9BQU82akIsUUFBUTNqQixDQUFSLElBQWEsdUJBQXBCLENBQXhCO0FBQ0E0akIsMkJBQXVCOWpCLE9BQU82akIsUUFBUTNqQixDQUFSLElBQWEsNkJBQXBCLENBQXZCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQUksQ0FBQ29TLHFCQUFELElBQTBCLENBQUN3UixvQkFBL0IsRUFBcUQ7QUFDbkR4Uiw0QkFBd0IsK0JBQVNxQixRQUFULEVBQW1CO0FBQ3pDLFVBQUlvSSxNQUFNLENBQUMvWSxLQUFLK1ksR0FBTCxFQUFYO0FBQUEsVUFDRWdJLFdBQVd4bUIsS0FBS2tILEdBQUwsQ0FBU21mLFdBQVcsRUFBcEIsRUFBd0I3SCxHQUF4QixDQURiO0FBRUEsYUFBT3JVLFdBQVcsWUFBVztBQUMzQmlNLGlCQUFTaVEsV0FBV0csUUFBcEI7QUFDRCxPQUZNLEVBRUpBLFdBQVdoSSxHQUZQLENBQVA7QUFHRCxLQU5EOztBQVFBK0gsMkJBQXVCN1IsWUFBdkI7QUFDRDs7QUFFRDtBQUNBalMsU0FBT3NTLHFCQUFQLEdBQStCQSxxQkFBL0I7QUFDQXRTLFNBQU84akIsb0JBQVAsR0FBOEJBLG9CQUE5QjtBQUNELENBOUJBLEVBOEJDOWpCLE1BOUJELENBQUQ7O0FBaUNBOzs7OztBQUtBMmpCLFlBQVlLLG9CQUFaLEdBQW1DLFVBQVNDLEdBQVQsRUFBYztBQUMvQyxNQUFJQyxTQUFTRCxJQUFJRSxJQUFKLENBQVMsU0FBVCxLQUF1QixFQUFwQztBQUNBLE1BQUlDLFFBQVFILElBQUlJLElBQUosQ0FBUyxJQUFULEtBQWtCLEVBQTlCO0FBQ0EsTUFBSUMsV0FBV0wsSUFBSUksSUFBSixDQUFTLE9BQVQsS0FBcUIsRUFBcEM7QUFDQSxTQUFPLENBQUNILFNBQVNFLEtBQVQsR0FBaUJFLFFBQWxCLEVBQTRCL1gsT0FBNUIsQ0FBb0MsS0FBcEMsRUFBMEMsRUFBMUMsQ0FBUDtBQUNELENBTEQ7O0FBUUE7QUFDQW9YLFlBQVlZLElBQVosR0FBb0IsWUFBVztBQUM3QixXQUFTQyxFQUFULEdBQWM7QUFDWixXQUFPam5CLEtBQUtrbkIsS0FBTCxDQUFXLENBQUMsSUFBSWxuQixLQUFLbW5CLE1BQUwsRUFBTCxJQUFzQixPQUFqQyxFQUNKdmhCLFFBREksQ0FDSyxFQURMLEVBRUp3aEIsU0FGSSxDQUVNLENBRk4sQ0FBUDtBQUdEO0FBQ0QsU0FBTyxZQUFXO0FBQ2hCLFdBQU9ILE9BQU9BLElBQVAsR0FBYyxHQUFkLEdBQW9CQSxJQUFwQixHQUEyQixHQUEzQixHQUFpQ0EsSUFBakMsR0FBd0MsR0FBeEMsR0FDQUEsSUFEQSxHQUNPLEdBRFAsR0FDYUEsSUFEYixHQUNvQkEsSUFEcEIsR0FDMkJBLElBRGxDO0FBRUQsR0FIRDtBQUlELENBVmtCLEVBQW5COztBQVlBOzs7OztBQUtBYixZQUFZaUIsVUFBWixHQUF5QixVQUFTQyxJQUFULEVBQWU7QUFDdEMsU0FBT0EsS0FBS3RZLE9BQUwsQ0FBYyxtQkFBZCxFQUFtQyxNQUFuQyxDQUFQO0FBQ0QsQ0FGRDs7QUFJQW9YLFlBQVltQixzQkFBWixHQUFxQyxVQUFTemYsT0FBVCxFQUFrQjtBQUNuRCxNQUFJMGYsV0FBV2hwQixFQUFFc0osT0FBRixDQUFmO0FBQ0EsTUFBSTJmLGlCQUFpQkQsU0FBU2hYLEdBQVQsQ0FBYWdYLFNBQVNFLE9BQVQsRUFBYixDQUFyQjtBQUNBLE1BQUlDLFVBQVUsS0FBZDtBQUNBRixpQkFBZXRrQixJQUFmLENBQW9CLFlBQVU7QUFDMUIsUUFBSTNFLEVBQUUsSUFBRixFQUFRb1MsR0FBUixDQUFZLFVBQVosTUFBNEIsT0FBaEMsRUFBeUM7QUFDckMrVyxnQkFBVSxJQUFWO0FBQ0EsYUFBTyxLQUFQO0FBQ0g7QUFDSixHQUxEO0FBTUEsU0FBT0EsT0FBUDtBQUNILENBWEQ7O0FBY0E7Ozs7OztBQU1BLElBQUlqaUIsVUFBV0QsS0FBSytZLEdBQUwsSUFBWSxZQUFZO0FBQ3JDLFNBQU8sSUFBSS9ZLElBQUosR0FBV0MsT0FBWCxFQUFQO0FBQ0QsQ0FGRDs7QUFLQTs7Ozs7Ozs7Ozs7O0FBWUEwZ0IsWUFBWXdCLFFBQVosR0FBdUIsVUFBU0MsSUFBVCxFQUFlQyxJQUFmLEVBQXFCdFQsT0FBckIsRUFBOEI7QUFDbkQsTUFBSXVULE9BQUosRUFBYUMsSUFBYixFQUFtQkMsTUFBbkI7QUFDQSxNQUFJQyxVQUFVLElBQWQ7QUFDQSxNQUFJQyxXQUFXLENBQWY7QUFDQTNULGNBQVlBLFVBQVUsRUFBdEI7QUFDQSxNQUFJNFQsUUFBUSxTQUFSQSxLQUFRLEdBQVk7QUFDdEJELGVBQVczVCxRQUFRNlQsT0FBUixLQUFvQixLQUFwQixHQUE0QixDQUE1QixHQUFnQzNpQixTQUEzQztBQUNBd2lCLGNBQVUsSUFBVjtBQUNBRCxhQUFTSixLQUFLemtCLEtBQUwsQ0FBVzJrQixPQUFYLEVBQW9CQyxJQUFwQixDQUFUO0FBQ0FELGNBQVVDLE9BQU8sSUFBakI7QUFDRCxHQUxEO0FBTUEsU0FBTyxZQUFZO0FBQ2pCLFFBQUl4SixNQUFNOVksU0FBVjtBQUNBLFFBQUksQ0FBQ3lpQixRQUFELElBQWEzVCxRQUFRNlQsT0FBUixLQUFvQixLQUFyQyxFQUE0Q0YsV0FBVzNKLEdBQVg7QUFDNUMsUUFBSThKLFlBQVlSLFFBQVF0SixNQUFNMkosUUFBZCxDQUFoQjtBQUNBSixjQUFVLElBQVY7QUFDQUMsV0FBT3ZrQixTQUFQO0FBQ0EsUUFBSTZrQixhQUFhLENBQWpCLEVBQW9CO0FBQ2xCNVQsbUJBQWF3VCxPQUFiO0FBQ0FBLGdCQUFVLElBQVY7QUFDQUMsaUJBQVczSixHQUFYO0FBQ0F5SixlQUFTSixLQUFLemtCLEtBQUwsQ0FBVzJrQixPQUFYLEVBQW9CQyxJQUFwQixDQUFUO0FBQ0FELGdCQUFVQyxPQUFPLElBQWpCO0FBQ0QsS0FORCxNQU1PLElBQUksQ0FBQ0UsT0FBRCxJQUFZMVQsUUFBUStULFFBQVIsS0FBcUIsS0FBckMsRUFBNEM7QUFDakRMLGdCQUFVL2QsV0FBV2llLEtBQVgsRUFBa0JFLFNBQWxCLENBQVY7QUFDRDtBQUNELFdBQU9MLE1BQVA7QUFDRCxHQWhCRDtBQWlCRCxDQTVCRDs7QUErQkE7QUFDQTtBQUNBLElBQUlPLEdBQUo7QUFDQSxJQUFJanFCLE1BQUosRUFBWTtBQUNWaXFCLFFBQU1qcUIsT0FBT3VELFFBQWI7QUFDRCxDQUZELE1BRU8sSUFBSXRELENBQUosRUFBTztBQUNaZ3FCLFFBQU1ocUIsRUFBRXNELFFBQVI7QUFDRCxDQUZNLE1BRUE7QUFDTDBtQixRQUFNMW1CLFFBQU47QUFDRDtBQUNELENBQUUsV0FBVXRELENBQVYsRUFBYTtBQUNiQSxJQUFFK0QsRUFBRixDQUFLa21CLFdBQUwsR0FBbUIsVUFBU2pVLE9BQVQsRUFBa0JrVSxXQUFsQixFQUErQjtBQUNoRCxRQUFJaGhCLFdBQVc7QUFDYmloQixpQkFBV3BuQixTQURFO0FBRWJxbkIsY0FBUXJuQixTQUZLO0FBR2JzbkIsZUFBU3RuQjtBQUhJLEtBQWY7O0FBTUEsUUFBSXVuQixhQUFhdFUsT0FBakI7QUFDQUEsY0FBVWhXLEVBQUVHLE1BQUYsQ0FBUytJLFFBQVQsRUFBbUI4TSxPQUFuQixDQUFWOztBQUdBLFdBQU8sS0FBS3JSLElBQUwsQ0FBVSxZQUFXOztBQUUxQixVQUFJNGxCLFFBQVF2cUIsRUFBRSxJQUFGLENBQVo7O0FBRUEsVUFBSXdxQixpQkFBaUJ4cUIsRUFBRSxJQUFGLEVBQVF5cUIsSUFBUixDQUFhLDRCQUFiLENBQXJCOztBQUVBLFVBQUlDLG1CQUFtQkgsTUFBTTFsQixJQUFOLENBQVcsYUFBWCxDQUF2Qjs7QUFFQTs7OztBQUlBO0FBQ0EsZUFBUzhsQixhQUFULENBQXVCQyxNQUF2QixFQUErQjtBQUM3QkoseUJBQWlCRCxNQUFNRSxJQUFOLENBQVcsNEJBQVgsQ0FBakI7QUFDQSxZQUFJRyxPQUFPQyxRQUFQLENBQWdCLFFBQWhCLENBQUosRUFBK0I7QUFDN0JELGlCQUFPRSxNQUFQLEdBQWdCaFosUUFBaEIsQ0FBeUIsUUFBekI7QUFDRCxTQUZELE1BR0s7QUFDSDhZLGlCQUFPRSxNQUFQLEdBQWdCcmYsV0FBaEIsQ0FBNEIsUUFBNUI7QUFDRDtBQUNELFlBQUltZixPQUFPRSxNQUFQLEdBQWdCRCxRQUFoQixDQUF5QixRQUF6QixDQUFKLEVBQXVDO0FBQ3JDRCxpQkFBT0csUUFBUCxDQUFnQixtQkFBaEIsRUFBcUN6RyxJQUFyQyxDQUEwQyxJQUExQyxFQUErQyxLQUEvQyxFQUFzRDBHLFNBQXRELENBQWdFLEVBQUUzaEIsVUFBVSxHQUFaLEVBQWlCbkosUUFBUSxjQUF6QixFQUF5Q2tGLE9BQU8sS0FBaEQsRUFBdURzRyxVQUFVLG9CQUFXO0FBQUMxTCxnQkFBRSxJQUFGLEVBQVFvUyxHQUFSLENBQVksUUFBWixFQUFzQixFQUF0QjtBQUEyQixhQUF4RyxFQUFoRTtBQUNELFNBRkQsTUFHSTtBQUNGd1ksaUJBQU9HLFFBQVAsQ0FBZ0IsbUJBQWhCLEVBQXFDekcsSUFBckMsQ0FBMEMsSUFBMUMsRUFBK0MsS0FBL0MsRUFBc0QyRyxPQUF0RCxDQUE4RCxFQUFFNWhCLFVBQVUsR0FBWixFQUFpQm5KLFFBQVEsY0FBekIsRUFBeUNrRixPQUFPLEtBQWhELEVBQXVEc0csVUFBVSxvQkFBVztBQUFDMUwsZ0JBQUUsSUFBRixFQUFRb1MsR0FBUixDQUFZLFFBQVosRUFBc0IsRUFBdEI7QUFBMkIsYUFBeEcsRUFBOUQ7QUFDRDs7QUFFRG9ZLHVCQUFlVSxHQUFmLENBQW1CTixNQUFuQixFQUEyQm5mLFdBQTNCLENBQXVDLFFBQXZDLEVBQWlEcWYsTUFBakQsR0FBMERyZixXQUExRCxDQUFzRSxRQUF0RTs7QUFFQTtBQUNBK2UsdUJBQWVVLEdBQWYsQ0FBbUJOLE1BQW5CLEVBQTJCRSxNQUEzQixHQUFvQ0ssUUFBcEMsQ0FBNkMsbUJBQTdDLEVBQWtFN0csSUFBbEUsQ0FBdUUsSUFBdkUsRUFBNEUsS0FBNUUsRUFBbUYzZixJQUFuRixDQUF3RixZQUFXO0FBQ2pHLGNBQUkzRSxFQUFFLElBQUYsRUFBUW9yQixFQUFSLENBQVcsVUFBWCxDQUFKLEVBQTRCO0FBQzFCcHJCLGNBQUUsSUFBRixFQUFRaXJCLE9BQVIsQ0FBZ0I7QUFDZDVoQix3QkFBVSxHQURJO0FBRWRuSixzQkFBUSxjQUZNO0FBR2RrRixxQkFBTyxLQUhPO0FBSWRzRyx3QkFDRSxvQkFBVztBQUNUMUwsa0JBQUUsSUFBRixFQUFRb1MsR0FBUixDQUFZLFFBQVosRUFBc0IsRUFBdEI7QUFDQWlaLDhCQUFjcnJCLEVBQUUsSUFBRixFQUFRK3FCLFFBQVIsQ0FBaUIscUJBQWpCLENBQWQ7QUFDRDtBQVJXLGFBQWhCO0FBVUQ7QUFDRixTQWJEO0FBY0Q7O0FBRUQ7QUFDQSxlQUFTTyxjQUFULENBQXdCVixNQUF4QixFQUFnQztBQUM5QixZQUFJQSxPQUFPQyxRQUFQLENBQWdCLFFBQWhCLENBQUosRUFBK0I7QUFDN0JELGlCQUFPRSxNQUFQLEdBQWdCaFosUUFBaEIsQ0FBeUIsUUFBekI7QUFDRCxTQUZELE1BR0s7QUFDSDhZLGlCQUFPRSxNQUFQLEdBQWdCcmYsV0FBaEIsQ0FBNEIsUUFBNUI7QUFDRDtBQUNELFlBQUltZixPQUFPRSxNQUFQLEdBQWdCRCxRQUFoQixDQUF5QixRQUF6QixDQUFKLEVBQXVDO0FBQ3JDRCxpQkFBT0csUUFBUCxDQUFnQixtQkFBaEIsRUFBcUN6RyxJQUFyQyxDQUEwQyxJQUExQyxFQUErQyxLQUEvQyxFQUFzRDBHLFNBQXRELENBQWdFLEVBQUUzaEIsVUFBVSxHQUFaLEVBQWlCbkosUUFBUSxjQUF6QixFQUF5Q2tGLE9BQU8sS0FBaEQsRUFBdURzRyxVQUFVLG9CQUFXO0FBQUMxTCxnQkFBRSxJQUFGLEVBQVFvUyxHQUFSLENBQVksUUFBWixFQUFzQixFQUF0QjtBQUEyQixhQUF4RyxFQUFoRTtBQUNELFNBRkQsTUFHSztBQUNId1ksaUJBQU9HLFFBQVAsQ0FBZ0IsbUJBQWhCLEVBQXFDekcsSUFBckMsQ0FBMEMsSUFBMUMsRUFBK0MsS0FBL0MsRUFBc0QyRyxPQUF0RCxDQUE4RCxFQUFFNWhCLFVBQVUsR0FBWixFQUFpQm5KLFFBQVEsY0FBekIsRUFBeUNrRixPQUFPLEtBQWhELEVBQXVEc0csVUFBVSxvQkFBVztBQUFDMUwsZ0JBQUUsSUFBRixFQUFRb1MsR0FBUixDQUFZLFFBQVosRUFBc0IsRUFBdEI7QUFBMkIsYUFBeEcsRUFBOUQ7QUFDRDtBQUNGOztBQUVEO0FBQ0EsZUFBU21aLGVBQVQsQ0FBeUJYLE1BQXpCLEVBQWlDWSxRQUFqQyxFQUEyQztBQUN6QyxZQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNiWixpQkFBT2EsV0FBUCxDQUFtQixRQUFuQjtBQUNEOztBQUVELFlBQUl6VixRQUFRbVUsU0FBUixJQUFxQk8scUJBQXFCLFdBQTFDLElBQXlEQSxxQkFBcUIzbkIsU0FBbEYsRUFBNkY7QUFBRTtBQUM3RjRuQix3QkFBY0MsTUFBZDtBQUNELFNBRkQsTUFFTztBQUFFO0FBQ1BVLHlCQUFlVixNQUFmO0FBQ0Q7O0FBRURTLHNCQUFjVCxNQUFkO0FBQ0Q7O0FBRUQ7QUFDQSxlQUFTUyxhQUFULENBQXVCVCxNQUF2QixFQUErQjtBQUM3QixZQUFJQSxPQUFPQyxRQUFQLENBQWdCLFFBQWhCLENBQUosRUFBK0I7QUFDN0IsY0FBSSxPQUFPN1UsUUFBUW9VLE1BQWYsS0FBMkIsVUFBL0IsRUFBMkM7QUFDekNwVSxvQkFBUW9VLE1BQVIsQ0FBZWhtQixJQUFmLENBQW9CLElBQXBCLEVBQTBCd21CLE9BQU9FLE1BQVAsRUFBMUI7QUFDRDtBQUNGLFNBSkQsTUFJTztBQUNMLGNBQUksT0FBTzlVLFFBQVFxVSxPQUFmLEtBQTRCLFVBQWhDLEVBQTRDO0FBQzFDclUsb0JBQVFxVSxPQUFSLENBQWdCam1CLElBQWhCLENBQXFCLElBQXJCLEVBQTJCd21CLE9BQU9FLE1BQVAsRUFBM0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7O0FBS0EsZUFBU1ksdUJBQVQsQ0FBaUNkLE1BQWpDLEVBQXlDOztBQUV2QyxZQUFJZSxjQUFjQyxlQUFlaEIsTUFBZixDQUFsQjs7QUFFQSxlQUFPZSxZQUFZam9CLE1BQVosR0FBcUIsQ0FBNUI7QUFDRDs7QUFFRDs7Ozs7QUFLQSxlQUFTa29CLGNBQVQsQ0FBd0JoQixNQUF4QixFQUFnQzs7QUFFOUIsZUFBT0EsT0FBT2lCLE9BQVAsQ0FBZSwwQkFBZixDQUFQO0FBQ0Q7O0FBR0Q7QUFDQSxlQUFTQyxtQkFBVCxHQUErQjtBQUM3QnZCLGNBQU03RixHQUFOLENBQVUsZ0JBQVYsRUFBNEIsNEJBQTVCO0FBQ0Q7O0FBRUQ7O0FBR0E7QUFDQSxVQUFJNEYsZUFBZSxTQUFuQixFQUE4QjtBQUM1QndCO0FBQ0E7QUFDRCxPQUhELE1BR08sSUFBSTVCLGVBQWUsQ0FBZixJQUNQQSxjQUFjTSxlQUFlOW1CLE1BRDFCLEVBQ2tDO0FBQ3ZDLFlBQUlxb0IsZUFBZXZCLGVBQWV3QixFQUFmLENBQWtCOUIsV0FBbEIsQ0FBbkI7QUFDQSxZQUFJNkIsYUFBYXJvQixNQUFiLEtBQ0M0bUIsZUFBZSxNQUFmLElBQ0FBLGVBQWUsT0FBZixJQUNEeUIsYUFBYWxCLFFBQWIsQ0FBc0IsUUFBdEIsQ0FIQSxDQUFKLEVBR3VDO0FBQ3JDVSwwQkFBZ0JRLFlBQWhCO0FBQ0Q7QUFDRDtBQUNEOztBQUdERDs7QUFHQTtBQUNBdkIsWUFBTTlGLEVBQU4sQ0FBUyxnQkFBVCxFQUEyQiw0QkFBM0IsRUFBeUQsVUFBU2hoQixDQUFULEVBQVk7QUFDbkUsWUFBSTZGLFVBQVV0SixFQUFFeUQsRUFBRW9VLE1BQUosQ0FBZDs7QUFFQSxZQUFJNlQsd0JBQXdCcGlCLE9BQXhCLENBQUosRUFBc0M7QUFDcENBLG9CQUFVc2lCLGVBQWV0aUIsT0FBZixDQUFWO0FBQ0Q7O0FBRURpaUIsd0JBQWdCamlCLE9BQWhCO0FBQ0QsT0FSRDs7QUFXQTtBQUNBLFVBQUkwTSxRQUFRbVUsU0FBUixJQUFxQk8scUJBQXFCLFdBQTFDLElBQXlEQSxxQkFBcUIzbkIsU0FBbEYsRUFBNkY7QUFBRTtBQUM3RndvQix3QkFBZ0JmLGVBQWUvTixNQUFmLENBQXNCLFNBQXRCLEVBQWlDd1AsS0FBakMsRUFBaEIsRUFBMEQsSUFBMUQ7QUFFRCxPQUhELE1BR087QUFBRTtBQUNQekIsdUJBQWUvTixNQUFmLENBQXNCLFNBQXRCLEVBQWlDOVgsSUFBakMsQ0FBc0MsWUFBVztBQUMvQzRtQiwwQkFBZ0J2ckIsRUFBRSxJQUFGLENBQWhCLEVBQXlCLElBQXpCO0FBQ0QsU0FGRDtBQUdEO0FBRUYsS0FwS00sQ0FBUDtBQXFLRCxHQWhMRDs7QUFrTEFBLElBQUVnRyxRQUFGLEVBQVlrbUIsS0FBWixDQUFrQixZQUFVO0FBQzFCbHNCLE1BQUUsY0FBRixFQUFrQmlxQixXQUFsQjtBQUNELEdBRkQ7QUFHRCxDQXRMQyxFQXNMQ2xxQixNQXRMRCxDQUFELENBc0xZLENBQUUsV0FBVUMsQ0FBVixFQUFhOztBQUUxQjtBQUNBO0FBQ0FBLElBQUUrRCxFQUFGLENBQUs2TyxRQUFMLEdBQWdCLFVBQVN1WixJQUFULEVBQWU7QUFDN0Juc0IsTUFBRSxJQUFGLEVBQVFpRyxTQUFSLENBQWtCakcsRUFBRSxJQUFGLEVBQVFpRyxTQUFSLEtBQXNCakcsRUFBRSxJQUFGLEVBQVEyRixNQUFSLEdBQWlCRSxHQUF2QyxHQUE2QzdGLEVBQUVtc0IsSUFBRixFQUFReG1CLE1BQVIsR0FBaUJFLEdBQWhGO0FBQ0EsV0FBTyxJQUFQO0FBQ0QsR0FIRDs7QUFLQTdGLElBQUUrRCxFQUFGLENBQUtxb0IsUUFBTCxHQUFnQixVQUFVcFcsT0FBVixFQUFtQjtBQUNqQyxRQUFJOU0sV0FBVztBQUNibWpCLGtCQUFZLEdBREM7QUFFYkMsbUJBQWEsR0FGQTtBQUdiQyxzQkFBZ0IsSUFISCxFQUdTO0FBQ3RCQyxhQUFPLEtBSk07QUFLYkMsY0FBUSxDQUxLLEVBS0Y7QUFDWEMsbUJBQWEsS0FOQTtBQU9iQyxpQkFBVyxNQVBFO0FBUWJDLHVCQUFpQjtBQVJKLEtBQWY7O0FBV0E7QUFDQSxRQUFJNVcsWUFBWSxNQUFoQixFQUF3QjtBQUN0QixXQUFLclIsSUFBTCxDQUFVLFlBQVc7QUFDbkIzRSxVQUFFLElBQUYsRUFBUTBuQixPQUFSLENBQWdCLE1BQWhCO0FBQ0QsT0FGRDtBQUdBLGFBQU8sS0FBUDtBQUNEOztBQUVEO0FBQ0EsUUFBSTFSLFlBQVksT0FBaEIsRUFBeUI7QUFDdkIsV0FBS3JSLElBQUwsQ0FBVSxZQUFXO0FBQ25CM0UsVUFBRSxJQUFGLEVBQVEwbkIsT0FBUixDQUFnQixPQUFoQjtBQUNELE9BRkQ7QUFHQSxhQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFLL2lCLElBQUwsQ0FBVSxZQUFVO0FBQ2xCLFVBQUlrb0IsU0FBUzdzQixFQUFFLElBQUYsQ0FBYjtBQUNBLFVBQUk4c0IsZUFBZTlzQixFQUFFRyxNQUFGLENBQVMsRUFBVCxFQUFhK0ksUUFBYixFQUF1QjhNLE9BQXZCLENBQW5CO0FBQ0EsVUFBSStXLFlBQVksS0FBaEI7O0FBRUE7QUFDQSxVQUFJQyxZQUFZaHRCLEVBQUUsTUFBSzZzQixPQUFPdkUsSUFBUCxDQUFZLGdCQUFaLENBQVAsQ0FBaEI7O0FBRUEsZUFBUzJFLGFBQVQsR0FBeUI7QUFDdkIsWUFBSUosT0FBT2hvQixJQUFQLENBQVksWUFBWixNQUE4QjlCLFNBQWxDLEVBQ0UrcEIsYUFBYVQsVUFBYixHQUEwQlEsT0FBT2hvQixJQUFQLENBQVksWUFBWixDQUExQjtBQUNGLFlBQUlnb0IsT0FBT2hvQixJQUFQLENBQVksYUFBWixNQUErQjlCLFNBQW5DLEVBQ0UrcEIsYUFBYVIsV0FBYixHQUEyQk8sT0FBT2hvQixJQUFQLENBQVksYUFBWixDQUEzQjtBQUNGLFlBQUlnb0IsT0FBT2hvQixJQUFQLENBQVksZ0JBQVosTUFBa0M5QixTQUF0QyxFQUNFK3BCLGFBQWFQLGNBQWIsR0FBOEJNLE9BQU9ob0IsSUFBUCxDQUFZLGdCQUFaLENBQTlCO0FBQ0YsWUFBSWdvQixPQUFPaG9CLElBQVAsQ0FBWSxPQUFaLE1BQXlCOUIsU0FBN0IsRUFDRStwQixhQUFhTixLQUFiLEdBQXFCSyxPQUFPaG9CLElBQVAsQ0FBWSxPQUFaLENBQXJCO0FBQ0YsWUFBSWdvQixPQUFPaG9CLElBQVAsQ0FBWSxRQUFaLE1BQTBCOUIsU0FBOUIsRUFDRStwQixhQUFhTCxNQUFiLEdBQXNCSSxPQUFPaG9CLElBQVAsQ0FBWSxRQUFaLENBQXRCO0FBQ0YsWUFBSWdvQixPQUFPaG9CLElBQVAsQ0FBWSxhQUFaLE1BQStCOUIsU0FBbkMsRUFDRStwQixhQUFhSixXQUFiLEdBQTJCRyxPQUFPaG9CLElBQVAsQ0FBWSxhQUFaLENBQTNCO0FBQ0YsWUFBSWdvQixPQUFPaG9CLElBQVAsQ0FBWSxXQUFaLE1BQTZCOUIsU0FBakMsRUFDRStwQixhQUFhSCxTQUFiLEdBQXlCRSxPQUFPaG9CLElBQVAsQ0FBWSxXQUFaLENBQXpCO0FBQ0YsWUFBSWdvQixPQUFPaG9CLElBQVAsQ0FBWSxpQkFBWixNQUFtQzlCLFNBQXZDLEVBQ0UrcEIsYUFBYUYsZUFBYixHQUErQkMsT0FBT2hvQixJQUFQLENBQVksaUJBQVosQ0FBL0I7QUFDSDs7QUFFRG9vQjs7QUFFQTtBQUNBSixhQUFPSyxLQUFQLENBQWFGLFNBQWI7O0FBRUE7Ozs7QUFJQSxlQUFTRyxhQUFULENBQXVCclUsU0FBdkIsRUFBa0M7QUFDaEM7QUFDQSxZQUFJQSxjQUFjLE9BQWxCLEVBQTJCO0FBQ3pCaVUsc0JBQVksSUFBWjtBQUNEOztBQUVEO0FBQ0FFOztBQUVBO0FBQ0FELGtCQUFVbGIsUUFBVixDQUFtQixRQUFuQjtBQUNBK2EsZUFBTy9hLFFBQVAsQ0FBZ0IsUUFBaEI7O0FBRUE7QUFDQSxZQUFJZ2IsYUFBYVAsY0FBYixLQUFnQyxJQUFwQyxFQUEwQztBQUN4Q1Msb0JBQVU1YSxHQUFWLENBQWMsT0FBZCxFQUF1QnlhLE9BQU9PLFVBQVAsRUFBdkI7QUFFRCxTQUhELE1BR087QUFDTEosb0JBQVU1YSxHQUFWLENBQWMsYUFBZCxFQUE2QixRQUE3QjtBQUNEOztBQUVEO0FBQ0EsWUFBSWliLGVBQWVwcEIsT0FBT3NRLFdBQTFCO0FBQ0EsWUFBSStZLGVBQWVULE9BQU90WSxXQUFQLEVBQW5CO0FBQ0EsWUFBSWdaLGFBQWFWLE9BQU9sbkIsTUFBUCxHQUFnQkcsSUFBakM7QUFDQSxZQUFJMG5CLFlBQVlYLE9BQU9sbkIsTUFBUCxHQUFnQkUsR0FBaEIsR0FBc0I3RixFQUFFaUUsTUFBRixFQUFVZ0MsU0FBVixFQUF0QztBQUNBLFlBQUl3bkIsZ0JBQWdCWCxhQUFhSCxTQUFqQztBQUNBLFlBQUllLGdCQUFnQixDQUFwQjtBQUNBLFlBQUlDLGVBQWUsQ0FBbkI7O0FBRUE7QUFDQSxZQUFJQyxpQkFBaUIsQ0FBckI7QUFDQSxZQUFJZCxhQUFhSixXQUFiLEtBQTZCLElBQWpDLEVBQXVDO0FBQ3JDa0IsMkJBQWlCTixZQUFqQjtBQUNEOztBQUVEO0FBQ0EsWUFBSU8sZ0JBQWdCLENBQXBCO0FBQ0EsWUFBSUMsZ0JBQWdCLENBQXBCO0FBQ0EsWUFBSUMsVUFBVWxCLE9BQU8vQixNQUFQLEVBQWQ7QUFDQSxZQUFJLENBQUNpRCxRQUFRM0MsRUFBUixDQUFXLE1BQVgsQ0FBTCxFQUF5QjtBQUN2QixjQUFJMkMsUUFBUSxDQUFSLEVBQVdDLFlBQVgsR0FBMEJELFFBQVEsQ0FBUixFQUFXRSxZQUF6QyxFQUF1RDtBQUNyREosNEJBQWdCRSxRQUFRLENBQVIsRUFBVzluQixTQUEzQjtBQUNEO0FBQ0QsY0FBSThuQixRQUFRLENBQVIsRUFBV0csV0FBWCxHQUF5QkgsUUFBUSxDQUFSLEVBQVdJLFdBQXhDLEVBQXFEO0FBQ25ETCw0QkFBZ0JDLFFBQVEsQ0FBUixFQUFXM25CLFVBQTNCO0FBQ0Q7QUFDRjs7QUFHRCxZQUFJbW5CLGFBQWFQLFVBQVUzWSxVQUFWLEVBQWIsR0FBc0NyVSxFQUFFaUUsTUFBRixFQUFVbXFCLEtBQVYsRUFBMUMsRUFBNkQ7QUFDM0Q7QUFDQVgsMEJBQWdCLE9BQWhCO0FBRUQsU0FKRCxNQUlPLElBQUlGLGFBQWFQLFVBQVUzWSxVQUFWLEVBQWIsR0FBc0N3WSxPQUFPeFksVUFBUCxFQUF0QyxHQUE0RCxDQUFoRSxFQUFtRTtBQUN4RTtBQUNBb1osMEJBQWdCLE1BQWhCO0FBQ0Q7QUFDRDtBQUNBLFlBQUlELFlBQVlSLFVBQVV6WSxXQUFWLEVBQVosR0FBc0M4WSxZQUExQyxFQUF3RDtBQUN0RDtBQUNBLGNBQUlHLFlBQVlGLFlBQVosR0FBMkJOLFVBQVV6WSxXQUFWLEVBQTNCLEdBQXFELENBQXpELEVBQTREO0FBQzFELGdCQUFJOFosaUJBQWlCaEIsZUFBZUcsU0FBZixHQUEyQkksY0FBaEQ7QUFDQVosc0JBQVU1YSxHQUFWLENBQWMsWUFBZCxFQUE0QmljLGNBQTVCO0FBQ0QsV0FIRCxNQUdPO0FBQ0w7QUFDQSxnQkFBSSxDQUFDVCxjQUFMLEVBQXFCO0FBQ25CQSxnQ0FBa0JOLFlBQWxCO0FBQ0Q7QUFDRE0sOEJBQWtCWixVQUFVelksV0FBVixFQUFsQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxZQUFJa1osa0JBQWtCLE1BQXRCLEVBQThCO0FBQzVCQywwQkFBZ0JaLGFBQWFMLE1BQTdCO0FBQ0FrQix5QkFBZWQsT0FBT3ZtQixRQUFQLEdBQWtCUixJQUFsQixHQUF5QjRuQixhQUF4QztBQUNELFNBSEQsTUFJSyxJQUFJRCxrQkFBa0IsT0FBdEIsRUFBK0I7QUFDbEMsY0FBSWEsY0FBY3pCLE9BQU92bUIsUUFBUCxHQUFrQlIsSUFBbEIsR0FBeUIrbUIsT0FBT08sVUFBUCxFQUF6QixHQUErQ0osVUFBVUksVUFBVixFQUFqRTtBQUNBTSwwQkFBZ0IsQ0FBQ1osYUFBYUwsTUFBOUI7QUFDQWtCLHlCQUFnQlcsY0FBY1osYUFBOUI7QUFDRDs7QUFFRDtBQUNBVixrQkFBVTVhLEdBQVYsQ0FBYztBQUNaOUwsb0JBQVUsVUFERTtBQUVaVCxlQUFLZ25CLE9BQU92bUIsUUFBUCxHQUFrQlQsR0FBbEIsR0FBd0IrbkIsY0FBeEIsR0FBeUNDLGFBRmxDO0FBR1ovbkIsZ0JBQU02bkIsZUFBZUc7QUFIVCxTQUFkOztBQU9BO0FBQ0FkLGtCQUFVMUksSUFBVixDQUFlLElBQWYsRUFBcUIsSUFBckIsRUFBMkJsUyxHQUEzQixDQUErQixTQUEvQixFQUEwQyxDQUExQyxFQUNHNFksU0FESCxDQUNhO0FBQ1Q1bEIsaUJBQU8sS0FERTtBQUVUaUUsb0JBQVV5akIsYUFBYVQsVUFGZDtBQUdUbnNCLGtCQUFRLGNBSEM7QUFJVHdMLG9CQUFVLG9CQUFXO0FBQ25CMUwsY0FBRSxJQUFGLEVBQVFvUyxHQUFSLENBQVksUUFBWixFQUFzQixFQUF0QjtBQUNEO0FBTlEsU0FEYixFQVNHdEYsT0FUSCxDQVNZLEVBQUM0RCxTQUFTLENBQVYsRUFUWixFQVMwQixFQUFDdEwsT0FBTyxLQUFSLEVBQWVpRSxVQUFVeWpCLGFBQWFULFVBQXRDLEVBQWtEbnNCLFFBQVEsYUFBMUQsRUFUMUI7O0FBV0E7QUFDQXlMLG1CQUFXLFlBQVc7QUFDcEIzTCxZQUFFZ0csUUFBRixFQUFZdW9CLElBQVosQ0FBaUIsV0FBVXZCLFVBQVUxRSxJQUFWLENBQWUsSUFBZixDQUEzQixFQUFpRCxVQUFVN2tCLENBQVYsRUFBYTtBQUM1RCtxQjtBQUNBeHVCLGNBQUVnRyxRQUFGLEVBQVl5b0IsTUFBWixDQUFtQixXQUFVekIsVUFBVTFFLElBQVYsQ0FBZSxJQUFmLENBQTdCO0FBQ0QsV0FIRDtBQUlELFNBTEQsRUFLRyxDQUxIO0FBTUQ7O0FBRUQsZUFBU2tHLFlBQVQsR0FBd0I7QUFDdEI7QUFDQXpCLG9CQUFZLEtBQVo7QUFDQUMsa0JBQVUwQixPQUFWLENBQWtCNUIsYUFBYVIsV0FBL0I7QUFDQVUsa0JBQVV2aEIsV0FBVixDQUFzQixRQUF0QjtBQUNBb2hCLGVBQU9waEIsV0FBUCxDQUFtQixRQUFuQjtBQUNBekwsVUFBRWdHLFFBQUYsRUFBWXlvQixNQUFaLENBQW1CLFdBQVV6QixVQUFVMUUsSUFBVixDQUFlLElBQWYsQ0FBN0I7QUFDQTNjLG1CQUFXLFlBQVc7QUFBRXFoQixvQkFBVTVhLEdBQVYsQ0FBYyxZQUFkLEVBQTRCLEVBQTVCO0FBQWtDLFNBQTFELEVBQTREMGEsYUFBYVIsV0FBekU7QUFDRDs7QUFFRDtBQUNBLFVBQUlRLGFBQWFOLEtBQWpCLEVBQXdCO0FBQ3RCLFlBQUltQyxPQUFPLEtBQVg7QUFDQTlCLGVBQU80QixNQUFQLENBQWMsV0FBVzVCLE9BQU92RSxJQUFQLENBQVksSUFBWixDQUF6QjtBQUNBO0FBQ0F1RSxlQUFPcEksRUFBUCxDQUFVLFlBQVYsRUFBd0IsVUFBU2hoQixDQUFULEVBQVc7QUFBRTtBQUNuQyxjQUFJa3JCLFNBQVMsS0FBYixFQUFvQjtBQUNsQnhCO0FBQ0F3QixtQkFBTyxJQUFQO0FBQ0Q7QUFDRixTQUxEO0FBTUE5QixlQUFPcEksRUFBUCxDQUFVLFlBQVYsRUFBd0IsVUFBU2hoQixDQUFULEVBQVc7QUFDakM7QUFDQSxjQUFJbXJCLE9BQU9uckIsRUFBRW9yQixTQUFGLElBQWVwckIsRUFBRXFyQixhQUE1QixDQUZpQyxDQUVVO0FBQzNDLGNBQUcsQ0FBQzl1QixFQUFFNHVCLElBQUYsRUFBUS9DLE9BQVIsQ0FBZ0IsbUJBQWhCLEVBQXFDVCxFQUFyQyxDQUF3QzRCLFNBQXhDLENBQUosRUFBd0Q7QUFDdERBLHNCQUFVMUksSUFBVixDQUFlLElBQWYsRUFBcUIsSUFBckI7QUFDQWtLO0FBQ0FHLG1CQUFPLEtBQVA7QUFDRDtBQUNGLFNBUkQ7O0FBVUEzQixrQkFBVXZJLEVBQVYsQ0FBYSxZQUFiLEVBQTJCLFVBQVNoaEIsQ0FBVCxFQUFXO0FBQUU7QUFDdEMsY0FBSW1yQixPQUFPbnJCLEVBQUVvckIsU0FBRixJQUFlcHJCLEVBQUVxckIsYUFBNUI7QUFDQSxjQUFHLENBQUM5dUIsRUFBRTR1QixJQUFGLEVBQVEvQyxPQUFSLENBQWdCLGtCQUFoQixFQUFvQ1QsRUFBcEMsQ0FBdUN5QixNQUF2QyxDQUFKLEVBQW9EO0FBQ2xERyxzQkFBVTFJLElBQVYsQ0FBZSxJQUFmLEVBQXFCLElBQXJCO0FBQ0FrSztBQUNBRyxtQkFBTyxLQUFQO0FBQ0Q7QUFDRixTQVBEOztBQVNBO0FBQ0QsT0E5QkQsTUE4Qk87QUFDTDtBQUNBOUIsZUFBTzRCLE1BQVAsQ0FBYyxXQUFXNUIsT0FBT3ZFLElBQVAsQ0FBWSxJQUFaLENBQXpCO0FBQ0F1RSxlQUFPMEIsSUFBUCxDQUFZLFdBQVMxQixPQUFPdkUsSUFBUCxDQUFZLElBQVosQ0FBckIsRUFBd0MsVUFBUzdrQixDQUFULEVBQVc7QUFDakQsY0FBSSxDQUFDc3BCLFNBQUwsRUFBZ0I7QUFDZCxnQkFBS0YsT0FBTyxDQUFQLEtBQWFwcEIsRUFBRXNyQixhQUFmLElBQ0EsQ0FBQ2xDLE9BQU9oQyxRQUFQLENBQWdCLFFBQWhCLENBREQsSUFFQzdxQixFQUFFeUQsRUFBRW9VLE1BQUosRUFBWWdVLE9BQVosQ0FBb0IsbUJBQXBCLEVBQXlDbm9CLE1BQXpDLEtBQW9ELENBRjFELEVBRThEO0FBQzVERCxnQkFBRTZlLGNBQUYsR0FENEQsQ0FDeEM7QUFDcEIsa0JBQUl3SyxhQUFhRixlQUFqQixFQUFrQztBQUNoQ25wQixrQkFBRW1wQixlQUFGO0FBQ0Q7QUFDRE8sNEJBQWMsT0FBZDtBQUNEO0FBQ0Q7QUFUQSxpQkFVSyxJQUFJTixPQUFPaEMsUUFBUCxDQUFnQixRQUFoQixDQUFKLEVBQStCO0FBQ2xDMkQ7QUFDQXh1QixrQkFBRWdHLFFBQUYsRUFBWXlvQixNQUFaLENBQW1CLFdBQVV6QixVQUFVMUUsSUFBVixDQUFlLElBQWYsQ0FBN0I7QUFDRDtBQUNGO0FBQ0YsU0FqQkQ7QUFtQkQsT0FwTmlCLENBb05oQjs7QUFFRjtBQUNBdUUsYUFBT3BJLEVBQVAsQ0FBVSxNQUFWLEVBQWtCLFVBQVNoaEIsQ0FBVCxFQUFZcVYsU0FBWixFQUF1QjtBQUN2Q3FVLHNCQUFjclUsU0FBZDtBQUNELE9BRkQ7QUFHQStULGFBQU9wSSxFQUFQLENBQVUsT0FBVixFQUFtQitKLFlBQW5CO0FBR0QsS0E3TkQ7QUE4TkQsR0ExUEQsQ0FUMEIsQ0FtUXZCOztBQUVIeHVCLElBQUVnRyxRQUFGLEVBQVlrbUIsS0FBWixDQUFrQixZQUFVO0FBQzFCbHNCLE1BQUUsa0JBQUYsRUFBc0Jvc0IsUUFBdEI7QUFDRCxHQUZEO0FBR0QsQ0F4UWMsRUF3UVpyc0IsTUF4UVksQ0FBRDtBQXlRZCxDQUFDLENBQUMsVUFBU0MsQ0FBVCxFQUFZO0FBQ1osTUFBSWd2QixTQUFTLENBQWI7QUFBQSxNQUNBQyxVQUFVLENBRFY7QUFBQSxNQUVBQyxjQUFjLFNBQWRBLFdBQWMsR0FBVztBQUN2QkQ7QUFDQSxXQUFPLCtCQUErQkEsT0FBdEM7QUFDRCxHQUxEOztBQU9BLE1BQUlFLFVBQVU7QUFDWm5yQixVQUFPLGNBQVNnUyxPQUFULEVBQWtCO0FBQ3ZCLFVBQUk5TSxXQUFXO0FBQ2J3SCxpQkFBUyxHQURJO0FBRWIyYixvQkFBWSxHQUZDO0FBR2JDLHFCQUFhLEdBSEE7QUFJYkosZUFBT25wQixTQUpNO0FBS2IySSxrQkFBVTNJLFNBTEc7QUFNYnFzQixxQkFBYSxJQU5BO0FBT2JDLHFCQUFhLElBUEE7QUFRYkMsbUJBQVc7QUFSRSxPQUFmOztBQVdBO0FBQ0F0WixnQkFBVWhXLEVBQUVHLE1BQUYsQ0FBUytJLFFBQVQsRUFBbUI4TSxPQUFuQixDQUFWOztBQUVBLGFBQU8sS0FBS3JSLElBQUwsQ0FBVSxZQUFXO0FBQzFCLFlBQUk0cUIsU0FBU3Z2QixFQUFFLElBQUYsQ0FBYjtBQUNBLFlBQUl3dkIsV0FBV3h2QixFQUFFLElBQUYsRUFBUXNvQixJQUFSLENBQWEsSUFBYixLQUFzQixNQUFNdG9CLEVBQUUsSUFBRixFQUFRNkUsSUFBUixDQUFhLFFBQWIsQ0FBM0M7O0FBRUEsWUFBSTRxQixhQUFhLFNBQWJBLFVBQWEsR0FBVztBQUMxQixjQUFJQyxZQUFZSCxPQUFPMXFCLElBQVAsQ0FBWSxZQUFaLENBQWhCO0FBQ0EsY0FBSThxQixXQUFXM3ZCLEVBQUUsTUFBTTB2QixTQUFSLENBQWY7QUFDQUgsaUJBQU85akIsV0FBUCxDQUFtQixNQUFuQjs7QUFFQTtBQUNBekwsWUFBRSxNQUFGLEVBQVVvUyxHQUFWLENBQWM7QUFDWjBFLHNCQUFVLEVBREU7QUFFWnNYLG1CQUFPO0FBRkssV0FBZDs7QUFLQW1CLGlCQUFPOUUsSUFBUCxDQUFZLGNBQVosRUFBNEIvRixHQUE1QixDQUFnQyxhQUFoQztBQUNBMWtCLFlBQUVnRyxRQUFGLEVBQVkwZSxHQUFaLENBQWdCLGdCQUFnQmdMLFNBQWhDOztBQUVBQyxtQkFBUzlpQixRQUFULENBQW1CLEVBQUU2RCxTQUFTLENBQVgsRUFBbkIsRUFBa0MsRUFBQ3JILFVBQVUyTSxRQUFRc1csV0FBbkIsRUFBZ0NsbkIsT0FBTyxLQUF2QyxFQUE4Q3dxQixNQUFNLGNBQXBELEVBQWxDOztBQUdBO0FBQ0EsY0FBSUMsc0JBQXNCO0FBQ3hCeG1CLHNCQUFVMk0sUUFBUXNXLFdBRE07QUFFeEJsbkIsbUJBQU8sS0FGaUI7QUFHeEJ3cUIsa0JBQU0sY0FIa0I7QUFJeEI7QUFDQWxrQixzQkFBVSxvQkFBVztBQUNuQjFMLGdCQUFFLElBQUYsRUFBUW9TLEdBQVIsQ0FBWSxFQUFDN0ksU0FBUSxNQUFULEVBQVo7O0FBRUE7QUFDQSxrQkFBSSxPQUFPeU0sUUFBUXRLLFFBQWYsS0FBNkIsVUFBakMsRUFBNkM7QUFDM0NzSyx3QkFBUXRLLFFBQVIsQ0FBaUJ0SCxJQUFqQixDQUFzQixJQUF0QixFQUE0Qm1yQixNQUE1QjtBQUNEO0FBQ0RJLHVCQUFTemQsTUFBVDtBQUNBOGM7QUFDRDtBQWR1QixXQUExQjtBQWdCQSxjQUFJTyxPQUFPMUUsUUFBUCxDQUFnQixjQUFoQixDQUFKLEVBQXFDO0FBQ25DMEUsbUJBQU8xaUIsUUFBUCxDQUFnQixFQUFDaWpCLFFBQVEsT0FBVCxFQUFrQnBmLFNBQVMsQ0FBM0IsRUFBaEIsRUFBK0NtZixtQkFBL0M7QUFDRCxXQUZELE1BR0s7QUFDSE4sbUJBQU8xaUIsUUFBUCxDQUNFLEVBQUVoSCxLQUFLbVEsUUFBUXFaLFdBQWYsRUFBNEIzZSxTQUFTLENBQXJDLEVBQXdDcWYsUUFBUSxHQUFoRCxFQURGLEVBRUVGLG1CQUZGO0FBSUQ7QUFDRixTQTNDRDs7QUE2Q0EsWUFBSUcsWUFBWSxTQUFaQSxTQUFZLENBQVNDLFFBQVQsRUFBbUI7QUFDakMsY0FBSUMsUUFBUWx3QixFQUFFLE1BQUYsQ0FBWjtBQUNBLGNBQUltd0IsV0FBV0QsTUFBTTdiLFVBQU4sRUFBZjtBQUNBNmIsZ0JBQU05ZCxHQUFOLENBQVUsVUFBVixFQUFzQixRQUF0QjtBQUNBOGQsZ0JBQU05QixLQUFOLENBQVkrQixRQUFaOztBQUVBLGNBQUlaLE9BQU8xRSxRQUFQLENBQWdCLE1BQWhCLENBQUosRUFBNkI7QUFDM0I7QUFDRDs7QUFFRCxjQUFJNkUsWUFBWVIsYUFBaEI7QUFDQSxjQUFJUyxXQUFXM3ZCLEVBQUUsbUNBQUYsQ0FBZjtBQUNBb3dCLG1CQUFVLEVBQUVwQixNQUFaOztBQUVBO0FBQ0FXLG1CQUFTckgsSUFBVCxDQUFjLElBQWQsRUFBb0JvSCxTQUFwQixFQUErQnRkLEdBQS9CLENBQW1DLFNBQW5DLEVBQThDLE9BQU9nZSxTQUFTLENBQTlEO0FBQ0FiLGlCQUFPMXFCLElBQVAsQ0FBWSxZQUFaLEVBQTBCNnFCLFNBQTFCLEVBQXFDdGQsR0FBckMsQ0FBeUMsU0FBekMsRUFBb0QsT0FBT2dlLFNBQVMsQ0FBaEIsR0FBb0IsQ0FBeEU7QUFDQWIsaUJBQU96ZCxRQUFQLENBQWdCLE1BQWhCOztBQUVBOVIsWUFBRSxNQUFGLEVBQVVxd0IsTUFBVixDQUFpQlYsUUFBakI7O0FBRUEsY0FBSTNaLFFBQVFvWixXQUFaLEVBQXlCO0FBQ3ZCTyxxQkFBU1csS0FBVCxDQUFlLFlBQVc7QUFDeEJiO0FBQ0QsYUFGRDtBQUdBO0FBQ0F6dkIsY0FBRWdHLFFBQUYsRUFBWXllLEVBQVosQ0FBZSxnQkFBZ0JpTCxTQUEvQixFQUEwQyxVQUFTanNCLENBQVQsRUFBWTtBQUNwRCxrQkFBSUEsRUFBRThzQixPQUFGLEtBQWMsRUFBbEIsRUFBc0I7QUFBSTtBQUN4QmQ7QUFDRDtBQUNGLGFBSkQ7QUFLRDs7QUFFREYsaUJBQU85RSxJQUFQLENBQVksY0FBWixFQUE0QmhHLEVBQTVCLENBQStCLGFBQS9CLEVBQThDLFVBQVNoaEIsQ0FBVCxFQUFZO0FBQ3hEZ3NCO0FBQ0QsV0FGRDs7QUFJQUUsbUJBQVN2ZCxHQUFULENBQWEsRUFBRTdJLFNBQVUsT0FBWixFQUFxQm1ILFNBQVUsQ0FBL0IsRUFBYjs7QUFFQTZlLGlCQUFPbmQsR0FBUCxDQUFXO0FBQ1Q3SSxxQkFBVSxPQUREO0FBRVRtSCxxQkFBUztBQUZBLFdBQVg7O0FBS0FpZixtQkFBUzlpQixRQUFULENBQWtCLEVBQUM2RCxTQUFTc0YsUUFBUXRGLE9BQWxCLEVBQWxCLEVBQThDLEVBQUNySCxVQUFVMk0sUUFBUXFXLFVBQW5CLEVBQStCam5CLE9BQU8sS0FBdEMsRUFBNkN3cUIsTUFBTSxjQUFuRCxFQUE5QztBQUNBTCxpQkFBTzFxQixJQUFQLENBQVksb0JBQVosRUFBa0M4cUIsU0FBUyxDQUFULENBQWxDOztBQUVBO0FBQ0EsY0FBSWEsdUJBQXVCO0FBQ3pCbm5CLHNCQUFVMk0sUUFBUXFXLFVBRE87QUFFekJqbkIsbUJBQU8sS0FGa0I7QUFHekJ3cUIsa0JBQU0sY0FIbUI7QUFJekI7QUFDQWxrQixzQkFBVSxvQkFBVztBQUNuQixrQkFBSSxPQUFPc0ssUUFBUWtXLEtBQWYsS0FBMEIsVUFBOUIsRUFBMEM7QUFDeENsVyx3QkFBUWtXLEtBQVIsQ0FBYzluQixJQUFkLENBQW1CLElBQW5CLEVBQXlCbXJCLE1BQXpCLEVBQWlDVSxRQUFqQztBQUNEO0FBQ0Y7QUFUd0IsV0FBM0I7QUFXQSxjQUFJVixPQUFPMUUsUUFBUCxDQUFnQixjQUFoQixDQUFKLEVBQXFDO0FBQ25DMEUsbUJBQU8xaUIsUUFBUCxDQUFnQixFQUFDaWpCLFFBQVEsR0FBVCxFQUFjcGYsU0FBUyxDQUF2QixFQUFoQixFQUEyQzhmLG9CQUEzQztBQUNELFdBRkQsTUFHSztBQUNIeHdCLGNBQUVzRCxRQUFGLENBQVc0SyxJQUFYLENBQWdCcWhCLE1BQWhCLEVBQXdCLFFBQXhCLEVBQWtDLEdBQWxDO0FBQ0FBLG1CQUFPbmQsR0FBUCxDQUFXLEVBQUV2TSxLQUFLbVEsUUFBUXFaLFdBQWYsRUFBWDtBQUNBRSxtQkFBTzFpQixRQUFQLENBQWdCLEVBQUNoSCxLQUFLbVEsUUFBUXNaLFNBQWQsRUFBeUI1ZSxTQUFTLENBQWxDLEVBQXFDcWYsUUFBUSxHQUE3QyxFQUFoQixFQUFtRVMsb0JBQW5FO0FBQ0Q7QUFFRixTQXBFRDs7QUFzRUE7QUFDQXh3QixVQUFFZ0csUUFBRixFQUFZMGUsR0FBWixDQUFnQixvQkFBaEIsRUFBc0MsY0FBYzhLLFFBQWQsR0FBeUIsb0JBQXpCLEdBQWdEQSxRQUFoRCxHQUEyRCxJQUFqRztBQUNBeHZCLFVBQUUsSUFBRixFQUFRMGtCLEdBQVIsQ0FBWSxXQUFaO0FBQ0Exa0IsVUFBRSxJQUFGLEVBQVEwa0IsR0FBUixDQUFZLFlBQVo7O0FBRUE7QUFDQTFrQixVQUFFZ0csUUFBRixFQUFZeWUsRUFBWixDQUFlLG9CQUFmLEVBQXFDLGNBQWMrSyxRQUFkLEdBQXlCLG9CQUF6QixHQUFnREEsUUFBaEQsR0FBMkQsSUFBaEcsRUFBc0csVUFBUy9yQixDQUFULEVBQVk7QUFDaEh1UyxrQkFBUXFaLFdBQVIsR0FBc0IsQ0FBQ3J2QixFQUFFLElBQUYsRUFBUTJGLE1BQVIsR0FBaUJFLEdBQWpCLEdBQXVCN0YsRUFBRWlFLE1BQUYsRUFBVWdDLFNBQVYsRUFBeEIsSUFBZ0QsSUFBdEU7QUFDQStwQixvQkFBVWh3QixFQUFFLElBQUYsQ0FBVjtBQUNBeUQsWUFBRTZlLGNBQUY7QUFDRCxTQUpELEVBN0gwQixDQWlJdEI7O0FBRUp0aUIsVUFBRSxJQUFGLEVBQVF5a0IsRUFBUixDQUFXLFdBQVgsRUFBd0IsWUFBVztBQUNqQyxjQUFJK0ssV0FBV3h2QixFQUFFLElBQUYsRUFBUXNvQixJQUFSLENBQWEsTUFBYixLQUF3QixNQUFNdG9CLEVBQUUsSUFBRixFQUFRNkUsSUFBUixDQUFhLFFBQWIsQ0FBN0M7QUFDQW1yQjtBQUNELFNBSEQ7O0FBS0Fod0IsVUFBRSxJQUFGLEVBQVF5a0IsRUFBUixDQUFXLFlBQVgsRUFBeUIsWUFBVztBQUNsQ2dMO0FBQ0QsU0FGRDtBQUdELE9BM0lNLENBQVAsQ0FmdUIsQ0EwSm5CO0FBQ0wsS0E1Slc7QUE2SlpkLFVBQU8sZ0JBQVc7QUFDaEIzdUIsUUFBRSxJQUFGLEVBQVEwbkIsT0FBUixDQUFnQixXQUFoQjtBQUNELEtBL0pXO0FBZ0taK0ksV0FBUSxpQkFBVztBQUNqQnp3QixRQUFFLElBQUYsRUFBUTBuQixPQUFSLENBQWdCLFlBQWhCO0FBQ0Q7QUFsS1csR0FBZDs7QUFxS0ExbkIsSUFBRStELEVBQUYsQ0FBSzJzQixLQUFMLEdBQWEsVUFBU0MsZUFBVCxFQUEwQjtBQUNyQyxRQUFLeEIsUUFBUXdCLGVBQVIsQ0FBTCxFQUFnQztBQUM5QixhQUFPeEIsUUFBU3dCLGVBQVQsRUFBMkIvckIsS0FBM0IsQ0FBa0MsSUFBbEMsRUFBd0NOLE1BQU1JLFNBQU4sQ0FBZ0JpRCxLQUFoQixDQUFzQnZELElBQXRCLENBQTRCYSxTQUE1QixFQUF1QyxDQUF2QyxDQUF4QyxDQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUssUUFBTzByQixlQUFQLHlDQUFPQSxlQUFQLE9BQTJCLFFBQTNCLElBQXVDLENBQUVBLGVBQTlDLEVBQWdFO0FBQ3JFO0FBQ0EsYUFBT3hCLFFBQVFuckIsSUFBUixDQUFhWSxLQUFiLENBQW9CLElBQXBCLEVBQTBCSyxTQUExQixDQUFQO0FBQ0QsS0FITSxNQUdBO0FBQ0xqRixRQUFFNHdCLEtBQUYsQ0FBUyxZQUFhRCxlQUFiLEdBQStCLGlDQUF4QztBQUNEO0FBQ0YsR0FURDtBQVVELENBdkxBLEVBdUxFNXdCLE1BdkxGO0FBd0xELENBQUUsV0FBVUMsQ0FBVixFQUFhOztBQUViQSxJQUFFK0QsRUFBRixDQUFLOHNCLFdBQUwsR0FBbUIsWUFBWTs7QUFFN0IsV0FBTyxLQUFLbHNCLElBQUwsQ0FBVSxZQUFXOztBQUUxQixVQUFJM0UsRUFBRSxJQUFGLEVBQVE2cUIsUUFBUixDQUFpQixhQUFqQixDQUFKLEVBQXFDO0FBQ25DO0FBQ0Q7O0FBRUQ3cUIsUUFBRSxJQUFGLEVBQVE4UixRQUFSLENBQWlCLGFBQWpCOztBQUVBLFVBQUlnZixnQkFBZ0IsS0FBcEI7QUFDQSxVQUFJQyxnQkFBZ0IsSUFBcEI7QUFDQSxVQUFJMUUsYUFBYSxHQUFqQjtBQUNBLFVBQUlDLGNBQWMsR0FBbEI7QUFDQSxVQUFJTyxTQUFTN3NCLEVBQUUsSUFBRixDQUFiO0FBQ0EsVUFBSWd4QixjQUFjaHhCLEVBQUUsYUFBRixFQUFpQjhSLFFBQWpCLENBQTBCLHNCQUExQixDQUFsQjtBQUNBLFVBQUltZixnQkFBZ0IsQ0FBcEI7QUFDQSxVQUFJQyxpQkFBaUIsQ0FBckI7QUFDQSxVQUFJQyxnQkFBSjtBQUNBLFVBQUlDLFFBQUo7QUFDQSxVQUFJQyxxQkFBcUJ4RSxPQUFPdkUsSUFBUCxDQUFZLE9BQVosQ0FBekI7QUFDQXVFLGFBQU95RSxJQUFQLENBQVlOLFdBQVo7O0FBR0FuRSxhQUFPcEksRUFBUCxDQUFVLE9BQVYsRUFBbUIsWUFBVTtBQUMzQixZQUFJdU0sY0FBY25FLE9BQU8vQixNQUFQLENBQWMsdUJBQWQsQ0FBbEI7QUFDQSxZQUFJeUcsY0FBY3R0QixPQUFPb1EsVUFBekI7QUFDQSxZQUFJZ1osZUFBZXBwQixPQUFPc1EsV0FBMUI7QUFDQSxZQUFJMGMsZ0JBQWdCcEUsT0FBT3VCLEtBQVAsRUFBcEI7QUFDQSxZQUFJOEMsaUJBQWlCckUsT0FBT25XLE1BQVAsRUFBckI7O0FBR0E7QUFDQSxZQUFJcWEsa0JBQWtCLEtBQXRCLEVBQTZCO0FBQzNCUztBQUNBLGlCQUFPLEtBQVA7QUFDRCxTQUhELE1BSUssSUFBSVYsaUJBQWlCQyxrQkFBZ0IsSUFBckMsRUFBMkM7QUFDOUNTO0FBQ0EsaUJBQU8sS0FBUDtBQUNEOztBQUdEO0FBQ0FULHdCQUFnQixLQUFoQjtBQUNBbEUsZUFBTy9hLFFBQVAsQ0FBZ0IsUUFBaEI7QUFDQWdmLHdCQUFnQixJQUFoQjs7QUFFQTtBQUNBRSxvQkFBWTVlLEdBQVosQ0FBZ0I7QUFDZGdjLGlCQUFPNEMsWUFBWSxDQUFaLEVBQWVwckIscUJBQWYsR0FBdUN3b0IsS0FEaEM7QUFFZDFYLGtCQUFRc2EsWUFBWSxDQUFaLEVBQWVwckIscUJBQWYsR0FBdUM4USxNQUZqQztBQUdkcFEsb0JBQVUsVUFISTtBQUlkVCxlQUFLLENBSlM7QUFLZEMsZ0JBQU07QUFMUSxTQUFoQjs7QUFRQTtBQUNBcXJCLDJCQUFtQnB1QixTQUFuQjtBQUNBcXVCLG1CQUFXSixZQUFZLENBQVosRUFBZXJpQixVQUExQjtBQUNBLFlBQUlvUSxRQUFRLENBQVo7QUFDQSxlQUFPcVMsYUFBYSxJQUFiLElBQXFCLENBQUNweEIsRUFBRW94QixRQUFGLEVBQVloRyxFQUFaLENBQWVwbEIsUUFBZixDQUE3QixFQUF1RDtBQUNyRCxjQUFJeXJCLE9BQU96eEIsRUFBRW94QixRQUFGLENBQVg7QUFDQSxjQUFJSyxLQUFLcmYsR0FBTCxDQUFTLFVBQVQsTUFBeUIsU0FBN0IsRUFBd0M7QUFDdENxZixpQkFBS3JmLEdBQUwsQ0FBUyxVQUFULEVBQXFCLFNBQXJCO0FBQ0EsZ0JBQUkrZSxxQkFBcUJwdUIsU0FBekIsRUFBb0M7QUFDbENvdUIsaUNBQW1CTSxJQUFuQjtBQUNELGFBRkQsTUFHSztBQUNITixpQ0FBbUJBLGlCQUFpQm5mLEdBQWpCLENBQXFCeWYsSUFBckIsQ0FBbkI7QUFDRDtBQUNGO0FBQ0RMLHFCQUFXQSxTQUFTemlCLFVBQXBCO0FBQ0Q7O0FBRUQ7QUFDQWtlLGVBQU96YSxHQUFQLENBQVc7QUFDVDlMLG9CQUFVLFVBREQ7QUFFVCxxQkFBVyxJQUZGO0FBR1QseUJBQWU7QUFITixTQUFYLEVBS0N6QixJQUxELENBS00sT0FMTixFQUtlb3NCLGFBTGYsRUFNQ3BzQixJQU5ELENBTU0sUUFOTixFQU1nQnFzQixjQU5oQjs7QUFRQTtBQUNBLFlBQUlRLFVBQVUxeEIsRUFBRSxzQ0FBRixFQUNYb1MsR0FEVyxDQUNQO0FBQ0gxQixtQkFBUztBQUROLFNBRE8sRUFJWDRmLEtBSlcsQ0FJTCxZQUFVO0FBQ2YsY0FBSVMsa0JBQWtCLElBQXRCLEVBQ0FTO0FBQ0QsU0FQVyxDQUFkOztBQVNBO0FBQ0EzRSxlQUFPOEUsTUFBUCxDQUFjRCxPQUFkOztBQUVBO0FBQ0EsWUFBSUUsZ0JBQWdCRixRQUFRLENBQVIsRUFBVzlyQixxQkFBWCxFQUFwQjtBQUNBOHJCLGdCQUFRdGYsR0FBUixDQUFZO0FBQ1ZnYyxpQkFBT21ELFdBREc7QUFFVjdhLGtCQUFRMlcsWUFGRTtBQUdWdm5CLGdCQUFNLENBQUMsQ0FBRCxHQUFLOHJCLGNBQWM5ckIsSUFIZjtBQUlWRCxlQUFLLENBQUMsQ0FBRCxHQUFLK3JCLGNBQWMvckI7QUFKZCxTQUFaOztBQU9BO0FBQ0E2ckIsZ0JBQVE3a0IsUUFBUixDQUFpQixFQUFDNkQsU0FBUyxDQUFWLEVBQWpCLEVBQ21CLEVBQUNySCxVQUFVZ2pCLFVBQVgsRUFBdUJqbkIsT0FBTyxLQUE5QixFQUFxQ2xGLFFBQVEsYUFBN0MsRUFEbkI7O0FBR0E7QUFDQSxZQUFJMnNCLE9BQU9ob0IsSUFBUCxDQUFZLFNBQVosTUFBMkIsRUFBL0IsRUFBbUM7QUFDakMsY0FBSWd0QixpQkFBaUI3eEIsRUFBRSx5Q0FBRixDQUFyQjtBQUNBNnhCLHlCQUFlQyxJQUFmLENBQW9CakYsT0FBT2hvQixJQUFQLENBQVksU0FBWixDQUFwQjtBQUNBN0UsWUFBRSxNQUFGLEVBQVVxd0IsTUFBVixDQUFpQndCLGNBQWpCO0FBQ0FBLHlCQUFlemYsR0FBZixDQUFtQixFQUFFLFdBQVcsUUFBYixFQUFuQjtBQUNBeWYseUJBQWVobEIsUUFBZixDQUF3QixFQUFDNkQsU0FBUyxDQUFWLEVBQXhCLEVBQXNDLEVBQUNySCxVQUFVZ2pCLFVBQVgsRUFBdUJqbkIsT0FBTyxLQUE5QixFQUFxQ2xGLFFBQVEsYUFBN0MsRUFBdEM7QUFDRDs7QUFFRDtBQUNBLFlBQUk2eEIsUUFBUSxDQUFaO0FBQ0EsWUFBSUMsZUFBZWYsZ0JBQWdCTSxXQUFuQztBQUNBLFlBQUlVLGdCQUFnQmYsaUJBQWlCN0QsWUFBckM7QUFDQSxZQUFJNkUsV0FBVyxDQUFmO0FBQ0EsWUFBSUMsWUFBWSxDQUFoQjs7QUFFQSxZQUFJSCxlQUFlQyxhQUFuQixFQUFrQztBQUNoQ0Ysa0JBQVFiLGlCQUFpQkQsYUFBekI7QUFDQWlCLHFCQUFXWCxjQUFjLEdBQXpCO0FBQ0FZLHNCQUFZWixjQUFjLEdBQWQsR0FBb0JRLEtBQWhDO0FBQ0QsU0FKRCxNQUtLO0FBQ0hBLGtCQUFRZCxnQkFBZ0JDLGNBQXhCO0FBQ0FnQixxQkFBWTdFLGVBQWUsR0FBaEIsR0FBdUIwRSxLQUFsQztBQUNBSSxzQkFBWTlFLGVBQWUsR0FBM0I7QUFDRDs7QUFFRDtBQUNBLFlBQUdSLE9BQU9oQyxRQUFQLENBQWdCLGdCQUFoQixDQUFILEVBQXNDO0FBQ3BDZ0MsaUJBQU9oZ0IsUUFBUCxDQUFnQixFQUFDLGFBQWFxbEIsUUFBZCxFQUF3QixTQUFTakIsYUFBakMsRUFBaEIsRUFBaUUsRUFBQzVuQixVQUFVLENBQVgsRUFBY2pFLE9BQU8sS0FBckI7QUFDL0RzRyxzQkFBVSxvQkFBVTtBQUNsQm1oQixxQkFBT3phLEdBQVAsQ0FBVyxFQUFDdE0sTUFBTSxDQUFQLEVBQVVELEtBQUssQ0FBZixFQUFYLEVBQ0NnSCxRQURELENBRUU7QUFDRTZKLHdCQUFReWIsU0FEVjtBQUVFL0QsdUJBQU84RCxRQUZUO0FBR0Vwc0Isc0JBQU05RixFQUFFZ0csUUFBRixFQUFZSSxVQUFaLEtBQTJCbXJCLGNBQVksQ0FBdkMsR0FBMkMxRSxPQUFPL0IsTUFBUCxDQUFjLHVCQUFkLEVBQXVDbmxCLE1BQXZDLEdBQWdERyxJQUEzRixHQUFrR29zQixXQUFTLENBSG5IO0FBSUVyc0IscUJBQUs3RixFQUFFZ0csUUFBRixFQUFZQyxTQUFaLEtBQTBCb25CLGVBQWEsQ0FBdkMsR0FBMkNSLE9BQU8vQixNQUFQLENBQWMsdUJBQWQsRUFBdUNubEIsTUFBdkMsR0FBZ0RFLEdBQTNGLEdBQWlHc3NCLFlBQVc7QUFKbkgsZUFGRixFQVFFO0FBQ0U5b0IsMEJBQVVnakIsVUFEWjtBQUVFam5CLHVCQUFPLEtBRlQ7QUFHRWxGLHdCQUFRLGFBSFY7QUFJRXdMLDBCQUFVLG9CQUFVO0FBQUNxbEIsa0NBQWdCLElBQWhCO0FBQXNCO0FBSjdDLGVBUkY7QUFlRCxhQWpCOEQsQ0FpQjdEO0FBakI2RCxXQUFqRSxFQURvQyxDQW1CaEM7QUFDTCxTQXBCRCxNQXFCSztBQUNIbEUsaUJBQU96YSxHQUFQLENBQVcsTUFBWCxFQUFtQixDQUFuQixFQUNDQSxHQURELENBQ0ssS0FETCxFQUNZLENBRFosRUFFQ3ZGLFFBRkQsQ0FHRTtBQUNFNkosb0JBQVF5YixTQURWO0FBRUUvRCxtQkFBTzhELFFBRlQ7QUFHRXBzQixrQkFBTTlGLEVBQUVnRyxRQUFGLEVBQVlJLFVBQVosS0FBMkJtckIsY0FBWSxDQUF2QyxHQUEyQzFFLE9BQU8vQixNQUFQLENBQWMsdUJBQWQsRUFBdUNubEIsTUFBdkMsR0FBZ0RHLElBQTNGLEdBQWtHb3NCLFdBQVMsQ0FIbkg7QUFJRXJzQixpQkFBSzdGLEVBQUVnRyxRQUFGLEVBQVlDLFNBQVosS0FBMEJvbkIsZUFBYSxDQUF2QyxHQUEyQ1IsT0FBTy9CLE1BQVAsQ0FBYyx1QkFBZCxFQUF1Q25sQixNQUF2QyxHQUFnREUsR0FBM0YsR0FBaUdzc0IsWUFBVztBQUpuSCxXQUhGLEVBU0U7QUFDRTlvQixzQkFBVWdqQixVQURaO0FBRUVqbkIsbUJBQU8sS0FGVDtBQUdFbEYsb0JBQVEsYUFIVjtBQUlFd0wsc0JBQVUsb0JBQVU7QUFBQ3FsQiw4QkFBZ0IsSUFBaEI7QUFBc0I7QUFKN0MsV0FURixFQURHLENBZ0JFO0FBQ047QUFFRixPQTFKRCxFQXRCMEIsQ0FnTHRCOzs7QUFHSjtBQUNBL3dCLFFBQUVpRSxNQUFGLEVBQVUwUSxNQUFWLENBQWlCLFlBQVc7QUFDMUIsWUFBSW1jLGFBQUosRUFBbUI7QUFDakJVO0FBQ0Q7QUFDRixPQUpEOztBQU1BO0FBQ0F4eEIsUUFBRWdHLFFBQUYsRUFBWW9zQixLQUFaLENBQWtCLFVBQVMzdUIsQ0FBVCxFQUFZOztBQUU1QixZQUFJQSxFQUFFOHNCLE9BQUYsS0FBYyxFQUFkLElBQW9CUSxrQkFBa0IsSUFBMUMsRUFBZ0Q7QUFBSTtBQUNsRCxjQUFJRCxhQUFKLEVBQW1CO0FBQ2pCVTtBQUNEO0FBQ0Y7QUFDRixPQVBEOztBQVVBO0FBQ0EsZUFBU0EsZ0JBQVQsR0FBNEI7O0FBRTFCVCx3QkFBZ0IsS0FBaEI7O0FBRUEsWUFBSUMsY0FBY25FLE9BQU8vQixNQUFQLENBQWMsdUJBQWQsQ0FBbEI7QUFDQSxZQUFJeUcsY0FBY3R0QixPQUFPb1EsVUFBekI7QUFDQSxZQUFJZ1osZUFBZXBwQixPQUFPc1EsV0FBMUI7QUFDQSxZQUFJMGMsZ0JBQWdCcEUsT0FBT2hvQixJQUFQLENBQVksT0FBWixDQUFwQjtBQUNBLFlBQUlxc0IsaUJBQWlCckUsT0FBT2hvQixJQUFQLENBQVksUUFBWixDQUFyQjs7QUFFQWdvQixlQUFPaGdCLFFBQVAsQ0FBZ0IsTUFBaEIsRUFBd0IsSUFBeEI7QUFDQTdNLFVBQUUsc0JBQUYsRUFBMEI2TSxRQUExQixDQUFtQyxNQUFuQyxFQUEyQyxJQUEzQztBQUNBN00sVUFBRSxzQkFBRixFQUEwQjZNLFFBQTFCLENBQW1DLE1BQW5DLEVBQTJDLElBQTNDOztBQUdBN00sVUFBRSxzQkFBRixFQUEwQjZNLFFBQTFCLENBQW1DLEVBQUM2RCxTQUFTLENBQVYsRUFBbkMsRUFBaUQ7QUFDL0NySCxvQkFBVWlqQixXQURxQyxFQUN4QjtBQUN2QmxuQixpQkFBTyxLQUZ3QyxFQUVqQ2xGLFFBQVEsYUFGeUI7QUFHL0N3TCxvQkFBVSxvQkFBVTtBQUNsQjtBQUNBb2xCLDRCQUFnQixLQUFoQjtBQUNBOXdCLGNBQUUsSUFBRixFQUFRa1MsTUFBUjtBQUNEO0FBUDhDLFNBQWpEOztBQVVBO0FBQ0EyYSxlQUFPaGdCLFFBQVAsQ0FDRTtBQUNFdWhCLGlCQUFPNkMsYUFEVDtBQUVFdmEsa0JBQVF3YSxjQUZWO0FBR0VwckIsZ0JBQU0sQ0FIUjtBQUlFRCxlQUFLO0FBSlAsU0FERixFQU9FO0FBQ0V3RCxvQkFBVWlqQixXQURaO0FBRUVsbkIsaUJBQU8sS0FGVCxFQUVnQmxGLFFBQVEsYUFGeEI7QUFHRXdMLG9CQUFVLG9CQUFXO0FBQ25Cc2xCLHdCQUFZNWUsR0FBWixDQUFnQjtBQUNkc0Usc0JBQVEsRUFETTtBQUVkMFgscUJBQU8sRUFGTztBQUdkOW5CLHdCQUFVLEVBSEk7QUFJZFQsbUJBQUssRUFKUztBQUtkQyxvQkFBTTtBQUxRLGFBQWhCOztBQVFBK21CLG1CQUFPd0YsVUFBUCxDQUFrQixPQUFsQjtBQUNBeEYsbUJBQU92RSxJQUFQLENBQVksT0FBWixFQUFxQitJLGtCQUFyQjs7QUFFQTtBQUNBeEUsbUJBQU9waEIsV0FBUCxDQUFtQixRQUFuQjtBQUNBc2xCLDRCQUFnQixJQUFoQjs7QUFFQTtBQUNBLGdCQUFJSSxnQkFBSixFQUFzQjtBQUNwQkEsK0JBQWlCL2UsR0FBakIsQ0FBcUIsVUFBckIsRUFBaUMsRUFBakM7QUFDRDtBQUNGO0FBdkJILFNBUEY7O0FBa0NBO0FBQ0FwUyxVQUFFLHNCQUFGLEVBQTBCNk0sUUFBMUIsQ0FBbUMsRUFBQzZELFNBQVMsQ0FBVixFQUFuQyxFQUFpRDtBQUMvQ3JILG9CQUFVaWpCLFdBRHFDLEVBQ3hCO0FBQ3ZCbG5CLGlCQUFPLEtBRndDLEVBRWpDbEYsUUFBUSxhQUZ5QjtBQUcvQ3dMLG9CQUFVLG9CQUFVO0FBQ2xCMUwsY0FBRSxJQUFGLEVBQVFrUyxNQUFSO0FBQ0Q7QUFMOEMsU0FBakQ7QUFRRDtBQUNGLEtBNVFNLENBQVA7QUE2UUQsR0EvUUQ7O0FBaVJBbFMsSUFBRWdHLFFBQUYsRUFBWWttQixLQUFaLENBQWtCLFlBQVU7QUFDMUJsc0IsTUFBRSxnQkFBRixFQUFvQjZ3QixXQUFwQjtBQUNELEdBRkQ7QUFJRCxDQXZSQyxFQXVSQzl3QixNQXZSRCxDQUFEO0FBd1JELENBQUUsV0FBVUMsQ0FBVixFQUFhOztBQUViQSxJQUFFK0QsRUFBRixDQUFLdXVCLFFBQUwsR0FBZ0IsWUFBWTtBQUMxQixRQUFJQyxlQUFldnlCLEVBQUVpRSxNQUFGLEVBQVVtcUIsS0FBVixFQUFuQjtBQUNBO0FBQ0EsV0FBTyxLQUFLenBCLElBQUwsQ0FBVSxVQUFTUixDQUFULEVBQVk7QUFDM0IsVUFBSW9tQixRQUFRdnFCLEVBQUUsSUFBRixDQUFaO0FBQ0F1cUIsWUFBTXpZLFFBQU4sQ0FBZSxVQUFmOztBQUVBLGVBQVMwZ0IsY0FBVCxDQUF3QkMsT0FBeEIsRUFBaUM7QUFDL0IsWUFBSUMsZ0JBQUo7QUFDQSxZQUFJSCxlQUFlLEdBQW5CLEVBQXdCO0FBQ3RCRyw2QkFBb0JuSSxNQUFNN1QsTUFBTixLQUFpQixDQUFsQixHQUF1QjZULE1BQU03VCxNQUFOLEVBQXZCLEdBQXdDNlQsTUFBTVksUUFBTixDQUFlLEtBQWYsRUFBc0J6VSxNQUF0QixFQUEzRDtBQUNELFNBRkQsTUFHSztBQUNIZ2MsNkJBQW9CbkksTUFBTTdULE1BQU4sS0FBaUIsQ0FBbEIsR0FBdUI2VCxNQUFNN1QsTUFBTixFQUF2QixHQUF3QyxHQUEzRDtBQUNEO0FBQ0QsWUFBSWljLE9BQU9wSSxNQUFNWSxRQUFOLENBQWUsS0FBZixFQUFzQmMsS0FBdEIsRUFBWDtBQUNBLFlBQUkyRyxhQUFhRCxLQUFLamMsTUFBTCxFQUFqQjtBQUNBLFlBQUltYyxnQkFBZ0JELGFBQWFGLGdCQUFqQztBQUNBLFlBQUk1QyxTQUFTdkYsTUFBTTVrQixNQUFOLEdBQWVFLEdBQWYsR0FBcUI2c0IsZ0JBQWxDO0FBQ0EsWUFBSTdzQixNQUFNMGtCLE1BQU01a0IsTUFBTixHQUFlRSxHQUF6QjtBQUNBLFlBQUlJLFlBQVlqRyxFQUFFaUUsTUFBRixFQUFVZ0MsU0FBVixFQUFoQjtBQUNBLFlBQUlvbkIsZUFBZXBwQixPQUFPc1EsV0FBMUI7QUFDQSxZQUFJdWUsZUFBZTdzQixZQUFZb25CLFlBQS9CO0FBQ0EsWUFBSTBGLGtCQUFrQixDQUFDRCxlQUFlanRCLEdBQWhCLEtBQXdCNnNCLG1CQUFtQnJGLFlBQTNDLENBQXRCO0FBQ0EsWUFBSWlGLFdBQVc5d0IsS0FBS3NHLEtBQUwsQ0FBWStxQixnQkFBZ0JFLGVBQTVCLENBQWY7O0FBRUEsWUFBSU4sT0FBSixFQUFhO0FBQ1hFLGVBQUt2Z0IsR0FBTCxDQUFTLFNBQVQsRUFBb0IsT0FBcEI7QUFDRDtBQUNELFlBQUswZCxTQUFTN3BCLFNBQVYsSUFBeUJKLE1BQU9JLFlBQVlvbkIsWUFBaEQsRUFBZ0U7QUFDOURzRixlQUFLdmdCLEdBQUwsQ0FBUyxXQUFULEVBQXNCLHNCQUFzQmtnQixRQUF0QixHQUFpQyxRQUF2RDtBQUNEO0FBRUY7O0FBRUQ7QUFDQS9ILFlBQU1ZLFFBQU4sQ0FBZSxLQUFmLEVBQXNCNkgsR0FBdEIsQ0FBMEIsTUFBMUIsRUFBa0MsWUFBVztBQUMzQ1IsdUJBQWUsSUFBZjtBQUNELE9BRkQsRUFFRzd0QixJQUZILENBRVEsWUFBVztBQUNqQixZQUFJLEtBQUsrRyxRQUFULEVBQW1CMUwsRUFBRSxJQUFGLEVBQVEwbkIsT0FBUixDQUFnQixNQUFoQjtBQUNwQixPQUpEOztBQU1BMW5CLFFBQUVpRSxNQUFGLEVBQVUwUSxNQUFWLENBQWlCLFlBQVc7QUFDMUI0ZCx1QkFBZXZ5QixFQUFFaUUsTUFBRixFQUFVbXFCLEtBQVYsRUFBZjtBQUNBb0UsdUJBQWUsS0FBZjtBQUNELE9BSEQ7O0FBS0F4eUIsUUFBRWlFLE1BQUYsRUFBVWd2QixNQUFWLENBQWlCLFlBQVc7QUFDMUJWLHVCQUFldnlCLEVBQUVpRSxNQUFGLEVBQVVtcUIsS0FBVixFQUFmO0FBQ0FvRSx1QkFBZSxLQUFmO0FBQ0QsT0FIRDtBQUtELEtBakRNLENBQVA7QUFtREQsR0F0REQ7QUF1REQsQ0F6REMsRUF5REN6eUIsTUF6REQsQ0FBRDtBQTBERCxDQUFFLFdBQVVDLENBQVYsRUFBYTs7QUFFYixNQUFJbXZCLFVBQVU7QUFDWm5yQixVQUFPLGNBQVNnUyxPQUFULEVBQWtCO0FBQ3ZCLFVBQUk5TSxXQUFXO0FBQ2JncUIsZ0JBQVEsSUFESztBQUViQyxtQkFBVyxLQUZFO0FBR2JDLDZCQUFxQkMsUUFIUixDQUdrQjtBQUhsQixPQUFmO0FBS0FyZCxnQkFBVWhXLEVBQUVHLE1BQUYsQ0FBUytJLFFBQVQsRUFBbUI4TSxPQUFuQixDQUFWO0FBQ0EsVUFBSXNkLFlBQVkxTCxZQUFZSyxvQkFBWixDQUFpQ2pvQixFQUFFLElBQUYsQ0FBakMsQ0FBaEI7O0FBRUEsYUFBTyxLQUFLMkUsSUFBTCxDQUFVLFVBQVNSLENBQVQsRUFBWTs7QUFFN0IsWUFBSW92QixrQkFBa0JELFlBQVVudkIsQ0FBaEM7O0FBRUE7QUFDQTtBQUNBLFlBQUlvbUIsUUFBUXZxQixFQUFFLElBQUYsQ0FBWjtBQUFBLFlBQ0l1eUIsZUFBZXZ5QixFQUFFaUUsTUFBRixFQUFVbXFCLEtBQVYsRUFEbkI7O0FBR0EsWUFBSW9GLE9BQUo7QUFBQSxZQUFhQyxRQUFiO0FBQUEsWUFBdUJDLFNBQVNuSixNQUFNRSxJQUFOLENBQVcsVUFBWCxDQUFoQztBQUFBLFlBQ0lrSixjQUFjcEosTUFBTTZELEtBQU4sRUFEbEI7QUFBQSxZQUVJd0YsZ0JBQWdCNXpCLEdBRnBCO0FBQUEsWUFHSTZ6QixhQUhKO0FBQUEsWUFJSUMsYUFBYXR5QixLQUFLa0gsR0FBTCxDQUFTaXJCLFdBQVQsRUFBc0JwSixNQUFNLENBQU4sRUFBUzJELFdBQS9CLElBQThDd0YsT0FBT2h3QixNQUp0RTtBQUFBLFlBS0lxd0IsVUFMSjtBQUFBLFlBTUlDLFFBQVFDLGFBQWEsQ0FOekI7QUFBQSxZQU9JQyxVQUFVLEtBUGQ7QUFBQSxZQVFJQyxjQVJKO0FBQUEsWUFTSUMsYUFBYSxHQVRqQjs7QUFZQTtBQUNBO0FBQ0EsWUFBSUMsZUFBZSxTQUFmQSxZQUFlLENBQVMvTSxFQUFULEVBQWE7QUFDOUIsaUJBQU85bEIsS0FBSzh5QixJQUFMLENBQVVYLGNBQWNyTSxHQUFHaGhCLFFBQUgsR0FBY1IsSUFBNUIsR0FBbUN3aEIsR0FBRzhGLFVBQUgsRUFBbkMsR0FBcUQ3QyxNQUFNbmtCLFVBQU4sRUFBL0QsQ0FBUDtBQUNELFNBRkQ7O0FBSUE7QUFDQTtBQUNBLFlBQUltdUIsY0FBYyxTQUFkQSxXQUFjLENBQVNqTixFQUFULEVBQWE7QUFDN0IsaUJBQU85bEIsS0FBS2tuQixLQUFMLENBQVdwQixHQUFHaGhCLFFBQUgsR0FBY1IsSUFBZCxHQUFxQnlrQixNQUFNbmtCLFVBQU4sRUFBaEMsQ0FBUDtBQUNELFNBRkQ7O0FBSUE7QUFDQTtBQUNBLFlBQUlvdUIsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBU1AsVUFBVCxFQUFxQjtBQUMxQyxjQUFLRCxRQUFRQyxVQUFULElBQXdCLENBQTVCLEVBQStCO0FBQzdCRix1QkFBV2xuQixRQUFYLENBQW9CLEVBQUMsU0FBU3duQixhQUFhYixPQUFiLENBQVYsRUFBcEIsRUFBdUQsRUFBRW5xQixVQUFVK3FCLFVBQVosRUFBd0JodkIsT0FBTyxLQUEvQixFQUFzQ2xGLFFBQVEsYUFBOUMsRUFBdkQ7QUFDQTZ6Qix1QkFBV2xuQixRQUFYLENBQW9CLEVBQUMsUUFBUTBuQixZQUFZZixPQUFaLENBQVQsRUFBcEIsRUFBcUQsRUFBQ25xQixVQUFVK3FCLFVBQVgsRUFBdUJodkIsT0FBTyxLQUE5QixFQUFxQ2xGLFFBQVEsYUFBN0MsRUFBNEQyTCxPQUFPLEVBQW5FLEVBQXJEO0FBRUQsV0FKRCxNQUlPO0FBQ0xrb0IsdUJBQVdsbkIsUUFBWCxDQUFvQixFQUFDLFFBQVEwbkIsWUFBWWYsT0FBWixDQUFULEVBQXBCLEVBQXFELEVBQUVucUIsVUFBVStxQixVQUFaLEVBQXdCaHZCLE9BQU8sS0FBL0IsRUFBc0NsRixRQUFRLGFBQTlDLEVBQXJEO0FBQ0E2ekIsdUJBQVdsbkIsUUFBWCxDQUFvQixFQUFDLFNBQVN3bkIsYUFBYWIsT0FBYixDQUFWLEVBQXBCLEVBQXVELEVBQUNucUIsVUFBVStxQixVQUFYLEVBQXVCaHZCLE9BQU8sS0FBOUIsRUFBcUNsRixRQUFRLGFBQTdDLEVBQTREMkwsT0FBTyxFQUFuRSxFQUF2RDtBQUNEO0FBQ0YsU0FURDs7QUFXQTtBQUNBLFlBQUltSyxRQUFRbWQsU0FBWixFQUF1QjtBQUNyQixjQUFJWixlQUFldmMsUUFBUW9kLG1CQUEzQixFQUFnRDtBQUM5Q3BkLG9CQUFRbWQsU0FBUixHQUFvQixLQUFwQjtBQUNEO0FBQ0Y7O0FBR0Q7QUFDQUssa0JBQVV4ekIsRUFBRTB6QixPQUFPalgsTUFBUCxDQUFjLFlBQVVnWSxTQUFTM0wsSUFBbkIsR0FBd0IsSUFBdEMsQ0FBRixDQUFWOztBQUVBO0FBQ0EsWUFBSTBLLFFBQVE5dkIsTUFBUixLQUFtQixDQUF2QixFQUEwQjtBQUN4Qjh2QixvQkFBVXh6QixFQUFFLElBQUYsRUFBUXlxQixJQUFSLENBQWEsaUJBQWIsRUFBZ0N3QixLQUFoQyxFQUFWO0FBQ0Q7QUFDRCxZQUFJdUgsUUFBUTl2QixNQUFSLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3hCOHZCLG9CQUFVeHpCLEVBQUUsSUFBRixFQUFReXFCLElBQVIsQ0FBYSxVQUFiLEVBQXlCd0IsS0FBekIsRUFBVjtBQUNEOztBQUVEdUgsZ0JBQVExaEIsUUFBUixDQUFpQixRQUFqQjtBQUNBa2lCLGdCQUFRTixPQUFPTSxLQUFQLENBQWFSLE9BQWIsQ0FBUjtBQUNBLFlBQUlRLFFBQVEsQ0FBWixFQUFlO0FBQ2JBLGtCQUFRLENBQVI7QUFDRDs7QUFFRCxZQUFJUixRQUFRLENBQVIsTUFBZXp3QixTQUFuQixFQUE4QjtBQUM1QjB3QixxQkFBV3p6QixFQUFFd3pCLFFBQVEsQ0FBUixFQUFXMUssSUFBYixDQUFYO0FBQ0EySyxtQkFBUzNoQixRQUFULENBQWtCLFFBQWxCO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFJLENBQUN5WSxNQUFNRSxJQUFOLENBQVcsWUFBWCxFQUF5Qi9tQixNQUE5QixFQUFzQztBQUNwQzZtQixnQkFBTThGLE1BQU4sQ0FBYSwrQkFBYjtBQUNEO0FBQ0QwRCxxQkFBYXhKLE1BQU1FLElBQU4sQ0FBVyxZQUFYLENBQWI7O0FBRUE7QUFDQUYsY0FBTThGLE1BQU4sQ0FBYTBELFVBQWI7O0FBRUEsWUFBSXhKLE1BQU1hLEVBQU4sQ0FBUyxVQUFULENBQUosRUFBMEI7QUFDeEI7QUFDQTtBQUNBemYscUJBQVcsWUFBVztBQUNwQm9vQix1QkFBVzNoQixHQUFYLENBQWUsRUFBQyxTQUFTaWlCLGFBQWFiLE9BQWIsQ0FBVixFQUFmO0FBQ0FPLHVCQUFXM2hCLEdBQVgsQ0FBZSxFQUFDLFFBQVFtaUIsWUFBWWYsT0FBWixDQUFULEVBQWY7QUFDRCxXQUhELEVBR0csQ0FISDtBQUlEO0FBQ0R4ekIsVUFBRWlFLE1BQUYsRUFBVXlnQixHQUFWLENBQWMsaUJBQWU2TyxlQUE3QixFQUE4QzlPLEVBQTlDLENBQWlELGlCQUFlOE8sZUFBaEUsRUFBaUYsWUFBWTtBQUMzRkksd0JBQWNwSixNQUFNNkQsS0FBTixFQUFkO0FBQ0EwRix1QkFBYXR5QixLQUFLa0gsR0FBTCxDQUFTaXJCLFdBQVQsRUFBc0JwSixNQUFNLENBQU4sRUFBUzJELFdBQS9CLElBQThDd0YsT0FBT2h3QixNQUFsRTtBQUNBLGNBQUlzd0IsUUFBUSxDQUFaLEVBQWU7QUFDYkEsb0JBQVEsQ0FBUjtBQUNEO0FBQ0QsY0FBSUYsZUFBZSxDQUFmLElBQW9CSCxnQkFBZ0IsQ0FBeEMsRUFBMkM7QUFDekNJLHVCQUFXM2hCLEdBQVgsQ0FBZSxFQUFDLFNBQVNpaUIsYUFBYWIsT0FBYixDQUFWLEVBQWY7QUFDQU8sdUJBQVczaEIsR0FBWCxDQUFlLEVBQUMsUUFBUW1pQixZQUFZZixPQUFaLENBQVQsRUFBZjtBQUNEO0FBQ0YsU0FWRDs7QUFZQTtBQUNBLFlBQUl4ZCxRQUFRbWQsU0FBWixFQUF1QjtBQUNyQjtBQUNBTyxpQkFBTy91QixJQUFQLENBQVksWUFBWTtBQUN0QixnQkFBSSt2QixnQkFBZ0IxMEIsRUFBRTRuQixZQUFZaUIsVUFBWixDQUF1QixLQUFLQyxJQUE1QixDQUFGLENBQXBCO0FBQ0E0TCwwQkFBYzVpQixRQUFkLENBQXVCLGVBQXZCO0FBQ0E4aEIsNEJBQWdCQSxjQUFjNWhCLEdBQWQsQ0FBa0IwaUIsYUFBbEIsQ0FBaEI7QUFDRCxXQUpEO0FBS0FiLDBCQUFnQkQsY0FBY2UsT0FBZCxDQUFzQiwyQ0FBdEIsQ0FBaEI7QUFDQWYsd0JBQWN4aEIsR0FBZCxDQUFrQixTQUFsQixFQUE2QixFQUE3QjtBQUNBcFMsWUFBRSx3QkFBRixFQUE0QjQwQixRQUE1QixDQUFxQztBQUNuQ0MsdUJBQVcsSUFEd0I7QUFFbkNDLG9CQUFRLElBRjJCO0FBR25DQyx1QkFBVyxtQkFBU0MsSUFBVCxFQUFlO0FBQ3hCLGtCQUFJLENBQUNkLE9BQUwsRUFBYztBQUNaLG9CQUFJRCxhQUFhRCxLQUFqQjtBQUNBQSx3QkFBUUgsY0FBY0csS0FBZCxDQUFvQmdCLElBQXBCLENBQVI7QUFDQXhCLDBCQUFVRSxPQUFPMUgsRUFBUCxDQUFVZ0ksS0FBVixDQUFWO0FBQ0FRLGlDQUFpQlAsVUFBakI7QUFDRDtBQUNGO0FBVmtDLFdBQXJDO0FBWUQsU0FyQkQsTUFxQk87QUFDTDtBQUNBUCxpQkFBT3hJLEdBQVAsQ0FBV3NJLE9BQVgsRUFBb0I3dUIsSUFBcEIsQ0FBeUIsWUFBWTtBQUNuQzNFLGNBQUU0bkIsWUFBWWlCLFVBQVosQ0FBdUIsS0FBS0MsSUFBNUIsQ0FBRixFQUFxQ21NLElBQXJDO0FBQ0QsV0FGRDtBQUdEOztBQUdEO0FBQ0ExSyxjQUFNN0YsR0FBTixDQUFVLFlBQVYsRUFBd0JELEVBQXhCLENBQTJCLFlBQTNCLEVBQXlDLEdBQXpDLEVBQThDLFVBQVNoaEIsQ0FBVCxFQUFZO0FBQ3hELGNBQUl6RCxFQUFFLElBQUYsRUFBUThxQixNQUFSLEdBQWlCRCxRQUFqQixDQUEwQixVQUExQixDQUFKLEVBQTJDO0FBQ3pDcG5CLGNBQUU2ZSxjQUFGO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLGNBQUksQ0FBQyxDQUFDdGlCLEVBQUUsSUFBRixFQUFRc29CLElBQVIsQ0FBYSxRQUFiLENBQU4sRUFBOEI7QUFDNUI7QUFDRDs7QUFFRDRMLG9CQUFVLElBQVY7QUFDQVAsd0JBQWNwSixNQUFNNkQsS0FBTixFQUFkO0FBQ0EwRix1QkFBYXR5QixLQUFLa0gsR0FBTCxDQUFTaXJCLFdBQVQsRUFBc0JwSixNQUFNLENBQU4sRUFBUzJELFdBQS9CLElBQThDd0YsT0FBT2h3QixNQUFsRTs7QUFFQTtBQUNBOHZCLGtCQUFRL25CLFdBQVIsQ0FBb0IsUUFBcEI7QUFDQSxjQUFJeXBCLGNBQWN6QixRQUFsQjs7QUFFQTtBQUNBRCxvQkFBVXh6QixFQUFFLElBQUYsQ0FBVjtBQUNBeXpCLHFCQUFXenpCLEVBQUU0bkIsWUFBWWlCLFVBQVosQ0FBdUIsS0FBS0MsSUFBNUIsQ0FBRixDQUFYO0FBQ0E0SyxtQkFBU25KLE1BQU1FLElBQU4sQ0FBVyxVQUFYLENBQVQ7QUFDQSxjQUFJMEssYUFBYTNCLFFBQVFsdEIsUUFBUixFQUFqQjs7QUFFQTtBQUNBa3RCLGtCQUFRMWhCLFFBQVIsQ0FBaUIsUUFBakI7QUFDQW1pQix1QkFBYUQsS0FBYjtBQUNBQSxrQkFBUU4sT0FBT00sS0FBUCxDQUFhaDBCLEVBQUUsSUFBRixDQUFiLENBQVI7QUFDQSxjQUFJZzBCLFFBQVEsQ0FBWixFQUFlO0FBQ2JBLG9CQUFRLENBQVI7QUFDRDtBQUNEO0FBQ0E7O0FBRUE7QUFDQSxjQUFJaGUsUUFBUW1kLFNBQVosRUFBdUI7QUFDckIsZ0JBQUlTLGNBQWNsd0IsTUFBbEIsRUFBMEI7QUFDeEJrd0IsNEJBQWNnQixRQUFkLENBQXVCLEtBQXZCLEVBQThCWixLQUE5QjtBQUNEO0FBQ0YsV0FKRCxNQUlPO0FBQ0wsZ0JBQUlQLGFBQWExd0IsU0FBakIsRUFBNEI7QUFDMUIwd0IsdUJBQVMyQixJQUFUO0FBQ0EzQix1QkFBUzNoQixRQUFULENBQWtCLFFBQWxCO0FBQ0Esa0JBQUksT0FBT2tFLFFBQVFrZCxNQUFmLEtBQTJCLFVBQS9CLEVBQTJDO0FBQ3pDbGQsd0JBQVFrZCxNQUFSLENBQWU5dUIsSUFBZixDQUFvQixJQUFwQixFQUEwQnF2QixRQUExQjtBQUNEO0FBQ0Y7O0FBRUQsZ0JBQUl5QixnQkFBZ0JueUIsU0FBaEIsSUFDQSxDQUFDbXlCLFlBQVk5SixFQUFaLENBQWVxSSxRQUFmLENBREwsRUFDK0I7QUFDN0J5QiwwQkFBWUQsSUFBWjtBQUNBQywwQkFBWXpwQixXQUFaLENBQXdCLFFBQXhCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBMG9CLDJCQUFpQnhvQixXQUFXLFlBQVU7QUFBRXVvQixzQkFBVSxLQUFWO0FBQWtCLFdBQXpDLEVBQTJDRSxVQUEzQyxDQUFqQjs7QUFFQTtBQUNBSSwyQkFBaUJQLFVBQWpCOztBQUVBO0FBQ0F4d0IsWUFBRTZlLGNBQUY7QUFDRCxTQWhFRDtBQWlFRCxPQXpNUSxDQUFQO0FBMk1ELEtBck5XO0FBc05aK1MsZ0JBQWEsb0JBQVVoWSxFQUFWLEVBQWU7QUFDMUIsV0FBS29OLElBQUwsQ0FBVSxjQUFjcE4sRUFBZCxHQUFtQixJQUE3QixFQUFtQ3FLLE9BQW5DLENBQTJDLE9BQTNDO0FBQ0Q7QUF4TlcsR0FBZDs7QUEyTkExbkIsSUFBRStELEVBQUYsQ0FBS3V4QixJQUFMLEdBQVksVUFBUzNFLGVBQVQsRUFBMEI7QUFDcEMsUUFBS3hCLFFBQVF3QixlQUFSLENBQUwsRUFBZ0M7QUFDOUIsYUFBT3hCLFFBQVN3QixlQUFULEVBQTJCL3JCLEtBQTNCLENBQWtDLElBQWxDLEVBQXdDTixNQUFNSSxTQUFOLENBQWdCaUQsS0FBaEIsQ0FBc0J2RCxJQUF0QixDQUE0QmEsU0FBNUIsRUFBdUMsQ0FBdkMsQ0FBeEMsQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFLLFFBQU8wckIsZUFBUCx5Q0FBT0EsZUFBUCxPQUEyQixRQUEzQixJQUF1QyxDQUFFQSxlQUE5QyxFQUFnRTtBQUNyRTtBQUNBLGFBQU94QixRQUFRbnJCLElBQVIsQ0FBYVksS0FBYixDQUFvQixJQUFwQixFQUEwQkssU0FBMUIsQ0FBUDtBQUNELEtBSE0sTUFHQTtBQUNMakYsUUFBRTR3QixLQUFGLENBQVMsWUFBYUQsZUFBYixHQUErQixnQ0FBeEM7QUFDRDtBQUNGLEdBVEQ7O0FBV0Ezd0IsSUFBRWdHLFFBQUYsRUFBWWttQixLQUFaLENBQWtCLFlBQVU7QUFDMUJsc0IsTUFBRSxTQUFGLEVBQWFzMUIsSUFBYjtBQUNELEdBRkQ7QUFHRCxDQTNPQyxFQTJPQ3YxQixNQTNPRCxDQUFEO0FBNE9ELENBQUUsV0FBVUMsQ0FBVixFQUFhO0FBQ1hBLElBQUUrRCxFQUFGLENBQUt3eEIsT0FBTCxHQUFlLFVBQVV2ZixPQUFWLEVBQW1CO0FBQ2hDLFFBQUkwVCxVQUFVLElBQWQ7QUFBQSxRQUNBOEwsU0FBUyxDQURUOztBQUdBO0FBQ0EsUUFBSXRzQixXQUFXO0FBQ2IyQyxhQUFPLEdBRE07QUFFYjBwQixlQUFTLEVBRkk7QUFHYmp2QixnQkFBVSxRQUhHO0FBSWJtdkIsWUFBTTtBQUpPLEtBQWY7O0FBT0E7QUFDQSxRQUFJemYsWUFBWSxRQUFoQixFQUEwQjtBQUN4QixXQUFLclIsSUFBTCxDQUFVLFlBQVc7QUFDbkIzRSxVQUFFLE1BQU1BLEVBQUUsSUFBRixFQUFRc29CLElBQVIsQ0FBYSxpQkFBYixDQUFSLEVBQXlDcFcsTUFBekM7QUFDQWxTLFVBQUUsSUFBRixFQUFRMGtCLEdBQVIsQ0FBWSx1Q0FBWjtBQUNELE9BSEQ7QUFJQSxhQUFPLEtBQVA7QUFDRDs7QUFFRDFPLGNBQVVoVyxFQUFFRyxNQUFGLENBQVMrSSxRQUFULEVBQW1COE0sT0FBbkIsQ0FBVjs7QUFFQSxXQUFPLEtBQUtyUixJQUFMLENBQVUsWUFBVztBQUMxQixVQUFJK3dCLFlBQVk5TixZQUFZWSxJQUFaLEVBQWhCO0FBQ0EsVUFBSXFFLFNBQVM3c0IsRUFBRSxJQUFGLENBQWI7O0FBRUE7QUFDQSxVQUFJNnNCLE9BQU92RSxJQUFQLENBQVksaUJBQVosQ0FBSixFQUFvQztBQUNsQ3RvQixVQUFFLE1BQU02c0IsT0FBT3ZFLElBQVAsQ0FBWSxpQkFBWixDQUFSLEVBQXdDcFcsTUFBeEM7QUFDRDs7QUFFRDJhLGFBQU92RSxJQUFQLENBQVksaUJBQVosRUFBK0JvTixTQUEvQjs7QUFFQTtBQUNBLFVBQUlDLFNBQUosRUFDSUMsWUFESixFQUVJQyxlQUZKLEVBR0lDLFdBSEosRUFJSUMsU0FKSixFQUtJQyxRQUxKO0FBTUEsVUFBSUMsZ0JBQWdCLFNBQWhCQSxhQUFnQixHQUFXO0FBQzdCTixvQkFBWTlJLE9BQU92RSxJQUFQLENBQVksV0FBWixJQUEyQnVFLE9BQU92RSxJQUFQLENBQVksV0FBWixNQUE2QixNQUF4RCxHQUFpRXRTLFFBQVF5ZixJQUFyRjtBQUNBRyx1QkFBZS9JLE9BQU92RSxJQUFQLENBQVksWUFBWixDQUFmO0FBQ0FzTix1QkFBZ0JBLGlCQUFpQjd5QixTQUFqQixJQUE4QjZ5QixpQkFBaUIsRUFBaEQsR0FDWDVmLFFBQVFuSyxLQURHLEdBQ0srcEIsWUFEcEI7QUFFQUMsMEJBQWtCaEosT0FBT3ZFLElBQVAsQ0FBWSxlQUFaLENBQWxCO0FBQ0F1TiwwQkFBbUJBLG9CQUFvQjl5QixTQUFwQixJQUFpQzh5QixvQkFBb0IsRUFBdEQsR0FDZDdmLFFBQVExUCxRQURNLEdBQ0t1dkIsZUFEdkI7QUFFQUMsc0JBQWNqSixPQUFPdkUsSUFBUCxDQUFZLGNBQVosQ0FBZDtBQUNBd04sc0JBQWVBLGdCQUFnQi95QixTQUFoQixJQUE2Qit5QixnQkFBZ0IsRUFBOUMsR0FDVjlmLFFBQVF1ZixPQURFLEdBQ1FPLFdBRHRCO0FBRUQsT0FYRDtBQVlBRzs7QUFFQSxVQUFJQyxrQkFBa0IsU0FBbEJBLGVBQWtCLEdBQVc7QUFDL0IsWUFBSVgsVUFBVXYxQixFQUFFLHNDQUFGLENBQWQ7O0FBRUE7QUFDQSxZQUFJMjFCLFNBQUosRUFBZTtBQUNiRyx3QkFBYzkxQixFQUFFLGVBQUYsRUFBbUJ5MUIsSUFBbkIsQ0FBd0JLLFdBQXhCLENBQWQ7QUFDRCxTQUZELE1BRU07QUFDSkEsd0JBQWM5MUIsRUFBRSxlQUFGLEVBQW1COHhCLElBQW5CLENBQXdCZ0UsV0FBeEIsQ0FBZDtBQUNEOztBQUVEO0FBQ0FQLGdCQUFRbEYsTUFBUixDQUFleUYsV0FBZixFQUNHSyxRQURILENBQ1luMkIsRUFBRSxNQUFGLENBRFosRUFFR3NvQixJQUZILENBRVEsSUFGUixFQUVjb04sU0FGZDs7QUFJQTtBQUNBTSxtQkFBV2gyQixFQUFFLDhCQUFGLENBQVg7QUFDQWcyQixpQkFBU0csUUFBVCxDQUFrQlosT0FBbEI7QUFDQSxlQUFPQSxPQUFQO0FBQ0QsT0FuQkQ7QUFvQkFRLGtCQUFZRyxpQkFBWjs7QUFFQTtBQUNBckosYUFBT25JLEdBQVAsQ0FBVyx1Q0FBWDtBQUNBO0FBQ0EsVUFBSXpJLFVBQVUsS0FBZDtBQUFBLFVBQXFCbWEsVUFBckI7QUFDQXZKLGFBQU9wSSxFQUFQLENBQVUsRUFBQyxzQkFBc0IsMkJBQVNoaEIsQ0FBVCxFQUFZO0FBQzNDLGNBQUk0eUIsY0FBYyxTQUFkQSxXQUFjLEdBQVc7QUFDM0JKO0FBQ0FoYSxzQkFBVSxJQUFWO0FBQ0E4WixzQkFBVWxwQixRQUFWLENBQW1CLE1BQW5CO0FBQ0FtcEIscUJBQVNucEIsUUFBVCxDQUFrQixNQUFsQjtBQUNBa3BCLHNCQUFVM2pCLEdBQVYsQ0FBYyxFQUFFM0ksWUFBWSxTQUFkLEVBQXlCM0QsTUFBTSxLQUEvQixFQUFzQ0QsS0FBSyxLQUEzQyxFQUFkOztBQUVBO0FBQ0EsZ0JBQUl5d0IsY0FBY3pKLE9BQU9PLFVBQVAsRUFBbEI7QUFDQSxnQkFBSUUsZUFBZVQsT0FBTzBKLFdBQVAsRUFBbkI7QUFDQSxnQkFBSUMsZ0JBQWdCVCxVQUFVUSxXQUFWLEVBQXBCO0FBQ0EsZ0JBQUlFLGVBQWVWLFVBQVUzSSxVQUFWLEVBQW5CO0FBQ0EsZ0JBQUlzSiwwQkFBMEIsS0FBOUI7QUFDQSxnQkFBSUMsNEJBQTRCLEtBQWhDO0FBQ0EsZ0JBQUlDLHNCQUFzQlosU0FBUyxDQUFULEVBQVkxakIsV0FBdEM7QUFDQSxnQkFBSXVrQix1QkFBdUJiLFNBQVMsQ0FBVCxFQUFZM2pCLFlBQXZDO0FBQ0EsZ0JBQUl5a0IsZUFBZSxDQUFuQjtBQUNBLGdCQUFJQyxlQUFlLENBQW5CO0FBQ0EsZ0JBQUlDLGNBQWMsQ0FBbEI7QUFDQSxnQkFBSUMsU0FBSixFQUFlQyxVQUFmLEVBQTJCQyxjQUEzQjs7QUFFQSxnQkFBSXRCLG9CQUFvQixLQUF4QixFQUErQjtBQUM3QjtBQUNBb0IsMEJBQVlwSyxPQUFPbG5CLE1BQVAsR0FBZ0JFLEdBQWhCLEdBQXNCMndCLGFBQXRCLEdBQXNDaEIsTUFBbEQ7QUFDQTBCLDJCQUFhckssT0FBT2xuQixNQUFQLEdBQWdCRyxJQUFoQixHQUF1Qnd3QixjQUFZLENBQW5DLEdBQXVDRyxlQUFhLENBQWpFO0FBQ0FVLCtCQUFpQkMsdUJBQXVCRixVQUF2QixFQUFtQ0QsU0FBbkMsRUFBOENSLFlBQTlDLEVBQTRERCxhQUE1RCxDQUFqQjtBQUNBRSx3Q0FBMEIsT0FBMUI7QUFDQVYsdUJBQVM1akIsR0FBVCxDQUFhO0FBQ1gwZCx3QkFBUSxDQURHO0FBRVhocUIsc0JBQU0sQ0FGSztBQUdYdXhCLDhCQUFjLGVBSEg7QUFJWHRuQixpQ0FBaUIsVUFKTjtBQUtYbEosMkJBQVcydkIsYUFMQTtBQU1YMXZCLDRCQUFhMnZCLGVBQWEsQ0FBZCxHQUFvQkcsc0JBQW9CO0FBTnpDLGVBQWI7QUFRRDtBQUNEO0FBZkEsaUJBZ0JLLElBQUlmLG9CQUFvQixNQUF4QixFQUFnQztBQUNuQ29CLDRCQUFZcEssT0FBT2xuQixNQUFQLEdBQWdCRSxHQUFoQixHQUFzQnluQixlQUFhLENBQW5DLEdBQXVDa0osZ0JBQWMsQ0FBakU7QUFDQVUsNkJBQWNySyxPQUFPbG5CLE1BQVAsR0FBZ0JHLElBQWhCLEdBQXVCMndCLFlBQXZCLEdBQXNDakIsTUFBcEQ7QUFDQTJCLGlDQUFpQkMsdUJBQXVCRixVQUF2QixFQUFtQ0QsU0FBbkMsRUFBOENSLFlBQTlDLEVBQTRERCxhQUE1RCxDQUFqQjs7QUFFQUcsNENBQTRCLE9BQTVCO0FBQ0FYLHlCQUFTNWpCLEdBQVQsQ0FBYTtBQUNYdk0sdUJBQUssTUFETTtBQUVYeXhCLHlCQUFPLENBRkk7QUFHWGxKLHlCQUFPLE1BSEk7QUFJWDFYLDBCQUFRLE1BSkc7QUFLWDJnQixnQ0FBYyxlQUxIO0FBTVh0bkIsbUNBQWlCLFNBTk47QUFPWGxKLDZCQUFXMnZCLGdCQUFjLENBUGQ7QUFRWDF2Qiw4QkFBWTJ2QjtBQVJELGlCQUFiO0FBVUQ7QUFDRDtBQWpCSyxtQkFrQkEsSUFBSVosb0JBQW9CLE9BQXhCLEVBQWlDO0FBQ3BDb0IsOEJBQVlwSyxPQUFPbG5CLE1BQVAsR0FBZ0JFLEdBQWhCLEdBQXNCeW5CLGVBQWEsQ0FBbkMsR0FBdUNrSixnQkFBYyxDQUFqRTtBQUNBVSwrQkFBYXJLLE9BQU9sbkIsTUFBUCxHQUFnQkcsSUFBaEIsR0FBdUJ3d0IsV0FBdkIsR0FBcUNkLE1BQWxEO0FBQ0EyQixtQ0FBaUJDLHVCQUF1QkYsVUFBdkIsRUFBbUNELFNBQW5DLEVBQThDUixZQUE5QyxFQUE0REQsYUFBNUQsQ0FBakI7O0FBRUFHLDhDQUE0QixPQUE1QjtBQUNBWCwyQkFBUzVqQixHQUFULENBQWE7QUFDWHZNLHlCQUFLLE1BRE07QUFFWEMsMEJBQU0sQ0FGSztBQUdYc29CLDJCQUFPLE1BSEk7QUFJWDFYLDRCQUFRLE1BSkc7QUFLWDJnQixrQ0FBYyxlQUxIO0FBTVh0bkIscUNBQWlCLFFBTk47QUFPWGxKLCtCQUFXMnZCLGdCQUFjLENBUGQ7QUFRWDF2QixnQ0FBWTtBQVJELG1CQUFiO0FBVUQsaUJBaEJJLE1BaUJBO0FBQ0g7QUFDQW13Qiw4QkFBWXBLLE9BQU9sbkIsTUFBUCxHQUFnQkUsR0FBaEIsR0FBc0JnbkIsT0FBTzBKLFdBQVAsRUFBdEIsR0FBNkNmLE1BQXpEO0FBQ0EwQiwrQkFBYXJLLE9BQU9sbkIsTUFBUCxHQUFnQkcsSUFBaEIsR0FBdUJ3d0IsY0FBWSxDQUFuQyxHQUF1Q0csZUFBYSxDQUFqRTtBQUNBVSxtQ0FBaUJDLHVCQUF1QkYsVUFBdkIsRUFBbUNELFNBQW5DLEVBQThDUixZQUE5QyxFQUE0REQsYUFBNUQsQ0FBakI7QUFDQUUsNENBQTBCLE9BQTFCO0FBQ0FWLDJCQUFTNWpCLEdBQVQsQ0FBYTtBQUNYdk0seUJBQUssQ0FETTtBQUVYQywwQkFBTSxDQUZLO0FBR1hnQixnQ0FBYTJ2QixlQUFhLENBQWQsR0FBb0JHLHNCQUFvQjtBQUh6QyxtQkFBYjtBQUtEOztBQUVEO0FBQ0FiLHNCQUFVM2pCLEdBQVYsQ0FBYztBQUNadk0sbUJBQUtzeEIsZUFBZWp2QixDQURSO0FBRVpwQyxvQkFBTXF4QixlQUFlNzJCO0FBRlQsYUFBZDs7QUFLQTtBQUNBdzJCLDJCQUFldDFCLEtBQUsrMUIsS0FBTCxHQUFhZCxZQUFiLEdBQTRCN2xCLFNBQVNnbUIsbUJBQVQsQ0FBM0M7QUFDQUcsMkJBQWV2MUIsS0FBSysxQixLQUFMLEdBQWFmLGFBQWIsR0FBNkI1bEIsU0FBU2ltQixvQkFBVCxDQUE1QztBQUNBRywwQkFBY3gxQixLQUFLa0gsR0FBTCxDQUFTb3VCLFlBQVQsRUFBdUJDLFlBQXZCLENBQWQ7O0FBRUFoQixzQkFBVWxwQixRQUFWLENBQW1CLEVBQUUycUIsWUFBWWQsdUJBQWQsRUFBdUNlLFlBQVlkLHlCQUFuRCxFQUFuQixFQUFrRyxFQUFFdHRCLFVBQVUsR0FBWixFQUFpQmpFLE9BQU8sS0FBeEIsRUFBbEcsRUFDR3lILFFBREgsQ0FDWSxFQUFDNkQsU0FBUyxDQUFWLEVBRFosRUFDMEIsRUFBQ3JILFVBQVUsR0FBWCxFQUFnQndDLE9BQU8sRUFBdkIsRUFBMkJ6RyxPQUFPLEtBQWxDLEVBRDFCO0FBRUE0d0IscUJBQVM1akIsR0FBVCxDQUFhLEVBQUUzSSxZQUFZLFNBQWQsRUFBYixFQUNHb0QsUUFESCxDQUNZLEVBQUM2RCxTQUFRLENBQVQsRUFEWixFQUN3QixFQUFDckgsVUFBVSxFQUFYLEVBQWV3QyxPQUFPLENBQXRCLEVBQXlCekcsT0FBTyxLQUFoQyxFQUR4QixFQUVHeUgsUUFGSCxDQUVZLEVBQUNrakIsUUFBUWlILFdBQVQsRUFBc0JVLFFBQVFWLFdBQTlCLEVBRlosRUFFd0QsRUFBQzN0QixVQUFVLEdBQVgsRUFBZ0J3QyxPQUFPLENBQXZCLEVBQTBCekcsT0FBTyxLQUFqQyxFQUF3Q2xGLFFBQVEsZUFBaEQsRUFGeEQ7QUFHRCxXQXJHRDs7QUF1R0FrMkIsdUJBQWF6cUIsV0FBVzBxQixXQUFYLEVBQXdCVCxZQUF4QixDQUFiLENBeEcyQyxDQXdHUzs7QUFFdEQ7QUFDQyxTQTNHUztBQTRHViw4QkFBc0IsNkJBQVU7QUFDOUI7QUFDQTNaLG9CQUFVLEtBQVY7QUFDQS9GLHVCQUFha2dCLFVBQWI7O0FBRUE7QUFDQXpxQixxQkFBVyxZQUFXO0FBQ3BCLGdCQUFJc1EsWUFBWSxJQUFoQixFQUFzQjtBQUNwQjhaLHdCQUFVbHBCLFFBQVYsQ0FBbUI7QUFDakI2RCx5QkFBUyxDQURRLEVBQ0w4bUIsWUFBWSxDQURQLEVBQ1VDLFlBQVksQ0FEdEIsRUFBbkIsRUFDNkMsRUFBRXB1QixVQUFVLEdBQVosRUFBaUJqRSxPQUFPLEtBQXhCLEVBRDdDO0FBRUE0d0IsdUJBQVNucEIsUUFBVCxDQUFrQixFQUFDNkQsU0FBUyxDQUFWLEVBQWFxZixRQUFRLENBQXJCLEVBQXdCMkgsUUFBUSxDQUFoQyxFQUFsQixFQUFzRDtBQUNwRHJ1QiwwQkFBUyxHQUQyQztBQUVwRGpFLHVCQUFPLEtBRjZDO0FBR3BEc0csMEJBQVUsb0JBQVU7QUFDbEJzcUIsMkJBQVM1akIsR0FBVCxDQUFhLEVBQUUzSSxZQUFZLFFBQWQsRUFBYjtBQUNBc3NCLDRCQUFVM2pCLEdBQVYsQ0FBYyxFQUFFM0ksWUFBWSxRQUFkLEVBQWQ7QUFDQXdTLDRCQUFVLEtBQVY7QUFBaUI7QUFOaUMsZUFBdEQ7QUFRRDtBQUNGLFdBYkQsRUFhRSxHQWJGO0FBY0Q7QUFoSVMsT0FBVjtBQWtJSCxLQTVMUSxDQUFQO0FBNkxILEdBcE5DOztBQXNORixNQUFJbWIseUJBQXlCLFNBQXpCQSxzQkFBeUIsQ0FBUzkyQixDQUFULEVBQVk0SCxDQUFaLEVBQWVrbUIsS0FBZixFQUFzQjFYLE1BQXRCLEVBQThCO0FBQ3pELFFBQUlpaEIsT0FBT3IzQixDQUFYO0FBQ0EsUUFBSXMzQixPQUFPMXZCLENBQVg7O0FBRUEsUUFBSXl2QixPQUFPLENBQVgsRUFBYztBQUNaQSxhQUFPLENBQVA7QUFDRCxLQUZELE1BRU8sSUFBSUEsT0FBT3ZKLEtBQVAsR0FBZW5xQixPQUFPb1EsVUFBMUIsRUFBc0M7QUFDM0NzakIsY0FBUUEsT0FBT3ZKLEtBQVAsR0FBZW5xQixPQUFPb1EsVUFBOUI7QUFDRDs7QUFFRCxRQUFJdWpCLE9BQU8sQ0FBWCxFQUFjO0FBQ1pBLGFBQU8sQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFJQSxPQUFPbGhCLE1BQVAsR0FBZ0J6UyxPQUFPc1EsV0FBUCxHQUFxQnZVLEVBQUVpRSxNQUFGLEVBQVVnQyxTQUFuRCxFQUE4RDtBQUNuRTJ4QixjQUFRQSxPQUFPbGhCLE1BQVAsR0FBZ0J6UyxPQUFPc1EsV0FBL0I7QUFDRDs7QUFFRCxXQUFPLEVBQUNqVSxHQUFHcTNCLElBQUosRUFBVXp2QixHQUFHMHZCLElBQWIsRUFBUDtBQUNELEdBakJEOztBQW1CQTUzQixJQUFFZ0csUUFBRixFQUFZa21CLEtBQVosQ0FBa0IsWUFBVTtBQUN6QmxzQixNQUFFLGFBQUYsRUFBaUJ1MUIsT0FBakI7QUFDRCxHQUZGO0FBR0QsQ0E3T0MsRUE2T0N4MUIsTUE3T0QsQ0FBRDtBQThPRCxDLENBQUM7Ozs7Ozs7OztBQVNELENBQUMsQ0FBQyxVQUFTa0UsTUFBVCxFQUFpQjtBQUNmOztBQUVBLE1BQUk0ekIsUUFBUUEsU0FBUyxFQUFyQjtBQUNBLE1BQUlDLEtBQUs5eEIsU0FBUyt4QixnQkFBVCxDQUEwQnhKLElBQTFCLENBQStCdm9CLFFBQS9CLENBQVQ7O0FBRUE7QUFDQSxXQUFTbkMsUUFBVCxDQUFrQnFrQixHQUFsQixFQUF1QjtBQUNuQixXQUFPQSxRQUFRLElBQVIsSUFBZ0JBLFFBQVFBLElBQUlqa0IsTUFBbkM7QUFDSDs7QUFFRCxXQUFTK3pCLFNBQVQsQ0FBbUI3TCxJQUFuQixFQUF5QjtBQUNyQixXQUFPdG9CLFNBQVNzb0IsSUFBVCxJQUFpQkEsSUFBakIsR0FBd0JBLEtBQUtyb0IsUUFBTCxLQUFrQixDQUFsQixJQUF1QnFvQixLQUFLM1UsV0FBM0Q7QUFDSDs7QUFFRCxXQUFTN1IsTUFBVCxDQUFnQndtQixJQUFoQixFQUFzQjtBQUNsQixRQUFJOEwsT0FBSjtBQUFBLFFBQWFDLEdBQWI7QUFBQSxRQUNJQyxNQUFNLEVBQUN0eUIsS0FBSyxDQUFOLEVBQVNDLE1BQU0sQ0FBZixFQURWO0FBQUEsUUFFSXN5QixNQUFNak0sUUFBUUEsS0FBSzVVLGFBRnZCOztBQUlBMGdCLGNBQVVHLElBQUkzcEIsZUFBZDs7QUFFQSxRQUFJLFFBQU8wZCxLQUFLdm1CLHFCQUFaLHFDQUE2QzdDLFNBQTdDLEVBQUosRUFBNEQ7QUFDeERvMUIsWUFBTWhNLEtBQUt2bUIscUJBQUwsRUFBTjtBQUNIO0FBQ0RzeUIsVUFBTUYsVUFBVUksR0FBVixDQUFOO0FBQ0EsV0FBTztBQUNIdnlCLFdBQUtzeUIsSUFBSXR5QixHQUFKLEdBQVVxeUIsSUFBSW55QixXQUFkLEdBQTRCa3lCLFFBQVEveEIsU0FEdEM7QUFFSEosWUFBTXF5QixJQUFJcnlCLElBQUosR0FBV295QixJQUFJL3hCLFdBQWYsR0FBNkI4eEIsUUFBUTV4QjtBQUZ4QyxLQUFQO0FBSUg7O0FBRUQsV0FBU2d5QixZQUFULENBQXNCblEsR0FBdEIsRUFBMkI7QUFDdkIsUUFBSXpoQixRQUFRLEVBQVo7O0FBRUEsU0FBSyxJQUFJaEUsQ0FBVCxJQUFjeWxCLEdBQWQsRUFBbUI7QUFDZixVQUFJQSxJQUFJL2dCLGNBQUosQ0FBbUIxRSxDQUFuQixDQUFKLEVBQTJCO0FBQ3ZCZ0UsaUJBQVVoRSxJQUFJLEdBQUosR0FBVXlsQixJQUFJemxCLENBQUosQ0FBVixHQUFtQixHQUE3QjtBQUNIO0FBQ0o7O0FBRUQsV0FBT2dFLEtBQVA7QUFDSDs7QUFFRCxNQUFJNnhCLFNBQVM7O0FBRVQ7QUFDQWp2QixjQUFVLEdBSEQ7O0FBS1QrckIsVUFBTSxjQUFTM3hCLENBQVQsRUFBWTZGLE9BQVosRUFBcUI7O0FBRXZCO0FBQ0EsVUFBSTdGLEVBQUVpZCxNQUFGLEtBQWEsQ0FBakIsRUFBb0I7QUFDaEIsZUFBTyxLQUFQO0FBQ0g7O0FBRUQsVUFBSTRHLEtBQUtoZSxXQUFXLElBQXBCOztBQUVBO0FBQ0EsVUFBSWl2QixTQUFTdnlCLFNBQVMrRixhQUFULENBQXVCLEtBQXZCLENBQWI7QUFDQXdzQixhQUFPdG1CLFNBQVAsR0FBbUIsY0FBbkI7QUFDQXFWLFNBQUdyVCxXQUFILENBQWVza0IsTUFBZjs7QUFFQTtBQUNBLFVBQUlDLE1BQWM3eUIsT0FBTzJoQixFQUFQLENBQWxCO0FBQ0EsVUFBSW1SLFlBQWVoMUIsRUFBRWkxQixLQUFGLEdBQVVGLElBQUkzeUIsR0FBakM7QUFDQSxVQUFJOHlCLFlBQWVsMUIsRUFBRW0xQixLQUFGLEdBQVVKLElBQUkxeUIsSUFBakM7QUFDQSxVQUFJb04sUUFBYyxXQUFXb1UsR0FBRzZHLFdBQUgsR0FBaUIsR0FBbEIsR0FBeUIsRUFBbkMsR0FBdUMsR0FBekQ7O0FBRUE7QUFDQSxVQUFJLGFBQWExcUIsQ0FBakIsRUFBb0I7QUFDbEJnMUIsb0JBQWVoMUIsRUFBRTBZLE9BQUYsQ0FBVSxDQUFWLEVBQWF1YyxLQUFiLEdBQXFCRixJQUFJM3lCLEdBQXhDO0FBQ0E4eUIsb0JBQWVsMUIsRUFBRTBZLE9BQUYsQ0FBVSxDQUFWLEVBQWF5YyxLQUFiLEdBQXFCSixJQUFJMXlCLElBQXhDO0FBQ0Q7O0FBRUQ7QUFDQXl5QixhQUFPemxCLFlBQVAsQ0FBb0IsV0FBcEIsRUFBaUM3TCxLQUFLK1ksR0FBTCxFQUFqQztBQUNBdVksYUFBT3psQixZQUFQLENBQW9CLFlBQXBCLEVBQWtDSSxLQUFsQztBQUNBcWxCLGFBQU96bEIsWUFBUCxDQUFvQixRQUFwQixFQUE4QjZsQixTQUE5QjtBQUNBSixhQUFPemxCLFlBQVAsQ0FBb0IsUUFBcEIsRUFBOEIybEIsU0FBOUI7O0FBRUE7QUFDQSxVQUFJSSxjQUFjO0FBQ2QsZUFBT0osWUFBVSxJQURIO0FBRWQsZ0JBQVFFLFlBQVU7QUFGSixPQUFsQjs7QUFLQUosYUFBT3RtQixTQUFQLEdBQW1Cc21CLE9BQU90bUIsU0FBUCxHQUFtQixxQkFBdEM7QUFDQXNtQixhQUFPemxCLFlBQVAsQ0FBb0IsT0FBcEIsRUFBNkJ1bEIsYUFBYVEsV0FBYixDQUE3QjtBQUNBTixhQUFPdG1CLFNBQVAsR0FBbUJzbUIsT0FBT3RtQixTQUFQLENBQWlCekIsT0FBakIsQ0FBeUIsb0JBQXpCLEVBQStDLEVBQS9DLENBQW5COztBQUVBO0FBQ0Fxb0Isa0JBQVksbUJBQVosSUFBbUMzbEIsS0FBbkM7QUFDQTJsQixrQkFBWSxnQkFBWixJQUFnQzNsQixLQUFoQztBQUNBMmxCLGtCQUFZLGVBQVosSUFBK0IzbEIsS0FBL0I7QUFDQTJsQixrQkFBWSxjQUFaLElBQThCM2xCLEtBQTlCO0FBQ0EybEIsa0JBQVlDLFNBQVosR0FBd0I1bEIsS0FBeEI7QUFDQTJsQixrQkFBWW5vQixPQUFaLEdBQXdCLEdBQXhCOztBQUVBbW9CLGtCQUFZLDZCQUFaLElBQTZDUCxPQUFPanZCLFFBQVAsR0FBa0IsSUFBL0Q7QUFDQXd2QixrQkFBWSwwQkFBWixJQUE2Q1AsT0FBT2p2QixRQUFQLEdBQWtCLElBQS9EO0FBQ0F3dkIsa0JBQVksd0JBQVosSUFBNkNQLE9BQU9qdkIsUUFBUCxHQUFrQixJQUEvRDtBQUNBd3ZCLGtCQUFZLHFCQUFaLElBQTZDUCxPQUFPanZCLFFBQVAsR0FBa0IsSUFBL0Q7O0FBRUF3dkIsa0JBQVksb0NBQVosSUFBb0QsMENBQXBEO0FBQ0FBLGtCQUFZLGlDQUFaLElBQW9ELDBDQUFwRDtBQUNBQSxrQkFBWSwrQkFBWixJQUFvRCwwQ0FBcEQ7QUFDQUEsa0JBQVksNEJBQVosSUFBb0QsMENBQXBEOztBQUVBTixhQUFPemxCLFlBQVAsQ0FBb0IsT0FBcEIsRUFBNkJ1bEIsYUFBYVEsV0FBYixDQUE3QjtBQUNILEtBbEVROztBQW9FVDVELFVBQU0sY0FBU3h4QixDQUFULEVBQVk7QUFDZHMxQixtQkFBYUMsT0FBYixDQUFxQnYxQixDQUFyQjs7QUFFQSxVQUFJNmpCLEtBQUssSUFBVDtBQUNBLFVBQUk4RyxRQUFROUcsR0FBRzZHLFdBQUgsR0FBaUIsR0FBN0I7O0FBRUE7QUFDQSxVQUFJb0ssU0FBUyxJQUFiO0FBQ0EsVUFBSVUsVUFBVTNSLEdBQUc0UixzQkFBSCxDQUEwQixjQUExQixDQUFkO0FBQ0EsVUFBSUQsUUFBUXYxQixNQUFSLEdBQWlCLENBQXJCLEVBQXdCO0FBQ3BCNjBCLGlCQUFTVSxRQUFRQSxRQUFRdjFCLE1BQVIsR0FBaUIsQ0FBekIsQ0FBVDtBQUNILE9BRkQsTUFFTztBQUNILGVBQU8sS0FBUDtBQUNIOztBQUVELFVBQUlpMUIsWUFBY0osT0FBTzlsQixZQUFQLENBQW9CLFFBQXBCLENBQWxCO0FBQ0EsVUFBSWdtQixZQUFjRixPQUFPOWxCLFlBQVAsQ0FBb0IsUUFBcEIsQ0FBbEI7QUFDQSxVQUFJUyxRQUFjcWxCLE9BQU85bEIsWUFBUCxDQUFvQixZQUFwQixDQUFsQjs7QUFFQTtBQUNBLFVBQUkwbUIsT0FBT2x5QixLQUFLK1ksR0FBTCxLQUFhb1osT0FBT2IsT0FBTzlsQixZQUFQLENBQW9CLFdBQXBCLENBQVAsQ0FBeEI7QUFDQSxVQUFJNUcsUUFBUSxNQUFNc3RCLElBQWxCOztBQUVBLFVBQUl0dEIsUUFBUSxDQUFaLEVBQWU7QUFDWEEsZ0JBQVEsQ0FBUjtBQUNIOztBQUVEO0FBQ0FGLGlCQUFXLFlBQVc7QUFDbEIsWUFBSWxGLFFBQVE7QUFDUixpQkFBT2d5QixZQUFVLElBRFQ7QUFFUixrQkFBUUUsWUFBVSxJQUZWO0FBR1IscUJBQVcsR0FISDs7QUFLUjtBQUNBLHlDQUErQkwsT0FBT2p2QixRQUFQLEdBQWtCLElBTnpDO0FBT1Isc0NBQTRCaXZCLE9BQU9qdkIsUUFBUCxHQUFrQixJQVB0QztBQVFSLG9DQUEwQml2QixPQUFPanZCLFFBQVAsR0FBa0IsSUFScEM7QUFTUixpQ0FBdUJpdkIsT0FBT2p2QixRQUFQLEdBQWtCLElBVGpDO0FBVVIsK0JBQXFCNkosS0FWYjtBQVdSLDRCQUFrQkEsS0FYVjtBQVlSLDJCQUFpQkEsS0FaVDtBQWFSLDBCQUFnQkEsS0FiUjtBQWNSLHVCQUFhQTtBQWRMLFNBQVo7O0FBaUJBcWxCLGVBQU96bEIsWUFBUCxDQUFvQixPQUFwQixFQUE2QnVsQixhQUFhNXhCLEtBQWIsQ0FBN0I7O0FBRUFrRixtQkFBVyxZQUFXO0FBQ2xCLGNBQUk7QUFDQTJiLGVBQUdwVCxXQUFILENBQWVxa0IsTUFBZjtBQUNILFdBRkQsQ0FFRSxPQUFNOTBCLENBQU4sRUFBUztBQUNQLG1CQUFPLEtBQVA7QUFDSDtBQUNKLFNBTkQsRUFNRzYwQixPQUFPanZCLFFBTlY7QUFPSCxPQTNCRCxFQTJCR3dDLEtBM0JIO0FBNEJILEtBNUhROztBQThIVDtBQUNBd3RCLGVBQVcsbUJBQVN0akIsUUFBVCxFQUFtQjtBQUMxQixXQUFLLElBQUl0VCxJQUFJLENBQWIsRUFBZ0JBLElBQUlzVCxTQUFTclMsTUFBN0IsRUFBcUNqQixHQUFyQyxFQUEwQztBQUN0QyxZQUFJNmtCLEtBQUt2UixTQUFTdFQsQ0FBVCxDQUFUOztBQUVBLFlBQUk2a0IsR0FBR3pWLE9BQUgsQ0FBV3JMLFdBQVgsT0FBNkIsT0FBakMsRUFBMEM7QUFDdEMsY0FBSXNrQixTQUFTeEQsR0FBRzNZLFVBQWhCOztBQUVBO0FBQ0EsY0FBSW1jLE9BQU9qWixPQUFQLENBQWVyTCxXQUFmLE9BQWlDLEdBQWpDLElBQXdDc2tCLE9BQU83WSxTQUFQLENBQWlCbUYsT0FBakIsQ0FBeUIsY0FBekIsTUFBNkMsQ0FBQyxDQUExRixFQUE2RjtBQUN6RjtBQUNIOztBQUVEO0FBQ0EsY0FBSTJXLFVBQVUvbkIsU0FBUytGLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBZDtBQUNBZ2lCLGtCQUFROWIsU0FBUixHQUFvQnFWLEdBQUdyVixTQUFILEdBQWUsc0JBQW5DOztBQUVBLGNBQUlxbkIsZUFBZWhTLEdBQUc3VSxZQUFILENBQWdCLE9BQWhCLENBQW5COztBQUVBLGNBQUksQ0FBQzZtQixZQUFMLEVBQW1CO0FBQ2ZBLDJCQUFlLEVBQWY7QUFDSDs7QUFFRHZMLGtCQUFRamIsWUFBUixDQUFxQixPQUFyQixFQUE4QndtQixZQUE5Qjs7QUFFQWhTLGFBQUdyVixTQUFILEdBQWUsb0JBQWY7QUFDQXFWLGFBQUdpUyxlQUFILENBQW1CLE9BQW5COztBQUVBO0FBQ0F6TyxpQkFBTzBPLFlBQVAsQ0FBb0J6TCxPQUFwQixFQUE2QnpHLEVBQTdCO0FBQ0F5RyxrQkFBUTlaLFdBQVIsQ0FBb0JxVCxFQUFwQjtBQUNIO0FBQ0o7QUFDSjtBQS9KUSxHQUFiOztBQW1LQTs7O0FBR0EsTUFBSXlSLGVBQWU7QUFDZjs7OztBQUlBNWMsYUFBUyxDQUxNO0FBTWZzZCxnQkFBWSxvQkFBU2gyQixDQUFULEVBQVk7QUFDcEIsVUFBSThYLFFBQVEsSUFBWjs7QUFFQSxVQUFJOVgsRUFBRUcsSUFBRixLQUFXLFlBQWYsRUFBNkI7QUFDekJtMUIscUJBQWE1YyxPQUFiLElBQXdCLENBQXhCLENBRHlCLENBQ0U7QUFDOUIsT0FGRCxNQUVPLElBQUkxWSxFQUFFRyxJQUFGLEtBQVcsVUFBWCxJQUF5QkgsRUFBRUcsSUFBRixLQUFXLGFBQXhDLEVBQXVEO0FBQzFEK0gsbUJBQVcsWUFBVztBQUNsQixjQUFJb3RCLGFBQWE1YyxPQUFiLEdBQXVCLENBQTNCLEVBQThCO0FBQzFCNGMseUJBQWE1YyxPQUFiLElBQXdCLENBQXhCLENBRDBCLENBQ0M7QUFDOUI7QUFDSixTQUpELEVBSUcsR0FKSDtBQUtILE9BTk0sTUFNQSxJQUFJMVksRUFBRUcsSUFBRixLQUFXLFdBQVgsSUFBMEJtMUIsYUFBYTVjLE9BQWIsR0FBdUIsQ0FBckQsRUFBd0Q7QUFDM0RaLGdCQUFRLEtBQVI7QUFDSDs7QUFFRCxhQUFPQSxLQUFQO0FBQ0gsS0F0QmM7QUF1QmZ5ZCxhQUFTLGlCQUFTdjFCLENBQVQsRUFBWTtBQUNqQnMxQixtQkFBYVUsVUFBYixDQUF3QmgyQixDQUF4QjtBQUNIO0FBekJjLEdBQW5COztBQTZCQTs7OztBQUlBLFdBQVNpMkIscUJBQVQsQ0FBK0JqMkIsQ0FBL0IsRUFBa0M7QUFDOUIsUUFBSXMxQixhQUFhVSxVQUFiLENBQXdCaDJCLENBQXhCLE1BQStCLEtBQW5DLEVBQTBDO0FBQ3RDLGFBQU8sSUFBUDtBQUNIOztBQUVELFFBQUk2RixVQUFVLElBQWQ7QUFDQSxRQUFJdU8sU0FBU3BVLEVBQUVvVSxNQUFGLElBQVlwVSxFQUFFazJCLFVBQTNCOztBQUVBLFdBQU85aEIsT0FBTytoQixhQUFQLEtBQXlCLElBQWhDLEVBQXNDO0FBQ2xDLFVBQUksRUFBRS9oQixrQkFBa0JsTCxVQUFwQixLQUFtQ2tMLE9BQU81RixTQUFQLENBQWlCbUYsT0FBakIsQ0FBeUIsY0FBekIsTUFBNkMsQ0FBQyxDQUFyRixFQUF3RjtBQUNwRjlOLGtCQUFVdU8sTUFBVjtBQUNBO0FBQ0gsT0FIRCxNQUdPLElBQUlBLE9BQU85RixTQUFQLENBQWlCOG5CLFFBQWpCLENBQTBCLGNBQTFCLENBQUosRUFBK0M7QUFDbER2d0Isa0JBQVV1TyxNQUFWO0FBQ0E7QUFDSDtBQUNEQSxlQUFTQSxPQUFPK2hCLGFBQWhCO0FBQ0g7O0FBRUQsV0FBT3R3QixPQUFQO0FBQ0g7O0FBRUQ7OztBQUdBLFdBQVN3d0IsVUFBVCxDQUFvQnIyQixDQUFwQixFQUF1QjtBQUNuQixRQUFJNkYsVUFBVW93QixzQkFBc0JqMkIsQ0FBdEIsQ0FBZDs7QUFFQSxRQUFJNkYsWUFBWSxJQUFoQixFQUFzQjtBQUNsQmd2QixhQUFPbEQsSUFBUCxDQUFZM3hCLENBQVosRUFBZTZGLE9BQWY7O0FBRUEsVUFBSSxrQkFBa0JyRixNQUF0QixFQUE4QjtBQUMxQnFGLGdCQUFRbU4sZ0JBQVIsQ0FBeUIsVUFBekIsRUFBcUM2aEIsT0FBT3JELElBQTVDLEVBQWtELEtBQWxEO0FBQ0EzckIsZ0JBQVFtTixnQkFBUixDQUF5QixhQUF6QixFQUF3QzZoQixPQUFPckQsSUFBL0MsRUFBcUQsS0FBckQ7QUFDSDs7QUFFRDNyQixjQUFRbU4sZ0JBQVIsQ0FBeUIsU0FBekIsRUFBb0M2aEIsT0FBT3JELElBQTNDLEVBQWlELEtBQWpEO0FBQ0EzckIsY0FBUW1OLGdCQUFSLENBQXlCLFlBQXpCLEVBQXVDNmhCLE9BQU9yRCxJQUE5QyxFQUFvRCxLQUFwRDtBQUNIO0FBQ0o7O0FBRUQ0QyxRQUFNa0MsYUFBTixHQUFzQixVQUFTL2pCLE9BQVQsRUFBa0I7QUFDcENBLGNBQVVBLFdBQVcsRUFBckI7O0FBRUEsUUFBSSxjQUFjQSxPQUFsQixFQUEyQjtBQUN2QnNpQixhQUFPanZCLFFBQVAsR0FBa0IyTSxRQUFRM00sUUFBMUI7QUFDSDs7QUFFRDtBQUNBaXZCLFdBQU9lLFNBQVAsQ0FBaUJ2QixHQUFHLGVBQUgsQ0FBakI7O0FBRUEsUUFBSSxrQkFBa0I3ekIsTUFBdEIsRUFBOEI7QUFDMUIrQixlQUFTMEksSUFBVCxDQUFjK0gsZ0JBQWQsQ0FBK0IsWUFBL0IsRUFBNkNxakIsVUFBN0MsRUFBeUQsS0FBekQ7QUFDSDs7QUFFRDl6QixhQUFTMEksSUFBVCxDQUFjK0gsZ0JBQWQsQ0FBK0IsV0FBL0IsRUFBNENxakIsVUFBNUMsRUFBd0QsS0FBeEQ7QUFDSCxHQWZEOztBQWlCQTs7Ozs7O0FBTUFqQyxRQUFNbUMsTUFBTixHQUFlLFVBQVMxd0IsT0FBVCxFQUFrQjtBQUM3QjtBQUNBO0FBQ0EsUUFBSUEsUUFBUXVJLE9BQVIsQ0FBZ0JyTCxXQUFoQixPQUFrQyxPQUF0QyxFQUErQztBQUMzQzh4QixhQUFPZSxTQUFQLENBQWlCLENBQUMvdkIsT0FBRCxDQUFqQjtBQUNBQSxnQkFBVUEsUUFBUXN3QixhQUFsQjtBQUNIOztBQUVELFFBQUksa0JBQWtCMzFCLE1BQXRCLEVBQThCO0FBQzFCcUYsY0FBUW1OLGdCQUFSLENBQXlCLFlBQXpCLEVBQXVDcWpCLFVBQXZDLEVBQW1ELEtBQW5EO0FBQ0g7O0FBRUR4d0IsWUFBUW1OLGdCQUFSLENBQXlCLFdBQXpCLEVBQXNDcWpCLFVBQXRDLEVBQWtELEtBQWxEO0FBQ0gsR0FiRDs7QUFlQTcxQixTQUFPNHpCLEtBQVAsR0FBZUEsS0FBZjs7QUFFQTd4QixXQUFTeVEsZ0JBQVQsQ0FBMEIsa0JBQTFCLEVBQThDLFlBQVc7QUFDckRvaEIsVUFBTWtDLGFBQU47QUFDSCxHQUZELEVBRUcsS0FGSDtBQUlILENBeFVBLEVBd1VFOTFCLE1BeFVGO0FBeVVELENBQUMyakIsWUFBWXFTLEtBQVosR0FBb0IsVUFBVUMsT0FBVixFQUFtQkMsYUFBbkIsRUFBa0Nsb0IsU0FBbEMsRUFBNkNtb0IsZ0JBQTdDLEVBQStEO0FBQ2xGbm9CLGNBQVlBLGFBQWEsRUFBekI7O0FBRUEsTUFBSVMsWUFBWTFNLFNBQVNxMEIsY0FBVCxDQUF3QixpQkFBeEIsQ0FBaEI7O0FBRUE7QUFDQSxNQUFJM25CLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEI7QUFDQUEsZ0JBQVkxTSxTQUFTK0YsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0EyRyxjQUFVMkssRUFBVixHQUFlLGlCQUFmO0FBQ0FyWCxhQUFTMEksSUFBVCxDQUFjdUYsV0FBZCxDQUEwQnZCLFNBQTFCO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJNG5CLFdBQVdDLFlBQVlMLE9BQVosQ0FBZjs7QUFFQTtBQUNBLE1BQUdBLE9BQUgsRUFBVztBQUNUeG5CLGNBQVV1QixXQUFWLENBQXNCcW1CLFFBQXRCO0FBQ0Q7O0FBRURBLFdBQVM3ekIsS0FBVCxDQUFlaUssT0FBZixHQUF5QixDQUF6Qjs7QUFFQTtBQUNBc1osTUFBSXNRLFFBQUosRUFBYyxFQUFDOUMsWUFBWSxPQUFiLEVBQXVCOW1CLFNBQVMsQ0FBaEMsRUFBZCxFQUFtRCxFQUFDckgsVUFBVSxHQUFYO0FBQ2pEbkosWUFBUSxjQUR5QztBQUVqRGtGLFdBQU8sS0FGMEMsRUFBbkQ7O0FBSUE7QUFDQSxNQUFJbzFCLFdBQVdMLGFBQWY7QUFDQSxNQUFJTSxlQUFKO0FBQ0EsTUFBSUQsWUFBWSxJQUFoQixFQUF1QjtBQUNyQkMsc0JBQWtCQyxZQUFhLFlBQVU7QUFDdkMsVUFBSUosU0FBUzNyQixVQUFULEtBQXdCLElBQTVCLEVBQ0UxSyxPQUFPMDJCLGFBQVAsQ0FBcUJGLGVBQXJCOztBQUVGO0FBQ0EsVUFBSSxDQUFDSCxTQUFTdm9CLFNBQVQsQ0FBbUI4bkIsUUFBbkIsQ0FBNEIsU0FBNUIsQ0FBTCxFQUE2QztBQUMzQ1csb0JBQVksRUFBWjtBQUNEOztBQUVELFVBQUlBLFlBQVksQ0FBaEIsRUFBbUI7QUFDakI7QUFDQXhRLFlBQUlzUSxRQUFKLEVBQWMsRUFBQyxXQUFXLENBQVosRUFBZXp6QixXQUFXLE9BQTFCLEVBQWQsRUFBa0QsRUFBRXdDLFVBQVUsR0FBWjtBQUM5Q25KLGtCQUFRLGFBRHNDO0FBRTlDa0YsaUJBQU8sS0FGdUM7QUFHOUNzRyxvQkFBVSxvQkFBVTtBQUNsQjtBQUNBLGdCQUFHLE9BQU8wdUIsZ0JBQVAsS0FBNkIsVUFBaEMsRUFDRUE7QUFDRjtBQUNBLGlCQUFLLENBQUwsRUFBUXpyQixVQUFSLENBQW1CdUYsV0FBbkIsQ0FBK0IsS0FBSyxDQUFMLENBQS9CO0FBQ0Q7QUFUNkMsU0FBbEQ7QUFXQWpRLGVBQU8wMkIsYUFBUCxDQUFxQkYsZUFBckI7QUFDRDtBQUNGLEtBeEJpQixFQXdCZixFQXhCZSxDQUFsQjtBQXlCRDs7QUFJRCxXQUFTRixXQUFULENBQXFCOUUsSUFBckIsRUFBMkI7O0FBRXpCO0FBQ0EsUUFBSXdFLFFBQVFqMEIsU0FBUytGLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBa3VCLFVBQU1sb0IsU0FBTixDQUFnQkMsR0FBaEIsQ0FBb0IsT0FBcEI7QUFDQSxRQUFJQyxTQUFKLEVBQWU7QUFDYixVQUFJMm9CLFVBQVUzb0IsVUFBVTVLLEtBQVYsQ0FBZ0IsR0FBaEIsQ0FBZDs7QUFFQSxXQUFLLElBQUlsRCxJQUFJLENBQVIsRUFBVzRhLFFBQVE2YixRQUFRbDNCLE1BQWhDLEVBQXdDUyxJQUFJNGEsS0FBNUMsRUFBbUQ1YSxHQUFuRCxFQUF3RDtBQUN0RDgxQixjQUFNbG9CLFNBQU4sQ0FBZ0JDLEdBQWhCLENBQW9CNG9CLFFBQVF6MkIsQ0FBUixDQUFwQjtBQUNEO0FBQ0Y7QUFDSDtBQUNFLFFBQUssUUFBTzAyQixXQUFQLHlDQUFPQSxXQUFQLE9BQXVCLFFBQXZCLEdBQWtDcEYsZ0JBQWdCb0YsV0FBbEQsR0FBZ0VwRixRQUFRLFFBQU9BLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBeEIsSUFBb0NBLFNBQVMsSUFBN0MsSUFBcURBLEtBQUszeEIsUUFBTCxLQUFrQixDQUF2RSxJQUE0RSxPQUFPMnhCLEtBQUs5dUIsUUFBWixLQUF1QixRQUF4SyxFQUNGO0FBQ0lzekIsWUFBTWhtQixXQUFOLENBQWtCd2hCLElBQWxCO0FBQ0QsS0FIRCxNQUlLLElBQUlBLGdCQUFnQjExQixNQUFwQixFQUE0QjtBQUMvQjtBQUNBazZCLFlBQU1obUIsV0FBTixDQUFrQndoQixLQUFLLENBQUwsQ0FBbEI7QUFDRCxLQUhJLE1BSUE7QUFDSDtBQUNBd0UsWUFBTWp1QixTQUFOLEdBQWtCeXBCLElBQWxCO0FBQ0Q7QUFDRDtBQUNBLFFBQUlxRixnQkFBZ0IsSUFBSTFULE1BQUosQ0FBVzZTLEtBQVgsRUFBa0IsRUFBQ2MsaUJBQWlCLEtBQWxCLEVBQWxCLENBQXBCO0FBQ0FELGtCQUFjclcsRUFBZCxDQUFpQixLQUFqQixFQUF3QixVQUFTaGhCLENBQVQsRUFBWTtBQUNsQyxVQUFJd1csU0FBU3hXLEVBQUV3VyxNQUFmO0FBQ0EsVUFBSStnQixxQkFBcUIsRUFBekI7O0FBRUE7QUFDQSxVQUFJLENBQUNmLE1BQU1sb0IsU0FBTixDQUFnQjhuQixRQUFoQixDQUF5QixTQUF6QixDQUFMLEVBQXlDO0FBQ3ZDSSxjQUFNbG9CLFNBQU4sQ0FBZ0JDLEdBQWhCLENBQW9CLFNBQXBCO0FBQ0Q7O0FBRUQsVUFBSWlwQixpQkFBaUIsSUFBRXo1QixLQUFLa0IsR0FBTCxDQUFTdVgsU0FBUytnQixrQkFBbEIsQ0FBdkI7QUFDQSxVQUFJQyxpQkFBaUIsQ0FBckIsRUFDRUEsaUJBQWlCLENBQWpCOztBQUVGalIsVUFBSWlRLEtBQUosRUFBVyxFQUFDbjBCLE1BQU1tVSxNQUFQLEVBQWV2SixTQUFTdXFCLGNBQXhCLEVBQVgsRUFBcUQsRUFBQzV4QixVQUFVLEVBQVgsRUFBZWpFLE9BQU8sS0FBdEIsRUFBNkJsRixRQUFRLGFBQXJDLEVBQXJEO0FBRUQsS0FmRDs7QUFpQkE0NkIsa0JBQWNyVyxFQUFkLENBQWlCLFFBQWpCLEVBQTJCLFVBQVNoaEIsQ0FBVCxFQUFZO0FBQ3JDLFVBQUl3VyxTQUFTeFcsRUFBRXdXLE1BQWY7QUFDQSxVQUFJK2dCLHFCQUFxQixFQUF6Qjs7QUFFQTtBQUNBLFVBQUl4NUIsS0FBS2tCLEdBQUwsQ0FBU3VYLE1BQVQsSUFBbUIrZ0Isa0JBQXZCLEVBQTJDO0FBQ3pDaFIsWUFBSWlRLEtBQUosRUFBVyxFQUFDcHpCLFdBQVcsT0FBWixFQUFYLEVBQWlDLEVBQUV3QyxVQUFVLEdBQVo7QUFDL0JuSixrQkFBUSxhQUR1QjtBQUUvQmtGLGlCQUFPLEtBRndCO0FBRy9Cc0csb0JBQVUsb0JBQVU7QUFDbEIsZ0JBQUcsT0FBTzB1QixnQkFBUCxLQUE2QixVQUFoQyxFQUE0QztBQUMxQ0E7QUFDRDtBQUNESCxrQkFBTXRyQixVQUFOLENBQWlCdUYsV0FBakIsQ0FBNkIrbEIsS0FBN0I7QUFDRDtBQVI4QixTQUFqQztBQVdELE9BWkQsTUFZTztBQUNMQSxjQUFNbG9CLFNBQU4sQ0FBZ0JHLE1BQWhCLENBQXVCLFNBQXZCO0FBQ0E7QUFDQThYLFlBQUlpUSxLQUFKLEVBQVcsRUFBRW4wQixNQUFNLENBQVIsRUFBVzRLLFNBQVMsQ0FBcEIsRUFBWCxFQUFvQyxFQUFFckgsVUFBVSxHQUFaO0FBQ2xDbkosa0JBQVEsYUFEMEI7QUFFbENrRixpQkFBTztBQUYyQixTQUFwQztBQUtEO0FBQ0YsS0ExQkQ7O0FBNEJBLFdBQU82MEIsS0FBUDtBQUNEO0FBQ0YsQ0F2SUE7QUF3SUQsQ0FBRSxXQUFVajZCLENBQVYsRUFBYTs7QUFFYixNQUFJbXZCLFVBQVU7QUFDWm5yQixVQUFPLGNBQVNnUyxPQUFULEVBQWtCO0FBQ3ZCLFVBQUk5TSxXQUFXO0FBQ2JneUIsbUJBQVcsR0FERTtBQUViQyxjQUFNLE1BRk87QUFHYkMsc0JBQWMsS0FIRDtBQUliQyxtQkFBVztBQUpFLE9BQWY7QUFNQXJsQixnQkFBVWhXLEVBQUVHLE1BQUYsQ0FBUytJLFFBQVQsRUFBbUI4TSxPQUFuQixDQUFWOztBQUVBaFcsUUFBRSxJQUFGLEVBQVEyRSxJQUFSLENBQWEsWUFBVTtBQUNyQixZQUFJNGxCLFFBQVF2cUIsRUFBRSxJQUFGLENBQVo7QUFDQSxZQUFJczdCLFNBQVMvUSxNQUFNakMsSUFBTixDQUFXLGdCQUFYLENBQWI7QUFDQSxZQUFJaVQsT0FBT3Y3QixFQUFFLE1BQUtzN0IsTUFBUCxDQUFYOztBQUVBO0FBQ0EsWUFBSXRsQixRQUFRa2xCLFNBQVIsSUFBcUIsR0FBekIsRUFBOEI7QUFDNUJLLGVBQUtucEIsR0FBTCxDQUFTLE9BQVQsRUFBa0I0RCxRQUFRa2xCLFNBQTFCO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFJTSxjQUFjeDdCLEVBQUUsZ0NBQWdDczdCLE1BQWhDLEdBQXlDLElBQTNDLENBQWxCO0FBQ0EsWUFBSXRsQixRQUFRcWxCLFNBQVosRUFBdUI7QUFDckI7QUFDQSxjQUFJRyxZQUFZOTNCLE1BQWhCLEVBQXdCO0FBQ3RCODNCLHdCQUFZdHBCLE1BQVo7QUFDRDs7QUFFRHNwQix3QkFBY3g3QixFQUFFLGlDQUFGLEVBQXFDc29CLElBQXJDLENBQTBDLGNBQTFDLEVBQTBEZ1QsTUFBMUQsQ0FBZDtBQUNBdDdCLFlBQUUsTUFBRixFQUFVcXdCLE1BQVYsQ0FBaUJtTCxXQUFqQjtBQUNELFNBUkQsTUFRTztBQUNMQSx3QkFBY3g3QixHQUFkO0FBQ0Q7O0FBRUQsWUFBSWdXLFFBQVFtbEIsSUFBUixJQUFnQixNQUFwQixFQUE0QjtBQUMxQkksZUFBS25wQixHQUFMLENBQVMsV0FBVCxFQUFzQixtQkFBdEI7QUFDQW9wQixzQkFBWXBwQixHQUFaLENBQWdCLEVBQUMsUUFBUSxDQUFULEVBQWhCLEVBRjBCLENBRUk7QUFDL0IsU0FIRCxNQUlLO0FBQ0htcEIsZUFBS3pwQixRQUFMLENBQWMsZUFBZCxFQUErQjtBQUEvQixXQUNHTSxHQURILENBQ08sV0FEUCxFQUNvQixrQkFEcEI7QUFFQW9wQixzQkFBWXBwQixHQUFaLENBQWdCLEVBQUMsU0FBUyxDQUFWLEVBQWhCLEVBSEcsQ0FHNEI7QUFDaEM7O0FBRUQ7QUFDQSxZQUFJbXBCLEtBQUsxUSxRQUFMLENBQWMsT0FBZCxDQUFKLEVBQTRCO0FBQ3hCLGNBQUk1bUIsT0FBT29RLFVBQVAsR0FBb0IsR0FBeEIsRUFBNkI7QUFDM0JrbkIsaUJBQUtucEIsR0FBTCxDQUFTLFdBQVQsRUFBc0IsZUFBdEI7QUFDRDtBQUNGOztBQUVIO0FBQ0EsWUFBSW1wQixLQUFLMVEsUUFBTCxDQUFjLE9BQWQsQ0FBSixFQUE0QjtBQUMxQjdxQixZQUFFaUUsTUFBRixFQUFVZ3ZCLE1BQVYsQ0FBa0IsWUFBVztBQUMzQixnQkFBSWh2QixPQUFPb1EsVUFBUCxHQUFvQixHQUF4QixFQUE2QjtBQUMzQjtBQUNBLGtCQUFJclUsRUFBRSxrQkFBRixFQUFzQjBELE1BQXRCLEtBQWlDLENBQWpDLElBQXNDKzNCLE9BQTFDLEVBQW1EO0FBQ2pEQywyQkFBVyxJQUFYO0FBQ0QsZUFGRCxNQUdLO0FBQ0g7QUFDQUgscUJBQUtucEIsR0FBTCxDQUFTLFdBQVQsRUFBc0IsZ0JBQXRCO0FBQ0E7QUFDRDtBQUNGLGFBVkQsTUFXSyxJQUFJcXBCLFlBQVksS0FBaEIsRUFBc0I7QUFDekIsa0JBQUl6bEIsUUFBUW1sQixJQUFSLEtBQWlCLE1BQXJCLEVBQTZCO0FBQzNCSSxxQkFBS25wQixHQUFMLENBQVMsV0FBVCxFQUFzQixtQkFBdEI7QUFDRCxlQUZELE1BRU87QUFDTG1wQixxQkFBS25wQixHQUFMLENBQVMsV0FBVCxFQUFzQixrQkFBdEI7QUFDRDtBQUVGO0FBRUYsV0FyQkQ7QUFzQkQ7O0FBRUQ7QUFDQSxZQUFJNEQsUUFBUW9sQixZQUFSLEtBQXlCLElBQTdCLEVBQW1DO0FBQ2pDRyxlQUFLOVcsRUFBTCxDQUFRLGlCQUFSLEVBQTJCLDRCQUEzQixFQUF5RCxZQUFVO0FBQ2pFaVg7QUFDRCxXQUZEO0FBR0Q7O0FBRUQsWUFBSUEsYUFBYSxTQUFiQSxVQUFhLENBQVNDLFVBQVQsRUFBcUI7QUFDcENDLG9CQUFVLEtBQVY7QUFDQUgsb0JBQVUsS0FBVjtBQUNBO0FBQ0F6N0IsWUFBRSxNQUFGLEVBQVVvUyxHQUFWLENBQWM7QUFDWjBFLHNCQUFVLEVBREU7QUFFWnNYLG1CQUFPO0FBRkssV0FBZDs7QUFLQXB1QixZQUFFLGtCQUFGLEVBQXNCNk0sUUFBdEIsQ0FBK0IsRUFBQzZELFNBQVMsQ0FBVixFQUEvQixFQUE2QyxFQUFDckgsVUFBVSxHQUFYO0FBQ3pDakUsbUJBQU8sS0FEa0MsRUFDM0JsRixRQUFRLGFBRG1CO0FBRTNDd0wsc0JBQVUsb0JBQVc7QUFDbkIxTCxnQkFBRSxJQUFGLEVBQVFrUyxNQUFSO0FBQ0QsYUFKMEMsRUFBN0M7QUFLQSxjQUFJOEQsUUFBUW1sQixJQUFSLEtBQWlCLE1BQXJCLEVBQTZCO0FBQzNCO0FBQ0FLLHdCQUFZcHBCLEdBQVosQ0FBZ0IsRUFBQ2djLE9BQU8sRUFBUixFQUFZa0osT0FBTyxFQUFuQixFQUF1Qnh4QixNQUFNLEdBQTdCLEVBQWhCO0FBQ0F5MUIsaUJBQUsxdUIsUUFBTCxDQUNFLEVBQUMsY0FBYyxPQUFmLEVBREYsRUFFRSxFQUFFeEQsVUFBVSxHQUFaO0FBQ0VqRSxxQkFBTyxLQURUO0FBRUVsRixzQkFBUSxjQUZWO0FBR0V3TCx3QkFBVSxvQkFBVztBQUNuQixvQkFBSWl3QixlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCO0FBQ0FKLHVCQUFLbEosVUFBTCxDQUFnQixPQUFoQjtBQUNBa0osdUJBQUtucEIsR0FBTCxDQUFTLE9BQVQsRUFBa0I0RCxRQUFRa2xCLFNBQTFCO0FBQ0Q7QUFDRjs7QUFUSCxhQUZGO0FBY0QsV0FqQkQsTUFrQks7QUFDSDtBQUNBTSx3QkFBWXBwQixHQUFaLENBQWdCLEVBQUNnYyxPQUFPLEVBQVIsRUFBWWtKLE9BQU8sR0FBbkIsRUFBd0J4eEIsTUFBTSxFQUE5QixFQUFoQjtBQUNBeTFCLGlCQUFLMXVCLFFBQUwsQ0FDRSxFQUFDLGNBQWMsTUFBZixFQURGLEVBRUUsRUFBRXhELFVBQVUsR0FBWjtBQUNFakUscUJBQU8sS0FEVDtBQUVFbEYsc0JBQVEsY0FGVjtBQUdFd0wsd0JBQVUsb0JBQVc7QUFDbkIsb0JBQUlpd0IsZUFBZSxJQUFuQixFQUF5QjtBQUN2QjtBQUNBSix1QkFBS2xKLFVBQUwsQ0FBZ0IsT0FBaEI7QUFDQWtKLHVCQUFLbnBCLEdBQUwsQ0FBUyxPQUFULEVBQWtCNEQsUUFBUWtsQixTQUExQjtBQUNEO0FBQ0Y7QUFUSCxhQUZGO0FBYUQ7QUFDRixTQWpERDs7QUFxREE7QUFDQSxZQUFJVSxVQUFVLEtBQWQ7QUFDQSxZQUFJSCxVQUFVLEtBQWQ7O0FBRUEsWUFBSXpsQixRQUFRcWxCLFNBQVosRUFBdUI7QUFDckJHLHNCQUFZL1csRUFBWixDQUFlLE9BQWYsRUFBd0IsWUFBVTtBQUNoQyxnQkFBSWdYLE9BQUosRUFBYTtBQUNYQztBQUNEO0FBQ0YsV0FKRDs7QUFNQUYsc0JBQVloVSxNQUFaLENBQW1CO0FBQ2pCdVQsNkJBQWlCO0FBREEsV0FBbkIsRUFFR3hNLElBRkgsQ0FFUSxLQUZSLEVBRWUsVUFBUzlxQixDQUFULEVBQVk7O0FBRXpCLGdCQUFJQSxFQUFFcWMsT0FBRixDQUFVYyxXQUFWLElBQXlCLE9BQTdCLEVBQXNDOztBQUVwQyxrQkFBSWpPLFlBQVlsUCxFQUFFcWMsT0FBRixDQUFVbk4sU0FBMUI7QUFDQSxrQkFBSXJTLElBQUltRCxFQUFFcWMsT0FBRixDQUFVeEcsTUFBVixDQUFpQmhaLENBQXpCO0FBQ0Esa0JBQUk0SCxJQUFJekUsRUFBRXFjLE9BQUYsQ0FBVXhHLE1BQVYsQ0FBaUJwUixDQUF6QjtBQUNBLGtCQUFJMFMsWUFBWW5YLEVBQUVxYyxPQUFGLENBQVVsRixTQUExQjs7QUFFQTtBQUNBLGtCQUFJc1YsUUFBUWx3QixFQUFFLE1BQUYsQ0FBWjtBQUNBLGtCQUFJMnZCLFdBQVczdkIsRUFBRSxrQkFBRixDQUFmO0FBQ0Esa0JBQUltd0IsV0FBV0QsTUFBTTdiLFVBQU4sRUFBZjtBQUNBNmIsb0JBQU05ZCxHQUFOLENBQVUsVUFBVixFQUFzQixRQUF0QjtBQUNBOGQsb0JBQU05QixLQUFOLENBQVkrQixRQUFaOztBQUVBO0FBQ0Esa0JBQUlSLFNBQVNqc0IsTUFBVCxLQUFvQixDQUF4QixFQUEyQjtBQUN6QmlzQiwyQkFBVzN2QixFQUFFLGtDQUFGLENBQVg7QUFDQTJ2Qix5QkFBU3ZkLEdBQVQsQ0FBYSxTQUFiLEVBQXdCLENBQXhCLEVBQTJCa2UsS0FBM0IsQ0FBa0MsWUFBVTtBQUMxQ29MO0FBQ0QsaUJBRkQ7QUFHQTE3QixrQkFBRSxNQUFGLEVBQVVxd0IsTUFBVixDQUFpQlYsUUFBakI7QUFDRDs7QUFFRDtBQUNBLGtCQUFJM1osUUFBUW1sQixJQUFSLEtBQWlCLE1BQXJCLEVBQTZCO0FBQzNCLG9CQUFJNzZCLElBQUkwVixRQUFRa2xCLFNBQWhCLEVBQTJCO0FBQUU1NkIsc0JBQUkwVixRQUFRa2xCLFNBQVo7QUFBd0IsaUJBQXJELE1BQ0ssSUFBSTU2QixJQUFJLENBQVIsRUFBVztBQUFFQSxzQkFBSSxDQUFKO0FBQVE7QUFDM0I7O0FBRUQsa0JBQUkwVixRQUFRbWxCLElBQVIsS0FBaUIsTUFBckIsRUFBNkI7QUFDM0I7QUFDQSxvQkFBSTc2QixJQUFLMFYsUUFBUWtsQixTQUFSLEdBQW9CLENBQTdCLEVBQWlDO0FBQUVPLDRCQUFVLEtBQVY7QUFBa0I7QUFDckQ7QUFEQSxxQkFFSyxJQUFJbjdCLEtBQU0wVixRQUFRa2xCLFNBQVIsR0FBb0IsQ0FBOUIsRUFBa0M7QUFBRU8sOEJBQVUsSUFBVjtBQUFpQjtBQUMxREYscUJBQUtucEIsR0FBTCxDQUFTLFdBQVQsRUFBc0IsaUJBQWlCOVIsSUFBSTBWLFFBQVFrbEIsU0FBN0IsSUFBMEMsS0FBaEU7QUFDRCxlQU5ELE1BT0s7QUFDSDtBQUNBLG9CQUFJNTZCLElBQUsyRCxPQUFPb1EsVUFBUCxHQUFvQjJCLFFBQVFrbEIsU0FBUixHQUFvQixDQUFqRCxFQUFxRDtBQUNuRE8sNEJBQVUsSUFBVjtBQUNEO0FBQ0Q7QUFIQSxxQkFJSyxJQUFJbjdCLEtBQU0yRCxPQUFPb1EsVUFBUCxHQUFvQjJCLFFBQVFrbEIsU0FBUixHQUFvQixDQUFsRCxFQUFzRDtBQUMxRE8sOEJBQVUsS0FBVjtBQUNEO0FBQ0Esb0JBQUlJLFdBQVl2N0IsSUFBSTBWLFFBQVFrbEIsU0FBUixHQUFvQixDQUF4QztBQUNBLG9CQUFJVyxXQUFXLENBQWYsRUFBa0I7QUFDaEJBLDZCQUFXLENBQVg7QUFDRDs7QUFFRE4scUJBQUtucEIsR0FBTCxDQUFTLFdBQVQsRUFBc0IsZ0JBQWdCeXBCLFFBQWhCLEdBQTJCLEtBQWpEO0FBQ0Q7O0FBR0Q7QUFDQSxrQkFBSUMsV0FBSjtBQUNBLGtCQUFJOWxCLFFBQVFtbEIsSUFBUixLQUFpQixNQUFyQixFQUE2QjtBQUMzQlcsOEJBQWN4N0IsSUFBSTBWLFFBQVFrbEIsU0FBMUI7QUFDQXZMLHlCQUFTOWlCLFFBQVQsQ0FBa0IsRUFBQzZELFNBQVNvckIsV0FBVixFQUFsQixFQUEyQyxFQUFDenlCLFVBQVUsRUFBWCxFQUFlakUsT0FBTyxLQUF0QixFQUE2QmxGLFFBQVEsYUFBckMsRUFBM0M7QUFDRCxlQUhELE1BSUs7QUFDSDQ3Qiw4QkFBY3Q2QixLQUFLa0IsR0FBTCxDQUFTLENBQUNwQyxJQUFJMkQsT0FBT29RLFVBQVosSUFBMEIyQixRQUFRa2xCLFNBQTNDLENBQWQ7QUFDQXZMLHlCQUFTOWlCLFFBQVQsQ0FBa0IsRUFBQzZELFNBQVNvckIsV0FBVixFQUFsQixFQUEyQyxFQUFDenlCLFVBQVUsRUFBWCxFQUFlakUsT0FBTyxLQUF0QixFQUE2QmxGLFFBQVEsYUFBckMsRUFBM0M7QUFDRDtBQUNGO0FBRUYsV0F0RUQsRUFzRUdxdUIsSUF0RUgsQ0FzRVEsUUF0RVIsRUFzRWtCLFVBQVM5cUIsQ0FBVCxFQUFZOztBQUU1QixnQkFBSUEsRUFBRXFjLE9BQUYsQ0FBVWMsV0FBVixJQUF5QixPQUE3QixFQUFzQztBQUNwQyxrQkFBSStPLFdBQVczdkIsRUFBRSxrQkFBRixDQUFmO0FBQ0Esa0JBQUk0YSxZQUFZblgsRUFBRXFjLE9BQUYsQ0FBVWxGLFNBQTFCO0FBQ0Esa0JBQUl0YSxJQUFJbUQsRUFBRXFjLE9BQUYsQ0FBVXhHLE1BQVYsQ0FBaUJoWixDQUF6QjtBQUNBLGtCQUFJeTdCLFVBQVV6N0IsSUFBSTBWLFFBQVFrbEIsU0FBMUI7QUFDQSxrQkFBSVcsV0FBV3Y3QixJQUFJMFYsUUFBUWtsQixTQUFSLEdBQW9CLENBQXZDO0FBQ0Esa0JBQUlhLFVBQVUsQ0FBZCxFQUFrQjtBQUNoQkEsMEJBQVUsQ0FBVjtBQUNEO0FBQ0Qsa0JBQUlGLFdBQVcsQ0FBZixFQUFrQjtBQUNoQkEsMkJBQVcsQ0FBWDtBQUNEO0FBQ0RELHdCQUFVLEtBQVY7O0FBRUEsa0JBQUk1bEIsUUFBUW1sQixJQUFSLEtBQWlCLE1BQXJCLEVBQTZCO0FBQzNCO0FBQ0Esb0JBQUtNLFdBQVc3Z0IsYUFBYSxHQUF6QixJQUFpQ0EsWUFBWSxDQUFDLEdBQWxELEVBQXVEO0FBQ3JEO0FBQ0Esc0JBQUltaEIsWUFBWSxDQUFoQixFQUFtQjtBQUNqQlIseUJBQUsxdUIsUUFBTCxDQUFjLEVBQUMsY0FBYyxDQUFDLENBQUQsRUFBSWt2QixPQUFKLENBQWYsRUFBZCxFQUE0QyxFQUFDMXlCLFVBQVUsR0FBWCxFQUFnQmpFLE9BQU8sS0FBdkIsRUFBOEJsRixRQUFRLGFBQXRDLEVBQTVDO0FBQ0Q7O0FBRUR5dkIsMkJBQVM5aUIsUUFBVCxDQUFrQixFQUFDNkQsU0FBUyxDQUFWLEVBQWxCLEVBQWlDLEVBQUNySCxVQUFVLEVBQVgsRUFBZWpFLE9BQU8sS0FBdEIsRUFBNkJsRixRQUFRLGFBQXJDLEVBQWpDO0FBQ0FzN0IsOEJBQVlwcEIsR0FBWixDQUFnQixFQUFDZ2MsT0FBTyxLQUFSLEVBQWVrSixPQUFPLENBQXRCLEVBQXlCeHhCLE1BQU0sRUFBL0IsRUFBaEI7QUFDQTIxQiw0QkFBVSxJQUFWO0FBQ0QsaUJBVEQsTUFVSyxJQUFJLENBQUNBLE9BQUQsSUFBWTdnQixZQUFZLEdBQTVCLEVBQWlDO0FBQ3BDO0FBQ0E1YSxvQkFBRSxNQUFGLEVBQVVvUyxHQUFWLENBQWM7QUFDWjBFLDhCQUFVLEVBREU7QUFFWnNYLDJCQUFPO0FBRkssbUJBQWQ7QUFJQTtBQUNBbU4sdUJBQUsxdUIsUUFBTCxDQUFjLEVBQUMsY0FBYyxDQUFDLENBQUMsQ0FBRCxHQUFLbUosUUFBUWtsQixTQUFiLEdBQXlCLEVBQTFCLEVBQThCYSxPQUE5QixDQUFmLEVBQWQsRUFBc0UsRUFBQzF5QixVQUFVLEdBQVgsRUFBZ0JqRSxPQUFPLEtBQXZCLEVBQThCbEYsUUFBUSxhQUF0QyxFQUF0RTtBQUNBeXZCLDJCQUFTOWlCLFFBQVQsQ0FBa0IsRUFBQzZELFNBQVMsQ0FBVixFQUFsQixFQUFpQyxFQUFDckgsVUFBVSxHQUFYLEVBQWdCakUsT0FBTyxLQUF2QixFQUE4QmxGLFFBQVEsYUFBdEM7QUFDL0J3TCw4QkFBVSxvQkFBWTtBQUNwQjFMLHdCQUFFLElBQUYsRUFBUWtTLE1BQVI7QUFDRCxxQkFIOEIsRUFBakM7QUFJQXNwQiw4QkFBWXBwQixHQUFaLENBQWdCLEVBQUNnYyxPQUFPLE1BQVIsRUFBZ0JrSixPQUFPLEVBQXZCLEVBQTJCeHhCLE1BQU0sQ0FBakMsRUFBaEI7QUFDRDtBQUNGLGVBMUJELE1BMkJLO0FBQ0gsb0JBQUsyMUIsV0FBVzdnQixhQUFhLENBQUMsR0FBMUIsSUFBa0NBLFlBQVksR0FBbEQsRUFBdUQ7QUFDckQ7QUFDQSxzQkFBSWloQixhQUFhLENBQWpCLEVBQW9CO0FBQ2xCTix5QkFBSzF1QixRQUFMLENBQWMsRUFBQyxjQUFjLENBQUMsQ0FBRCxFQUFJZ3ZCLFFBQUosQ0FBZixFQUFkLEVBQTZDLEVBQUN4eUIsVUFBVSxHQUFYLEVBQWdCakUsT0FBTyxLQUF2QixFQUE4QmxGLFFBQVEsYUFBdEMsRUFBN0M7QUFDRDs7QUFFRHl2QiwyQkFBUzlpQixRQUFULENBQWtCLEVBQUM2RCxTQUFTLENBQVYsRUFBbEIsRUFBaUMsRUFBQ3JILFVBQVUsRUFBWCxFQUFlakUsT0FBTyxLQUF0QixFQUE2QmxGLFFBQVEsYUFBckMsRUFBakM7QUFDQXM3Qiw4QkFBWXBwQixHQUFaLENBQWdCLEVBQUNnYyxPQUFPLEtBQVIsRUFBZWtKLE9BQU8sRUFBdEIsRUFBMEJ4eEIsTUFBTSxDQUFoQyxFQUFoQjtBQUNBMjFCLDRCQUFVLElBQVY7QUFDRCxpQkFURCxNQVVLLElBQUksQ0FBQ0EsT0FBRCxJQUFZN2dCLFlBQVksQ0FBQyxHQUE3QixFQUFrQztBQUNyQztBQUNBNWEsb0JBQUUsTUFBRixFQUFVb1MsR0FBVixDQUFjO0FBQ1owRSw4QkFBVSxFQURFO0FBRVpzWCwyQkFBTztBQUZLLG1CQUFkOztBQUtBO0FBQ0FtTix1QkFBSzF1QixRQUFMLENBQWMsRUFBQyxjQUFjLENBQUNtSixRQUFRa2xCLFNBQVIsR0FBb0IsRUFBckIsRUFBeUJXLFFBQXpCLENBQWYsRUFBZCxFQUFrRSxFQUFDeHlCLFVBQVUsR0FBWCxFQUFnQmpFLE9BQU8sS0FBdkIsRUFBOEJsRixRQUFRLGFBQXRDLEVBQWxFO0FBQ0F5dkIsMkJBQVM5aUIsUUFBVCxDQUFrQixFQUFDNkQsU0FBUyxDQUFWLEVBQWxCLEVBQWlDLEVBQUNySCxVQUFVLEdBQVgsRUFBZ0JqRSxPQUFPLEtBQXZCLEVBQThCbEYsUUFBUSxhQUF0QztBQUMvQndMLDhCQUFVLG9CQUFZO0FBQ3BCMUwsd0JBQUUsSUFBRixFQUFRa1MsTUFBUjtBQUNELHFCQUg4QixFQUFqQztBQUlBc3BCLDhCQUFZcHBCLEdBQVosQ0FBZ0IsRUFBQ2djLE9BQU8sTUFBUixFQUFnQmtKLE9BQU8sQ0FBdkIsRUFBMEJ4eEIsTUFBTSxFQUFoQyxFQUFoQjtBQUNEO0FBQ0Y7QUFFRjtBQUNGLFdBOUlEO0FBK0lEOztBQUVEeWtCLGNBQU03RixHQUFOLENBQVUsZUFBVixFQUEyQkQsRUFBM0IsQ0FBOEIsZUFBOUIsRUFBK0MsWUFBVztBQUN4RCxjQUFJZ1gsWUFBWSxJQUFoQixFQUFzQjtBQUNwQkEsc0JBQVUsS0FBVjtBQUNBRyxzQkFBVSxLQUFWO0FBQ0FGO0FBQ0QsV0FKRCxNQUtLOztBQUVIO0FBQ0EsZ0JBQUl4TCxRQUFRbHdCLEVBQUUsTUFBRixDQUFaO0FBQ0EsZ0JBQUkydkIsV0FBVzN2QixFQUFFLGtDQUFGLENBQWY7QUFDQSxnQkFBSW13QixXQUFXRCxNQUFNN2IsVUFBTixFQUFmO0FBQ0E2YixrQkFBTTlkLEdBQU4sQ0FBVSxVQUFWLEVBQXNCLFFBQXRCO0FBQ0E4ZCxrQkFBTTlCLEtBQU4sQ0FBWStCLFFBQVo7O0FBRUE7QUFDQW53QixjQUFFLE1BQUYsRUFBVXF3QixNQUFWLENBQWlCbUwsV0FBakI7O0FBRUEsZ0JBQUl4bEIsUUFBUW1sQixJQUFSLEtBQWlCLE1BQXJCLEVBQTZCO0FBQzNCSywwQkFBWXBwQixHQUFaLENBQWdCLEVBQUNnYyxPQUFPLEtBQVIsRUFBZWtKLE9BQU8sQ0FBdEIsRUFBeUJ4eEIsTUFBTSxFQUEvQixFQUFoQjtBQUNBeTFCLG1CQUFLMXVCLFFBQUwsQ0FBYyxFQUFDLGNBQWMsQ0FBQyxDQUFELEVBQUksQ0FBQyxDQUFELEdBQUttSixRQUFRa2xCLFNBQWpCLENBQWYsRUFBZCxFQUEyRCxFQUFDN3hCLFVBQVUsR0FBWCxFQUFnQmpFLE9BQU8sS0FBdkIsRUFBOEJsRixRQUFRLGFBQXRDLEVBQTNEO0FBQ0QsYUFIRCxNQUlLO0FBQ0hzN0IsMEJBQVlwcEIsR0FBWixDQUFnQixFQUFDZ2MsT0FBTyxLQUFSLEVBQWVrSixPQUFPLEVBQXRCLEVBQTBCeHhCLE1BQU0sQ0FBaEMsRUFBaEI7QUFDQXkxQixtQkFBSzF1QixRQUFMLENBQWMsRUFBQyxjQUFjLENBQUMsQ0FBRCxFQUFJbUosUUFBUWtsQixTQUFaLENBQWYsRUFBZCxFQUFzRCxFQUFDN3hCLFVBQVUsR0FBWCxFQUFnQmpFLE9BQU8sS0FBdkIsRUFBOEJsRixRQUFRLGFBQXRDLEVBQXREO0FBQ0Q7O0FBRUR5dkIscUJBQVN2ZCxHQUFULENBQWEsU0FBYixFQUF3QixDQUF4QixFQUNDa2UsS0FERCxDQUNPLFlBQVU7QUFDZm1MLHdCQUFVLEtBQVY7QUFDQUcsd0JBQVUsS0FBVjtBQUNBRjtBQUNBL0wsdUJBQVM5aUIsUUFBVCxDQUFrQixFQUFDNkQsU0FBUyxDQUFWLEVBQWxCLEVBQWdDLEVBQUNySCxVQUFVLEdBQVgsRUFBZ0JqRSxPQUFPLEtBQXZCLEVBQThCbEYsUUFBUSxhQUF0QztBQUM5QndMLDBCQUFVLG9CQUFXO0FBQ25CMUwsb0JBQUUsSUFBRixFQUFRa1MsTUFBUjtBQUNELGlCQUg2QixFQUFoQztBQUtELGFBVkQ7QUFXQWxTLGNBQUUsTUFBRixFQUFVcXdCLE1BQVYsQ0FBaUJWLFFBQWpCO0FBQ0FBLHFCQUFTOWlCLFFBQVQsQ0FBa0IsRUFBQzZELFNBQVMsQ0FBVixFQUFsQixFQUFnQyxFQUFDckgsVUFBVSxHQUFYLEVBQWdCakUsT0FBTyxLQUF2QixFQUE4QmxGLFFBQVEsYUFBdEM7QUFDOUJ3TCx3QkFBVSxvQkFBWTtBQUNwQit2QiwwQkFBVSxJQUFWO0FBQ0FHLDBCQUFVLEtBQVY7QUFDRDtBQUo2QixhQUFoQztBQU1EOztBQUVELGlCQUFPLEtBQVA7QUFDRCxTQWhERDtBQWlERCxPQTVVRDtBQStVRCxLQXpWVztBQTBWWnZiLGFBQVMsbUJBQVk7QUFDbkIsVUFBSXNQLFdBQVczdkIsRUFBRSxrQkFBRixDQUFmO0FBQ0EsVUFBSXc3QixjQUFjeDdCLEVBQUUsZ0NBQWdDQSxFQUFFLElBQUYsRUFBUXNvQixJQUFSLENBQWEsZ0JBQWIsQ0FBaEMsR0FBaUUsSUFBbkUsQ0FBbEI7QUFDQXFILGVBQVNqSSxPQUFULENBQWlCLE9BQWpCO0FBQ0E4VCxrQkFBWXRwQixNQUFaO0FBQ0FsUyxRQUFFLElBQUYsRUFBUTBrQixHQUFSLENBQVksT0FBWjtBQUNBaUwsZUFBU3pkLE1BQVQ7QUFDRCxLQWpXVztBQWtXWmtqQixVQUFPLGdCQUFXO0FBQ2hCLFdBQUsxTixPQUFMLENBQWEsT0FBYjtBQUNELEtBcFdXO0FBcVdadU4sVUFBTyxnQkFBVztBQUNoQmoxQixRQUFFLGtCQUFGLEVBQXNCMG5CLE9BQXRCLENBQThCLE9BQTlCO0FBQ0Q7QUF2V1csR0FBZDs7QUEyV0ExbkIsSUFBRStELEVBQUYsQ0FBS2k0QixPQUFMLEdBQWUsVUFBU3JMLGVBQVQsRUFBMEI7QUFDdkMsUUFBS3hCLFFBQVF3QixlQUFSLENBQUwsRUFBZ0M7QUFDOUIsYUFBT3hCLFFBQVN3QixlQUFULEVBQTJCL3JCLEtBQTNCLENBQWtDLElBQWxDLEVBQXdDTixNQUFNSSxTQUFOLENBQWdCaUQsS0FBaEIsQ0FBc0J2RCxJQUF0QixDQUE0QmEsU0FBNUIsRUFBdUMsQ0FBdkMsQ0FBeEMsQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFLLFFBQU8wckIsZUFBUCx5Q0FBT0EsZUFBUCxPQUEyQixRQUEzQixJQUF1QyxDQUFFQSxlQUE5QyxFQUFnRTtBQUNyRTtBQUNBLGFBQU94QixRQUFRbnJCLElBQVIsQ0FBYVksS0FBYixDQUFvQixJQUFwQixFQUEwQkssU0FBMUIsQ0FBUDtBQUNELEtBSE0sTUFHQTtBQUNMakYsUUFBRTR3QixLQUFGLENBQVMsWUFBYUQsZUFBYixHQUErQixtQ0FBeEM7QUFDRDtBQUNGLEdBVEQsQ0E3V2EsQ0FzWFY7QUFDSixDQXZYQyxFQXVYQzV3QixNQXZYRCxDQUFEO0FBd1hELEMsQ0FBQzs7Ozs7Ozs7Ozs7O0FBWUQsQ0FBQyxVQUFTQyxDQUFULEVBQVk7O0FBRVosTUFBSWk4QixVQUFVajhCLEVBQUVpRSxNQUFGLENBQWQ7QUFDQSxNQUFJOFIsV0FBVyxFQUFmO0FBQ0EsTUFBSW1tQixpQkFBaUIsRUFBckI7QUFDQSxNQUFJQyxXQUFXLEtBQWY7QUFDQSxNQUFJQyxRQUFRLENBQVo7QUFDQSxNQUFJQyxZQUFZLENBQWhCO0FBQ0EsTUFBSTEyQixTQUFTO0FBQ1pFLFNBQU0sQ0FETTtBQUVaeXhCLFdBQVEsQ0FGSTtBQUdaeEgsWUFBUyxDQUhHO0FBSVpocUIsVUFBTzs7QUFHUjs7Ozs7Ozs7QUFQYSxHQUFiLENBZUEsU0FBU3cyQixZQUFULENBQXNCejJCLEdBQXRCLEVBQTJCeXhCLEtBQTNCLEVBQWtDeEgsTUFBbEMsRUFBMENocUIsSUFBMUMsRUFBZ0Q7QUFDL0MsUUFBSXkyQixPQUFPdjhCLEdBQVg7QUFDQUEsTUFBRTJFLElBQUYsQ0FBT29SLFFBQVAsRUFBaUIsVUFBUzVSLENBQVQsRUFBWW1GLE9BQVosRUFBcUI7QUFDckMsVUFBSUEsUUFBUW9OLE1BQVIsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDekIsWUFBSThsQixRQUFRbHpCLFFBQVEzRCxNQUFSLEdBQWlCRSxHQUE3QjtBQUFBLFlBQ0M0MkIsU0FBU256QixRQUFRM0QsTUFBUixHQUFpQkcsSUFEM0I7QUFBQSxZQUVDNDJCLFVBQVVELFNBQVNuekIsUUFBUThrQixLQUFSLEVBRnBCO0FBQUEsWUFHQ3VPLFdBQVdILFFBQVFsekIsUUFBUW9OLE1BQVIsRUFIcEI7O0FBS0EsWUFBSWttQixjQUFjLEVBQUVILFNBQVNuRixLQUFULElBQ25Cb0YsVUFBVTUyQixJQURTLElBRW5CMDJCLFFBQVExTSxNQUZXLElBR25CNk0sV0FBVzkyQixHQUhNLENBQWxCOztBQUtBLFlBQUkrMkIsV0FBSixFQUFpQjtBQUNoQkwsZUFBS2ozQixJQUFMLENBQVVnRSxPQUFWO0FBQ0E7QUFDRDtBQUNELEtBaEJEOztBQWtCQSxXQUFPaXpCLElBQVA7QUFDQTs7QUFHRDs7O0FBR0EsV0FBU00sUUFBVCxDQUFrQkMsWUFBbEIsRUFBZ0M7QUFDL0I7QUFDQSxNQUFFVixLQUFGOztBQUVBO0FBQ0EsUUFBSXYyQixNQUFNbzJCLFFBQVFoMkIsU0FBUixFQUFWO0FBQUEsUUFDQ0gsT0FBT20yQixRQUFRNzFCLFVBQVIsRUFEUjtBQUFBLFFBRUNreEIsUUFBUXh4QixPQUFPbTJCLFFBQVE3TixLQUFSLEVBRmhCO0FBQUEsUUFHQzBCLFNBQVNqcUIsTUFBTW8yQixRQUFRdmxCLE1BQVIsRUFIaEI7O0FBS0E7QUFDQSxRQUFJcW1CLGdCQUFnQlQsYUFBYXoyQixNQUFJRixPQUFPRSxHQUFYLEdBQWlCaTNCLFlBQWpCLElBQWlDLEdBQTlDLEVBQW1EeEYsUUFBTTN4QixPQUFPMnhCLEtBQWhFLEVBQXVFeEgsU0FBT25xQixPQUFPbXFCLE1BQXJGLEVBQTZGaHFCLE9BQUtILE9BQU9HLElBQXpHLENBQXBCO0FBQ0E5RixNQUFFMkUsSUFBRixDQUFPbzRCLGFBQVAsRUFBc0IsVUFBUzU0QixDQUFULEVBQVltRixPQUFaLEVBQXFCOztBQUUxQyxVQUFJMHpCLFdBQVcxekIsUUFBUXpFLElBQVIsQ0FBYSxpQkFBYixDQUFmO0FBQ0EsVUFBSSxPQUFPbTRCLFFBQVAsSUFBbUIsUUFBdkIsRUFBaUM7QUFDaEM7QUFDQTF6QixnQkFBUTJ6QixjQUFSLENBQXVCLGlCQUF2QjtBQUNBOztBQUVEO0FBQ0EzekIsY0FBUXpFLElBQVIsQ0FBYSxpQkFBYixFQUFnQ3UzQixLQUFoQztBQUNBLEtBVkQ7O0FBWUE7QUFDQXA4QixNQUFFMkUsSUFBRixDQUFPdTNCLGNBQVAsRUFBdUIsVUFBUy8zQixDQUFULEVBQVltRixPQUFaLEVBQXFCO0FBQzNDLFVBQUkwekIsV0FBVzF6QixRQUFRekUsSUFBUixDQUFhLGlCQUFiLENBQWY7QUFDQSxVQUFJLE9BQU9tNEIsUUFBUCxJQUFtQixRQUFuQixJQUErQkEsYUFBYVosS0FBaEQsRUFBdUQ7QUFDdEQ7QUFDQTl5QixnQkFBUTJ6QixjQUFSLENBQXVCLGdCQUF2QjtBQUNBM3pCLGdCQUFRekUsSUFBUixDQUFhLGlCQUFiLEVBQWdDLElBQWhDO0FBQ0E7QUFDRCxLQVBEOztBQVNBO0FBQ0FxM0IscUJBQWlCYSxhQUFqQjtBQUNBOztBQUVEOzs7QUFHQSxXQUFTRyxTQUFULEdBQXFCO0FBQ3BCakIsWUFBUXZVLE9BQVIsQ0FBZ0IsbUJBQWhCO0FBQ0E7O0FBR0Q7Ozs7Ozs7Ozs7O0FBV0ExbkIsSUFBRW05QixTQUFGLEdBQWMsVUFBU0MsUUFBVCxFQUFtQnBuQixPQUFuQixFQUE0QjtBQUN4QyxRQUFJOU0sV0FBVztBQUNma2dCLGdCQUFVLEdBREs7QUFFZjBULG9CQUFjLEdBRkMsQ0FFRztBQUZILEtBQWY7QUFJQzltQixjQUFVaFcsRUFBRUcsTUFBRixDQUFTK0ksUUFBVCxFQUFtQjhNLE9BQW5CLENBQVY7O0FBRUYsUUFBSXFuQixVQUFVLEVBQWQ7QUFDQUQsZUFBV3A5QixFQUFFbzlCLFFBQUYsQ0FBWDtBQUNBQSxhQUFTejRCLElBQVQsQ0FBYyxVQUFTUixDQUFULEVBQVltRixPQUFaLEVBQXFCO0FBQ2xDeU0sZUFBU3pRLElBQVQsQ0FBY3RGLEVBQUVzSixPQUFGLENBQWQ7QUFDQXRKLFFBQUVzSixPQUFGLEVBQVd6RSxJQUFYLENBQWdCLGNBQWhCLEVBQWdDVixDQUFoQztBQUNBO0FBQ0NuRSxRQUFFLGNBQWNBLEVBQUVzSixPQUFGLEVBQVdnZixJQUFYLENBQWdCLElBQWhCLENBQWQsR0FBc0MsSUFBeEMsRUFBOENnSSxLQUE5QyxDQUFvRCxVQUFTN3NCLENBQVQsRUFBWTtBQUM5REEsVUFBRTZlLGNBQUY7QUFDQSxZQUFJM2MsU0FBUzNGLEVBQUU0bkIsWUFBWWlCLFVBQVosQ0FBdUIsS0FBS0MsSUFBNUIsQ0FBRixFQUFxQ25qQixNQUFyQyxHQUE4Q0UsR0FBOUMsR0FBb0QsQ0FBakU7QUFDQTdGLFVBQUUsWUFBRixFQUFnQjhNLE9BQWhCLENBQXdCLEVBQUU3RyxXQUFXTixTQUFTcVEsUUFBUThtQixZQUE5QixFQUF4QixFQUFzRSxFQUFDenpCLFVBQVUsR0FBWCxFQUFnQmpFLE9BQU8sS0FBdkIsRUFBOEJsRixRQUFRLGNBQXRDLEVBQXRFO0FBQ0QsT0FKRDtBQUtELEtBVEQ7O0FBV0F5RixXQUFPRSxHQUFQLEdBQWFtUSxRQUFRd1gsU0FBUixJQUFxQixDQUFsQztBQUNBN25CLFdBQU8yeEIsS0FBUCxHQUFldGhCLFFBQVFzWSxXQUFSLElBQXVCLENBQXRDO0FBQ0Ezb0IsV0FBT21xQixNQUFQLEdBQWdCOVosUUFBUXNuQixZQUFSLElBQXdCLENBQXhDO0FBQ0EzM0IsV0FBT0csSUFBUCxHQUFja1EsUUFBUXVYLFVBQVIsSUFBc0IsQ0FBcEM7O0FBRUEsUUFBSWdRLGtCQUFrQjNWLFlBQVl3QixRQUFaLENBQXFCLFlBQVc7QUFDckR5VCxlQUFTN21CLFFBQVE4bUIsWUFBakI7QUFDQSxLQUZxQixFQUVuQjltQixRQUFRb1QsUUFBUixJQUFvQixHQUZELENBQXRCO0FBR0EsUUFBSW9VLGNBQWMsU0FBZEEsV0FBYyxHQUFVO0FBQzNCeDlCLFFBQUVnRyxRQUFGLEVBQVlrbUIsS0FBWixDQUFrQnFSLGVBQWxCO0FBQ0EsS0FGRDs7QUFJQSxRQUFJLENBQUNwQixRQUFMLEVBQWU7QUFDZEYsY0FBUXhYLEVBQVIsQ0FBVyxRQUFYLEVBQXFCK1ksV0FBckI7QUFDQXZCLGNBQVF4WCxFQUFSLENBQVcsUUFBWCxFQUFxQitZLFdBQXJCO0FBQ0FyQixpQkFBVyxJQUFYO0FBQ0E7O0FBRUQ7QUFDQXh3QixlQUFXNnhCLFdBQVgsRUFBd0IsQ0FBeEI7O0FBR0FKLGFBQVMzWSxFQUFULENBQVksaUJBQVosRUFBK0IsWUFBVztBQUN6QzRZLGdCQUFVcjlCLEVBQUV5OUIsSUFBRixDQUFPSixPQUFQLEVBQWdCLFVBQVNLLEtBQVQsRUFBZ0I7QUFDdEMsZUFBT0EsTUFBTWhuQixNQUFOLE1BQWtCLENBQXpCO0FBQ0QsT0FGTyxDQUFWOztBQUlBLFVBQUk2VCxRQUFRdnFCLEVBQUUsSUFBRixDQUFaOztBQUVBLFVBQUlxOUIsUUFBUSxDQUFSLENBQUosRUFBZ0I7QUFDZnI5QixVQUFFLGNBQWNxOUIsUUFBUSxDQUFSLEVBQVcvVSxJQUFYLENBQWdCLElBQWhCLENBQWQsR0FBc0MsSUFBeEMsRUFBOEM3YyxXQUE5QyxDQUEwRCxRQUExRDtBQUNBLFlBQUk4ZSxNQUFNMWxCLElBQU4sQ0FBVyxjQUFYLElBQTZCdzRCLFFBQVEsQ0FBUixFQUFXeDRCLElBQVgsQ0FBZ0IsY0FBaEIsQ0FBakMsRUFBa0U7QUFDakV3NEIsa0JBQVE1M0IsT0FBUixDQUFnQnpGLEVBQUUsSUFBRixDQUFoQjtBQUNBLFNBRkQsTUFHSztBQUNKcTlCLGtCQUFRLzNCLElBQVIsQ0FBYXRGLEVBQUUsSUFBRixDQUFiO0FBQ0E7QUFDRCxPQVJELE1BU0s7QUFDSnE5QixnQkFBUS8zQixJQUFSLENBQWF0RixFQUFFLElBQUYsQ0FBYjtBQUNBOztBQUdEQSxRQUFFLGNBQWNxOUIsUUFBUSxDQUFSLEVBQVcvVSxJQUFYLENBQWdCLElBQWhCLENBQWQsR0FBc0MsSUFBeEMsRUFBOEN4VyxRQUE5QyxDQUF1RCxRQUF2RDtBQUNBLEtBdEJEO0FBdUJBc3JCLGFBQVMzWSxFQUFULENBQVksZ0JBQVosRUFBOEIsWUFBVztBQUN4QzRZLGdCQUFVcjlCLEVBQUV5OUIsSUFBRixDQUFPSixPQUFQLEVBQWdCLFVBQVNLLEtBQVQsRUFBZ0I7QUFDdEMsZUFBT0EsTUFBTWhuQixNQUFOLE1BQWtCLENBQXpCO0FBQ0QsT0FGTyxDQUFWOztBQUlBLFVBQUkybUIsUUFBUSxDQUFSLENBQUosRUFBZ0I7QUFDZnI5QixVQUFFLGNBQWNxOUIsUUFBUSxDQUFSLEVBQVcvVSxJQUFYLENBQWdCLElBQWhCLENBQWQsR0FBc0MsSUFBeEMsRUFBOEM3YyxXQUE5QyxDQUEwRCxRQUExRDtBQUNBLFlBQUk4ZSxRQUFRdnFCLEVBQUUsSUFBRixDQUFaO0FBQ0FxOUIsa0JBQVVyOUIsRUFBRXk5QixJQUFGLENBQU9KLE9BQVAsRUFBZ0IsVUFBU0ssS0FBVCxFQUFnQjtBQUNyQyxpQkFBT0EsTUFBTXBWLElBQU4sQ0FBVyxJQUFYLEtBQW9CaUMsTUFBTWpDLElBQU4sQ0FBVyxJQUFYLENBQTNCO0FBQ0QsU0FGTSxDQUFWO0FBR0csWUFBSStVLFFBQVEsQ0FBUixDQUFKLEVBQWdCO0FBQUU7QUFDcEJyOUIsWUFBRSxjQUFjcTlCLFFBQVEsQ0FBUixFQUFXL1UsSUFBWCxDQUFnQixJQUFoQixDQUFkLEdBQXNDLElBQXhDLEVBQThDeFcsUUFBOUMsQ0FBdUQsUUFBdkQ7QUFDRztBQUNKO0FBQ0QsS0FmRDs7QUFpQkEsV0FBT3NyQixRQUFQO0FBQ0EsR0FuRkQ7O0FBcUZBOzs7OztBQUtBcDlCLElBQUUyOUIsVUFBRixHQUFlLFVBQVMzbkIsT0FBVCxFQUFrQjtBQUNoQ2hXLE1BQUUyOUIsVUFBRixHQUFlLFlBQVc7QUFBRSxhQUFPMUIsT0FBUDtBQUFpQixLQUE3QyxDQURnQyxDQUNlO0FBQy9Dam1CLGNBQVVBLFdBQVc7QUFDcEJvVCxnQkFBVTtBQURVLEtBQXJCO0FBR0EsV0FBTzZTLFFBQVF4WCxFQUFSLENBQVcsUUFBWCxFQUFxQm1ELFlBQVl3QixRQUFaLENBQXFCOFQsU0FBckIsRUFBZ0NsbkIsUUFBUW9ULFFBQVIsSUFBb0IsR0FBcEQsQ0FBckIsQ0FBUDtBQUNBLEdBTkQ7O0FBUUE7Ozs7Ozs7Ozs7O0FBV0FwcEIsSUFBRStELEVBQUYsQ0FBS281QixTQUFMLEdBQWlCLFVBQVNubkIsT0FBVCxFQUFrQjtBQUNsQyxXQUFPaFcsRUFBRW05QixTQUFGLENBQVluOUIsRUFBRSxJQUFGLENBQVosRUFBcUJnVyxPQUFyQixDQUFQO0FBQ0EsR0FGRDtBQUlBLENBNU5ELEVBNE5HalcsTUE1Tkg7QUE2TkEsQ0FBRSxXQUFVQyxDQUFWLEVBQWE7QUFDYkEsSUFBRWdHLFFBQUYsRUFBWWttQixLQUFaLENBQWtCLFlBQVc7O0FBRTNCO0FBQ0F0RSxnQkFBWWdXLGdCQUFaLEdBQStCLFlBQVc7QUFDeEMsVUFBSUMsaUJBQWlCLCtJQUFyQjtBQUNBNzlCLFFBQUU2OUIsY0FBRixFQUFrQmw1QixJQUFsQixDQUF1QixVQUFTcXZCLEtBQVQsRUFBZ0IxcUIsT0FBaEIsRUFBeUI7QUFDOUMsWUFBSWloQixRQUFRdnFCLEVBQUUsSUFBRixDQUFaO0FBQ0EsWUFBSUEsRUFBRXNKLE9BQUYsRUFBV3cwQixHQUFYLEdBQWlCcDZCLE1BQWpCLEdBQTBCLENBQTFCLElBQStCNEYsUUFBUXkwQixTQUF2QyxJQUFvRHhULE1BQU1qQyxJQUFOLENBQVcsYUFBWCxNQUE4QnZsQixTQUF0RixFQUFpRztBQUMvRnduQixnQkFBTVEsUUFBTixDQUFlLE9BQWYsRUFBd0JqWixRQUF4QixDQUFpQyxRQUFqQztBQUNELFNBRkQsTUFFTyxJQUFJOVIsRUFBRXNKLE9BQUYsRUFBVyxDQUFYLEVBQWMwMEIsUUFBbEIsRUFBNEI7QUFDakN6VCxnQkFBTVEsUUFBTixDQUFlLE9BQWYsRUFBd0JVLFdBQXhCLENBQW9DLFFBQXBDLEVBQThDenJCLEVBQUVzSixPQUFGLEVBQVcsQ0FBWCxFQUFjMDBCLFFBQWQsQ0FBdUJDLFFBQXZCLEtBQW9DLElBQWxGO0FBQ0QsU0FGTSxNQUVBO0FBQ0wxVCxnQkFBTVEsUUFBTixDQUFlLE9BQWYsRUFBd0J0ZixXQUF4QixDQUFvQyxRQUFwQztBQUNEO0FBQ0YsT0FURDtBQVVELEtBWkQ7O0FBY0E7QUFDQSxRQUFJb3lCLGlCQUFpQiwrSUFBckI7O0FBRUE7QUFDQTc5QixNQUFFZ0csUUFBRixFQUFZeWUsRUFBWixDQUFlLFFBQWYsRUFBeUJvWixjQUF6QixFQUF5QyxZQUFZO0FBQ25ELFVBQUc3OUIsRUFBRSxJQUFGLEVBQVE4OUIsR0FBUixHQUFjcDZCLE1BQWQsS0FBeUIsQ0FBekIsSUFBOEIxRCxFQUFFLElBQUYsRUFBUXNvQixJQUFSLENBQWEsYUFBYixNQUFnQ3ZsQixTQUFqRSxFQUE0RTtBQUMxRS9DLFVBQUUsSUFBRixFQUFRK3FCLFFBQVIsQ0FBaUIsT0FBakIsRUFBMEJqWixRQUExQixDQUFtQyxRQUFuQztBQUNEO0FBQ0Rvc0IscUJBQWVsK0IsRUFBRSxJQUFGLENBQWY7QUFDRCxLQUxEOztBQU9BO0FBQ0FBLE1BQUVnRyxRQUFGLEVBQVlrbUIsS0FBWixDQUFrQixZQUFXO0FBQzNCdEUsa0JBQVlnVyxnQkFBWjtBQUNELEtBRkQ7O0FBSUE7QUFDQTU5QixNQUFFZ0csUUFBRixFQUFZeWUsRUFBWixDQUFlLE9BQWYsRUFBd0IsVUFBU2hoQixDQUFULEVBQVk7QUFDbEMsVUFBSTA2QixZQUFZbitCLEVBQUV5RCxFQUFFb1UsTUFBSixDQUFoQjtBQUNBLFVBQUlzbUIsVUFBVS9TLEVBQVYsQ0FBYSxNQUFiLENBQUosRUFBMEI7QUFDeEIrUyxrQkFBVTFULElBQVYsQ0FBZW9ULGNBQWYsRUFBK0JweUIsV0FBL0IsQ0FBMkMsT0FBM0MsRUFBb0RBLFdBQXBELENBQWdFLFNBQWhFO0FBQ0EweUIsa0JBQVUxVCxJQUFWLENBQWVvVCxjQUFmLEVBQStCbDVCLElBQS9CLENBQW9DLFlBQVk7QUFDOUMsY0FBSTNFLEVBQUUsSUFBRixFQUFRc29CLElBQVIsQ0FBYSxPQUFiLE1BQTBCLEVBQTlCLEVBQWtDO0FBQ2hDdG9CLGNBQUUsSUFBRixFQUFRK3FCLFFBQVIsQ0FBaUIsT0FBakIsRUFBMEJ0ZixXQUExQixDQUFzQyxRQUF0QztBQUNEO0FBQ0YsU0FKRDs7QUFNQTtBQUNBMHlCLGtCQUFVMVQsSUFBVixDQUFlLG9CQUFmLEVBQXFDOWxCLElBQXJDLENBQTBDLFlBQVk7QUFDcEQsY0FBSXk1QixhQUFhRCxVQUFVMVQsSUFBVixDQUFlLGtCQUFmLEVBQW1DcUgsSUFBbkMsRUFBakI7QUFDQXFNLG9CQUFVcFQsUUFBVixDQUFtQix1QkFBbkIsRUFBNEMrUyxHQUE1QyxDQUFnRE0sVUFBaEQ7QUFDRCxTQUhEO0FBSUQ7QUFDRixLQWhCRDs7QUFrQkE7QUFDQXArQixNQUFFZ0csUUFBRixFQUFZeWUsRUFBWixDQUFlLE9BQWYsRUFBd0JvWixjQUF4QixFQUF3QyxZQUFZO0FBQ2xENzlCLFFBQUUsSUFBRixFQUFRK3FCLFFBQVIsQ0FBaUIsZ0JBQWpCLEVBQW1DalosUUFBbkMsQ0FBNEMsUUFBNUM7QUFDRCxLQUZEOztBQUlBOVIsTUFBRWdHLFFBQUYsRUFBWXllLEVBQVosQ0FBZSxNQUFmLEVBQXVCb1osY0FBdkIsRUFBdUMsWUFBWTtBQUNqRCxVQUFJUSxnQkFBZ0JyK0IsRUFBRSxJQUFGLENBQXBCO0FBQ0EsVUFBSW85QixXQUFXLFNBQWY7O0FBRUEsVUFBSWlCLGNBQWNQLEdBQWQsR0FBb0JwNkIsTUFBcEIsS0FBK0IsQ0FBL0IsSUFBb0MyNkIsY0FBYyxDQUFkLEVBQWlCTCxRQUFqQixDQUEwQkMsUUFBMUIsS0FBdUMsSUFBM0UsSUFBbUZJLGNBQWMvVixJQUFkLENBQW1CLGFBQW5CLE1BQXNDdmxCLFNBQTdILEVBQXdJO0FBQ3RJcTZCLG9CQUFZLFNBQVo7QUFDRDs7QUFFRGlCLG9CQUFjdFQsUUFBZCxDQUF1QnFTLFFBQXZCLEVBQWlDM3hCLFdBQWpDLENBQTZDLFFBQTdDOztBQUVBeXlCLHFCQUFlRyxhQUFmO0FBQ0QsS0FYRDs7QUFhQXA2QixXQUFPaTZCLGNBQVAsR0FBd0IsVUFBU3RULE1BQVQsRUFBaUI7QUFDdkMsVUFBSTBULFlBQVkxVCxPQUFPdEMsSUFBUCxDQUFZLGFBQVosTUFBK0J2bEIsU0FBL0M7QUFDQSxVQUFJdzdCLFVBQVUzdEIsU0FBU2dhLE9BQU90QyxJQUFQLENBQVksYUFBWixDQUFULENBQWQ7QUFDQSxVQUFJa1csTUFBTTVULE9BQU9rVCxHQUFQLEdBQWFwNkIsTUFBdkI7O0FBRUEsVUFBSWtuQixPQUFPa1QsR0FBUCxHQUFhcDZCLE1BQWIsS0FBd0IsQ0FBeEIsSUFBNkJrbkIsT0FBTyxDQUFQLEVBQVVvVCxRQUFWLENBQW1CQyxRQUFuQixLQUFnQyxLQUFqRSxFQUF3RTtBQUN0RSxZQUFJclQsT0FBT0MsUUFBUCxDQUFnQixVQUFoQixDQUFKLEVBQWlDO0FBQy9CRCxpQkFBT25mLFdBQVAsQ0FBbUIsT0FBbkI7QUFDQW1mLGlCQUFPbmYsV0FBUCxDQUFtQixTQUFuQjtBQUNEO0FBQ0YsT0FMRCxNQU1LO0FBQ0gsWUFBSW1mLE9BQU9DLFFBQVAsQ0FBZ0IsVUFBaEIsQ0FBSixFQUFpQztBQUMvQjtBQUNBLGNBQUtELE9BQU9RLEVBQVAsQ0FBVSxRQUFWLEtBQXVCa1QsU0FBdkIsSUFBcUNFLE9BQU9ELE9BQTdDLElBQTJEM1QsT0FBT1EsRUFBUCxDQUFVLFFBQVYsS0FBdUIsQ0FBQ2tULFNBQXZGLEVBQW1HO0FBQ2pHMVQsbUJBQU9uZixXQUFQLENBQW1CLFNBQW5CO0FBQ0FtZixtQkFBTzlZLFFBQVAsQ0FBZ0IsT0FBaEI7QUFDRCxXQUhELE1BSUs7QUFDSDhZLG1CQUFPbmYsV0FBUCxDQUFtQixPQUFuQjtBQUNBbWYsbUJBQU85WSxRQUFQLENBQWdCLFNBQWhCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsS0F4QkQ7O0FBMEJBO0FBQ0EsUUFBSTJzQixpQkFBaUIseUNBQXJCO0FBQ0F6K0IsTUFBRWdHLFFBQUYsRUFBWXllLEVBQVosQ0FBZSxhQUFmLEVBQThCZ2EsY0FBOUIsRUFBOEMsVUFBU2g3QixDQUFULEVBQVk7QUFDeEQ7QUFDQSxVQUFJQSxFQUFFa2QsS0FBRixLQUFZLENBQWhCLEVBQW1CO0FBQ2pCM2dCLFVBQUUsSUFBRixFQUFROFIsUUFBUixDQUFpQixRQUFqQjtBQUNBLFlBQUl5WSxRQUFRdnFCLEVBQUUsSUFBRixDQUFaO0FBQ0F1cUIsY0FBTXlJLEdBQU4sQ0FBVSxNQUFWLEVBQWtCLFVBQVN2dkIsQ0FBVCxFQUFZOztBQUU1QnpELFlBQUUsSUFBRixFQUFReUwsV0FBUixDQUFvQixRQUFwQjtBQUNELFNBSEQ7QUFJQTtBQUNEO0FBQ0YsS0FYRDs7QUFhQTtBQUNBLFFBQUlpekIsWUFBWTErQixFQUFFLFlBQUYsRUFBZ0Jpc0IsS0FBaEIsRUFBaEI7QUFDQSxRQUFJLENBQUN5UyxVQUFVaDdCLE1BQWYsRUFBdUI7QUFDckJnN0Isa0JBQVkxK0IsRUFBRSxzQ0FBRixDQUFaO0FBQ0FBLFFBQUUsTUFBRixFQUFVcXdCLE1BQVYsQ0FBaUJxTyxTQUFqQjtBQUNEO0FBQ0QsUUFBSUMscUJBQXFCLHVCQUF6Qjs7QUFFQSxhQUFTQyxrQkFBVCxDQUE0QkMsU0FBNUIsRUFBdUM7QUFDckM7O0FBRUEsVUFBSUMsYUFBYUQsVUFBVXpzQixHQUFWLENBQWMsYUFBZCxDQUFqQjtBQUNBLFVBQUlrQixXQUFXdXJCLFVBQVV6c0IsR0FBVixDQUFjLFdBQWQsQ0FBZjtBQUNBLFVBQUkyc0IsYUFBYUYsVUFBVXpzQixHQUFWLENBQWMsYUFBZCxDQUFqQjs7QUFFQSxVQUFJa0IsUUFBSixFQUFjO0FBQUVvckIsa0JBQVV0c0IsR0FBVixDQUFjLFdBQWQsRUFBMkJrQixRQUEzQjtBQUF1QztBQUN2RCxVQUFJd3JCLFVBQUosRUFBZ0I7QUFBRUosa0JBQVV0c0IsR0FBVixDQUFjLGFBQWQsRUFBNkIwc0IsVUFBN0I7QUFBMkM7QUFDN0QsVUFBSUMsVUFBSixFQUFnQjtBQUFFTCxrQkFBVXRzQixHQUFWLENBQWMsYUFBZCxFQUE2QjJzQixVQUE3QjtBQUEyQzs7QUFFN0QsVUFBSUYsVUFBVXZXLElBQVYsQ0FBZSxNQUFmLE1BQTJCLEtBQS9CLEVBQXNDO0FBQ3BDb1csa0JBQVV0c0IsR0FBVixDQUFjLGVBQWQsRUFBK0IsUUFBL0IsRUFDVUEsR0FEVixDQUNjLGFBRGQsRUFDNkIsS0FEN0I7QUFFRDs7QUFFRHNzQixnQkFBVTVNLElBQVYsQ0FBZStNLFVBQVVmLEdBQVYsS0FBa0IsSUFBakM7QUFDQSxVQUFJa0IsVUFBVU4sVUFBVWpKLElBQVYsR0FBaUJqbEIsT0FBakIsQ0FBeUIsS0FBekIsRUFBZ0MsTUFBaEMsQ0FBZDtBQUNBa3VCLGdCQUFVakosSUFBVixDQUFldUosT0FBZjs7QUFHQTtBQUNBOztBQUVBLFVBQUlILFVBQVV6VCxFQUFWLENBQWEsVUFBYixDQUFKLEVBQThCO0FBQzVCc1Qsa0JBQVV0c0IsR0FBVixDQUFjLE9BQWQsRUFBdUJ5c0IsVUFBVXpRLEtBQVYsRUFBdkI7QUFDRCxPQUZELE1BR0s7QUFDSHNRLGtCQUFVdHNCLEdBQVYsQ0FBYyxPQUFkLEVBQXVCcFMsRUFBRWlFLE1BQUYsRUFBVW1xQixLQUFWLEtBQWtCLENBQXpDO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxVQUFJeVEsVUFBVWg2QixJQUFWLENBQWUsaUJBQWYsS0FBcUM2NUIsVUFBVWhvQixNQUFWLEVBQXpDLEVBQTZEO0FBQzNEbW9CLGtCQUFVenNCLEdBQVYsQ0FBYyxRQUFkLEVBQXdCc3NCLFVBQVVob0IsTUFBVixFQUF4QjtBQUNELE9BRkQsTUFFTyxJQUFJbW9CLFVBQVVmLEdBQVYsR0FBZ0JwNkIsTUFBaEIsR0FBeUJtN0IsVUFBVWg2QixJQUFWLENBQWUsaUJBQWYsQ0FBN0IsRUFBZ0U7QUFDckU7Ozs7O0FBS0FnNkIsa0JBQVV6c0IsR0FBVixDQUFjLFFBQWQsRUFBd0J5c0IsVUFBVWg2QixJQUFWLENBQWUsaUJBQWYsQ0FBeEI7QUFDRDtBQUNEZzZCLGdCQUFVaDZCLElBQVYsQ0FBZSxpQkFBZixFQUFrQ2c2QixVQUFVZixHQUFWLEdBQWdCcDZCLE1BQWxEO0FBQ0Q7O0FBRUQxRCxNQUFFMitCLGtCQUFGLEVBQXNCaDZCLElBQXRCLENBQTJCLFlBQVk7QUFDckMsVUFBSWs2QixZQUFZNytCLEVBQUUsSUFBRixDQUFoQjtBQUNBOzs7O0FBSUE2K0IsZ0JBQVVoNkIsSUFBVixDQUFlLGlCQUFmLEVBQWtDZzZCLFVBQVVub0IsTUFBVixFQUFsQztBQUNBbW9CLGdCQUFVaDZCLElBQVYsQ0FBZSxpQkFBZixFQUFrQ2c2QixVQUFVZixHQUFWLEdBQWdCcDZCLE1BQWxEO0FBQ0QsS0FSRDs7QUFVQTFELE1BQUUsTUFBRixFQUFVeWtCLEVBQVYsQ0FBYSwwQkFBYixFQUF5Q2thLGtCQUF6QyxFQUE2RCxZQUFZO0FBQ3ZFQyx5QkFBbUI1K0IsRUFBRSxJQUFGLENBQW5CO0FBQ0QsS0FGRDs7QUFJQTtBQUNBQSxNQUFFZ0csUUFBRixFQUFZeWUsRUFBWixDQUFlLFFBQWYsRUFBeUIsZ0NBQXpCLEVBQTJELFlBQVk7QUFDckUsVUFBSXdhLGFBQWFqL0IsRUFBRSxJQUFGLEVBQVE2ckIsT0FBUixDQUFnQixhQUFoQixDQUFqQjtBQUNBLFVBQUlxVCxhQUFhRCxXQUFXeFUsSUFBWCxDQUFnQixpQkFBaEIsQ0FBakI7QUFDQSxVQUFJMFUsUUFBYW4vQixFQUFFLElBQUYsRUFBUSxDQUFSLEVBQVdtL0IsS0FBNUI7QUFDQSxVQUFJQyxhQUFhLEVBQWpCO0FBQ0EsV0FBSyxJQUFJajdCLElBQUksQ0FBYixFQUFnQkEsSUFBSWc3QixNQUFNejdCLE1BQTFCLEVBQWtDUyxHQUFsQyxFQUF1QztBQUNyQ2k3QixtQkFBVzk1QixJQUFYLENBQWdCNjVCLE1BQU1oN0IsQ0FBTixFQUFTazdCLElBQXpCO0FBQ0Q7QUFDREgsaUJBQVdwQixHQUFYLENBQWVzQixXQUFXanZCLElBQVgsQ0FBZ0IsSUFBaEIsQ0FBZjtBQUNBK3VCLGlCQUFXeFgsT0FBWCxDQUFtQixRQUFuQjtBQUNELEtBVkQ7O0FBWUE7Ozs7QUFJQSxRQUFJNFgsYUFBYSxtQkFBakI7QUFDQSxRQUFJQyxrQkFBa0IsS0FBdEI7QUFDQSxRQUFJejVCLElBQUo7O0FBRUE5RixNQUFFcy9CLFVBQUYsRUFBYzM2QixJQUFkLENBQW1CLFlBQVk7QUFDN0IsVUFBSTY2QixRQUFReC9CLEVBQUUsd0RBQUYsQ0FBWjtBQUNBQSxRQUFFLElBQUYsRUFBUWt0QixLQUFSLENBQWNzUyxLQUFkO0FBQ0QsS0FIRDs7QUFLQSxRQUFJQyxrQkFBa0IsU0FBbEJBLGVBQWtCLENBQVNELEtBQVQsRUFBZ0I7QUFDcEMsVUFBSUUsY0FBYzl1QixTQUFTNHVCLE1BQU0xVSxNQUFOLEdBQWUxWSxHQUFmLENBQW1CLGNBQW5CLENBQVQsQ0FBbEI7QUFDQSxVQUFJdEwsYUFBYyxDQUFDLENBQUQsR0FBSzQ0QixXQUFOLEdBQXFCLElBQXRDO0FBQ0FGLFlBQU0zeUIsUUFBTixDQUFlLEVBQUU2SixRQUFRLE1BQVYsRUFBa0IwWCxPQUFPLE1BQXpCLEVBQWlDdm9CLEtBQUssT0FBdEMsRUFBK0NpQixZQUFZQSxVQUEzRCxFQUFmLEVBQXVGLEVBQUV1QyxVQUFVLEdBQVosRUFBaUJuSixRQUFRLGFBQXpCLEVBQXZGO0FBQ0QsS0FKRDs7QUFNQSxRQUFJeS9CLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBU0MsS0FBVCxFQUFnQjtBQUNwQyxVQUFJeFIsUUFBUXdSLE1BQU14UixLQUFOLEtBQWdCLEVBQTVCO0FBQ0EsVUFBSTFsQixNQUFNOUIsV0FBV2c1QixNQUFNdFgsSUFBTixDQUFXLEtBQVgsQ0FBWCxDQUFWO0FBQ0EsVUFBSTdmLE1BQU03QixXQUFXZzVCLE1BQU10WCxJQUFOLENBQVcsS0FBWCxDQUFYLENBQVY7QUFDQSxVQUFJdVgsVUFBVSxDQUFDajVCLFdBQVdnNUIsTUFBTTlCLEdBQU4sRUFBWCxJQUEwQnIxQixHQUEzQixLQUFtQ0MsTUFBTUQsR0FBekMsQ0FBZDtBQUNBLGFBQU9vM0IsVUFBVXpSLEtBQWpCO0FBQ0QsS0FORDs7QUFRQSxRQUFJMFIsZ0JBQWdCLGNBQXBCO0FBQ0E5L0IsTUFBRWdHLFFBQUYsRUFBWXllLEVBQVosQ0FBZSxRQUFmLEVBQXlCNmEsVUFBekIsRUFBcUMsVUFBUzc3QixDQUFULEVBQVk7QUFDL0MsVUFBSSs3QixRQUFReC9CLEVBQUUsSUFBRixFQUFRK3FCLFFBQVIsQ0FBaUIsUUFBakIsQ0FBWjtBQUNBeVUsWUFBTS9VLElBQU4sQ0FBVyxRQUFYLEVBQXFCZ0wsSUFBckIsQ0FBMEJ6MUIsRUFBRSxJQUFGLEVBQVE4OUIsR0FBUixFQUExQjs7QUFFQSxVQUFJLENBQUMwQixNQUFNM1UsUUFBTixDQUFlLFFBQWYsQ0FBTCxFQUErQjtBQUM3QjRVLHdCQUFnQkQsS0FBaEI7QUFDRDs7QUFFRCxVQUFJalMsYUFBYW9TLGdCQUFnQjMvQixFQUFFLElBQUYsQ0FBaEIsQ0FBakI7QUFDQXcvQixZQUFNMXRCLFFBQU4sQ0FBZSxRQUFmLEVBQXlCTSxHQUF6QixDQUE2QixNQUE3QixFQUFxQ21iLFVBQXJDO0FBQ0QsS0FWRDs7QUFZQXZ0QixNQUFFZ0csUUFBRixFQUFZeWUsRUFBWixDQUFlLHNCQUFmLEVBQXVDNmEsVUFBdkMsRUFBbUQsVUFBUzc3QixDQUFULEVBQVk7QUFDN0QsVUFBSSs3QixRQUFReC9CLEVBQUUsSUFBRixFQUFRK3FCLFFBQVIsQ0FBaUIsUUFBakIsQ0FBWjs7QUFFQTtBQUNBLFVBQUl5VSxNQUFNOTdCLE1BQU4sSUFBZ0IsQ0FBcEIsRUFBdUI7QUFDckI4N0IsZ0JBQVF4L0IsRUFBRSx3REFBRixDQUFSO0FBQ0FBLFVBQUUsSUFBRixFQUFRa3RCLEtBQVIsQ0FBY3NTLEtBQWQ7QUFDRDs7QUFFRDtBQUNBQSxZQUFNL1UsSUFBTixDQUFXLFFBQVgsRUFBcUJnTCxJQUFyQixDQUEwQnoxQixFQUFFLElBQUYsRUFBUTg5QixHQUFSLEVBQTFCOztBQUVBeUIsd0JBQWtCLElBQWxCO0FBQ0F2L0IsUUFBRSxJQUFGLEVBQVE4UixRQUFSLENBQWlCLFFBQWpCOztBQUVBLFVBQUksQ0FBQzB0QixNQUFNM1UsUUFBTixDQUFlLFFBQWYsQ0FBTCxFQUErQjtBQUM3QjRVLHdCQUFnQkQsS0FBaEI7QUFDRDs7QUFFRCxVQUFJLzdCLEVBQUVHLElBQUYsS0FBVyxPQUFmLEVBQXdCO0FBQ3RCLFlBQUkycEIsYUFBYW9TLGdCQUFnQjMvQixFQUFFLElBQUYsQ0FBaEIsQ0FBakI7QUFDQXcvQixjQUFNMXRCLFFBQU4sQ0FBZSxRQUFmLEVBQXlCTSxHQUF6QixDQUE2QixNQUE3QixFQUFxQ21iLFVBQXJDO0FBQ0Q7QUFDRixLQXZCRDs7QUF5QkF2dEIsTUFBRWdHLFFBQUYsRUFBWXllLEVBQVosQ0FBZSxrQkFBZixFQUFtQ3FiLGFBQW5DLEVBQWtELFlBQVc7QUFDM0RQLHdCQUFrQixLQUFsQjtBQUNBdi9CLFFBQUUsSUFBRixFQUFReUwsV0FBUixDQUFvQixRQUFwQjtBQUNELEtBSEQ7O0FBS0F6TCxNQUFFZ0csUUFBRixFQUFZeWUsRUFBWixDQUFlLDJCQUFmLEVBQTRDcWIsYUFBNUMsRUFBMkQsVUFBU3I4QixDQUFULEVBQVk7QUFDckUsVUFBSSs3QixRQUFReC9CLEVBQUUsSUFBRixFQUFRbXJCLFFBQVIsQ0FBaUIsUUFBakIsQ0FBWjtBQUNBLFVBQUlybEIsSUFBSjtBQUNBLFVBQUl1WixRQUFRcmYsRUFBRSxJQUFGLEVBQVF5cUIsSUFBUixDQUFhNlUsVUFBYixDQUFaOztBQUVBLFVBQUlDLGVBQUosRUFBcUI7QUFDbkIsWUFBSSxDQUFDQyxNQUFNM1UsUUFBTixDQUFlLFFBQWYsQ0FBTCxFQUErQjtBQUM3QjRVLDBCQUFnQkQsS0FBaEI7QUFDRDs7QUFFRCxZQUFJalMsYUFBYW9TLGdCQUFnQnRnQixLQUFoQixDQUFqQjtBQUNBbWdCLGNBQU0xdEIsUUFBTixDQUFlLFFBQWYsRUFBeUJNLEdBQXpCLENBQTZCLE1BQTdCLEVBQXFDbWIsVUFBckM7QUFDQWlTLGNBQU0vVSxJQUFOLENBQVcsUUFBWCxFQUFxQmdMLElBQXJCLENBQTBCK0osTUFBTXpVLFFBQU4sQ0FBZXVVLFVBQWYsRUFBMkJ4QixHQUEzQixFQUExQjtBQUNEO0FBQ0YsS0FkRDs7QUFnQkE5OUIsTUFBRWdHLFFBQUYsRUFBWXllLEVBQVosQ0FBZSxxQkFBZixFQUFzQ3FiLGFBQXRDLEVBQXFELFlBQVc7QUFDOUQsVUFBSSxDQUFDUCxlQUFMLEVBQXNCOztBQUVwQixZQUFJQyxRQUFReC9CLEVBQUUsSUFBRixFQUFRbXJCLFFBQVIsQ0FBaUIsUUFBakIsQ0FBWjtBQUNBLFlBQUl1VSxjQUFjOXVCLFNBQVM1USxFQUFFLElBQUYsRUFBUW9TLEdBQVIsQ0FBWSxjQUFaLENBQVQsQ0FBbEI7QUFDQSxZQUFJdEwsYUFBYyxJQUFJNDRCLFdBQUwsR0FBb0IsSUFBckM7O0FBRUEsWUFBSUYsTUFBTTNVLFFBQU4sQ0FBZSxRQUFmLENBQUosRUFBOEI7QUFDNUIyVSxnQkFBTTN5QixRQUFOLENBQWUsRUFBRTZKLFFBQVEsR0FBVixFQUFlMFgsT0FBTyxHQUF0QixFQUEyQnZvQixLQUFLLE1BQWhDLEVBQXdDaUIsWUFBWUEsVUFBcEQsRUFBZixFQUFnRixFQUFFdUMsVUFBVSxHQUFaLEVBQWhGO0FBQ0Q7QUFDRG0yQixjQUFNL3pCLFdBQU4sQ0FBa0IsUUFBbEI7QUFDRDtBQUNGLEtBWkQ7O0FBY0E7OztBQUdBekwsTUFBRStELEVBQUYsQ0FBS2c4QixZQUFMLEdBQW9CLFVBQVUvcEIsT0FBVixFQUFtQjtBQUNyQztBQUNBLFVBQUk5TSxXQUFXO0FBQ2JyRSxjQUFNLEVBRE87QUFFYm03QixlQUFPM00sUUFGTTtBQUdiNE0sd0JBQWdCLElBSEg7QUFJYkMsbUJBQVc7QUFKRSxPQUFmOztBQU9BbHFCLGdCQUFVaFcsRUFBRUcsTUFBRixDQUFTK0ksUUFBVCxFQUFtQjhNLE9BQW5CLENBQVY7O0FBRUEsYUFBTyxLQUFLclIsSUFBTCxDQUFVLFlBQVc7QUFDMUIsWUFBSXc3QixTQUFTbmdDLEVBQUUsSUFBRixDQUFiO0FBQ0EsWUFBSTZFLE9BQU9tUixRQUFRblIsSUFBbkI7QUFBQSxZQUNJa2EsUUFBUSxDQURaO0FBQUEsWUFFSXFoQixjQUFjLENBQUMsQ0FGbkI7QUFBQSxZQUdJQyxNQUhKO0FBQUEsWUFJSUMsWUFBWUgsT0FBT3RVLE9BQVAsQ0FBZSxjQUFmLENBSmhCLENBRjBCLENBTXNCOztBQUVoRDtBQUNBLFlBQUksQ0FBQzdyQixFQUFFNE0sYUFBRixDQUFnQi9ILElBQWhCLENBQUwsRUFBNEI7QUFDMUIsY0FBSTA3QixnQkFBZ0J2Z0MsRUFBRSx5REFBRixDQUFwQjtBQUNBLGNBQUl3Z0MsZ0JBQUo7O0FBRUE7QUFDQTtBQUNBLGNBQUlGLFVBQVU1OEIsTUFBZCxFQUFzQjtBQUNwQjg4QiwrQkFBbUJGLFVBQVVuVixRQUFWLENBQW1CLHdDQUFuQixFQUE2RGMsS0FBN0QsRUFBbkI7QUFDQSxnQkFBSSxDQUFDdVUsaUJBQWlCOThCLE1BQXRCLEVBQThCO0FBQzVCNDhCLHdCQUFValEsTUFBVixDQUFpQmtRLGFBQWpCLEVBRDRCLENBQ0s7QUFDbEM7QUFDRixXQUxELE1BS087QUFDTEMsK0JBQW1CTCxPQUFPdnFCLElBQVAsQ0FBWSx3Q0FBWixDQUFuQjtBQUNBLGdCQUFJLENBQUM0cUIsaUJBQWlCOThCLE1BQXRCLEVBQThCO0FBQzVCeThCLHFCQUFPalQsS0FBUCxDQUFhcVQsYUFBYjtBQUNEO0FBQ0Y7QUFDRCxjQUFJQyxpQkFBaUI5OEIsTUFBckIsRUFBNkI7QUFDM0I2OEIsNEJBQWdCQyxnQkFBaEI7QUFDRDs7QUFFRDtBQUNBLGNBQUlDLFlBQVksU0FBWkEsU0FBWSxDQUFTQyxNQUFULEVBQWlCblosR0FBakIsRUFBc0I7QUFDcEMsZ0JBQUlvWixNQUFNcFosSUFBSWtELElBQUosQ0FBUyxLQUFULENBQVY7QUFDQSxnQkFBSW1XLGFBQWFyWixJQUFJdUssSUFBSixHQUFXdHJCLFdBQVgsR0FBeUI0USxPQUF6QixDQUFpQyxLQUFLc3BCLE9BQU9sNkIsV0FBUCxFQUFMLEdBQTRCLEVBQTdELENBQWpCO0FBQUEsZ0JBQ0lxNkIsV0FBV0QsYUFBYUYsT0FBT2g5QixNQUFwQixHQUE2QixDQUQ1QztBQUFBLGdCQUVJbzlCLGNBQWN2WixJQUFJdUssSUFBSixHQUFXbnFCLEtBQVgsQ0FBaUIsQ0FBakIsRUFBb0JpNUIsVUFBcEIsQ0FGbEI7QUFBQSxnQkFHSUcsWUFBWXhaLElBQUl1SyxJQUFKLEdBQVducUIsS0FBWCxDQUFpQmk1QixVQUFqQixFQUE2QkMsV0FBVyxDQUF4QyxDQUhoQjtBQUFBLGdCQUlJRyxhQUFhelosSUFBSXVLLElBQUosR0FBV25xQixLQUFYLENBQWlCazVCLFdBQVcsQ0FBNUIsQ0FKakI7QUFLQXRaLGdCQUFJa08sSUFBSixDQUFTLFdBQVdxTCxXQUFYLEdBQXlCLDBCQUF6QixHQUFzREMsU0FBdEQsR0FBa0UsU0FBbEUsR0FBOEVDLFVBQTlFLEdBQTJGLFNBQXBHO0FBQ0EsZ0JBQUlMLElBQUlqOUIsTUFBUixFQUFnQjtBQUNkNmpCLGtCQUFJMFosT0FBSixDQUFZTixHQUFaO0FBQ0Q7QUFDRixXQVhEOztBQWFBO0FBQ0EsY0FBSU8sc0JBQXNCLFNBQXRCQSxtQkFBc0IsR0FBVztBQUNuQ2QsMEJBQWMsQ0FBQyxDQUFmO0FBQ0FHLDBCQUFjOVYsSUFBZCxDQUFtQixTQUFuQixFQUE4QmhmLFdBQTlCLENBQTBDLFFBQTFDO0FBQ0QsV0FIRDs7QUFLQTtBQUNBLGNBQUkwMUIscUJBQXFCLFNBQXJCQSxrQkFBcUIsR0FBVztBQUNsQ1osMEJBQWNhLEtBQWQ7QUFDQUY7QUFDQWIscUJBQVN0OUIsU0FBVDtBQUNELFdBSkQ7O0FBTUFvOUIsaUJBQU96YixHQUFQLENBQVcsbUJBQVgsRUFBZ0NELEVBQWhDLENBQW1DLG1CQUFuQyxFQUF3RCxZQUFXO0FBQ2pFMGM7QUFDRCxXQUZEOztBQUlBO0FBQ0FoQixpQkFBT3piLEdBQVAsQ0FBVyx1Q0FBWCxFQUFvREQsRUFBcEQsQ0FBdUQsdUNBQXZELEVBQWdHLFVBQVVoaEIsQ0FBVixFQUFhO0FBQzNHO0FBQ0FzYixvQkFBUSxDQUFSO0FBQ0EsZ0JBQUkrZSxNQUFNcUMsT0FBT3JDLEdBQVAsR0FBYXQzQixXQUFiLEVBQVY7O0FBRUE7QUFDQSxnQkFBSS9DLEVBQUVrZCxLQUFGLEtBQVksRUFBWixJQUNBbGQsRUFBRWtkLEtBQUYsS0FBWSxFQURaLElBRUFsZCxFQUFFa2QsS0FBRixLQUFZLEVBRmhCLEVBRW9CO0FBQ2xCO0FBQ0Q7O0FBR0Q7QUFDQSxnQkFBSTBmLFdBQVd2QyxHQUFmLEVBQW9CO0FBQ2xCcUQ7O0FBRUEsa0JBQUlyRCxJQUFJcDZCLE1BQUosSUFBY3NTLFFBQVFrcUIsU0FBMUIsRUFBcUM7QUFDbkMscUJBQUksSUFBSW1CLEdBQVIsSUFBZXg4QixJQUFmLEVBQXFCO0FBQ25CLHNCQUFJQSxLQUFLc0MsY0FBTCxDQUFvQms2QixHQUFwQixLQUNBQSxJQUFJNzZCLFdBQUosR0FBa0I0USxPQUFsQixDQUEwQjBtQixHQUExQixNQUFtQyxDQUFDLENBRHBDLElBRUF1RCxJQUFJNzZCLFdBQUosT0FBc0JzM0IsR0FGMUIsRUFFK0I7QUFDN0I7QUFDQSx3QkFBSS9lLFNBQVMvSSxRQUFRZ3FCLEtBQXJCLEVBQTRCO0FBQzFCO0FBQ0Q7O0FBRUQsd0JBQUlzQixxQkFBcUJ0aEMsRUFBRSxXQUFGLENBQXpCO0FBQ0Esd0JBQUksQ0FBQyxDQUFDNkUsS0FBS3c4QixHQUFMLENBQU4sRUFBaUI7QUFDZkMseUNBQW1CalIsTUFBbkIsQ0FBMEIsZUFBY3hyQixLQUFLdzhCLEdBQUwsQ0FBZCxHQUF5QiwrQkFBekIsR0FBMERBLEdBQTFELEdBQStELFNBQXpGO0FBQ0QscUJBRkQsTUFFTztBQUNMQyx5Q0FBbUJqUixNQUFuQixDQUEwQixXQUFVZ1IsR0FBVixHQUFlLFNBQXpDO0FBQ0Q7O0FBRURkLGtDQUFjbFEsTUFBZCxDQUFxQmlSLGtCQUFyQjtBQUNBYiw4QkFBVTNDLEdBQVYsRUFBZXdELGtCQUFmO0FBQ0F2aUI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBc2hCLHFCQUFTdkMsR0FBVDtBQUNELFdBNUNEOztBQThDQXFDLGlCQUFPemIsR0FBUCxDQUFXLHNCQUFYLEVBQW1DRCxFQUFuQyxDQUFzQyxzQkFBdEMsRUFBOEQsVUFBVWhoQixDQUFWLEVBQWE7QUFDekU7QUFDQSxnQkFBSThzQixVQUFVOXNCLEVBQUVrZCxLQUFoQjtBQUFBLGdCQUNJNGdCLFNBREo7QUFBQSxnQkFFSUMsV0FBV2pCLGNBQWNwVixRQUFkLENBQXVCLElBQXZCLEVBQTZCem5CLE1BRjVDO0FBQUEsZ0JBR0k4dkIsVUFBVStNLGNBQWNwVixRQUFkLENBQXVCLFNBQXZCLEVBQWtDYyxLQUFsQyxFQUhkOztBQUtBO0FBQ0EsZ0JBQUlzRSxZQUFZLEVBQVosSUFBa0I2UCxlQUFlLENBQXJDLEVBQXdDO0FBQ3RDbUIsMEJBQVloQixjQUFjcFYsUUFBZCxDQUF1QixJQUF2QixFQUE2QmEsRUFBN0IsQ0FBZ0NvVSxXQUFoQyxDQUFaO0FBQ0Esa0JBQUltQixVQUFVNzlCLE1BQWQsRUFBc0I7QUFDcEI2OUIsMEJBQVU3WixPQUFWLENBQWtCLHdCQUFsQjtBQUNBamtCLGtCQUFFNmUsY0FBRjtBQUNEO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBLGdCQUFLaU8sWUFBWSxFQUFaLElBQWtCQSxZQUFZLEVBQW5DLEVBQXdDO0FBQ3RDOXNCLGdCQUFFNmUsY0FBRjs7QUFFQSxrQkFBSWlPLFlBQVksRUFBWixJQUNBNlAsY0FBYyxDQURsQixFQUNxQjtBQUNuQkE7QUFDRDs7QUFFRCxrQkFBSTdQLFlBQVksRUFBWixJQUNBNlAsY0FBZW9CLFdBQVcsQ0FEOUIsRUFDa0M7QUFDaENwQjtBQUNEOztBQUVENU0sc0JBQVEvbkIsV0FBUixDQUFvQixRQUFwQjtBQUNBLGtCQUFJMjBCLGVBQWUsQ0FBbkIsRUFBc0I7QUFDcEJHLDhCQUFjcFYsUUFBZCxDQUF1QixJQUF2QixFQUE2QmEsRUFBN0IsQ0FBZ0NvVSxXQUFoQyxFQUE2Q3R1QixRQUE3QyxDQUFzRCxRQUF0RDtBQUNEO0FBQ0Y7QUFDRixXQXBDRDs7QUFzQ0E7QUFDQXl1Qix3QkFBYzliLEVBQWQsQ0FBaUIsZ0RBQWpCLEVBQW1FLElBQW5FLEVBQXlFLFlBQVk7QUFDbkYsZ0JBQUlxTixPQUFPOXhCLEVBQUUsSUFBRixFQUFROHhCLElBQVIsR0FBZXphLElBQWYsRUFBWDtBQUNBOG9CLG1CQUFPckMsR0FBUCxDQUFXaE0sSUFBWDtBQUNBcU8sbUJBQU96WSxPQUFQLENBQWUsUUFBZjtBQUNBeVo7O0FBRUE7QUFDQSxnQkFBSSxPQUFPbnJCLFFBQVFpcUIsY0FBZixLQUFtQyxVQUF2QyxFQUFtRDtBQUNqRGpxQixzQkFBUWlxQixjQUFSLENBQXVCNzdCLElBQXZCLENBQTRCLElBQTVCLEVBQWtDMHRCLElBQWxDO0FBQ0Q7QUFDRixXQVZEO0FBV0Q7QUFDRixPQS9KTSxDQUFQO0FBZ0tELEtBM0tEO0FBNktELEdBdGRELEVBRGEsQ0F1ZFQ7O0FBRUo7OztBQUdBOXhCLElBQUUrRCxFQUFGLENBQUswOUIsZUFBTCxHQUF1QixVQUFVN3BCLFFBQVYsRUFBb0I7QUFDekM1WCxNQUFFLElBQUYsRUFBUTJFLElBQVIsQ0FBYSxZQUFVO0FBQ3JCLFVBQUkrOEIsVUFBVTFoQyxFQUFFLElBQUYsQ0FBZDs7QUFFQSxVQUFJMGhDLFFBQVE3VyxRQUFSLENBQWlCLGlCQUFqQixDQUFKLEVBQXlDO0FBQ3ZDLGVBRHVDLENBQy9CO0FBQ1Q7O0FBRUQsVUFBSThXLFdBQVdELFFBQVFwWixJQUFSLENBQWEsVUFBYixJQUEyQixJQUEzQixHQUFrQyxLQUFqRDtBQUFBLFVBQ0lzWixTQUFTRixRQUFRNzhCLElBQVIsQ0FBYSxXQUFiLENBRGIsQ0FQcUIsQ0FRbUI7O0FBRXhDLFVBQUkrOEIsTUFBSixFQUFZO0FBQ1ZGLGdCQUFRNVcsTUFBUixHQUFpQkwsSUFBakIsQ0FBc0IsWUFBdEIsRUFBb0N2WSxNQUFwQztBQUNBd3ZCLGdCQUFRNVcsTUFBUixHQUFpQkwsSUFBakIsQ0FBc0IsT0FBdEIsRUFBK0J2WSxNQUEvQjs7QUFFQXd2QixnQkFBUUcsTUFBUjtBQUNBN2hDLFVBQUUsdUJBQXFCNGhDLE1BQXZCLEVBQStCMXZCLE1BQS9CO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFHMEYsYUFBYSxTQUFoQixFQUEyQjtBQUN6QjhwQixnQkFBUTc4QixJQUFSLENBQWEsV0FBYixFQUEwQixJQUExQixFQUFnQzRHLFdBQWhDLENBQTRDLGFBQTVDO0FBQ0E7QUFDRDs7QUFFRCxVQUFJcTJCLFdBQVdsYSxZQUFZWSxJQUFaLEVBQWY7QUFDQWtaLGNBQVE3OEIsSUFBUixDQUFhLFdBQWIsRUFBMEJpOUIsUUFBMUI7QUFDQSxVQUFJL1QsVUFBVS90QixFQUFFLG9DQUFGLENBQWQ7QUFDQSt0QixjQUFRamMsUUFBUixDQUFpQjR2QixRQUFRcFosSUFBUixDQUFhLE9BQWIsQ0FBakI7QUFDQSxVQUFJdFMsVUFBVWhXLEVBQUUsNEJBQTRCOGhDLFFBQTVCLEdBQXNDLDRDQUF0QyxJQUFzRkgsV0FBVywwQkFBWCxHQUF3QyxFQUE5SCxJQUFvSSxTQUF0SSxDQUFkO0FBQUEsVUFDSUksaUJBQWlCTCxRQUFRdlcsUUFBUixDQUFpQixrQkFBakIsQ0FEckI7QUFBQSxVQUVJNlcsaUJBQWlCLEVBRnJCO0FBQUEsVUFHSUMsZUFBZSxLQUhuQjs7QUFLQSxVQUFJQyxRQUFRUixRQUFRalgsSUFBUixDQUFhLGlCQUFiLEVBQWdDZ0wsSUFBaEMsTUFBMENpTSxRQUFRalgsSUFBUixDQUFhLGNBQWIsRUFBNkJnTCxJQUE3QixFQUExQyxJQUFpRixFQUE3Rjs7QUFFQTtBQUNBO0FBQ0EsVUFBSTBNLHVCQUF1QixTQUF2QkEsb0JBQXVCLENBQVNDLE1BQVQsRUFBaUJDLE1BQWpCLEVBQXlCeitCLElBQXpCLEVBQStCO0FBQ3hEO0FBQ0EsWUFBSTArQixnQkFBaUJELE9BQU9qWCxFQUFQLENBQVUsV0FBVixDQUFELEdBQTJCLFdBQTNCLEdBQXlDLEVBQTdEO0FBQ0EsWUFBSW1YLGdCQUFpQjMrQixTQUFTLGlCQUFWLEdBQStCLGtCQUEvQixHQUFvRCxFQUF4RTtBQUNBLFlBQUk0K0IsbUJBQW1CYixXQUFXLDJCQUEyQlcsYUFBM0IsR0FBMkMsbUJBQXRELEdBQTRFLEVBQW5HOztBQUVBO0FBQ0EsWUFBSUcsV0FBV0osT0FBT3g5QixJQUFQLENBQVksTUFBWixDQUFmO0FBQ0EsWUFBSSsxQixVQUFVeUgsT0FBTy9aLElBQVAsQ0FBWSxPQUFaLENBQWQ7QUFDQSxZQUFJLENBQUMsQ0FBQ21hLFFBQU4sRUFBZ0I7QUFDZCxjQUFJQyxjQUFjLEVBQWxCO0FBQ0EsY0FBSSxDQUFDLENBQUM5SCxPQUFOLEVBQWU4SCxjQUFjLGFBQWE5SCxPQUFiLEdBQXVCLEdBQXJDOztBQUVmO0FBQ0E1a0Isa0JBQVFxYSxNQUFSLENBQWVyd0IsRUFBRSxnQkFBZ0JzaUMsYUFBaEIsR0FBZ0NDLGFBQWhDLEdBQWdELHFCQUFoRCxHQUF3RUUsUUFBeEUsR0FBbUYsR0FBbkYsR0FBeUZDLFdBQXpGLEdBQXVHLFNBQXZHLEdBQW1IRixnQkFBbkgsR0FBc0lILE9BQU81TSxJQUFQLEVBQXRJLEdBQXNKLGNBQXhKLENBQWY7QUFDQSxpQkFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQXpmLGdCQUFRcWEsTUFBUixDQUFlcndCLEVBQUUsZ0JBQWdCc2lDLGFBQWhCLEdBQWdDQyxhQUFoQyxHQUFnRCxVQUFoRCxHQUE2REMsZ0JBQTdELEdBQWdGSCxPQUFPNU0sSUFBUCxFQUFoRixHQUFnRyxjQUFsRyxDQUFmO0FBQ0QsT0FwQkQ7O0FBc0JBO0FBQ0EsVUFBSXNNLGVBQWVyK0IsTUFBbkIsRUFBMkI7QUFDekJxK0IsdUJBQWVwOUIsSUFBZixDQUFvQixZQUFXO0FBQzdCLGNBQUkzRSxFQUFFLElBQUYsRUFBUW9yQixFQUFSLENBQVcsUUFBWCxDQUFKLEVBQTBCO0FBQ3hCO0FBQ0EsZ0JBQUl1VyxRQUFKLEVBQWM7QUFDWlEsbUNBQXFCVCxPQUFyQixFQUE4QjFoQyxFQUFFLElBQUYsQ0FBOUIsRUFBdUMsVUFBdkM7QUFFRCxhQUhELE1BR087QUFDTG1pQyxtQ0FBcUJULE9BQXJCLEVBQThCMWhDLEVBQUUsSUFBRixDQUE5QjtBQUNEO0FBQ0YsV0FSRCxNQVFPLElBQUlBLEVBQUUsSUFBRixFQUFRb3JCLEVBQVIsQ0FBVyxVQUFYLENBQUosRUFBNEI7QUFDakM7QUFDQSxnQkFBSXVYLGdCQUFnQjNpQyxFQUFFLElBQUYsRUFBUW1yQixRQUFSLENBQWlCLFFBQWpCLENBQXBCO0FBQ0FuVixvQkFBUXFhLE1BQVIsQ0FBZXJ3QixFQUFFLGdDQUFnQ0EsRUFBRSxJQUFGLEVBQVFzb0IsSUFBUixDQUFhLE9BQWIsQ0FBaEMsR0FBd0QsY0FBMUQsQ0FBZjs7QUFFQXFhLDBCQUFjaCtCLElBQWQsQ0FBbUIsWUFBVztBQUM1Qnc5QixtQ0FBcUJULE9BQXJCLEVBQThCMWhDLEVBQUUsSUFBRixDQUE5QixFQUF1QyxpQkFBdkM7QUFDRCxhQUZEO0FBR0Q7QUFDRixTQWxCRDtBQW1CRDs7QUFFRGdXLGNBQVF5VSxJQUFSLENBQWEsbUJBQWIsRUFBa0M5bEIsSUFBbEMsQ0FBdUMsVUFBVVIsQ0FBVixFQUFhO0FBQ2xEbkUsVUFBRSxJQUFGLEVBQVFzd0IsS0FBUixDQUFjLFVBQVU3c0IsQ0FBVixFQUFhO0FBQ3pCO0FBQ0EsY0FBSSxDQUFDekQsRUFBRSxJQUFGLEVBQVE2cUIsUUFBUixDQUFpQixVQUFqQixDQUFELElBQWlDLENBQUM3cUIsRUFBRSxJQUFGLEVBQVE2cUIsUUFBUixDQUFpQixVQUFqQixDQUF0QyxFQUFvRTtBQUNsRSxnQkFBSStYLFdBQVcsSUFBZjs7QUFFQSxnQkFBSWpCLFFBQUosRUFBYztBQUNaM2hDLGdCQUFFLHdCQUFGLEVBQTRCLElBQTVCLEVBQWtDb29CLElBQWxDLENBQXVDLFNBQXZDLEVBQWtELFVBQVNqa0IsQ0FBVCxFQUFZOEQsQ0FBWixFQUFlO0FBQUUsdUJBQU8sQ0FBQ0EsQ0FBUjtBQUFZLGVBQS9FO0FBQ0EyNkIseUJBQVdDLHFCQUFxQmIsY0FBckIsRUFBcUM3OUIsQ0FBckMsRUFBd0N1OUIsT0FBeEMsQ0FBWDtBQUNBb0IseUJBQVdwYixPQUFYLENBQW1CLE9BQW5CO0FBQ0QsYUFKRCxNQUlPO0FBQ0wxUixzQkFBUXlVLElBQVIsQ0FBYSxJQUFiLEVBQW1CaGYsV0FBbkIsQ0FBK0IsUUFBL0I7QUFDQXpMLGdCQUFFLElBQUYsRUFBUXlyQixXQUFSLENBQW9CLFFBQXBCO0FBQ0FxWCx5QkFBV2hGLEdBQVgsQ0FBZTk5QixFQUFFLElBQUYsRUFBUTh4QixJQUFSLEVBQWY7QUFDRDs7QUFFRGlSLDJCQUFlL3NCLE9BQWYsRUFBd0JoVyxFQUFFLElBQUYsQ0FBeEI7QUFDQTBoQyxvQkFBUWpYLElBQVIsQ0FBYSxRQUFiLEVBQXVCdUIsRUFBdkIsQ0FBMEI3bkIsQ0FBMUIsRUFBNkJpa0IsSUFBN0IsQ0FBa0MsVUFBbEMsRUFBOEN3YSxRQUE5QztBQUNBO0FBQ0FsQixvQkFBUWhhLE9BQVIsQ0FBZ0IsUUFBaEI7QUFDQSxnQkFBSSxPQUFPOVAsUUFBUCxLQUFvQixXQUF4QixFQUFxQ0E7QUFDdEM7O0FBRURuVSxZQUFFbXBCLGVBQUY7QUFDRCxTQXZCRDtBQXdCRCxPQXpCRDs7QUEyQkE7QUFDQThVLGNBQVFwUSxJQUFSLENBQWF2RCxPQUFiO0FBQ0E7QUFDQSxVQUFJaVYsZUFBZWhqQyxFQUFFLG9DQUFGLENBQW5CO0FBQ0EsVUFBSTBoQyxRQUFRdFcsRUFBUixDQUFXLFdBQVgsQ0FBSixFQUNFNFgsYUFBYWx4QixRQUFiLENBQXNCLFVBQXRCOztBQUVGO0FBQ0EsVUFBSW14QixxQkFBcUJmLE1BQU0xeEIsT0FBTixDQUFjLElBQWQsRUFBb0IsUUFBcEIsQ0FBekI7O0FBRUEsVUFBSXN5QixhQUFhOWlDLEVBQUUsaUVBQWtFMGhDLFFBQVF0VyxFQUFSLENBQVcsV0FBWCxDQUFELEdBQTRCLFVBQTVCLEdBQXlDLEVBQTFHLElBQWdILGtDQUFoSCxHQUFxSjBXLFFBQXJKLEdBQStKLFdBQS9KLEdBQTRLbUIsa0JBQTVLLEdBQWdNLEtBQWxNLENBQWpCO0FBQ0F2QixjQUFRL1AsTUFBUixDQUFlbVIsVUFBZjtBQUNBQSxpQkFBV25SLE1BQVgsQ0FBa0JxUixZQUFsQjs7QUFFQUYsaUJBQVc1VixLQUFYLENBQWlCbFgsT0FBakI7QUFDQTtBQUNBLFVBQUksQ0FBQzByQixRQUFRdFcsRUFBUixDQUFXLFdBQVgsQ0FBTCxFQUE4QjtBQUM1QjBYLG1CQUFXMVcsUUFBWCxDQUFvQixFQUFDLFNBQVMsS0FBVixFQUFwQjtBQUNEOztBQUVEO0FBQ0EsVUFBSXNWLFFBQVFwWixJQUFSLENBQWEsVUFBYixDQUFKLEVBQThCO0FBQzVCdG9CLFVBQUU4aUMsV0FBVyxDQUFYLENBQUYsRUFBaUJ4YSxJQUFqQixDQUFzQixVQUF0QixFQUFrQ29aLFFBQVFwWixJQUFSLENBQWEsVUFBYixDQUFsQztBQUNEOztBQUVEb1osY0FBUTV2QixRQUFSLENBQWlCLGFBQWpCOztBQUVBZ3hCLGlCQUFXcmUsRUFBWCxDQUFjO0FBQ1osaUJBQVMsaUJBQVc7QUFDbEIsY0FBSXprQixFQUFFLG9CQUFGLEVBQXdCa3JCLEdBQXhCLENBQTRCbFYsUUFBUSxDQUFSLENBQTVCLEVBQXdDb1YsRUFBeEMsQ0FBMkMsVUFBM0MsQ0FBSixFQUE0RDtBQUMxRHByQixjQUFFLHVCQUFGLEVBQTJCMG5CLE9BQTNCLENBQW1DLE9BQW5DO0FBQ0Q7QUFDRCxjQUFJLENBQUMxUixRQUFRb1YsRUFBUixDQUFXLFVBQVgsQ0FBTCxFQUE2QjtBQUMzQnByQixjQUFFLElBQUYsRUFBUTBuQixPQUFSLENBQWdCLE1BQWhCLEVBQXdCLENBQUMsT0FBRCxDQUF4QjtBQUNBLGdCQUFJd2EsUUFBUWxpQyxFQUFFLElBQUYsRUFBUTg5QixHQUFSLEVBQVo7QUFDQSxnQkFBSTZELFlBQVlPLE1BQU05cUIsT0FBTixDQUFjLEdBQWQsS0FBc0IsQ0FBdEMsRUFBeUM7QUFDdkM4cUIsc0JBQVFBLE1BQU03NkIsS0FBTixDQUFZLEdBQVosRUFBaUIsQ0FBakIsQ0FBUjtBQUNEOztBQUVELGdCQUFJNjdCLGlCQUFpQmx0QixRQUFReVUsSUFBUixDQUFhLElBQWIsRUFBbUJoTyxNQUFuQixDQUEwQixZQUFXO0FBQ3hELHFCQUFPemMsRUFBRSxJQUFGLEVBQVE4eEIsSUFBUixHQUFldHJCLFdBQWYsT0FBaUMwN0IsTUFBTTE3QixXQUFOLEVBQXhDO0FBQ0QsYUFGb0IsRUFFbEIsQ0FGa0IsQ0FBckI7QUFHQXU4QiwyQkFBZS9zQixPQUFmLEVBQXdCa3RCLGNBQXhCLEVBQXdDLElBQXhDO0FBQ0Q7QUFDRixTQWpCVztBQWtCWixpQkFBUyxlQUFVei9CLENBQVYsRUFBWTtBQUNuQkEsWUFBRW1wQixlQUFGO0FBQ0Q7QUFwQlcsT0FBZDs7QUF1QkFrVyxpQkFBV3JlLEVBQVgsQ0FBYyxNQUFkLEVBQXNCLFlBQVc7QUFDL0IsWUFBSSxDQUFDa2QsUUFBTCxFQUFlO0FBQ2IzaEMsWUFBRSxJQUFGLEVBQVEwbkIsT0FBUixDQUFnQixPQUFoQjtBQUNEO0FBQ0QxUixnQkFBUXlVLElBQVIsQ0FBYSxhQUFiLEVBQTRCaGYsV0FBNUIsQ0FBd0MsVUFBeEM7QUFDRCxPQUxEOztBQU9BdUssY0FBUXdXLEtBQVIsQ0FBYyxZQUFXO0FBQ3ZCeVYsdUJBQWUsSUFBZjtBQUNELE9BRkQsRUFFRyxZQUFZO0FBQ2JBLHVCQUFlLEtBQWY7QUFDRCxPQUpEOztBQU1BamlDLFFBQUVpRSxNQUFGLEVBQVV3Z0IsRUFBVixDQUFhO0FBQ1gsaUJBQVMsaUJBQVk7QUFDbkJrZCx1QkFBYU0sZ0JBQWdCYSxXQUFXcGIsT0FBWCxDQUFtQixPQUFuQixDQUE3QjtBQUNEO0FBSFUsT0FBYjs7QUFNQTtBQUNBLFVBQUlpYSxRQUFKLEVBQWM7QUFDWkQsZ0JBQVFqWCxJQUFSLENBQWEsZ0NBQWIsRUFBK0M5bEIsSUFBL0MsQ0FBb0QsWUFBWTtBQUM5RCxjQUFJcXZCLFFBQVFoMEIsRUFBRSxJQUFGLEVBQVFnMEIsS0FBUixFQUFaOztBQUVBNk8sK0JBQXFCYixjQUFyQixFQUFxQ2hPLEtBQXJDLEVBQTRDME4sT0FBNUM7QUFDQTFyQixrQkFBUXlVLElBQVIsQ0FBYSxJQUFiLEVBQW1CdUIsRUFBbkIsQ0FBc0JnSSxLQUF0QixFQUE2QnZKLElBQTdCLENBQWtDLFdBQWxDLEVBQStDckMsSUFBL0MsQ0FBb0QsU0FBcEQsRUFBK0QsSUFBL0Q7QUFDRCxTQUxEO0FBTUQ7O0FBRUQ7Ozs7OztBQU1BLFVBQUkyYSxpQkFBaUIsU0FBakJBLGNBQWlCLENBQVNJLFVBQVQsRUFBcUJDLFNBQXJCLEVBQWdDQyxlQUFoQyxFQUFpRDtBQUNwRSxZQUFJRCxTQUFKLEVBQWU7QUFDYkQscUJBQVcxWSxJQUFYLENBQWdCLGFBQWhCLEVBQStCaGYsV0FBL0IsQ0FBMkMsVUFBM0M7QUFDQSxjQUFJNDJCLFNBQVNyaUMsRUFBRW9qQyxTQUFGLENBQWI7QUFDQWYsaUJBQU92d0IsUUFBUCxDQUFnQixVQUFoQjtBQUNBLGNBQUksQ0FBQzZ2QixRQUFELElBQWEsQ0FBQyxDQUFDMEIsZUFBbkIsRUFBb0M7QUFDbENydEIsb0JBQVFwRCxRQUFSLENBQWlCeXZCLE1BQWpCO0FBQ0Q7QUFDRjtBQUNGLE9BVEQ7O0FBV0E7QUFDQTtBQUNBLFVBQUlpQixjQUFjLEVBQWxCO0FBQUEsVUFDSUMsWUFBWSxTQUFaQSxTQUFZLENBQVM5L0IsQ0FBVCxFQUFXO0FBQ3JCO0FBQ0EsWUFBR0EsRUFBRWtkLEtBQUYsSUFBVyxDQUFkLEVBQWdCO0FBQ2RtaUIscUJBQVdwYixPQUFYLENBQW1CLE9BQW5CO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLFlBQUdqa0IsRUFBRWtkLEtBQUYsSUFBVyxFQUFYLElBQWlCLENBQUMzSyxRQUFRb1YsRUFBUixDQUFXLFVBQVgsQ0FBckIsRUFBNEM7QUFDMUMwWCxxQkFBV3BiLE9BQVgsQ0FBbUIsTUFBbkI7QUFDQTtBQUNEOztBQUVEO0FBQ0EsWUFBR2prQixFQUFFa2QsS0FBRixJQUFXLEVBQVgsSUFBaUIsQ0FBQzNLLFFBQVFvVixFQUFSLENBQVcsVUFBWCxDQUFyQixFQUE0QztBQUMxQztBQUNEOztBQUVEM25CLFVBQUU2ZSxjQUFGOztBQUVBO0FBQ0EsWUFBSWtoQixTQUFTQyxPQUFPQyxZQUFQLENBQW9CamdDLEVBQUVrZCxLQUF0QixFQUE2Qm5hLFdBQTdCLEVBQWI7QUFBQSxZQUNJbTlCLGFBQWEsQ0FBQyxDQUFELEVBQUcsRUFBSCxFQUFNLEVBQU4sRUFBUyxFQUFULEVBQVksRUFBWixDQURqQjtBQUVBLFlBQUlILFVBQVdHLFdBQVd2c0IsT0FBWCxDQUFtQjNULEVBQUVrZCxLQUFyQixNQUFnQyxDQUFDLENBQWhELEVBQW9EO0FBQ2xEMmlCLHNCQUFZaCtCLElBQVosQ0FBaUJrK0IsTUFBakI7O0FBRUEsY0FBSTlDLFNBQVM0QyxZQUFZbnpCLElBQVosQ0FBaUIsRUFBakIsQ0FBYjtBQUFBLGNBQ0lpekIsWUFBWXB0QixRQUFReVUsSUFBUixDQUFhLElBQWIsRUFBbUJoTyxNQUFuQixDQUEwQixZQUFXO0FBQy9DLG1CQUFPemMsRUFBRSxJQUFGLEVBQVE4eEIsSUFBUixHQUFldHJCLFdBQWYsR0FBNkI0USxPQUE3QixDQUFxQ3NwQixNQUFyQyxNQUFpRCxDQUF4RDtBQUNELFdBRlcsRUFFVCxDQUZTLENBRGhCOztBQUtBLGNBQUkwQyxTQUFKLEVBQWU7QUFDYkwsMkJBQWUvc0IsT0FBZixFQUF3Qm90QixTQUF4QjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxZQUFJMy9CLEVBQUVrZCxLQUFGLElBQVcsRUFBZixFQUFtQjtBQUNqQixjQUFJaWpCLGVBQWU1dEIsUUFBUXlVLElBQVIsQ0FBYSw0QkFBYixFQUEyQyxDQUEzQyxDQUFuQjtBQUNBLGNBQUdtWixZQUFILEVBQWdCO0FBQ2Q1akMsY0FBRTRqQyxZQUFGLEVBQWdCbGMsT0FBaEIsQ0FBd0IsT0FBeEI7QUFDQSxnQkFBSSxDQUFDaWEsUUFBTCxFQUFlO0FBQ2JtQix5QkFBV3BiLE9BQVgsQ0FBbUIsT0FBbkI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQSxZQUFJamtCLEVBQUVrZCxLQUFGLElBQVcsRUFBZixFQUFtQjtBQUNqQixjQUFJM0ssUUFBUXlVLElBQVIsQ0FBYSxhQUFiLEVBQTRCL21CLE1BQWhDLEVBQXdDO0FBQ3RDMC9CLHdCQUFZcHRCLFFBQVF5VSxJQUFSLENBQWEsYUFBYixFQUE0QjdVLElBQTVCLENBQWlDLG1CQUFqQyxFQUFzRCxDQUF0RCxDQUFaO0FBQ0QsV0FGRCxNQUVPO0FBQ0x3dEIsd0JBQVlwdEIsUUFBUXlVLElBQVIsQ0FBYSxtQkFBYixFQUFrQyxDQUFsQyxDQUFaO0FBQ0Q7QUFDRHNZLHlCQUFlL3NCLE9BQWYsRUFBd0JvdEIsU0FBeEI7QUFDRDs7QUFFRDtBQUNBLFlBQUkzL0IsRUFBRWtkLEtBQUYsSUFBVyxFQUFmLEVBQW1CO0FBQ2pCbWlCLHFCQUFXcGIsT0FBWCxDQUFtQixPQUFuQjtBQUNEOztBQUVEO0FBQ0EsWUFBSWprQixFQUFFa2QsS0FBRixJQUFXLEVBQWYsRUFBbUI7QUFDakJ5aUIsc0JBQVlwdEIsUUFBUXlVLElBQVIsQ0FBYSxhQUFiLEVBQTRCb1osSUFBNUIsQ0FBaUMsbUJBQWpDLEVBQXNELENBQXRELENBQVo7QUFDQSxjQUFHVCxTQUFILEVBQ0VMLGVBQWUvc0IsT0FBZixFQUF3Qm90QixTQUF4QjtBQUNIOztBQUVEO0FBQ0F6M0IsbUJBQVcsWUFBVTtBQUFFMjNCLHdCQUFjLEVBQWQ7QUFBbUIsU0FBMUMsRUFBNEMsSUFBNUM7QUFDRCxPQXhFTDs7QUEwRUFSLGlCQUFXcmUsRUFBWCxDQUFjLFNBQWQsRUFBeUI4ZSxTQUF6QjtBQUNELEtBMVJEOztBQTRSQSxhQUFTVixvQkFBVCxDQUE4QmlCLFlBQTlCLEVBQTRDQyxVQUE1QyxFQUF3RDNCLE1BQXhELEVBQWdFO0FBQzlELFVBQUlwTyxRQUFROFAsYUFBYTFzQixPQUFiLENBQXFCMnNCLFVBQXJCLENBQVo7QUFBQSxVQUNJQyxXQUFXaFEsVUFBVSxDQUFDLENBRDFCOztBQUdBLFVBQUlnUSxRQUFKLEVBQWM7QUFDWkYscUJBQWF4K0IsSUFBYixDQUFrQnkrQixVQUFsQjtBQUNELE9BRkQsTUFFTztBQUNMRCxxQkFBYXhpQixNQUFiLENBQW9CMFMsS0FBcEIsRUFBMkIsQ0FBM0I7QUFDRDs7QUFFRG9PLGFBQU9yWCxRQUFQLENBQWdCLHFCQUFoQixFQUF1Q04sSUFBdkMsQ0FBNEMsbUJBQTVDLEVBQWlFdUIsRUFBakUsQ0FBb0UrWCxVQUFwRSxFQUFnRnRZLFdBQWhGLENBQTRGLFFBQTVGOztBQUVBO0FBQ0EyVyxhQUFPM1gsSUFBUCxDQUFZLFFBQVosRUFBc0J1QixFQUF0QixDQUF5QitYLFVBQXpCLEVBQXFDM2IsSUFBckMsQ0FBMEMsVUFBMUMsRUFBc0Q0YixRQUF0RDtBQUNBQyxzQkFBZ0JILFlBQWhCLEVBQThCMUIsTUFBOUI7O0FBRUEsYUFBTzRCLFFBQVA7QUFDRDs7QUFFRCxhQUFTQyxlQUFULENBQXlCSCxZQUF6QixFQUF1QzFCLE1BQXZDLEVBQStDO0FBQzdDLFVBQUkxRSxRQUFRLEVBQVo7O0FBRUEsV0FBSyxJQUFJdjVCLElBQUksQ0FBUixFQUFXNGEsUUFBUStrQixhQUFhcGdDLE1BQXJDLEVBQTZDUyxJQUFJNGEsS0FBakQsRUFBd0Q1YSxHQUF4RCxFQUE2RDtBQUMzRCxZQUFJMnRCLE9BQU9zUSxPQUFPM1gsSUFBUCxDQUFZLFFBQVosRUFBc0J1QixFQUF0QixDQUF5QjhYLGFBQWEzL0IsQ0FBYixDQUF6QixFQUEwQzJ0QixJQUExQyxFQUFYOztBQUVBM3RCLGNBQU0sQ0FBTixHQUFVdTVCLFNBQVM1TCxJQUFuQixHQUEwQjRMLFNBQVMsT0FBTzVMLElBQTFDO0FBQ0Q7O0FBRUQsVUFBSTRMLFVBQVUsRUFBZCxFQUFrQjtBQUNoQkEsZ0JBQVEwRSxPQUFPM1gsSUFBUCxDQUFZLGlCQUFaLEVBQStCdUIsRUFBL0IsQ0FBa0MsQ0FBbEMsRUFBcUM4RixJQUFyQyxFQUFSO0FBQ0Q7O0FBRURzUSxhQUFPclgsUUFBUCxDQUFnQix1QkFBaEIsRUFBeUMrUyxHQUF6QyxDQUE2Q0osS0FBN0M7QUFDRDtBQUNGLEdBL1REO0FBaVVELENBN3hCQyxFQTZ4QkMzOUIsTUE3eEJELENBQUQ7QUE4eEJELENBQUUsV0FBVUMsQ0FBVixFQUFhOztBQUViLE1BQUltdkIsVUFBVTs7QUFFWm5yQixVQUFPLGNBQVNnUyxPQUFULEVBQWtCO0FBQ3ZCLFVBQUk5TSxXQUFXO0FBQ2JnN0Isb0JBQVksSUFEQztBQUVieHRCLGdCQUFRLEdBRks7QUFHYjBkLG9CQUFZLEdBSEM7QUFJYjVRLGtCQUFVO0FBSkcsT0FBZjtBQU1BeE4sZ0JBQVVoVyxFQUFFRyxNQUFGLENBQVMrSSxRQUFULEVBQW1COE0sT0FBbkIsQ0FBVjs7QUFFQSxhQUFPLEtBQUtyUixJQUFMLENBQVUsWUFBVzs7QUFFMUI7QUFDQTtBQUNBLFlBQUk0bEIsUUFBUXZxQixFQUFFLElBQUYsQ0FBWjtBQUNBLFlBQUlta0MsVUFBVTVaLE1BQU1FLElBQU4sQ0FBVyxXQUFYLEVBQXdCd0IsS0FBeEIsRUFBZDtBQUNBLFlBQUltWSxVQUFVRCxRQUFRMVosSUFBUixDQUFhLE1BQWIsQ0FBZDtBQUNBLFlBQUk0WixnQkFBZ0JGLFFBQVExWixJQUFSLENBQWEsU0FBYixFQUF3QnVKLEtBQXhCLEVBQXBCO0FBQ0EsWUFBSVIsT0FBSixFQUFhOFEsV0FBYixFQUEwQkMsU0FBMUI7QUFDQSxZQUFJRixpQkFBaUIsQ0FBQyxDQUF0QixFQUF5QjtBQUFFN1Esb0JBQVU0USxRQUFRcFksRUFBUixDQUFXcVksYUFBWCxDQUFWO0FBQXNDOztBQUVqRTtBQUNBLGlCQUFTRyxpQkFBVCxDQUEyQkMsT0FBM0IsRUFBb0NwN0IsUUFBcEMsRUFBOEM7QUFDNUMsY0FBSW83QixRQUFRNVosUUFBUixDQUFpQixjQUFqQixDQUFKLEVBQXNDO0FBQ3BDNFosb0JBQVE1M0IsUUFBUixDQUFpQixFQUFDNkQsU0FBUyxDQUFWLEVBQWE4bUIsWUFBWSxDQUFDLEdBQTFCLEVBQWpCLEVBQWlELEVBQUNudUIsVUFBVUEsUUFBWCxFQUFxQmpFLE9BQU8sS0FBNUIsRUFBakQ7QUFDRCxXQUZELE1BR0ssSUFBSXEvQixRQUFRNVosUUFBUixDQUFpQixhQUFqQixDQUFKLEVBQXFDO0FBQ3hDNFosb0JBQVE1M0IsUUFBUixDQUFpQixFQUFDNkQsU0FBUyxDQUFWLEVBQWErbUIsWUFBWSxHQUF6QixFQUFqQixFQUFnRCxFQUFDcHVCLFVBQVVBLFFBQVgsRUFBcUJqRSxPQUFPLEtBQTVCLEVBQWhEO0FBQ0QsV0FGSSxNQUdBLElBQUlxL0IsUUFBUTVaLFFBQVIsQ0FBaUIsWUFBakIsQ0FBSixFQUFvQztBQUN2QzRaLG9CQUFRNTNCLFFBQVIsQ0FBaUIsRUFBQzZELFNBQVMsQ0FBVixFQUFhK21CLFlBQVksQ0FBQyxHQUExQixFQUFqQixFQUFpRCxFQUFDcHVCLFVBQVVBLFFBQVgsRUFBcUJqRSxPQUFPLEtBQTVCLEVBQWpEO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLGlCQUFTcy9CLFdBQVQsQ0FBcUIxUSxLQUFyQixFQUE0QjtBQUMxQjtBQUNBLGNBQUlBLFNBQVNvUSxRQUFRMWdDLE1BQXJCLEVBQTZCc3dCLFFBQVEsQ0FBUixDQUE3QixLQUNLLElBQUlBLFFBQVEsQ0FBWixFQUFlQSxRQUFRb1EsUUFBUTFnQyxNQUFSLEdBQWdCLENBQXhCOztBQUVwQjJnQywwQkFBZ0JGLFFBQVExWixJQUFSLENBQWEsU0FBYixFQUF3QnVKLEtBQXhCLEVBQWhCOztBQUVBO0FBQ0EsY0FBSXFRLGlCQUFpQnJRLEtBQXJCLEVBQTRCO0FBQzFCUixzQkFBVTRRLFFBQVFwWSxFQUFSLENBQVdxWSxhQUFYLENBQVY7QUFDQU0sdUJBQVduUixRQUFRL0ksSUFBUixDQUFhLFVBQWIsQ0FBWDs7QUFFQStJLG9CQUFRL25CLFdBQVIsQ0FBb0IsUUFBcEI7QUFDQStuQixvQkFBUTNtQixRQUFSLENBQWlCLEVBQUM2RCxTQUFTLENBQVYsRUFBakIsRUFBK0IsRUFBQ3JILFVBQVUyTSxRQUFRb2UsVUFBbkIsRUFBK0JodkIsT0FBTyxLQUF0QyxFQUE2Q2xGLFFBQVEsYUFBckQ7QUFDYndMLHdCQUFVLG9CQUFXO0FBQ25CMDRCLHdCQUFRbFosR0FBUixDQUFZLFNBQVosRUFBdUJyZSxRQUF2QixDQUFnQyxFQUFDNkQsU0FBUyxDQUFWLEVBQWErbUIsWUFBWSxDQUF6QixFQUE0QkQsWUFBWSxDQUF4QyxFQUFoQyxFQUE0RSxFQUFDbnVCLFVBQVUsQ0FBWCxFQUFjakUsT0FBTyxLQUFyQixFQUE1RTtBQUNELGVBSFksRUFBL0I7QUFJQW8vQiw4QkFBa0JHLFFBQWxCLEVBQTRCM3VCLFFBQVFvZSxVQUFwQzs7QUFHQTtBQUNBLGdCQUFJcGUsUUFBUWt1QixVQUFaLEVBQXdCO0FBQ3RCSSwwQkFBWXRZLEVBQVosQ0FBZXFZLGFBQWYsRUFBOEI1NEIsV0FBOUIsQ0FBMEMsUUFBMUM7QUFDRDs7QUFFRDI0QixvQkFBUXBZLEVBQVIsQ0FBV2dJLEtBQVgsRUFBa0JubkIsUUFBbEIsQ0FBMkIsRUFBQzZELFNBQVMsQ0FBVixFQUEzQixFQUF5QyxFQUFDckgsVUFBVTJNLFFBQVFvZSxVQUFuQixFQUErQmh2QixPQUFPLEtBQXRDLEVBQTZDbEYsUUFBUSxhQUFyRCxFQUF6QztBQUNBa2tDLG9CQUFRcFksRUFBUixDQUFXZ0ksS0FBWCxFQUFrQnZKLElBQWxCLENBQXVCLFVBQXZCLEVBQW1DNWQsUUFBbkMsQ0FBNEMsRUFBQzZELFNBQVMsQ0FBVixFQUFhK21CLFlBQVksQ0FBekIsRUFBNEJELFlBQVksQ0FBeEMsRUFBNUMsRUFBd0YsRUFBQ251QixVQUFVMk0sUUFBUW9lLFVBQW5CLEVBQStCdm9CLE9BQU9tSyxRQUFRb2UsVUFBOUMsRUFBMERodkIsT0FBTyxLQUFqRSxFQUF3RWxGLFFBQVEsYUFBaEYsRUFBeEY7QUFDQWtrQyxvQkFBUXBZLEVBQVIsQ0FBV2dJLEtBQVgsRUFBa0JsaUIsUUFBbEIsQ0FBMkIsUUFBM0I7O0FBR0E7QUFDQSxnQkFBSWtFLFFBQVFrdUIsVUFBWixFQUF3QjtBQUN0QkksMEJBQVl0WSxFQUFaLENBQWVnSSxLQUFmLEVBQXNCbGlCLFFBQXRCLENBQStCLFFBQS9CO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0E7QUFDQSxZQUFJLENBQUN5WSxNQUFNTSxRQUFOLENBQWUsWUFBZixDQUFMLEVBQW1DO0FBQ2pDLGNBQUk3VSxRQUFRa3VCLFVBQVosRUFBd0I7QUFDdEI7QUFDQTNaLGtCQUFNN1QsTUFBTixDQUFhVixRQUFRVSxNQUFSLEdBQWlCLEVBQTlCO0FBQ0QsV0FIRCxNQUlLO0FBQ0g2VCxrQkFBTTdULE1BQU4sQ0FBYVYsUUFBUVUsTUFBckI7QUFDRDtBQUNEeXRCLGtCQUFRenRCLE1BQVIsQ0FBZVYsUUFBUVUsTUFBdkI7QUFDRDs7QUFHRDtBQUNBMHRCLGdCQUFRM1osSUFBUixDQUFhLFVBQWIsRUFBeUI5bEIsSUFBekIsQ0FBOEIsWUFBWTtBQUN4QzYvQiw0QkFBa0J4a0MsRUFBRSxJQUFGLENBQWxCLEVBQTJCLENBQTNCO0FBQ0QsU0FGRDs7QUFJQTtBQUNBb2tDLGdCQUFRM1osSUFBUixDQUFhLEtBQWIsRUFBb0I5bEIsSUFBcEIsQ0FBeUIsWUFBWTtBQUNuQyxjQUFJaWdDLG9CQUFvQixvRkFBeEI7QUFDQSxjQUFJNWtDLEVBQUUsSUFBRixFQUFRc29CLElBQVIsQ0FBYSxLQUFiLE1BQXdCc2MsaUJBQTVCLEVBQStDO0FBQzdDNWtDLGNBQUUsSUFBRixFQUFRb1MsR0FBUixDQUFZLGtCQUFaLEVBQWdDLFNBQVNwUyxFQUFFLElBQUYsRUFBUXNvQixJQUFSLENBQWEsS0FBYixDQUFULEdBQStCLEdBQS9EO0FBQ0F0b0IsY0FBRSxJQUFGLEVBQVFzb0IsSUFBUixDQUFhLEtBQWIsRUFBb0JzYyxpQkFBcEI7QUFDRDtBQUNGLFNBTkQ7O0FBUUE7QUFDQSxZQUFJNXVCLFFBQVFrdUIsVUFBWixFQUF3QjtBQUN0Qkksd0JBQWN0a0MsRUFBRSw4QkFBRixDQUFkO0FBQ0Fva0Msa0JBQVF6L0IsSUFBUixDQUFhLFVBQVVxdkIsS0FBVixFQUFrQjtBQUM3QixnQkFBSUQsYUFBYS96QixFQUFFLGtDQUFGLENBQWpCOztBQUVBO0FBQ0ErekIsdUJBQVd6RCxLQUFYLENBQWlCLFlBQVk7QUFDM0Isa0JBQUl1VSxVQUFVVixRQUFRclosTUFBUixFQUFkO0FBQ0Esa0JBQUlnYSxhQUFhRCxRQUFRcGEsSUFBUixDQUFhenFCLEVBQUUsSUFBRixDQUFiLEVBQXNCZzBCLEtBQXRCLEVBQWpCO0FBQ0EwUSwwQkFBWUksVUFBWjs7QUFFQTtBQUNBbkssNEJBQWM0SixTQUFkO0FBQ0FBLDBCQUFZN0osWUFDVixZQUFVO0FBQ1IySixnQ0FBZ0JGLFFBQVExWixJQUFSLENBQWEsU0FBYixFQUF3QnVKLEtBQXhCLEVBQWhCO0FBQ0Esb0JBQUlvUSxRQUFRMWdDLE1BQVIsSUFBa0IyZ0MsZ0JBQWdCLENBQXRDLEVBQXlDQSxnQkFBZ0IsQ0FBaEIsQ0FBekMsQ0FBNEQ7QUFBNUQscUJBQ0tBLGlCQUFpQixDQUFqQjs7QUFFTEssNEJBQVlMLGFBQVo7QUFFRCxlQVJTLEVBUVBydUIsUUFBUW9lLFVBQVIsR0FBcUJwZSxRQUFRd04sUUFSdEIsQ0FBWjtBQVVELGFBakJEO0FBa0JBOGdCLHdCQUFZalUsTUFBWixDQUFtQjBELFVBQW5CO0FBQ0QsV0F2QkQ7QUF3QkF4SixnQkFBTThGLE1BQU4sQ0FBYWlVLFdBQWI7QUFDQUEsd0JBQWMvWixNQUFNRSxJQUFOLENBQVcsZUFBWCxFQUE0QkEsSUFBNUIsQ0FBaUMsbUJBQWpDLENBQWQ7QUFDRDs7QUFFRCxZQUFJK0ksT0FBSixFQUFhO0FBQ1hBLGtCQUFRNEIsSUFBUjtBQUNELFNBRkQsTUFHSztBQUNIZ1Asa0JBQVFuWSxLQUFSLEdBQWdCbmEsUUFBaEIsQ0FBeUIsUUFBekIsRUFBbUNqRixRQUFuQyxDQUE0QyxFQUFDNkQsU0FBUyxDQUFWLEVBQTVDLEVBQTBELEVBQUNySCxVQUFVMk0sUUFBUW9lLFVBQW5CLEVBQStCaHZCLE9BQU8sS0FBdEMsRUFBNkNsRixRQUFRLGFBQXJELEVBQTFEOztBQUVBbWtDLDBCQUFnQixDQUFoQjtBQUNBN1Esb0JBQVU0USxRQUFRcFksRUFBUixDQUFXcVksYUFBWCxDQUFWOztBQUVBO0FBQ0EsY0FBSXJ1QixRQUFRa3VCLFVBQVosRUFBd0I7QUFDdEJJLHdCQUFZdFksRUFBWixDQUFlcVksYUFBZixFQUE4QnZ5QixRQUE5QixDQUF1QyxRQUF2QztBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTBoQixnQkFBUS9JLElBQVIsQ0FBYSxLQUFiLEVBQW9COWxCLElBQXBCLENBQXlCLFlBQVc7QUFDbEM2dUIsa0JBQVEvSSxJQUFSLENBQWEsVUFBYixFQUF5QjVkLFFBQXpCLENBQWtDLEVBQUM2RCxTQUFTLENBQVYsRUFBYSttQixZQUFZLENBQXpCLEVBQTRCRCxZQUFZLENBQXhDLEVBQWxDLEVBQThFLEVBQUNudUIsVUFBVTJNLFFBQVFvZSxVQUFuQixFQUErQmh2QixPQUFPLEtBQXRDLEVBQTZDbEYsUUFBUSxhQUFyRCxFQUE5RTtBQUNELFNBRkQ7O0FBSUE7QUFDQXFrQyxvQkFBWTdKLFlBQ1YsWUFBVTtBQUNSMkosMEJBQWdCRixRQUFRMVosSUFBUixDQUFhLFNBQWIsRUFBd0J1SixLQUF4QixFQUFoQjtBQUNBMFEsc0JBQVlMLGdCQUFnQixDQUE1QjtBQUVELFNBTFMsRUFLUHJ1QixRQUFRb2UsVUFBUixHQUFxQnBlLFFBQVF3TixRQUx0QixDQUFaOztBQVNBOztBQUVBO0FBQ0EsWUFBSW9ZLFVBQVUsS0FBZDtBQUNBLFlBQUltSixZQUFZLEtBQWhCO0FBQ0EsWUFBSUMsYUFBYSxLQUFqQjs7QUFFQXphLGNBQU0vQyxNQUFOLENBQWE7QUFDVHVULDJCQUFpQjtBQURSLFNBQWIsRUFFR3hNLElBRkgsQ0FFUSxLQUZSLEVBRWUsVUFBUzlxQixDQUFULEVBQVk7QUFDekIsY0FBSUEsRUFBRXFjLE9BQUYsQ0FBVWMsV0FBVixLQUEwQixPQUE5QixFQUF1Qzs7QUFFckM7QUFDQStaLDBCQUFjNEosU0FBZDs7QUFFQSxnQkFBSTV4QixZQUFZbFAsRUFBRXFjLE9BQUYsQ0FBVW5OLFNBQTFCO0FBQ0EsZ0JBQUlyUyxJQUFJbUQsRUFBRXFjLE9BQUYsQ0FBVTdGLE1BQWxCO0FBQ0EsZ0JBQUlXLFlBQVluWCxFQUFFcWMsT0FBRixDQUFVbEYsU0FBMUI7QUFDQSxnQkFBSUMsWUFBWXBYLEVBQUVxYyxPQUFGLENBQVVqRixTQUExQjs7QUFFQW9xQiwwQkFBY2QsUUFBUTFaLElBQVIsQ0FBYSxTQUFiLENBQWQ7QUFDQSxnQkFBSWpwQixLQUFLa0IsR0FBTCxDQUFTa1ksU0FBVCxJQUFzQnBaLEtBQUtrQixHQUFMLENBQVNtWSxTQUFULENBQTFCLEVBQStDO0FBQzdDb3FCLDBCQUFZcDRCLFFBQVosQ0FBcUIsRUFBRTRxQixZQUFZbjNCO0FBQWQsZUFBckIsRUFDTyxFQUFDK0ksVUFBVSxFQUFYLEVBQWVqRSxPQUFPLEtBQXRCLEVBQTZCbEYsUUFBUSxhQUFyQyxFQURQO0FBRUQ7O0FBRUQ7QUFDQSxnQkFBSXlTLGNBQWMsQ0FBZCxLQUFvQnJTLElBQUtpcUIsTUFBTWxXLFVBQU4sS0FBcUIsQ0FBMUIsSUFBZ0N1RyxZQUFZLENBQUMsSUFBakUsQ0FBSixFQUE0RTtBQUMxRW9xQiwyQkFBYSxJQUFiO0FBQ0Q7QUFDRDtBQUhBLGlCQUlLLElBQUlyeUIsY0FBYyxDQUFkLEtBQW9CclMsSUFBSyxDQUFDLENBQUQsR0FBS2lxQixNQUFNbFcsVUFBTixFQUFMLEdBQTBCLENBQS9CLElBQXFDdUcsWUFBWSxJQUFyRSxDQUFKLEVBQWdGO0FBQ25GbXFCLDRCQUFZLElBQVo7QUFDRDs7QUFFRDtBQUNBLGdCQUFJRyxVQUFKO0FBQ0EsZ0JBQUlILFNBQUosRUFBZTtBQUNiRywyQkFBYUQsWUFBWXJ2QixJQUFaLEVBQWI7QUFDQSxrQkFBSXN2QixXQUFXeGhDLE1BQVgsS0FBc0IsQ0FBMUIsRUFBNkI7QUFDM0J3aEMsNkJBQWFkLFFBQVFuWSxLQUFSLEVBQWI7QUFDRDtBQUNEaVoseUJBQVdyNEIsUUFBWCxDQUFvQixFQUFFNkQsU0FBUztBQUFYLGVBQXBCLEVBQ08sRUFBQ3JILFVBQVUsR0FBWCxFQUFnQmpFLE9BQU8sS0FBdkIsRUFBOEJsRixRQUFRLGFBQXRDLEVBRFA7QUFFRDtBQUNELGdCQUFJOGtDLFVBQUosRUFBZ0I7QUFDZEUsMkJBQWFELFlBQVlwQixJQUFaLEVBQWI7QUFDQSxrQkFBSXFCLFdBQVd4aEMsTUFBWCxLQUFzQixDQUExQixFQUE2QjtBQUMzQndoQyw2QkFBYWQsUUFBUWUsSUFBUixFQUFiO0FBQ0Q7QUFDREQseUJBQVdyNEIsUUFBWCxDQUFvQixFQUFFNkQsU0FBUztBQUFYLGVBQXBCLEVBQ08sRUFBQ3JILFVBQVUsR0FBWCxFQUFnQmpFLE9BQU8sS0FBdkIsRUFBOEJsRixRQUFRLGFBQXRDLEVBRFA7QUFFRDtBQUdGO0FBRUYsU0FsREQsRUFrREdxdUIsSUFsREgsQ0FrRFEsUUFsRFIsRUFrRGtCLFVBQVM5cUIsQ0FBVCxFQUFZO0FBQzVCLGNBQUlBLEVBQUVxYyxPQUFGLENBQVVjLFdBQVYsS0FBMEIsT0FBOUIsRUFBdUM7O0FBRXJDcWtCLDBCQUFjZCxRQUFRMVosSUFBUixDQUFhLFNBQWIsQ0FBZDtBQUNBbVIsc0JBQVUsS0FBVjtBQUNBa0oseUJBQWFYLFFBQVExWixJQUFSLENBQWEsU0FBYixFQUF3QnVKLEtBQXhCLEVBQWI7O0FBRUEsZ0JBQUksQ0FBQ2dSLFVBQUQsSUFBZSxDQUFDRCxTQUFoQixJQUE2QlgsUUFBUTFnQyxNQUFSLElBQWlCLENBQWxELEVBQXFEO0FBQ25EO0FBQ0F1aEMsMEJBQVlwNEIsUUFBWixDQUFxQixFQUFFNHFCLFlBQVk7QUFBZCxlQUFyQixFQUNPLEVBQUNwdUIsVUFBVSxHQUFYLEVBQWdCakUsT0FBTyxLQUF2QixFQUE4QmxGLFFBQVEsYUFBdEMsRUFEUDtBQUVELGFBSkQsTUFLSyxJQUFJNmtDLFNBQUosRUFBZTtBQUNsQkwsMEJBQVlJLGFBQWEsQ0FBekI7QUFDQUcsMEJBQVlwNEIsUUFBWixDQUFxQixFQUFDNHFCLFlBQVksQ0FBQyxDQUFELEdBQUtsTixNQUFNbFcsVUFBTixFQUFsQixFQUFyQixFQUE2RCxFQUFDaEwsVUFBVSxHQUFYLEVBQWdCakUsT0FBTyxLQUF2QixFQUE4QmxGLFFBQVEsYUFBdEM7QUFDdkN3TCwwQkFBVSxvQkFBVztBQUNuQnU1Qiw4QkFBWXA0QixRQUFaLENBQXFCLEVBQUM2RCxTQUFTLENBQVYsRUFBYSttQixZQUFZLENBQXpCLEVBQXJCLEVBQWtELEVBQUNwdUIsVUFBVSxDQUFYLEVBQWNqRSxPQUFPLEtBQXJCLEVBQWxEO0FBQ0QsaUJBSHNDLEVBQTdEO0FBSUQsYUFOSSxNQU9BLElBQUk0L0IsVUFBSixFQUFnQjtBQUNuQk4sMEJBQVlJLGFBQWEsQ0FBekI7QUFDQUcsMEJBQVlwNEIsUUFBWixDQUFxQixFQUFDNHFCLFlBQVlsTixNQUFNbFcsVUFBTixFQUFiLEVBQXJCLEVBQXdELEVBQUNoTCxVQUFVLEdBQVgsRUFBZ0JqRSxPQUFPLEtBQXZCLEVBQThCbEYsUUFBUSxhQUF0QztBQUNsQ3dMLDBCQUFVLG9CQUFXO0FBQ25CdTVCLDhCQUFZcDRCLFFBQVosQ0FBcUIsRUFBQzZELFNBQVMsQ0FBVixFQUFhK21CLFlBQVksQ0FBekIsRUFBckIsRUFBa0QsRUFBQ3B1QixVQUFVLENBQVgsRUFBY2pFLE9BQU8sS0FBckIsRUFBbEQ7QUFDRCxpQkFIaUMsRUFBeEQ7QUFJRDtBQUNEMi9CLHdCQUFZLEtBQVo7QUFDQUMseUJBQWEsS0FBYjs7QUFFQTtBQUNBckssMEJBQWM0SixTQUFkO0FBQ0FBLHdCQUFZN0osWUFDVixZQUFVO0FBQ1IySiw4QkFBZ0JGLFFBQVExWixJQUFSLENBQWEsU0FBYixFQUF3QnVKLEtBQXhCLEVBQWhCO0FBQ0Esa0JBQUlvUSxRQUFRMWdDLE1BQVIsSUFBa0IyZ0MsZ0JBQWdCLENBQXRDLEVBQXlDQSxnQkFBZ0IsQ0FBaEIsQ0FBekMsQ0FBNEQ7QUFBNUQsbUJBQ0tBLGlCQUFpQixDQUFqQjs7QUFFTEssMEJBQVlMLGFBQVo7QUFFRCxhQVJTLEVBUVBydUIsUUFBUW9lLFVBQVIsR0FBcUJwZSxRQUFRd04sUUFSdEIsQ0FBWjtBQVVEO0FBQ0YsU0E1RkQ7O0FBOEZBK0csY0FBTTlGLEVBQU4sQ0FBUyxhQUFULEVBQXdCLFlBQVc7QUFDakNrVyx3QkFBYzRKLFNBQWQ7QUFDRCxTQUZEOztBQUlBaGEsY0FBTTlGLEVBQU4sQ0FBUyxhQUFULEVBQXdCLFlBQVc7QUFDakNrVyx3QkFBYzRKLFNBQWQ7QUFDQUEsc0JBQVk3SixZQUNWLFlBQVU7QUFDUjJKLDRCQUFnQkYsUUFBUTFaLElBQVIsQ0FBYSxTQUFiLEVBQXdCdUosS0FBeEIsRUFBaEI7QUFDQSxnQkFBSW9RLFFBQVExZ0MsTUFBUixJQUFrQjJnQyxnQkFBZ0IsQ0FBdEMsRUFBeUNBLGdCQUFnQixDQUFoQixDQUF6QyxDQUE0RDtBQUE1RCxpQkFDS0EsaUJBQWlCLENBQWpCOztBQUVMSyx3QkFBWUwsYUFBWjtBQUVELFdBUlMsRUFRUHJ1QixRQUFRb2UsVUFBUixHQUFxQnBlLFFBQVF3TixRQVJ0QixDQUFaO0FBVUQsU0FaRDs7QUFjQStHLGNBQU05RixFQUFOLENBQVMsWUFBVCxFQUF1QixZQUFXO0FBQ2hDNGYsMEJBQWdCRixRQUFRMVosSUFBUixDQUFhLFNBQWIsRUFBd0J1SixLQUF4QixFQUFoQjtBQUNBMFEsc0JBQVlMLGdCQUFnQixDQUE1QjtBQUNELFNBSEQ7O0FBS0E5WixjQUFNOUYsRUFBTixDQUFTLFlBQVQsRUFBdUIsWUFBVztBQUNoQzRmLDBCQUFnQkYsUUFBUTFaLElBQVIsQ0FBYSxTQUFiLEVBQXdCdUosS0FBeEIsRUFBaEI7QUFDQTBRLHNCQUFZTCxnQkFBZ0IsQ0FBNUI7QUFDRCxTQUhEO0FBS0QsT0F4Uk0sQ0FBUDtBQTRSRCxLQXZTVztBQXdTWmUsV0FBUSxpQkFBVztBQUNqQnBsQyxRQUFFLElBQUYsRUFBUTBuQixPQUFSLENBQWdCLGFBQWhCO0FBQ0QsS0ExU1c7QUEyU1oyZCxXQUFRLGlCQUFXO0FBQ2pCcmxDLFFBQUUsSUFBRixFQUFRMG5CLE9BQVIsQ0FBZ0IsYUFBaEI7QUFDRCxLQTdTVztBQThTWjlSLFVBQU8sZ0JBQVc7QUFDaEI1VixRQUFFLElBQUYsRUFBUTBuQixPQUFSLENBQWdCLFlBQWhCO0FBQ0QsS0FoVFc7QUFpVFptYyxVQUFPLGdCQUFXO0FBQ2hCN2pDLFFBQUUsSUFBRixFQUFRMG5CLE9BQVIsQ0FBZ0IsWUFBaEI7QUFDRDtBQW5UVyxHQUFkOztBQXVUQTFuQixJQUFFK0QsRUFBRixDQUFLdWhDLE1BQUwsR0FBYyxVQUFTM1UsZUFBVCxFQUEwQjtBQUN0QyxRQUFLeEIsUUFBUXdCLGVBQVIsQ0FBTCxFQUFnQztBQUM5QixhQUFPeEIsUUFBU3dCLGVBQVQsRUFBMkIvckIsS0FBM0IsQ0FBa0MsSUFBbEMsRUFBd0NOLE1BQU1JLFNBQU4sQ0FBZ0JpRCxLQUFoQixDQUFzQnZELElBQXRCLENBQTRCYSxTQUE1QixFQUF1QyxDQUF2QyxDQUF4QyxDQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUssUUFBTzByQixlQUFQLHlDQUFPQSxlQUFQLE9BQTJCLFFBQTNCLElBQXVDLENBQUVBLGVBQTlDLEVBQWdFO0FBQ3JFO0FBQ0EsYUFBT3hCLFFBQVFuckIsSUFBUixDQUFhWSxLQUFiLENBQW9CLElBQXBCLEVBQTBCSyxTQUExQixDQUFQO0FBQ0QsS0FITSxNQUdBO0FBQ0xqRixRQUFFNHdCLEtBQUYsQ0FBUyxZQUFhRCxlQUFiLEdBQStCLG1DQUF4QztBQUNEO0FBQ0YsR0FURCxDQXpUYSxDQWtVVjtBQUNKLENBblVDLEVBbVVDNXdCLE1BblVELENBQUQ7QUFvVUQsQ0FBRSxXQUFVQyxDQUFWLEVBQWE7QUFDYkEsSUFBRWdHLFFBQUYsRUFBWWttQixLQUFaLENBQWtCLFlBQVc7O0FBRTNCbHNCLE1BQUVnRyxRQUFGLEVBQVl5ZSxFQUFaLENBQWUsWUFBZixFQUE2QixPQUE3QixFQUFzQyxVQUFVaGhCLENBQVYsRUFBYTtBQUNqRCxVQUFJekQsRUFBRSxJQUFGLEVBQVF5cUIsSUFBUixDQUFhLGdCQUFiLEVBQStCL21CLE1BQW5DLEVBQTJDO0FBQ3pDLFlBQUkxRCxFQUFFeUQsRUFBRW9VLE1BQUosRUFBWXVULEVBQVosQ0FBZXByQixFQUFFLDBCQUFGLENBQWYsS0FBaURBLEVBQUV5RCxFQUFFb1UsTUFBSixFQUFZdVQsRUFBWixDQUFlcHJCLEVBQUUsNEJBQUYsQ0FBZixDQUFyRCxFQUFzRztBQUNwRztBQUNBQSxZQUFFLElBQUYsRUFBUXlxQixJQUFSLENBQWEsY0FBYixFQUE2QjVkLFFBQTdCLENBQ0UsRUFBQzJxQixZQUFZLENBQWIsRUFERixFQUNtQjtBQUNmbnVCLHNCQUFVLEdBREs7QUFFZmpFLG1CQUFPLEtBRlE7QUFHZmxGLG9CQUFRLGVBSE87QUFJZndMLHNCQUFVLG9CQUFXO0FBQUUxTCxnQkFBRSxJQUFGLEVBQVFvUyxHQUFSLENBQVksRUFBRTdJLFNBQVMsTUFBWCxFQUFaO0FBQWtDO0FBSjFDLFdBRG5CO0FBUUQsU0FWRCxNQVdLLElBQUl2SixFQUFFeUQsRUFBRW9VLE1BQUosRUFBWXVULEVBQVosQ0FBZXByQixFQUFFLGtCQUFGLENBQWYsS0FDQUEsRUFBRXlELEVBQUVvVSxNQUFKLEVBQVl1VCxFQUFaLENBQWVwckIsRUFBRSxvQkFBRixDQUFmLENBREosRUFDOEM7QUFDakRBLFlBQUV5RCxFQUFFb1UsTUFBSixFQUFZZ1UsT0FBWixDQUFvQixPQUFwQixFQUE2QnpaLEdBQTdCLENBQWlDLFVBQWpDLEVBQTZDLFFBQTdDO0FBQ0FwUyxZQUFFLElBQUYsRUFBUXlxQixJQUFSLENBQWEsY0FBYixFQUE2QnJZLEdBQTdCLENBQWlDLEVBQUU3SSxTQUFTLE9BQVgsRUFBakMsRUFBc0RzRCxRQUF0RCxDQUErRCxNQUEvRCxFQUF1RSxLQUF2RSxFQUE4RUEsUUFBOUUsQ0FBdUYsRUFBQzJxQixZQUFZLE9BQWIsRUFBdkYsRUFBOEcsRUFBQ251QixVQUFVLEdBQVgsRUFBZ0JqRSxPQUFPLEtBQXZCLEVBQThCbEYsUUFBUSxlQUF0QyxFQUE5RztBQUNEO0FBQ0Y7QUFDRixLQW5CRDtBQXFCRCxHQXZCRDtBQXdCRCxDQXpCQyxFQXlCQ0gsTUF6QkQsQ0FBRCxDQXlCWSxDQUFFLFdBQVVDLENBQVYsRUFBYTtBQUMxQixNQUFJdWxDLHdCQUF3QjtBQUMxQjFnQyxVQUFNLEVBRG9CO0FBRTFCbXNCLGlCQUFhLEVBRmE7QUFHMUJ3VSwwQkFBc0IsRUFISTtBQUkxQkMseUJBQXFCO0FBSkssR0FBNUI7O0FBT0F6bEMsSUFBRWdHLFFBQUYsRUFBWWttQixLQUFaLENBQWtCLFlBQVc7QUFDM0I7QUFDQWxzQixNQUFFZ0csUUFBRixFQUFZeWUsRUFBWixDQUFlLE9BQWYsRUFBd0IsY0FBeEIsRUFBd0MsVUFBU2hoQixDQUFULEVBQVc7QUFDakQsVUFBSWlpQyxTQUFTMWxDLEVBQUUsSUFBRixFQUFRNnJCLE9BQVIsQ0FBZ0IsUUFBaEIsQ0FBYjtBQUNBLFVBQUk2WixPQUFPcGQsSUFBUCxDQUFZLGtCQUFaLENBQUosRUFBcUM7QUFDbkM7QUFDRDtBQUNEdG9CLFFBQUUsSUFBRixFQUFRNnJCLE9BQVIsQ0FBZ0IsT0FBaEIsRUFBeUIzWixNQUF6QjtBQUNELEtBTkQ7QUFPRCxHQVREOztBQVdBbFMsSUFBRStELEVBQUYsQ0FBSzRoQyxhQUFMLEdBQXFCLFVBQVUzdkIsT0FBVixFQUFtQjtBQUN0QyxRQUFJNHZCLE9BQU8sSUFBWDtBQUNBLFNBQUtyZSxHQUFMLEdBQVd2bkIsRUFBRSxJQUFGLENBQVg7QUFDQSxTQUFLNmxDLFNBQUwsR0FBaUI3bEMsRUFBRWdHLFFBQUYsQ0FBakI7QUFDQSxTQUFLOC9CLElBQUwsR0FBWTtBQUNWQyxhQUFPLFFBREc7QUFFVkMsWUFBTSxPQUZJO0FBR1ZDLGFBQU8sT0FIRztBQUlWQyxjQUFRLGlCQUpFO0FBS1ZDLHFCQUFlO0FBTEwsS0FBWjs7QUFRQSxRQUFJLFdBQVdud0IsT0FBZixFQUF3QjtBQUN0QixhQUFPLEtBQUt1UixHQUFMLENBQVMxaUIsSUFBVCxDQUFjLE9BQWQsQ0FBUDtBQUNEOztBQUVELFFBQUlpb0IsZUFBZTlzQixFQUFFRyxNQUFGLENBQVMsRUFBVCxFQUFhb2xDLHFCQUFiLEVBQW9DdnZCLE9BQXBDLENBQW5CO0FBQ0E0dkIsU0FBS1EsZUFBTCxHQUF1QixDQUFDcG1DLEVBQUU0TSxhQUFGLENBQWdCa2dCLGFBQWEyWSxtQkFBYixDQUFpQzVnQyxJQUFqRCxDQUF4Qjs7QUFFQTtBQUNBLFNBQUtiLElBQUwsR0FBWSxZQUFXO0FBQ3JCLFVBQUlHLElBQUksQ0FBUjtBQUNBLFVBQUlraUMsS0FBSjtBQUNBVCxXQUFLcmUsR0FBTCxDQUFTNWlCLElBQVQsQ0FBYyxZQUFVO0FBQ3RCLFlBQUkrZ0MsU0FBUzFsQyxFQUFFLElBQUYsQ0FBYjtBQUNBLFlBQUlzbUMsU0FBUzFlLFlBQVlZLElBQVosRUFBYjtBQUNBb2QsYUFBS1UsTUFBTCxHQUFjQSxNQUFkOztBQUVBLFlBQUksQ0FBQ3haLGFBQWFqb0IsSUFBZCxJQUFzQixFQUFFaW9CLGFBQWFqb0IsSUFBYixZQUE2QlAsS0FBL0IsQ0FBMUIsRUFBaUU7QUFDL0R3b0IsdUJBQWFqb0IsSUFBYixHQUFvQixFQUFwQjtBQUNEO0FBQ0Q2Z0MsZUFBTzdnQyxJQUFQLENBQVksT0FBWixFQUFxQmlvQixhQUFham9CLElBQWxDO0FBQ0E2Z0MsZUFBT3BkLElBQVAsQ0FBWSxZQUFaLEVBQTBCbmtCLENBQTFCO0FBQ0F1aEMsZUFBT3BkLElBQVAsQ0FBWSxrQkFBWixFQUFnQyxJQUFoQzs7QUFFQSxZQUFJLENBQUNvZCxPQUFPN2EsUUFBUCxDQUFnQithLEtBQUtFLElBQUwsQ0FBVUMsS0FBMUIsQ0FBTCxFQUF1QztBQUNyQ0wsaUJBQU81ekIsUUFBUCxDQUFnQixPQUFoQjtBQUNEOztBQUVEOHpCLGFBQUtTLEtBQUwsQ0FBV1gsTUFBWCxFQUFtQlksTUFBbkI7QUFDQW5pQztBQUNELE9BbEJEO0FBbUJELEtBdEJEOztBQXdCQSxTQUFLb2lDLFlBQUwsR0FBb0IsWUFBVztBQUM3QixVQUFJVCxPQUFPRixLQUFLRSxJQUFoQjs7QUFFQUYsV0FBS0MsU0FBTCxDQUFlbmhCLEdBQWYsQ0FBbUIsbUJBQW5CLEVBQXdDb2hCLEtBQUtDLEtBQTdDLEVBQW9EdGhCLEVBQXBELENBQXVELG1CQUF2RCxFQUE0RXFoQixLQUFLQyxLQUFqRixFQUF3RixVQUFTdGlDLENBQVQsRUFBVztBQUNqR3pELFVBQUV5RCxFQUFFb1UsTUFBSixFQUFZNFMsSUFBWixDQUFpQnFiLEtBQUtHLEtBQXRCLEVBQTZCTyxLQUE3QjtBQUNELE9BRkQ7O0FBSUFaLFdBQUtDLFNBQUwsQ0FBZW5oQixHQUFmLENBQW1CLG9CQUFuQixFQUF5Q29oQixLQUFLRSxJQUE5QyxFQUFvRHZoQixFQUFwRCxDQUF1RCxvQkFBdkQsRUFBNkVxaEIsS0FBS0UsSUFBbEYsRUFBd0YsVUFBU3ZpQyxDQUFULEVBQVc7QUFDakcsWUFBSWdqQyxRQUFRem1DLEVBQUV5RCxFQUFFb1UsTUFBSixDQUFaO0FBQ0EsWUFBSTR1QixNQUFNL2lDLE1BQVYsRUFBa0I7QUFDaEIsY0FBSWdqQyxjQUFjRCxNQUFNNWIsUUFBTixDQUFlLFVBQWYsQ0FBbEI7QUFDQSxjQUFJNmEsU0FBU2UsTUFBTTVhLE9BQU4sQ0FBY2lhLEtBQUtDLEtBQW5CLENBQWI7QUFDQS9sQyxZQUFFOGxDLEtBQUtFLElBQVAsRUFBYXY2QixXQUFiLENBQXlCLFVBQXpCOztBQUVBLGNBQUksQ0FBQ2k3QixXQUFMLEVBQWtCO0FBQ2hCZCxpQkFBS2UsVUFBTCxDQUFnQkYsTUFBTXpTLEtBQU4sRUFBaEIsRUFBK0IwUixNQUEvQjtBQUNEO0FBQ0Y7QUFDRixPQVhEOztBQWFBRSxXQUFLQyxTQUFMLENBQWVuaEIsR0FBZixDQUFtQixlQUFuQixFQUFvQ0QsRUFBcEMsQ0FBdUMsZUFBdkMsRUFBd0QsVUFBU2hoQixDQUFULEVBQVc7QUFDakUsWUFBSXpELEVBQUV5RCxFQUFFb1UsTUFBSixFQUFZdVQsRUFBWixDQUFlLGlCQUFmLENBQUosRUFBdUM7QUFDckM7QUFDRDs7QUFFRDtBQUNBLFlBQUlxYixRQUFRYixLQUFLQyxTQUFMLENBQWVwYixJQUFmLENBQW9CcWIsS0FBS0UsSUFBTCxHQUFZRixLQUFLSyxhQUFyQyxDQUFaO0FBQ0EsWUFBSVQsU0FBU2UsTUFBTTVhLE9BQU4sQ0FBY2lhLEtBQUtDLEtBQW5CLENBQWI7QUFDQSxZQUFJcmlDLFNBQVMraUMsTUFBTTFiLFFBQU4sQ0FBZSthLEtBQUtFLElBQXBCLEVBQTBCdGlDLE1BQXZDO0FBQ0EsWUFBSXN3QixLQUFKOztBQUVBLFlBQUksQ0FBQ3lTLE1BQU0vaUMsTUFBWCxFQUFtQjtBQUNqQjtBQUNEOztBQUVELFlBQUlELEVBQUVrZCxLQUFGLEtBQVksQ0FBWixJQUFpQmxkLEVBQUVrZCxLQUFGLEtBQVksRUFBakMsRUFBcUM7QUFDbkNsZCxZQUFFNmUsY0FBRjs7QUFFQTBSLGtCQUFReVMsTUFBTXpTLEtBQU4sRUFBUjtBQUNBNFIsZUFBS2dCLFVBQUwsQ0FBZ0I1UyxLQUFoQixFQUF1QjBSLE1BQXZCOztBQUVBLGNBQUltQixjQUFjLElBQWxCO0FBQ0EsY0FBSzdTLFFBQVEsQ0FBVCxHQUFjdHdCLE1BQWxCLEVBQTBCO0FBQ3hCbWpDLDBCQUFjN1MsS0FBZDtBQUNELFdBRkQsTUFFTyxJQUFJQSxVQUFVdHdCLE1BQVYsSUFBcUJzd0IsUUFBUSxDQUFULEtBQWdCdHdCLE1BQXhDLEVBQWdEO0FBQ3JEbWpDLDBCQUFjbmpDLFNBQVMsQ0FBdkI7QUFDRDs7QUFFRCxjQUFJbWpDLGNBQWMsQ0FBbEIsRUFBcUJBLGNBQWMsSUFBZDs7QUFFckIsY0FBSSxTQUFTQSxXQUFiLEVBQTBCO0FBQ3hCakIsaUJBQUtlLFVBQUwsQ0FBZ0JFLFdBQWhCLEVBQTZCbkIsTUFBN0I7QUFDRDtBQUNELGNBQUksQ0FBQ2hpQyxNQUFMLEVBQWFnaUMsT0FBT2piLElBQVAsQ0FBWSxPQUFaLEVBQXFCK2IsS0FBckI7O0FBRWY7QUFDQyxTQXJCRCxNQXFCTyxJQUFJL2lDLEVBQUVrZCxLQUFGLEtBQVksRUFBaEIsRUFBb0I7QUFDekJxVCxrQkFBUXlTLE1BQU16UyxLQUFOLEtBQWdCLENBQXhCO0FBQ0EsY0FBSUEsUUFBUSxDQUFaLEVBQWU7QUFDYjtBQUNEO0FBQ0RoMEIsWUFBRThsQyxLQUFLRSxJQUFQLEVBQWF2NkIsV0FBYixDQUF5QixVQUF6QjtBQUNBbTZCLGVBQUtlLFVBQUwsQ0FBZ0IzUyxLQUFoQixFQUF1QjBSLE1BQXZCOztBQUVGO0FBQ0MsU0FUTSxNQVNBLElBQUlqaUMsRUFBRWtkLEtBQUYsS0FBWSxFQUFoQixFQUFvQjtBQUN6QnFULGtCQUFReVMsTUFBTXpTLEtBQU4sS0FBZ0IsQ0FBeEI7QUFDQWgwQixZQUFFOGxDLEtBQUtFLElBQVAsRUFBYXY2QixXQUFiLENBQXlCLFVBQXpCO0FBQ0EsY0FBSXVvQixRQUFRdHdCLE1BQVosRUFBb0I7QUFDbEJnaUMsbUJBQU9qYixJQUFQLENBQVksT0FBWixFQUFxQitiLEtBQXJCO0FBQ0E7QUFDRDtBQUNEWixlQUFLZSxVQUFMLENBQWdCM1MsS0FBaEIsRUFBdUIwUixNQUF2QjtBQUNEO0FBQ0YsT0F0REQ7O0FBd0RBRSxXQUFLQyxTQUFMLENBQWVuaEIsR0FBZixDQUFtQixlQUFuQixFQUFvQ29oQixLQUFLQyxLQUFMLEdBQWEsR0FBYixHQUFtQkQsS0FBS0csS0FBNUQsRUFBbUV4aEIsRUFBbkUsQ0FBc0UsZUFBdEUsRUFBdUZxaEIsS0FBS0MsS0FBTCxHQUFhLEdBQWIsR0FBbUJELEtBQUtHLEtBQS9HLEVBQXNILFVBQVN4aUMsQ0FBVCxFQUFXO0FBQy9ILFlBQUlxakMsYUFBYTltQyxFQUFFeUQsRUFBRW9VLE1BQUosRUFBWWdVLE9BQVosQ0FBb0JpYSxLQUFLQyxLQUF6QixDQUFqQjtBQUNBZSxtQkFBV2gxQixRQUFYLENBQW9CLE9BQXBCO0FBQ0FnMUIsbUJBQVcvYixRQUFYLENBQW9CLGdCQUFwQixFQUFzQ2paLFFBQXRDLENBQStDLFFBQS9DO0FBQ0E5UixVQUFFOGxDLEtBQUtFLElBQVAsRUFBYXY2QixXQUFiLENBQXlCLFVBQXpCO0FBQ0QsT0FMRDs7QUFPQW02QixXQUFLQyxTQUFMLENBQWVuaEIsR0FBZixDQUFtQixnQkFBbkIsRUFBcUNvaEIsS0FBS0MsS0FBTCxHQUFhLEdBQWIsR0FBbUJELEtBQUtHLEtBQTdELEVBQW9FeGhCLEVBQXBFLENBQXVFLGdCQUF2RSxFQUF5RnFoQixLQUFLQyxLQUFMLEdBQWEsR0FBYixHQUFtQkQsS0FBS0csS0FBakgsRUFBd0gsVUFBU3hpQyxDQUFULEVBQVc7QUFDakksWUFBSXFqQyxhQUFhOW1DLEVBQUV5RCxFQUFFb1UsTUFBSixFQUFZZ1UsT0FBWixDQUFvQmlhLEtBQUtDLEtBQXpCLENBQWpCO0FBQ0FlLG1CQUFXcjdCLFdBQVgsQ0FBdUIsT0FBdkI7O0FBRUE7QUFDQSxZQUFJLENBQUNxN0IsV0FBV2ppQyxJQUFYLENBQWdCLE9BQWhCLEVBQXlCbkIsTUFBOUIsRUFBc0M7QUFDcENvakMscUJBQVcvYixRQUFYLENBQW9CLE9BQXBCLEVBQTZCdGYsV0FBN0IsQ0FBeUMsUUFBekM7QUFDRDtBQUNEcTdCLG1CQUFXL2IsUUFBWCxDQUFvQixTQUFwQixFQUErQnRmLFdBQS9CLENBQTJDLFFBQTNDO0FBQ0QsT0FURDs7QUFXQW02QixXQUFLQyxTQUFMLENBQWVuaEIsR0FBZixDQUFtQixtQkFBbkIsRUFBd0NvaEIsS0FBS0MsS0FBTCxHQUFhLEdBQWIsR0FBbUJELEtBQUtHLEtBQWhFLEVBQXVFeGhCLEVBQXZFLENBQTBFLG1CQUExRSxFQUErRnFoQixLQUFLQyxLQUFMLEdBQWEsR0FBYixHQUFtQkQsS0FBS0csS0FBdkgsRUFBOEgsVUFBU3hpQyxDQUFULEVBQVc7QUFDdkksWUFBSXNqQyxVQUFVL21DLEVBQUV5RCxFQUFFb1UsTUFBSixDQUFkO0FBQ0EsWUFBSTZ0QixTQUFTcUIsUUFBUWxiLE9BQVIsQ0FBZ0JpYSxLQUFLQyxLQUFyQixDQUFiO0FBQ0EsWUFBSWlCLGNBQWN0QixPQUFPdmEsUUFBUCxDQUFnQjJhLEtBQUtFLElBQXJCLEVBQTJCdGlDLE1BQTdDOztBQUVBO0FBQ0EsWUFBSSxPQUFPRCxFQUFFa2QsS0FBYixFQUFvQjtBQUNsQjtBQUNBLGNBQUlpbEIsS0FBS1EsZUFBTCxJQUNBVixPQUFPamIsSUFBUCxDQUFZLHdDQUFaLEVBQXNEL21CLE1BRHRELElBRUFnaUMsT0FBT2piLElBQVAsQ0FBWSx3Q0FBWixFQUFzRFUsUUFBdEQsR0FBaUV6bkIsTUFGckUsRUFFNkU7QUFDM0U7QUFDRDs7QUFFREQsWUFBRTZlLGNBQUY7QUFDQXNqQixlQUFLcUIsT0FBTCxDQUFhLEVBQUNDLEtBQUtILFFBQVFqSixHQUFSLEVBQU4sRUFBYixFQUFtQzRILE1BQW5DO0FBQ0FxQixrQkFBUWpKLEdBQVIsQ0FBWSxFQUFaO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLFlBQUksQ0FBQyxNQUFNcjZCLEVBQUU4c0IsT0FBUixJQUFtQixPQUFPOXNCLEVBQUU4c0IsT0FBN0IsS0FBeUMsT0FBT3dXLFFBQVFqSixHQUFSLEVBQWhELElBQWlFa0osV0FBckUsRUFBa0Y7QUFDaEZ2akMsWUFBRTZlLGNBQUY7QUFDQXNqQixlQUFLZSxVQUFMLENBQWdCSyxjQUFjLENBQTlCLEVBQWlDdEIsTUFBakM7QUFDQXFCLGtCQUFRdDJCLElBQVI7QUFDQTtBQUNEO0FBQ0YsT0EzQkQ7O0FBNkJBO0FBQ0FtMUIsV0FBS0MsU0FBTCxDQUFlbmhCLEdBQWYsQ0FBbUIsb0JBQW5CLEVBQXlDb2hCLEtBQUtDLEtBQUwsR0FBYSxHQUFiLEdBQW1CRCxLQUFLSSxNQUFqRSxFQUF5RXpoQixFQUF6RSxDQUE0RSxvQkFBNUUsRUFBa0dxaEIsS0FBS0MsS0FBTCxHQUFhLEdBQWIsR0FBbUJELEtBQUtJLE1BQTFILEVBQWtJLFVBQVN6aUMsQ0FBVCxFQUFZO0FBQzVJLFlBQUlzakMsVUFBVS9tQyxFQUFFeUQsRUFBRW9VLE1BQUosQ0FBZDtBQUNBLFlBQUk2dEIsU0FBU3FCLFFBQVFsYixPQUFSLENBQWdCaWEsS0FBS0MsS0FBckIsQ0FBYjtBQUNBLFlBQUlVLFFBQVFNLFFBQVFsYixPQUFSLENBQWdCaWEsS0FBS0UsSUFBckIsQ0FBWjtBQUNBdmlDLFVBQUVtcEIsZUFBRjtBQUNBZ1osYUFBS2dCLFVBQUwsQ0FBZ0JILE1BQU16UyxLQUFOLEVBQWhCLEVBQStCMFIsTUFBL0I7QUFDQUEsZUFBT2piLElBQVAsQ0FBWSxPQUFaLEVBQXFCK2IsS0FBckI7QUFDRCxPQVBEO0FBUUQsS0FwSUQ7O0FBc0lBLFNBQUtILEtBQUwsR0FBYSxVQUFTWCxNQUFULEVBQWlCWSxNQUFqQixFQUF5QjtBQUNwQ1osYUFBT3RFLEtBQVA7QUFDQXNFLGFBQU83Z0MsSUFBUCxDQUFZLE9BQVosRUFBcUJrUyxPQUFyQixDQUE2QixVQUFTb1YsSUFBVCxFQUFjO0FBQ3pDdVosZUFBT3JWLE1BQVAsQ0FBY3VWLEtBQUt1QixVQUFMLENBQWdCaGIsSUFBaEIsQ0FBZDtBQUNELE9BRkQ7QUFHQXVaLGFBQU9yVixNQUFQLENBQWNyd0IsRUFBRSxnQkFBZ0JzbUMsTUFBaEIsR0FBd0IsaUNBQTFCLENBQWQ7QUFDQVYsV0FBS3dCLGNBQUwsQ0FBb0IxQixNQUFwQjs7QUFFQTtBQUNBLFVBQUl4RCxRQUFRd0QsT0FBTzl2QixJQUFQLENBQVksT0FBWixDQUFaO0FBQ0EsVUFBSXNzQixNQUFNeCtCLE1BQVYsRUFBa0I7QUFDaEJ3K0IsY0FBTTVaLElBQU4sQ0FBVyxLQUFYLEVBQWtCZ2UsTUFBbEI7O0FBRUEsWUFBSVosT0FBTzdnQyxJQUFQLENBQVksT0FBWixFQUFxQm5CLE1BQXpCLEVBQWlDO0FBQy9CdytCLGdCQUFNcHdCLFFBQU4sQ0FBZSxRQUFmO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFVBQUl1TixRQUFRcmYsRUFBRSxNQUFNc21DLE1BQVIsQ0FBWjtBQUNBLFVBQUlWLEtBQUtRLGVBQVQsRUFBMEI7QUFDeEJ0WixxQkFBYTJZLG1CQUFiLENBQWlDeEYsY0FBakMsR0FBa0QsVUFBU25DLEdBQVQsRUFBYztBQUM5RDhILGVBQUtxQixPQUFMLENBQWEsRUFBQ0MsS0FBS3BKLEdBQU4sRUFBYixFQUF5QjRILE1BQXpCO0FBQ0FybUIsZ0JBQU15ZSxHQUFOLENBQVUsRUFBVjtBQUNBemUsZ0JBQU1tbkIsS0FBTjtBQUNELFNBSkQ7QUFLQW5uQixjQUFNMGdCLFlBQU4sQ0FBbUJqVCxhQUFhMlksbUJBQWhDO0FBQ0Q7QUFDRixLQTVCRDs7QUE4QkE7Ozs7O0FBS0EsU0FBSzBCLFVBQUwsR0FBa0IsVUFBU2hiLElBQVQsRUFBZTtBQUMvQixVQUFJLENBQUNBLEtBQUsrYSxHQUFWLEVBQWU7O0FBRWYsVUFBSUcsZ0JBQWdCcm5DLEVBQUUsMEJBQUYsQ0FBcEI7QUFDQXFuQyxvQkFBY3ZWLElBQWQsQ0FBbUIzRixLQUFLK2EsR0FBeEI7QUFDQUcsb0JBQWNoWCxNQUFkLENBQXFCcndCLEVBQUUsMkNBQUYsQ0FBckI7QUFDQSxhQUFPcW5DLGFBQVA7QUFDRCxLQVBEOztBQVNBLFNBQUtELGNBQUwsR0FBc0IsVUFBUzFCLE1BQVQsRUFBaUI7QUFDckMsVUFBSUEsT0FBTzdnQyxJQUFQLENBQVksT0FBWixFQUFxQm5CLE1BQXJCLElBQStCb3BCLGFBQWFrRSxXQUFoRCxFQUE2RDtBQUMzRDBVLGVBQU9qYixJQUFQLENBQVksT0FBWixFQUFxQnJDLElBQXJCLENBQTBCLGFBQTFCLEVBQXlDMEUsYUFBYWtFLFdBQXREO0FBRUQsT0FIRCxNQUdPLElBQUksQ0FBQzBVLE9BQU83Z0MsSUFBUCxDQUFZLE9BQVosRUFBcUJuQixNQUF0QixJQUFnQ29wQixhQUFhMFksb0JBQWpELEVBQXVFO0FBQzVFRSxlQUFPamIsSUFBUCxDQUFZLE9BQVosRUFBcUJyQyxJQUFyQixDQUEwQixhQUExQixFQUF5QzBFLGFBQWEwWSxvQkFBdEQ7QUFDRDtBQUNGLEtBUEQ7O0FBU0EsU0FBSzhCLE9BQUwsR0FBZSxVQUFTNUIsTUFBVCxFQUFpQnZaLElBQWpCLEVBQXVCO0FBQ3BDLFVBQUlrYSxRQUFRWCxPQUFPN2dDLElBQVAsQ0FBWSxPQUFaLENBQVo7QUFDQSxVQUFJMGlDLFNBQVMsS0FBYjtBQUNBLFdBQUssSUFBSXBqQyxJQUFFLENBQVgsRUFBY0EsSUFBSWtpQyxNQUFNM2lDLE1BQXhCLEVBQWdDUyxHQUFoQyxFQUFxQztBQUNuQyxZQUFJa2lDLE1BQU1saUMsQ0FBTixFQUFTK2lDLEdBQVQsS0FBaUIvYSxLQUFLK2EsR0FBMUIsRUFBK0I7QUFDM0JLLG1CQUFTLElBQVQ7QUFDQTtBQUNIO0FBQ0Y7QUFDRCxhQUFPLE9BQU9wYixLQUFLK2EsR0FBWixJQUFtQixDQUFDSyxNQUEzQjtBQUNELEtBVkQ7O0FBWUEsU0FBS04sT0FBTCxHQUFlLFVBQVM5YSxJQUFULEVBQWV1WixNQUFmLEVBQXVCO0FBQ3BDLFVBQUksQ0FBQ0UsS0FBSzBCLE9BQUwsQ0FBYTVCLE1BQWIsRUFBcUJ2WixJQUFyQixDQUFMLEVBQWlDO0FBQy9CO0FBQ0Q7QUFDRCxVQUFJa2IsZ0JBQWdCekIsS0FBS3VCLFVBQUwsQ0FBZ0JoYixJQUFoQixDQUFwQjtBQUNBLFVBQUlxYixVQUFVLEVBQWQ7QUFDQSxVQUFJQyxVQUFVL0IsT0FBTzdnQyxJQUFQLENBQVksT0FBWixDQUFkO0FBQ0EsV0FBSyxJQUFJVixJQUFJLENBQWIsRUFBZ0JBLElBQUlzakMsUUFBUS9qQyxNQUE1QixFQUFvQ1MsR0FBcEMsRUFBeUM7QUFDdkNxakMsZ0JBQVFsaUMsSUFBUixDQUFhbWlDLFFBQVF0akMsQ0FBUixDQUFiO0FBQ0Q7QUFDRHFqQyxjQUFRbGlDLElBQVIsQ0FBYTZtQixJQUFiOztBQUVBdVosYUFBTzdnQyxJQUFQLENBQVksT0FBWixFQUFxQjJpQyxPQUFyQjtBQUNBSCxvQkFBY0ssWUFBZCxDQUEyQmhDLE9BQU9qYixJQUFQLENBQVksT0FBWixDQUEzQjtBQUNBaWIsYUFBT2hlLE9BQVAsQ0FBZSxVQUFmLEVBQTJCeUUsSUFBM0I7QUFDQXlaLFdBQUt3QixjQUFMLENBQW9CMUIsTUFBcEI7QUFDRCxLQWhCRDs7QUFrQkEsU0FBS2tCLFVBQUwsR0FBa0IsVUFBU2UsU0FBVCxFQUFvQmpDLE1BQXBCLEVBQTRCO0FBQzVDLFVBQUlrQyxPQUFPbEMsT0FBTzdnQyxJQUFQLENBQVksT0FBWixFQUFxQjhpQyxTQUFyQixDQUFYO0FBQ0FqQyxhQUFPamIsSUFBUCxDQUFZLE9BQVosRUFBcUJ1QixFQUFyQixDQUF3QjJiLFNBQXhCLEVBQW1DejFCLE1BQW5DOztBQUVBLFVBQUlzMUIsVUFBVSxFQUFkO0FBQ0EsVUFBSUMsVUFBVS9CLE9BQU83Z0MsSUFBUCxDQUFZLE9BQVosQ0FBZDtBQUNBLFdBQUssSUFBSVYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc2pDLFFBQVEvakMsTUFBNUIsRUFBb0NTLEdBQXBDLEVBQXlDO0FBQ3ZDLFlBQUlBLE1BQU13akMsU0FBVixFQUFxQjtBQUNuQkgsa0JBQVFsaUMsSUFBUixDQUFhbWlDLFFBQVF0akMsQ0FBUixDQUFiO0FBQ0Q7QUFDRjs7QUFFRHVoQyxhQUFPN2dDLElBQVAsQ0FBWSxPQUFaLEVBQXFCMmlDLE9BQXJCO0FBQ0E5QixhQUFPaGUsT0FBUCxDQUFlLGFBQWYsRUFBOEJrZ0IsSUFBOUI7QUFDQWhDLFdBQUt3QixjQUFMLENBQW9CMUIsTUFBcEI7QUFDRCxLQWZEOztBQWlCQSxTQUFLaUIsVUFBTCxHQUFrQixVQUFTZ0IsU0FBVCxFQUFvQmpDLE1BQXBCLEVBQTRCO0FBQzVDLFVBQUllLFFBQVFmLE9BQU9qYixJQUFQLENBQVksT0FBWixFQUFxQnVCLEVBQXJCLENBQXdCMmIsU0FBeEIsQ0FBWjtBQUNBLFVBQUlsQixTQUFTLFVBQVVBLE1BQU01YixRQUFOLENBQWUsVUFBZixDQUF2QixFQUFtRDtBQUNqRDRiLGNBQU0zMEIsUUFBTixDQUFlLFVBQWY7QUFDQTR6QixlQUFPaGUsT0FBUCxDQUFlLGFBQWYsRUFBOEJnZSxPQUFPN2dDLElBQVAsQ0FBWSxPQUFaLEVBQXFCOGlDLFNBQXJCLENBQTlCO0FBQ0Q7QUFDRixLQU5EOztBQVFBLFNBQUtFLGVBQUwsR0FBdUIsVUFBUzdULEtBQVQsRUFBZ0IwUixNQUFoQixFQUF3QjtBQUM3QyxhQUFPQSxPQUFPMVosRUFBUCxDQUFVZ0ksS0FBVixDQUFQO0FBQ0QsS0FGRDs7QUFJQTtBQUNBLFNBQUtod0IsSUFBTDs7QUFFQSxTQUFLdWlDLFlBQUw7QUFDRCxHQXRTRDtBQXVTRCxDQTFUYyxFQTBUWnhtQyxNQTFUWSxDQUFEO0FBMlRkLENBQUUsV0FBVUMsQ0FBVixFQUFhO0FBQ2JBLElBQUUrRCxFQUFGLENBQUsrakMsT0FBTCxHQUFlLFVBQVU5eEIsT0FBVixFQUFtQjtBQUNoQztBQUNBLFFBQUk5TSxXQUFXO0FBQ2JyRCxXQUFLLENBRFE7QUFFYmlxQixjQUFRdUQsUUFGSztBQUdiMXRCLGNBQVE7QUFISyxLQUFmOztBQU1BO0FBQ0EsUUFBSXFRLFlBQVksUUFBaEIsRUFBMEI7QUFDeEIsV0FBS3JSLElBQUwsQ0FBVSxZQUFZO0FBQ3BCLFlBQUkwWSxLQUFLcmQsRUFBRSxJQUFGLEVBQVE2RSxJQUFSLENBQWEsWUFBYixDQUFULEVBQXFDO0FBQ25DN0UsWUFBRWlFLE1BQUYsRUFBVXlnQixHQUFWLENBQWMsWUFBWXJILEVBQTFCO0FBQ0FyZCxZQUFFLElBQUYsRUFBUWdGLFVBQVIsQ0FBbUIsWUFBbkIsRUFBaUN5RyxXQUFqQyxDQUE2QywyQkFBN0MsRUFBMEU0bUIsVUFBMUUsQ0FBcUYsT0FBckY7QUFDRDtBQUNGLE9BTEQ7QUFNQSxhQUFPLEtBQVA7QUFDRDs7QUFFRHJjLGNBQVVoVyxFQUFFRyxNQUFGLENBQVMrSSxRQUFULEVBQW1COE0sT0FBbkIsQ0FBVjs7QUFHQSt4QixhQUFTLENBQVQ7QUFDQSxXQUFPLEtBQUtwakMsSUFBTCxDQUFVLFlBQVc7QUFDMUIsVUFBSXFqQyxZQUFZcGdCLFlBQVlZLElBQVosRUFBaEI7QUFBQSxVQUNJK0IsUUFBUXZxQixFQUFFLElBQUYsQ0FEWjtBQUFBLFVBRUlpb0MsbUJBQW1Cam9DLEVBQUUsSUFBRixFQUFRMkYsTUFBUixHQUFpQkUsR0FGeEM7O0FBSUEsZUFBU3FpQyxnQkFBVCxDQUEwQnRkLE1BQTFCLEVBQWtDO0FBQ2hDQSxlQUFPbmYsV0FBUCxDQUFtQixTQUFuQjtBQUNBbWYsZUFBT25mLFdBQVAsQ0FBbUIsUUFBbkI7QUFDQW1mLGVBQU9uZixXQUFQLENBQW1CLFlBQW5CO0FBQ0Q7O0FBRUQsZUFBUzA4QixjQUFULENBQXdCQyxPQUF4QixFQUFpQ0MsUUFBakMsRUFBMkM7QUFDekNELGdCQUFRempDLElBQVIsQ0FBYSxZQUFZO0FBQ3ZCO0FBQ0EsY0FBSXFSLFFBQVFuUSxHQUFSLElBQWV3aUMsUUFBZixJQUEyQnJ5QixRQUFROFosTUFBUixJQUFrQnVZLFFBQTdDLElBQXlELENBQUNyb0MsRUFBRSxJQUFGLEVBQVE2cUIsUUFBUixDQUFpQixRQUFqQixDQUE5RCxFQUEwRjtBQUN4RnFkLDZCQUFpQmxvQyxFQUFFLElBQUYsQ0FBakI7QUFDQUEsY0FBRSxJQUFGLEVBQVFvUyxHQUFSLENBQVksS0FBWixFQUFtQjRELFFBQVFyUSxNQUEzQjtBQUNBM0YsY0FBRSxJQUFGLEVBQVE4UixRQUFSLENBQWlCLFFBQWpCO0FBQ0Q7O0FBRUQ7QUFDQSxjQUFJdTJCLFdBQVdyeUIsUUFBUW5RLEdBQW5CLElBQTBCLENBQUM3RixFQUFFLElBQUYsRUFBUTZxQixRQUFSLENBQWlCLFNBQWpCLENBQS9CLEVBQTREO0FBQzFEcWQsNkJBQWlCbG9DLEVBQUUsSUFBRixDQUFqQjtBQUNBQSxjQUFFLElBQUYsRUFBUW9TLEdBQVIsQ0FBWSxLQUFaLEVBQW1CLENBQW5CO0FBQ0FwUyxjQUFFLElBQUYsRUFBUThSLFFBQVIsQ0FBaUIsU0FBakI7QUFDRDs7QUFFRDtBQUNBLGNBQUl1MkIsV0FBV3J5QixRQUFROFosTUFBbkIsSUFBNkIsQ0FBQzl2QixFQUFFLElBQUYsRUFBUTZxQixRQUFSLENBQWlCLFlBQWpCLENBQWxDLEVBQWtFO0FBQ2hFcWQsNkJBQWlCbG9DLEVBQUUsSUFBRixDQUFqQjtBQUNBQSxjQUFFLElBQUYsRUFBUThSLFFBQVIsQ0FBaUIsWUFBakI7QUFDQTlSLGNBQUUsSUFBRixFQUFRb1MsR0FBUixDQUFZLEtBQVosRUFBbUI0RCxRQUFROFosTUFBUixHQUFpQm1ZLGdCQUFwQztBQUNEO0FBQ0YsU0FyQkQ7QUFzQkQ7O0FBRURqb0MsUUFBRSxJQUFGLEVBQVE2RSxJQUFSLENBQWEsWUFBYixFQUEyQm1qQyxTQUEzQjtBQUNBRyxxQkFBZTVkLEtBQWYsRUFBc0J2cUIsRUFBRWlFLE1BQUYsRUFBVWdDLFNBQVYsRUFBdEI7QUFDQWpHLFFBQUVpRSxNQUFGLEVBQVV3Z0IsRUFBVixDQUFhLFlBQVl1akIsU0FBekIsRUFBb0MsWUFBWTtBQUM5QyxZQUFJTSxZQUFZdG9DLEVBQUVpRSxNQUFGLEVBQVVnQyxTQUFWLEtBQXdCK1AsUUFBUXJRLE1BQWhEO0FBQ0F3aUMsdUJBQWU1ZCxLQUFmLEVBQXNCK2QsU0FBdEI7QUFDRCxPQUhEO0FBS0QsS0EzQ00sQ0FBUDtBQTZDRCxHQXBFRDtBQXFFRCxDQXRFQyxFQXNFQ3ZvQyxNQXRFRCxDQUFELENBc0VZLENBQUUsV0FBVUMsQ0FBVixFQUFhO0FBQzFCQSxJQUFFZ0csUUFBRixFQUFZa21CLEtBQVosQ0FBa0IsWUFBVzs7QUFFM0I7QUFDQWxzQixNQUFFK0QsRUFBRixDQUFLcVMsT0FBTCxHQUFlLEdBQUdBLE9BQWxCOztBQUVBO0FBQ0FwVyxNQUFFZ0csUUFBRixFQUFZeWUsRUFBWixDQUFlLDJCQUFmLEVBQTRDLHVEQUE1QyxFQUFxRyxVQUFTaGhCLENBQVQsRUFBWTtBQUMvRyxVQUFJOG1CLFFBQVF2cUIsRUFBRSxJQUFGLENBQVo7QUFDQXVvQyxrQkFBWWhlLEtBQVo7QUFDRCxLQUhEO0FBSUF2cUIsTUFBRWdHLFFBQUYsRUFBWXllLEVBQVosQ0FBZSwyQkFBZixFQUE0Qyx1REFBNUMsRUFBcUcsVUFBU2hoQixDQUFULEVBQVk7QUFDL0csVUFBSThtQixRQUFRdnFCLEVBQUUsSUFBRixDQUFaO0FBQ0F3b0MsbUJBQWFqZSxLQUFiO0FBQ0QsS0FIRDs7QUFLQTtBQUNBdnFCLE1BQUVnRyxRQUFGLEVBQVl5ZSxFQUFaLENBQWUsc0JBQWYsRUFBdUMsdUNBQXZDLEVBQWdGLFVBQVNoaEIsQ0FBVCxFQUFZO0FBQzFGLFVBQUk4bUIsUUFBUXZxQixFQUFFLElBQUYsQ0FBWjtBQUNBLFVBQUl5b0MsUUFBUWxlLE1BQU1PLE1BQU4sRUFBWjtBQUNBLFVBQUkyZCxNQUFNNWQsUUFBTixDQUFlLFFBQWYsQ0FBSixFQUE4QjtBQUM1QjJkLHFCQUFhQyxLQUFiO0FBQ0QsT0FGRCxNQUVPO0FBQ0xGLG9CQUFZRSxLQUFaO0FBQ0Q7QUFDRixLQVJEOztBQVVBO0FBQ0F6b0MsTUFBRWdHLFFBQUYsRUFBWXllLEVBQVosQ0FBZSxrQkFBZixFQUFtQywrQkFBbkMsRUFBb0UsVUFBU2hoQixDQUFULEVBQVk7QUFDOUUsVUFBSThtQixRQUFRdnFCLEVBQUUsSUFBRixDQUFaO0FBQ0EsVUFBSXlvQyxRQUFRbGUsTUFBTU8sTUFBTixFQUFaO0FBQ0E0ZCxtQkFBYUQsS0FBYjtBQUNELEtBSkQ7QUFNRCxHQWpDRDs7QUFtQ0F6b0MsSUFBRStELEVBQUYsQ0FBSzVELE1BQUwsQ0FBWTtBQUNWd29DLGFBQVMsbUJBQVc7QUFDbEJKLGtCQUFZdm9DLEVBQUUsSUFBRixDQUFaO0FBQ0QsS0FIUztBQUlWNG9DLGNBQVUsb0JBQVc7QUFDbkJKLG1CQUFheG9DLEVBQUUsSUFBRixDQUFiO0FBQ0QsS0FOUztBQU9WNm9DLGlCQUFhLHVCQUFXO0FBQ3RCSCxtQkFBYTFvQyxFQUFFLElBQUYsQ0FBYjtBQUNELEtBVFM7QUFVVjhvQyxrQkFBYyx3QkFBVztBQUN2QkMsbUJBQWEvb0MsRUFBRSxJQUFGLENBQWI7QUFDRDtBQVpTLEdBQVo7O0FBZ0JBLE1BQUl1b0MsY0FBYyxTQUFkQSxXQUFjLENBQVVTLEdBQVYsRUFBZTtBQUMvQixRQUFJemUsUUFBUXllLEdBQVo7QUFDQSxRQUFJemUsTUFBTU0sUUFBTixDQUFlLFFBQWYsTUFBNkIsS0FBakMsRUFBd0M7O0FBRXRDO0FBQ0EsVUFBSW9lLGFBQWExZSxNQUFNTSxRQUFOLENBQWUsWUFBZixDQUFqQjtBQUNBLFVBQUlxZSxPQUFKLEVBQWFDLE9BQWI7O0FBRUEsVUFBSUYsZUFBZSxJQUFuQixFQUF5QjtBQUN2QkUsa0JBQVUsRUFBVjtBQUNELE9BRkQsTUFFTztBQUNMRCxrQkFBVSxFQUFWO0FBQ0Q7O0FBRUQzZSxZQUFNelksUUFBTixDQUFlLFFBQWY7QUFDQXlZLFlBQU1FLElBQU4sQ0FBVyxrQkFBWCxFQUErQjVkLFFBQS9CLENBQ0UsRUFBRTZxQixRQUFRLElBQVYsRUFBZ0IzSCxRQUFRLElBQXhCLEVBQThCeUgsWUFBWTBSLFVBQVUsSUFBcEQsRUFBMER6UixZQUFZMFIsVUFBVSxJQUFoRixFQURGLEVBRUUsRUFBRTkvQixVQUFVLENBQVosRUFGRjs7QUFJQSxVQUFJaWEsT0FBTyxDQUFYO0FBQ0FpSCxZQUFNRSxJQUFOLENBQVcsa0JBQVgsRUFBK0JyVSxPQUEvQixHQUF5Q3pSLElBQXpDLENBQStDLFlBQVk7QUFDekQzRSxVQUFFLElBQUYsRUFBUTZNLFFBQVIsQ0FDRSxFQUFFNkQsU0FBUyxHQUFYLEVBQWdCcWYsUUFBUSxHQUF4QixFQUE2QjJILFFBQVEsR0FBckMsRUFBMENGLFlBQVksR0FBdEQsRUFBMkRDLFlBQVksR0FBdkUsRUFERixFQUVFLEVBQUVwdUIsVUFBVSxFQUFaLEVBQWdCd0MsT0FBT3lYLElBQXZCLEVBRkY7QUFHQUEsZ0JBQVEsRUFBUjtBQUNELE9BTEQ7QUFNRDtBQUNGLEdBM0JEOztBQTZCQSxNQUFJa2xCLGVBQWUsU0FBZkEsWUFBZSxDQUFVUSxHQUFWLEVBQWU7QUFDaEMsUUFBSXplLFFBQVF5ZSxHQUFaO0FBQ0E7QUFDQSxRQUFJQyxhQUFhMWUsTUFBTU0sUUFBTixDQUFlLFlBQWYsQ0FBakI7QUFDQSxRQUFJcWUsT0FBSixFQUFhQyxPQUFiOztBQUVBLFFBQUlGLGVBQWUsSUFBbkIsRUFBeUI7QUFDdkJFLGdCQUFVLEVBQVY7QUFDRCxLQUZELE1BRU87QUFDTEQsZ0JBQVUsRUFBVjtBQUNEOztBQUVEM2UsVUFBTTllLFdBQU4sQ0FBa0IsUUFBbEI7QUFDQSxRQUFJNlgsT0FBTyxDQUFYO0FBQ0FpSCxVQUFNRSxJQUFOLENBQVcsa0JBQVgsRUFBK0I1ZCxRQUEvQixDQUF3QyxNQUF4QyxFQUFnRCxJQUFoRDtBQUNBMGQsVUFBTUUsSUFBTixDQUFXLGtCQUFYLEVBQStCNWQsUUFBL0IsQ0FDRSxFQUFFNkQsU0FBUyxHQUFYLEVBQWdCcWYsUUFBUSxJQUF4QixFQUE4QjJILFFBQVEsSUFBdEMsRUFBNENGLFlBQVkwUixVQUFVLElBQWxFLEVBQXdFelIsWUFBWTBSLFVBQVUsSUFBOUYsRUFERixFQUVFLEVBQUU5L0IsVUFBVSxFQUFaLEVBRkY7QUFJRCxHQW5CRDs7QUFzQkE7Ozs7QUFJQSxNQUFJcS9CLGVBQWUsU0FBZkEsWUFBZSxDQUFTTSxHQUFULEVBQWM7QUFDL0IsUUFBSUEsSUFBSTFnQixJQUFKLENBQVMsV0FBVCxNQUEwQixNQUE5QixFQUFzQztBQUNwQztBQUNEOztBQUVELFFBQUk2Z0IsT0FBSixFQUFhRCxPQUFiLEVBQXNCbFMsV0FBdEI7QUFDQSxRQUFJekYsY0FBY3R0QixPQUFPb1EsVUFBekI7QUFDQSxRQUFJZ1osZUFBZXBwQixPQUFPc1EsV0FBMUI7QUFDQSxRQUFJNjBCLFVBQVVKLElBQUksQ0FBSixFQUFPcGpDLHFCQUFQLEVBQWQ7QUFDQSxRQUFJeWpDLFNBQVNMLElBQUl2ZSxJQUFKLENBQVMsS0FBVCxFQUFnQndCLEtBQWhCLEVBQWI7QUFDQSxRQUFJc1AsT0FBT3lOLElBQUl2ZSxJQUFKLENBQVMsTUFBVCxFQUFpQndCLEtBQWpCLEVBQVg7QUFDQSxRQUFJK0osV0FBV2gyQixFQUFFLGtDQUFGLENBQWY7QUFDQSxRQUFJc3BDLFdBQVdELE9BQU9qM0IsR0FBUCxDQUFXLGtCQUFYLENBQWY7QUFDQWkzQixXQUFPaFosTUFBUCxDQUFjMkYsUUFBZDs7QUFFQW1ULGNBQVVDLFFBQVF0akMsSUFBUixHQUFnQnlyQixjQUFjLENBQTlCLEdBQW9DNlgsUUFBUWhiLEtBQVIsR0FBZ0IsQ0FBOUQ7QUFDQThhLGNBQVU3YixlQUFlK2IsUUFBUXRaLE1BQWpDO0FBQ0FrSCxrQkFBY3pGLGNBQWN5RSxTQUFTNUgsS0FBVCxFQUE1QjtBQUNBNGEsUUFBSTFnQixJQUFKLENBQVMsb0JBQVQsRUFBK0I4Z0IsUUFBUXRaLE1BQXZDO0FBQ0FrWixRQUFJMWdCLElBQUosQ0FBUyxrQkFBVCxFQUE2QjhnQixRQUFRdGpDLElBQXJDO0FBQ0FrakMsUUFBSTFnQixJQUFKLENBQVMsbUJBQVQsRUFBOEI4Z0IsUUFBUWhiLEtBQXRDOztBQUVBO0FBQ0E0YSxRQUFJbDNCLFFBQUosQ0FBYSxRQUFiO0FBQ0FrM0IsUUFBSTFnQixJQUFKLENBQVMsV0FBVCxFQUFzQixJQUF0QjtBQUNBMGdCLFFBQUk1MkIsR0FBSixDQUFRO0FBQ04sb0JBQWMsUUFEUjtBQUVOZ2MsYUFBTyxNQUZEO0FBR04wQixjQUFRLENBSEY7QUFJTmhxQixZQUFNLENBSkE7QUFLTmd6QixpQkFBVyxnQkFBZ0JxUSxPQUFoQixHQUEwQixLQUwvQjtBQU1OL1Usa0JBQVk7QUFOTixLQUFSO0FBUUFpVixXQUFPajNCLEdBQVAsQ0FBVztBQUNUMG1CLGlCQUFXLGdCQUFnQixDQUFDb1EsT0FBakIsR0FBMkIsS0FEN0I7QUFFVDlVLGtCQUFZO0FBRkgsS0FBWDtBQUlBNEIsYUFBUzVqQixHQUFULENBQWE7QUFDWCwwQkFBb0JrM0I7QUFEVCxLQUFiOztBQUtBMzlCLGVBQVcsWUFBVztBQUNwQnE5QixVQUFJNTJCLEdBQUosQ0FBUTtBQUNOMG1CLG1CQUFXLEVBREw7QUFFTjFFLG9CQUFZO0FBRk4sT0FBUjtBQUlBaVYsYUFBT2ozQixHQUFQLENBQVc7QUFDVDBFLGtCQUFVLFNBREQ7QUFFVGdpQixtQkFBVyxFQUZGO0FBR1QxRSxvQkFBWTtBQUhILE9BQVg7O0FBTUF6b0IsaUJBQVcsWUFBVztBQUNwQnE5QixZQUFJNTJCLEdBQUosQ0FBUTtBQUNOMEUsb0JBQVUsUUFESjtBQUVOLDhCQUFvQnd5QjtBQUZkLFNBQVI7QUFJQXRULGlCQUFTNWpCLEdBQVQsQ0FBYTtBQUNYMG1CLHFCQUFXLFdBQVc5QixXQUFYLEdBQXlCLEdBRHpCO0FBRVg1QyxzQkFBWTtBQUZELFNBQWI7QUFJQW1ILGFBQUs5USxJQUFMLENBQVUsVUFBVixFQUFzQnJZLEdBQXRCLENBQTBCO0FBQ3hCMUIsbUJBQVM7QUFEZSxTQUExQjs7QUFJQTtBQUNBMVEsVUFBRWlFLE1BQUYsRUFBVXdnQixFQUFWLENBQWEsd0JBQWIsRUFBdUMsWUFBVztBQUNoRHNrQix1QkFBYUMsR0FBYjtBQUNBaHBDLFlBQUVpRSxNQUFGLEVBQVV5Z0IsR0FBVixDQUFjLHdCQUFkO0FBQ0Exa0IsWUFBRWdHLFFBQUYsRUFBWTBlLEdBQVosQ0FBZ0IsdUJBQWhCO0FBQ0QsU0FKRDs7QUFNQTFrQixVQUFFZ0csUUFBRixFQUFZeWUsRUFBWixDQUFlLHVCQUFmLEVBQXdDLFVBQVNoaEIsQ0FBVCxFQUFZO0FBQ2xELGNBQUksQ0FBQ3pELEVBQUV5RCxFQUFFb1UsTUFBSixFQUFZZ1UsT0FBWixDQUFvQjBQLElBQXBCLEVBQTBCNzNCLE1BQS9CLEVBQXVDO0FBQ3JDcWxDLHlCQUFhQyxHQUFiO0FBQ0FocEMsY0FBRWlFLE1BQUYsRUFBVXlnQixHQUFWLENBQWMsd0JBQWQ7QUFDQTFrQixjQUFFZ0csUUFBRixFQUFZMGUsR0FBWixDQUFnQix1QkFBaEI7QUFDRDtBQUNGLFNBTkQ7QUFPRCxPQTNCRCxFQTJCRyxHQTNCSDtBQTRCRCxLQXZDRCxFQXVDRyxDQXZDSDtBQXdDRCxHQWxGRDs7QUFvRkE7Ozs7QUFJQSxNQUFJcWtCLGVBQWUsU0FBZkEsWUFBZSxDQUFTQyxHQUFULEVBQWM7QUFDL0IsUUFBSUEsSUFBSTFnQixJQUFKLENBQVMsV0FBVCxNQUEwQixNQUE5QixFQUFzQztBQUNwQztBQUNEOztBQUVELFFBQUk2Z0IsT0FBSixFQUFhRCxPQUFiLEVBQXNCbFMsV0FBdEI7QUFDQSxRQUFJekYsY0FBY3R0QixPQUFPb1EsVUFBekI7QUFDQSxRQUFJZ1osZUFBZXBwQixPQUFPc1EsV0FBMUI7QUFDQSxRQUFJZzFCLFdBQVdQLElBQUkxZ0IsSUFBSixDQUFTLG1CQUFULENBQWY7QUFDQSxRQUFJa2hCLFlBQVlSLElBQUkxZ0IsSUFBSixDQUFTLG9CQUFULENBQWhCO0FBQ0EsUUFBSW1oQixVQUFVVCxJQUFJMWdCLElBQUosQ0FBUyxrQkFBVCxDQUFkO0FBQ0EsUUFBSStnQixTQUFTTCxJQUFJdmUsSUFBSixDQUFTLGlCQUFULEVBQTRCd0IsS0FBNUIsRUFBYjtBQUNBLFFBQUlzUCxPQUFPeU4sSUFBSXZlLElBQUosQ0FBUyxNQUFULEVBQWlCd0IsS0FBakIsRUFBWDtBQUNBLFFBQUkrSixXQUFXZ1QsSUFBSXZlLElBQUosQ0FBUyxlQUFULENBQWY7QUFDQSxRQUFJNmUsV0FBV0QsT0FBT2ozQixHQUFQLENBQVcsa0JBQVgsQ0FBZjs7QUFFQSsyQixjQUFVTSxVQUFXbFksY0FBYyxDQUF6QixHQUErQmdZLFdBQVcsQ0FBcEQ7QUFDQUwsY0FBVTdiLGVBQWVtYyxTQUF6QjtBQUNBeFMsa0JBQWN6RixjQUFjeUUsU0FBUzVILEtBQVQsRUFBNUI7O0FBR0E7QUFDQTRhLFFBQUl2OUIsV0FBSixDQUFnQixRQUFoQjtBQUNBdTlCLFFBQUkxZ0IsSUFBSixDQUFTLFdBQVQsRUFBc0IsS0FBdEI7QUFDQTBnQixRQUFJNTJCLEdBQUosQ0FBUTtBQUNOLDBCQUFvQixhQURkO0FBRU5naUIsa0JBQVk7QUFGTixLQUFSO0FBSUFpVixXQUFPajNCLEdBQVAsQ0FBVztBQUNUZ2lCLGtCQUFZO0FBREgsS0FBWDtBQUdBNEIsYUFBUzVqQixHQUFULENBQWE7QUFDWDBtQixpQkFBVyxVQURBO0FBRVgsMEJBQW9Cd1E7QUFGVCxLQUFiO0FBSUEvTixTQUFLOVEsSUFBTCxDQUFVLFVBQVYsRUFBc0JyWSxHQUF0QixDQUEwQjtBQUN4QjFCLGVBQVM7QUFEZSxLQUExQjs7QUFJQS9FLGVBQVcsWUFBVztBQUNwQnFxQixlQUFTOWpCLE1BQVQ7O0FBRUE7QUFDQTgyQixVQUFJNTJCLEdBQUosQ0FBUTtBQUNOLHNCQUFjLEVBRFI7QUFFTmdjLGVBQU8sRUFGRDtBQUdOMEIsZ0JBQVEsRUFIRjtBQUlOaHFCLGNBQU0sRUFKQTtBQUtOZ1Isa0JBQVUsRUFMSjtBQU1OLDRCQUFvQixFQU5kO0FBT05naUIsbUJBQVcsaUJBQWlCLENBQUNxUSxPQUFsQixHQUE0QjtBQVBqQyxPQUFSO0FBU0FFLGFBQU9qM0IsR0FBUCxDQUFXO0FBQ1QwRSxrQkFBVSxFQUREO0FBRVRnaUIsbUJBQVcsbUJBQW1Cb1EsT0FBbkIsR0FBNkI7QUFGL0IsT0FBWDs7QUFLQXY5QixpQkFBVyxZQUFXO0FBQ3BCcTlCLFlBQUk1MkIsR0FBSixDQUFRO0FBQ04wbUIscUJBQVcsb0JBREw7QUFFTjFFLHNCQUFZO0FBRk4sU0FBUjtBQUlBaVYsZUFBT2ozQixHQUFQLENBQVc7QUFDVDBtQixxQkFBVyxvQkFERjtBQUVUMUUsc0JBQVk7QUFGSCxTQUFYO0FBSUQsT0FURCxFQVNHLEVBVEg7QUFVRCxLQTVCRCxFQTRCRyxHQTVCSDtBQTZCRCxHQXBFRDtBQXVFRCxDQTFRYyxFQTBRWnIwQixNQTFRWSxDQUFEO0FBMlFkLENBQUUsV0FBVUMsQ0FBVixFQUFhO0FBQ2I7QUFDQTRuQixjQUFZOGhCLFdBQVosR0FBMEIsVUFBU0MsWUFBVCxFQUF1QjtBQUMvQyxRQUFJcmdDLE9BQUo7QUFDQSxRQUFJLE9BQU9xZ0MsWUFBUCxLQUF5QixRQUE3QixFQUF1QztBQUNyQ3JnQyxnQkFBVXRKLEVBQUUycEMsWUFBRixDQUFWO0FBQ0QsS0FGRCxNQUVPLElBQUksUUFBT0EsWUFBUCx5Q0FBT0EsWUFBUCxPQUF5QixRQUE3QixFQUF1QztBQUM1Q3JnQyxnQkFBVXFnQyxZQUFWO0FBQ0QsS0FGTSxNQUVBO0FBQ0w7QUFDRDtBQUNEcmdDLFlBQVE4SSxHQUFSLENBQVksRUFBQzFCLFNBQVMsQ0FBVixFQUFaO0FBQ0ExUSxNQUFFc0osT0FBRixFQUFXdUQsUUFBWCxDQUFvQixFQUFDNkQsU0FBUyxDQUFWLEVBQXBCLEVBQWtDO0FBQ2hDckgsZ0JBQVUsR0FEc0I7QUFFaENqRSxhQUFPLEtBRnlCO0FBR2hDbEYsY0FBUTtBQUh3QixLQUFsQztBQUtBRixNQUFFc0osT0FBRixFQUFXdUQsUUFBWCxDQUFvQixFQUFDNkQsU0FBUyxDQUFWLEVBQXBCLEVBQWtDO0FBQ2hDckgsZ0JBQVUsSUFEc0I7QUFFaENqRSxhQUFPLEtBRnlCO0FBR2hDbEYsY0FBUSxPQUh3QjtBQUloQzBwQyxZQUFNLGNBQVM1cEIsR0FBVCxFQUFjNnBCLEVBQWQsRUFBa0I7QUFDdEJBLFdBQUd4RSxLQUFILEdBQVcsR0FBWDtBQUNBLFlBQUl5RSxvQkFBb0I5cEIsTUFBSSxHQUE1QjtBQUNBLFlBQUkrcEIscUJBQXFCLE1BQU0sQ0FBQyxNQUFNL3BCLEdBQVAsSUFBWSxJQUEzQzs7QUFFQSxZQUFJK3BCLHFCQUFxQixHQUF6QixFQUE4QjtBQUM1QkEsK0JBQXFCLEdBQXJCO0FBQ0Q7QUFDRCxZQUFJL3BCLE9BQU8sQ0FBWCxFQUFjO0FBQ1poZ0IsWUFBRSxJQUFGLEVBQVFvUyxHQUFSLENBQVk7QUFDUiw4QkFBa0IsZUFBYTAzQixpQkFBYixHQUErQixHQUEvQixHQUFxQyxhQUFyQyxHQUFtREMsa0JBQW5ELEdBQXNFLElBRGhGO0FBRVIsc0JBQVUsZUFBYUQsaUJBQWIsR0FBK0IsR0FBL0IsR0FBcUMsYUFBckMsR0FBbURDLGtCQUFuRCxHQUFzRTtBQUZ4RSxXQUFaO0FBSUQ7QUFDRjtBQWxCK0IsS0FBbEM7QUFvQkQsR0FuQ0Q7O0FBcUNBO0FBQ0FuaUIsY0FBWW9pQixpQkFBWixHQUFnQyxVQUFTTCxZQUFULEVBQXVCO0FBQ3JELFFBQUlyZ0MsT0FBSjtBQUNBLFFBQUksT0FBT3FnQyxZQUFQLEtBQXlCLFFBQTdCLEVBQXVDO0FBQ3JDcmdDLGdCQUFVdEosRUFBRTJwQyxZQUFGLENBQVY7QUFDRCxLQUZELE1BRU8sSUFBSSxRQUFPQSxZQUFQLHlDQUFPQSxZQUFQLE9BQXlCLFFBQTdCLEVBQXVDO0FBQzVDcmdDLGdCQUFVcWdDLFlBQVY7QUFDRCxLQUZNLE1BRUE7QUFDTDtBQUNEO0FBQ0QsUUFBSXJtQixPQUFPLENBQVg7QUFDQWhhLFlBQVFtaEIsSUFBUixDQUFhLElBQWIsRUFBbUI1ZCxRQUFuQixDQUNJLEVBQUU0cUIsWUFBWSxRQUFkLEVBREosRUFFSSxFQUFFcHVCLFVBQVUsQ0FBWixFQUZKOztBQUlBQyxZQUFRbWhCLElBQVIsQ0FBYSxJQUFiLEVBQW1COWxCLElBQW5CLENBQXdCLFlBQVc7QUFDakMzRSxRQUFFLElBQUYsRUFBUTZNLFFBQVIsQ0FDRSxFQUFFNkQsU0FBUyxHQUFYLEVBQWdCK21CLFlBQVksR0FBNUIsRUFERixFQUVFLEVBQUVwdUIsVUFBVSxHQUFaLEVBQWlCd0MsT0FBT3lYLElBQXhCLEVBQThCcGpCLFFBQVEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUF0QyxFQUZGO0FBR0FvakIsY0FBUSxHQUFSO0FBQ0QsS0FMRDtBQU1ELEdBcEJEOztBQXVCQXRqQixJQUFFZ0csUUFBRixFQUFZa21CLEtBQVosQ0FBa0IsWUFBVztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQUk2WSxZQUFZLEtBQWhCO0FBQ0EsUUFBSUMsYUFBYSxLQUFqQjs7QUFHQTtBQUNBaGxDLE1BQUUsY0FBRixFQUFrQjJFLElBQWxCLENBQXVCLFlBQVc7QUFDaEMzRSxRQUFFLElBQUYsRUFBUXduQixNQUFSLENBQWU7QUFDYnVULHlCQUFpQjtBQURKLE9BQWYsRUFFR3hNLElBRkgsQ0FFUSxLQUZSLEVBRWUsVUFBUzlxQixDQUFULEVBQVk7QUFDekIsWUFBSUEsRUFBRXFjLE9BQUYsQ0FBVWMsV0FBVixLQUEwQixPQUE5QixFQUF1QztBQUNyQyxjQUFJMkosUUFBUXZxQixFQUFFLElBQUYsQ0FBWjtBQUNBLGNBQUkyUyxZQUFZbFAsRUFBRXFjLE9BQUYsQ0FBVW5OLFNBQTFCO0FBQ0EsY0FBSXJTLElBQUltRCxFQUFFcWMsT0FBRixDQUFVN0YsTUFBbEI7QUFDQSxjQUFJVyxZQUFZblgsRUFBRXFjLE9BQUYsQ0FBVWxGLFNBQTFCOztBQUVBMlAsZ0JBQU0xZCxRQUFOLENBQWUsRUFBRTRxQixZQUFZbjNCO0FBQWQsV0FBZixFQUNPLEVBQUMrSSxVQUFVLEVBQVgsRUFBZWpFLE9BQU8sS0FBdEIsRUFBNkJsRixRQUFRLGFBQXJDLEVBRFA7O0FBR0E7QUFDQSxjQUFJeVMsY0FBYyxDQUFkLEtBQW9CclMsSUFBS2lxQixNQUFNbFcsVUFBTixLQUFxQixDQUExQixJQUFnQ3VHLFlBQVksQ0FBQyxJQUFqRSxDQUFKLEVBQTRFO0FBQzFFbXFCLHdCQUFZLElBQVo7QUFDRDs7QUFFRDtBQUNBLGNBQUlweUIsY0FBYyxDQUFkLEtBQW9CclMsSUFBSyxDQUFDLENBQUQsR0FBS2lxQixNQUFNbFcsVUFBTixFQUFMLEdBQTBCLENBQS9CLElBQXFDdUcsWUFBWSxJQUFyRSxDQUFKLEVBQWdGO0FBQzlFb3FCLHlCQUFhLElBQWI7QUFDRDtBQUNGO0FBQ0YsT0F0QkQsRUFzQkd6VyxJQXRCSCxDQXNCUSxRQXRCUixFQXNCa0IsVUFBUzlxQixDQUFULEVBQVk7QUFDNUI7QUFDQSxZQUFJakMsS0FBS2tCLEdBQUwsQ0FBU2UsRUFBRXFjLE9BQUYsQ0FBVTdGLE1BQW5CLElBQThCamEsRUFBRSxJQUFGLEVBQVFxVSxVQUFSLEtBQXVCLENBQXpELEVBQTZEO0FBQzNEMndCLHVCQUFhLEtBQWI7QUFDQUQsc0JBQVksS0FBWjtBQUNEOztBQUVELFlBQUl0aEMsRUFBRXFjLE9BQUYsQ0FBVWMsV0FBVixLQUEwQixPQUE5QixFQUF1QztBQUNyQyxjQUFJMkosUUFBUXZxQixFQUFFLElBQUYsQ0FBWjtBQUNBLGNBQUkra0MsYUFBYUMsVUFBakIsRUFBNkI7QUFDM0IsZ0JBQUluUSxTQUFKO0FBQ0EsZ0JBQUlrUSxTQUFKLEVBQWU7QUFBRWxRLDBCQUFZdEssTUFBTWxXLFVBQU4sRUFBWjtBQUFpQyxhQUFsRCxNQUNLO0FBQUV3Z0IsMEJBQVksQ0FBQyxDQUFELEdBQUt0SyxNQUFNbFcsVUFBTixFQUFqQjtBQUFzQzs7QUFFN0NrVyxrQkFBTTFkLFFBQU4sQ0FBZSxFQUFFNHFCLFlBQVk1QztBQUFkLGFBQWYsRUFDSyxFQUFDeHJCLFVBQVUsR0FBWCxFQUFnQmpFLE9BQU8sS0FBdkIsRUFBOEJsRixRQUFRLGFBQXRDLEVBQXFEd0wsVUFDeEQsb0JBQVc7QUFDVDZlLHNCQUFNblksR0FBTixDQUFVLFFBQVYsRUFBb0IsTUFBcEI7QUFDQW1ZLHNCQUFNMWQsUUFBTixDQUFlLEVBQUU2SixRQUFRLENBQVYsRUFBYXV6QixTQUFTO0FBQXRCLGlCQUFmLEVBQ0ssRUFBQzVnQyxVQUFVLEdBQVgsRUFBZ0JqRSxPQUFPLEtBQXZCLEVBQThCbEYsUUFBUSxhQUF0QyxFQUFxRHdMLFVBQ3RELG9CQUFXO0FBQUU2ZSwwQkFBTXJZLE1BQU47QUFBaUI7QUFEN0IsaUJBREw7QUFJRDtBQVBFLGFBREw7QUFVRCxXQWZELE1BZ0JLO0FBQ0hxWSxrQkFBTTFkLFFBQU4sQ0FBZSxFQUFFNHFCLFlBQVk7QUFBZCxhQUFmLEVBQ0ssRUFBQ3B1QixVQUFVLEdBQVgsRUFBZ0JqRSxPQUFPLEtBQXZCLEVBQThCbEYsUUFBUSxhQUF0QyxFQURMO0FBRUQ7QUFDRDZrQyxzQkFBWSxLQUFaO0FBQ0FDLHVCQUFhLEtBQWI7QUFDRDtBQUNGLE9BdEREO0FBd0RELEtBekREOztBQTREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRCxHQXhHRDtBQXlHRCxDQXhLQyxFQXdLQ2psQyxNQXhLRCxDQUFEO0FBeUtELENBQUMsQ0FBQyxVQUFTQyxDQUFULEVBQVk7O0FBRVosTUFBSWtxQywwQkFBMEIsS0FBOUI7O0FBRUE7QUFDQXRpQixjQUFZdWlCLFVBQVosR0FBeUIsVUFBU24wQixPQUFULEVBQWtCO0FBQ3pDLFFBQUk2bUIsV0FBVyxTQUFYQSxRQUFXLEdBQVc7QUFDeEIsVUFBSXVOLGVBQWVubUMsT0FBTzhCLFdBQVAsR0FBcUI5QixPQUFPc1EsV0FBL0M7O0FBRUEsV0FBSyxJQUFJcFEsSUFBSSxDQUFiLEVBQWlCQSxJQUFJNlIsUUFBUXRTLE1BQTdCLEVBQXFDUyxHQUFyQyxFQUEwQztBQUN4QztBQUNBLFlBQUl1NUIsUUFBUTFuQixRQUFRN1IsQ0FBUixDQUFaO0FBQ0EsWUFBSWk1QixXQUFXTSxNQUFNTixRQUFyQjtBQUFBLFlBQ0l6M0IsU0FBUyszQixNQUFNLzNCLE1BRG5CO0FBQUEsWUFFSWlTLFdBQVc4bEIsTUFBTTlsQixRQUZyQjs7QUFJQSxZQUFJeXlCLGlCQUFpQnJrQyxTQUFTc2tDLGFBQVQsQ0FBdUJsTixRQUF2QixDQUFyQjtBQUNBLFlBQUtpTixtQkFBbUIsSUFBeEIsRUFBOEI7QUFDNUIsY0FBSUUsZ0JBQWdCRixlQUFlemtDLHFCQUFmLEdBQXVDQyxHQUF2QyxHQUE2QzVCLE9BQU84QixXQUF4RTs7QUFFQSxjQUFJcWtDLGVBQWdCRyxnQkFBZ0I1a0MsTUFBcEMsRUFBNkM7QUFDM0MsZ0JBQUkrM0IsTUFBTThNLElBQU4sS0FBZSxJQUFuQixFQUF5QjtBQUN2QixrQkFBSSxPQUFPNXlCLFFBQVAsS0FBcUIsVUFBekIsRUFBcUM7QUFDbkNBLHlCQUFTeFQsSUFBVCxDQUFjLElBQWQsRUFBb0JpbUMsY0FBcEI7QUFDRCxlQUZELE1BRU8sSUFBSSxPQUFPenlCLFFBQVAsS0FBcUIsUUFBekIsRUFBbUM7QUFDeEMsb0JBQUk2eUIsZUFBZSxJQUFJQyxRQUFKLENBQWE5eUIsUUFBYixDQUFuQjtBQUNBNnlCLDZCQUFhSixjQUFiO0FBQ0Q7QUFDRDNNLG9CQUFNOE0sSUFBTixHQUFhLElBQWI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNGLEtBM0JEOztBQThCQSxRQUFJak4sa0JBQWtCM1YsWUFBWXdCLFFBQVosQ0FBcUIsWUFBVztBQUNwRHlUO0FBQ0QsS0FGcUIsRUFFbkI3bUIsUUFBUW9ULFFBQVIsSUFBb0IsR0FGRCxDQUF0Qjs7QUFJQSxRQUFJLENBQUM4Z0IsdUJBQUwsRUFBOEI7QUFDNUJqbUMsYUFBT3dTLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDOG1CLGVBQWxDO0FBQ0F0NUIsYUFBT3dTLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDOG1CLGVBQWxDO0FBQ0EyTSxnQ0FBMEIsSUFBMUI7QUFDRDs7QUFFRDtBQUNBditCLGVBQVc0eEIsZUFBWCxFQUE0QixDQUE1QjtBQUNELEdBM0NEO0FBNkNELENBbERBLEVBa0RFeDlCLE1BbERGO0FBbURELEMsQ0FBQzs7Ozs7OztBQU9BLFdBQVdtbkIsT0FBWCxFQUFxQjs7QUFFbEI7QUFDQSxNQUFLLElBQUwsRUFDSSxpQ0FBa0IsQ0FBQyxzQkFBRCxDQUFsQixvQ0FBOEJBLE9BQTlCO0FBQUE7QUFBQTs7QUFFSjtBQUhBLE9BSUssSUFBSyxRQUFPMWYsT0FBUCx5Q0FBT0EsT0FBUCxNQUFrQixRQUF2QixFQUNERCxPQUFPQyxPQUFQLEdBQWlCMGYsUUFBU2puQixRQUFRLFFBQVIsQ0FBVCxDQUFqQjs7QUFFSjtBQUhLLFNBSUEsS0FBSzBxQyxNQUFMLEdBQWN6akIsUUFBU25uQixNQUFULENBQWQ7QUFFUixDQWJBLEVBYUMsVUFBVUMsQ0FBVixFQUFjOztBQUVoQixNQUFJNHFDLFVBQVU1cUMsRUFBR2lFLE1BQUgsQ0FBZDtBQUNBLE1BQUk0aEMsWUFBWTdsQyxFQUFHZ0csUUFBSCxDQUFoQjtBQUNBLE1BQUk2a0MsUUFBUTdxQyxFQUFHZ0csU0FBU3lJLGVBQVosQ0FBWjs7QUFHQTs7O0FBR0EsV0FBU3E4QixpQkFBVCxDQUE0QkMsT0FBNUIsRUFBcUNDLElBQXJDLEVBQTJDQyxTQUEzQyxFQUFzREMsT0FBdEQsRUFBZ0U7O0FBRTVEO0FBQ0EsUUFBSyxDQUFDSCxPQUFOLEVBQWdCLE9BQU9ELGlCQUFQOztBQUdoQixRQUNJSyxtQkFBbUIsS0FEdkI7OztBQUlJO0FBQ0FDLFlBQVE7QUFDSi90QixVQUFJMHRCLFFBQVExdEIsRUFBUixJQUFjLE1BQU03YixLQUFLa0IsR0FBTCxDQUFVLENBQUMsRUFBRWxCLEtBQUttbkIsTUFBTCxLQUFnQixJQUFJMWhCLElBQUosRUFBbEIsQ0FBWDtBQURwQixLQUxaOzs7QUFVSTtBQUNBb2tDLGVBQVdKLFlBQVlqckMsRUFBRUcsTUFBRixDQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0I4cUMsVUFBVS9oQyxRQUE5QixFQUF3Q2dpQyxPQUF4QyxDQUFaLEdBQWdFQSxXQUFXLEVBWDFGOzs7QUFjSTtBQUNBSSxjQUFVdHJDLEVBQUVHLE1BQUYsQ0FBVSxFQUFWLEVBQWMycUMsa0JBQWtCUyxPQUFsQixFQUFkLEVBQTJDRixTQUFTRyxLQUFwRCxDQWZkOzs7QUFrQkk7QUFDQUMsZUFBV3pyQyxFQUFHK3FDLE9BQUgsQ0FuQmY7OztBQXNCSTtBQUNBVyxxQkFBaUIsU0FBakJBLGNBQWlCLEdBQVc7QUFDeEIsYUFBTyxLQUFLckcsS0FBTCxFQUFQO0FBQ0gsS0F6Qkw7OztBQTRCSTtBQUNBLzhCLFFBQUlvakMsZUFBZWhuQyxTQUFmLEdBQTJCOztBQUUzQkYsbUJBQWFrbkMsY0FGYzs7QUFJM0JDLGFBQU9GLFFBSm9COztBQU8zQjs7O0FBR0FwRyxhQUFPLGlCQUFXOztBQUVkO0FBQ0EsWUFBSytGLFNBQVNBLE1BQU0vRixLQUFwQixFQUE0QixPQUFPLzhCLENBQVA7O0FBRzVCO0FBQ0E4aUMsY0FBTWpjLE9BQU4sR0FBZ0IsRUFBaEI7QUFDQWljLGNBQU0vRixLQUFOLEdBQWMsSUFBZDtBQUNBK0YsY0FBTXpjLElBQU4sR0FBYSxLQUFiO0FBQ0F5YyxjQUFNeG5DLElBQU4sR0FBYW1uQyxRQUFRbm5DLElBQXJCOztBQUdBO0FBQ0E7QUFDQW1uQyxnQkFBUWhOLFNBQVIsR0FBb0JnTixXQUFXYSxrQkFBL0I7QUFDQWIsZ0JBQVFjLFFBQVIsR0FBbUIsQ0FBQ1IsU0FBU1MsUUFBN0I7QUFDQWYsZ0JBQVExdEIsRUFBUixHQUFhMHRCLFFBQVExdEIsRUFBUixJQUFjK3RCLE1BQU0vdEIsRUFBakM7QUFDQSxZQUFLMHRCLFFBQVFubkMsSUFBUixJQUFnQixNQUFyQixFQUE4QjtBQUMxQm1uQyxrQkFBUW5uQyxJQUFSLEdBQWUsTUFBZjtBQUNIOztBQUdEO0FBQ0EwRSxVQUFFeWpDLFNBQUYsR0FBYyxJQUFJZCxTQUFKLENBQWMzaUMsQ0FBZCxFQUFpQitpQyxRQUFqQixDQUFkOztBQUdBO0FBQ0EvaUMsVUFBRTBqQyxLQUFGLEdBQVVoc0MsRUFBRzhxQyxrQkFBa0I1dkIsQ0FBbEIsQ0FBb0Ird0IsSUFBcEIsQ0FBeUIsS0FBekIsRUFBZ0NDLHdCQUFoQyxFQUEwRFosUUFBUWEsTUFBbEUsRUFBMEUsU0FBU3BCLFFBQVExdEIsRUFBakIsR0FBc0IscUJBQWhHLENBQUgsQ0FBVjtBQUNBK3VCOztBQUdBO0FBQ0EsWUFBS2YsU0FBU2dCLFlBQWQsRUFBNkI7QUFDekJDO0FBQ0g7O0FBR0Q7QUFDQUM7O0FBR0E7QUFDQSxZQUFLbEIsU0FBUzM0QixTQUFkLEVBQTBCMVMsRUFBR3FyQyxTQUFTMzRCLFNBQVosRUFBd0IyZCxNQUF4QixDQUFnQy9uQixFQUFFMGpDLEtBQWxDLEVBQTFCLEtBQ0tQLFNBQVN2ZSxLQUFULENBQWdCNWtCLEVBQUUwakMsS0FBbEI7O0FBR0w7QUFDQTFqQyxVQUFFbWMsRUFBRixDQUFLO0FBQ0Q0Z0IsaUJBQU8vOEIsRUFBRXlqQyxTQUFGLENBQVlTLE9BRGxCO0FBRURDLGtCQUFRbmtDLEVBQUV5akMsU0FBRixDQUFZVyxRQUZuQjtBQUdEcG9CLGdCQUFNaGMsRUFBRXlqQyxTQUFGLENBQVlZLE1BSGpCO0FBSURoZSxnQkFBTXJtQixFQUFFeWpDLFNBQUYsQ0FBWTNoQixNQUpqQjtBQUtEcUcsaUJBQU9ub0IsRUFBRXlqQyxTQUFGLENBQVkxaEIsT0FMbEI7QUFNRHhOLGVBQUt2VSxFQUFFeWpDLFNBQUYsQ0FBWWE7QUFOaEIsU0FBTCxFQU9Hbm9CLEVBUEgsQ0FPTTtBQUNGNGdCLGlCQUFPZ0csU0FBU21CLE9BRGQ7QUFFRkMsa0JBQVFwQixTQUFTcUIsUUFGZjtBQUdGcG9CLGdCQUFNK21CLFNBQVNzQixNQUhiO0FBSUZoZSxnQkFBTTBjLFNBQVNqaEIsTUFKYjtBQUtGcUcsaUJBQU80YSxTQUFTaGhCLE9BTGQ7QUFNRnhOLGVBQUt3dUIsU0FBU3VCO0FBTlosU0FQTjs7QUFpQkE7QUFDQXpCLDJCQUFtQjBCLG9CQUFxQnZrQyxFQUFFMGpDLEtBQUYsQ0FBUTdnQixRQUFSLEdBQW9CLENBQXBCLENBQXJCLENBQW5COztBQUdBO0FBQ0EsWUFBSzRmLFFBQVFoTixTQUFiLEVBQXlCO0FBQ3JCejFCLFlBQUVxbUIsSUFBRjtBQUNIOztBQUdEO0FBQ0EsZUFBT3JtQixFQUFFb2YsT0FBRixDQUFXLE9BQVgsRUFBcUJBLE9BQXJCLENBQThCLFFBQTlCLENBQVA7QUFDSCxPQXZGMEIsRUF1RnhCOzs7QUFHSDs7O0FBR0Era0IsY0FBUSxnQkFBVUssZUFBVixFQUE0Qjs7QUFFaEM7QUFDQSxZQUFLQSxlQUFMLEVBQXVCeGtDLEVBQUUwakMsS0FBRixDQUFRdlcsSUFBUixDQUFjeVcsd0JBQWQsRUFBdkIsS0FDSzVqQyxFQUFFMGpDLEtBQUYsQ0FBUXZoQixJQUFSLENBQWMsTUFBTTZnQixRQUFRblQsR0FBNUIsRUFBa0MxQyxJQUFsQyxDQUF3Q250QixFQUFFeWpDLFNBQUYsQ0FBWWdCLEtBQVosQ0FBbUIzQixNQUFNemMsSUFBekIsQ0FBeEM7O0FBRUw7QUFDQSxlQUFPcm1CLEVBQUVvZixPQUFGLENBQVcsUUFBWCxDQUFQO0FBQ0gsT0FyRzBCLEVBcUd4Qjs7O0FBR0g7OztBQUdBcEQsWUFBTSxnQkFBVzs7QUFFYjtBQUNBLFlBQUssQ0FBQzhtQixNQUFNL0YsS0FBWixFQUFvQixPQUFPLzhCLENBQVA7O0FBRXBCO0FBQ0FBLFVBQUVtb0IsS0FBRjs7QUFFQTtBQUNBLFlBQUtub0IsRUFBRTBrQyxPQUFQLEVBQWlCO0FBQ2Ixa0MsWUFBRTBrQyxPQUFGLENBQVVyK0IsVUFBVixDQUFxQnVGLFdBQXJCLENBQWtDNUwsRUFBRTBrQyxPQUFwQztBQUNIOztBQUVEO0FBQ0Exa0MsVUFBRTBqQyxLQUFGLENBQVE5NUIsTUFBUjs7QUFFQTtBQUNBO0FBQ0F1NUIsaUJBQVNoZ0MsV0FBVCxDQUFzQjYvQixRQUFRanNCLEtBQTlCLEVBQXNDcmEsVUFBdEMsQ0FBa0RnbUMsSUFBbEQ7QUFDQXIvQixtQkFBWSxZQUFXO0FBQ25COC9CLG1CQUFTL21CLEdBQVQsQ0FBYyxNQUFNMG1CLE1BQU0vdEIsRUFBMUI7QUFDSCxTQUZELEVBRUcsQ0FGSDs7QUFJQTtBQUNBMHRCLGdCQUFRbm5DLElBQVIsR0FBZXduQyxNQUFNeG5DLElBQXJCO0FBQ0FtbkMsZ0JBQVFjLFFBQVIsR0FBbUIsS0FBbkI7O0FBRUE7QUFDQXZqQyxVQUFFb2YsT0FBRixDQUFXLE1BQVg7O0FBRUE7QUFDQTBqQixjQUFNamMsT0FBTixHQUFnQixFQUFoQjtBQUNBaWMsY0FBTS9GLEtBQU4sR0FBYyxLQUFkOztBQUVBLGVBQU8vOEIsQ0FBUDtBQUNILE9BOUkwQixFQThJeEI7OztBQUdIOzs7QUFHQXFtQixZQUFNLGNBQVVzZSxhQUFWLEVBQTBCOztBQUU1QjtBQUNBLFlBQUs3QixNQUFNemMsSUFBWCxFQUFrQixPQUFPcm1CLENBQVA7O0FBRWxCO0FBQ0FtakMsaUJBQVMzNUIsUUFBVCxDQUFtQnc1QixRQUFRNEIsTUFBM0I7QUFDQUMsYUFBTXBDLE9BQU4sRUFBZSxVQUFmLEVBQTJCLElBQTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBcC9CLG1CQUFZLFlBQVc7O0FBRW5CO0FBQ0FyRCxZQUFFMGpDLEtBQUYsQ0FBUWw2QixRQUFSLENBQWtCdzVCLFFBQVE4QixNQUExQjtBQUNBRCxlQUFNN2tDLEVBQUUwakMsS0FBRixDQUFRLENBQVIsQ0FBTixFQUFrQixRQUFsQixFQUE0QixLQUE1QjtBQUVILFNBTkQsRUFNRyxDQU5IOztBQVFBO0FBQ0EsWUFBS2lCLGtCQUFrQixLQUF2QixFQUErQjs7QUFFM0I7QUFDQTdCLGdCQUFNemMsSUFBTixHQUFhLElBQWI7O0FBRUE7QUFDQSxjQUFLd2MsZ0JBQUwsRUFBd0I7QUFDcEJOLGtCQUNJejRCLEdBREosQ0FDUyxVQURULEVBQ3FCLFFBRHJCLEVBRUlBLEdBRkosQ0FFUyxlQUZULEVBRTBCLE9BQU9pN0IsbUJBRmpDO0FBR0g7O0FBRUQ7QUFDQTtBQUNBL2tDLFlBQUUwakMsS0FBRixDQUFRaGdCLEVBQVIsQ0FBVyxDQUFYLEVBQWN3YSxLQUFkOztBQUVBO0FBQ0FYLG9CQUFVcGhCLEVBQVYsQ0FBYyxXQUFXMm1CLE1BQU0vdEIsRUFBakIsR0FBc0IsV0FBdEIsR0FBb0MrdEIsTUFBTS90QixFQUF4RCxFQUE0RCxVQUFVeUYsS0FBVixFQUFrQjs7QUFFMUUsZ0JBQUlqTCxTQUFTaUwsTUFBTWpMLE1BQW5COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQUtBLFVBQVVrekIsT0FBVixJQUFxQmx6QixVQUFVN1IsUUFBL0IsSUFBMkM4YyxNQUFNbkMsS0FBTixJQUFlLENBQS9ELEVBQW1FOztBQUUvRDtBQUNBO0FBQ0FyWSxnQkFBRW1vQixLQUFGLENBQVM1WSxXQUFXdlAsRUFBRTBqQyxLQUFGLENBQVE3Z0IsUUFBUixHQUFtQixDQUFuQixDQUFwQjtBQUNIO0FBRUosV0FsQkQsRUFrQkcxRyxFQWxCSCxDQWtCTyxhQUFhMm1CLE1BQU0vdEIsRUFsQjFCLEVBa0I4QixVQUFVeUYsS0FBVixFQUFrQjs7QUFFNUM7QUFDSTtBQUNBd3FCLHNCQUFVeHFCLE1BQU15TixPQUZwQjs7O0FBSUk7QUFDQWdkLDRCQUFnQmpsQyxFQUFFeWpDLFNBQUYsQ0FBWTFLLEdBQVosQ0FBaUJpTSxPQUFqQixDQUxwQjs7O0FBT0k7QUFDQXoxQixxQkFBU2lMLE1BQU1qTCxNQVJuQjs7QUFXQTtBQUNBLGdCQUFLeTFCLFdBQVcsRUFBaEIsRUFBcUI7QUFDakJobEMsZ0JBQUVtb0IsS0FBRixDQUFTLElBQVQ7QUFDSDs7QUFHRDtBQUxBLGlCQU1LLElBQUs1WSxVQUFVdlAsRUFBRTBqQyxLQUFGLENBQVEsQ0FBUixDQUFWLEtBQTBCdUIsaUJBQWlCRCxXQUFXLEVBQXRELENBQUwsRUFBa0U7O0FBRW5FO0FBQ0F4cUIsc0JBQU1SLGNBQU47O0FBRUE7QUFDQSxvQkFBS2lyQixhQUFMLEVBQXFCO0FBQ2pCekMsb0NBQWtCNXZCLENBQWxCLENBQW9Cd00sT0FBcEIsQ0FBNkJwZixFQUFFeWpDLFNBQUYsQ0FBWTFLLEdBQVosQ0FBZ0JtTSxFQUE3QyxFQUFpRGxsQyxDQUFqRCxFQUFvRCxDQUFFd2lDLGtCQUFrQjV2QixDQUFsQixDQUFvQndNLE9BQXBCLENBQTZCNmxCLGFBQTdCLENBQUYsQ0FBcEQ7QUFDSDs7QUFFRDtBQUpBLHFCQUtLLElBQUssQ0FBQ2psQyxFQUFFMGpDLEtBQUYsQ0FBUXZoQixJQUFSLENBQWMsTUFBTTZnQixRQUFRbUMsV0FBNUIsRUFBMEM1aUIsUUFBMUMsQ0FBb0R5Z0IsUUFBUW9DLFFBQTVELENBQU4sRUFBK0U7QUFDaEZwbEMsc0JBQUV1VSxHQUFGLENBQU8sUUFBUCxFQUFpQnZVLEVBQUV5akMsU0FBRixDQUFZL1csSUFBWixDQUFpQnlMLFNBQWxDLEVBQThDaFEsS0FBOUM7QUFDSDtBQUNKOztBQUdEO0FBQ0E7QUFsQkssbUJBbUJBLElBQUt6d0IsRUFBRTY1QixRQUFGLENBQVl2eEIsRUFBRTBqQyxLQUFGLENBQVEsQ0FBUixDQUFaLEVBQXdCbjBCLE1BQXhCLEtBQW9DeTFCLFdBQVcsRUFBcEQsRUFBeUQ7QUFDMUR4cUIsd0JBQU1SLGNBQU47QUFDQXpLLHlCQUFPeVksS0FBUDtBQUNIO0FBQ0osV0E3REQ7QUE4REg7O0FBRUQ7QUFDQSxlQUFPaG9CLEVBQUVvZixPQUFGLENBQVcsTUFBWCxDQUFQO0FBQ0gsT0E1UDBCLEVBNFB4Qjs7O0FBR0g7OztBQUdBK0ksYUFBTyxlQUFVa2QsU0FBVixFQUFzQjs7QUFFekI7QUFDQSxZQUFLQSxTQUFMLEVBQWlCO0FBQ2I7QUFDQTtBQUNBO0FBQ0FybEMsWUFBRTBqQyxLQUFGLENBQVF0bkIsR0FBUixDQUFhLGNBQWIsRUFBOEJzSCxFQUE5QixDQUFpQyxDQUFqQyxFQUFvQ3dhLEtBQXBDO0FBQ0E3NkIscUJBQVksWUFBVztBQUNuQnJELGNBQUUwakMsS0FBRixDQUFRdm5CLEVBQVIsQ0FBWSxjQUFaLEVBQTRCbXBCLHNCQUE1QjtBQUNILFdBRkQsRUFFRyxDQUZIO0FBR0g7O0FBRUQ7QUFDQW5DLGlCQUFTaGdDLFdBQVQsQ0FBc0I2L0IsUUFBUTRCLE1BQTlCO0FBQ0FDLGFBQU1wQyxPQUFOLEVBQWUsVUFBZixFQUEyQixLQUEzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQXAvQixtQkFBWSxZQUFXOztBQUVuQjtBQUNBckQsWUFBRTBqQyxLQUFGLENBQVF2Z0MsV0FBUixDQUFxQjYvQixRQUFROEIsTUFBUixHQUFpQixHQUFqQixHQUF1QjlCLFFBQVF1QyxPQUFwRDtBQUNBVixlQUFNN2tDLEVBQUUwakMsS0FBRixDQUFRLENBQVIsQ0FBTixFQUFrQixRQUFsQixFQUE0QixJQUE1QjtBQUVILFNBTkQsRUFNRyxDQU5IOztBQVFBO0FBQ0EsWUFBSyxDQUFDWixNQUFNemMsSUFBWixFQUFtQixPQUFPcm1CLENBQVA7O0FBRW5CO0FBQ0E4aUMsY0FBTXpjLElBQU4sR0FBYSxLQUFiOztBQUVBO0FBQ0EsWUFBS3djLGdCQUFMLEVBQXdCO0FBQ3BCTixnQkFDSXo0QixHQURKLENBQ1MsVUFEVCxFQUNxQixFQURyQixFQUVJQSxHQUZKLENBRVMsZUFGVCxFQUUwQixPQUFPaTdCLG1CQUZqQztBQUdIOztBQUVEO0FBQ0F4SCxrQkFBVW5oQixHQUFWLENBQWUsTUFBTTBtQixNQUFNL3RCLEVBQTNCOztBQUVBO0FBQ0EsZUFBTy9VLEVBQUVvZixPQUFGLENBQVcsT0FBWCxDQUFQO0FBQ0gsT0FoVDBCLEVBZ1R4Qjs7O0FBR0g7OztBQUdBb21CLGFBQU8sZUFBVTkzQixPQUFWLEVBQW9CO0FBQ3ZCLGVBQU8xTixFQUFFdVUsR0FBRixDQUFPLE9BQVAsRUFBZ0IsSUFBaEIsRUFBc0I3RyxPQUF0QixDQUFQO0FBQ0gsT0F4VDBCLEVBd1R4Qjs7O0FBR0g7OztBQUdBNkcsV0FBSyxhQUFVa3hCLEtBQVYsRUFBaUJyUSxLQUFqQixFQUF3QjFuQixPQUF4QixFQUFrQzs7QUFFbkMsWUFBSWc0QixTQUFKO0FBQUEsWUFBZUMsVUFBZjtBQUFBLFlBQ0lDLGdCQUFnQmx1QyxFQUFFdUUsYUFBRixDQUFpQndwQyxLQUFqQixDQURwQjtBQUFBLFlBRUlJLGNBQWNELGdCQUFnQkgsS0FBaEIsR0FBd0IsRUFGMUM7O0FBSUE7QUFDQS8zQixrQkFBVWs0QixpQkFBaUJsdUMsRUFBRXVFLGFBQUYsQ0FBaUJtNUIsS0FBakIsQ0FBakIsR0FBNENBLEtBQTVDLEdBQW9EMW5CLFdBQVcsRUFBekU7O0FBRUEsWUFBSyszQixLQUFMLEVBQWE7O0FBRVQ7QUFDQSxjQUFLLENBQUNHLGFBQU4sRUFBc0I7QUFDbEJDLHdCQUFhSixLQUFiLElBQXVCclEsS0FBdkI7QUFDSDs7QUFFRDtBQUNBLGVBQU1zUSxTQUFOLElBQW1CRyxXQUFuQixFQUFpQzs7QUFFN0I7QUFDQUYseUJBQWFFLFlBQWFILFNBQWIsQ0FBYjs7QUFFQTtBQUNBLGdCQUFLQSxhQUFhMWxDLEVBQUV5akMsU0FBRixDQUFZL1csSUFBOUIsRUFBcUM7QUFDakMsa0JBQUtpWixlQUFlbHJDLFNBQXBCLEVBQWdDa3JDLGFBQWEsSUFBYjtBQUNoQzNsQyxnQkFBRXlqQyxTQUFGLENBQVlsdkIsR0FBWixDQUFpQm14QixTQUFqQixFQUE0QkMsVUFBNUIsRUFBd0NqNEIsT0FBeEM7QUFDSDs7QUFFRDtBQUNBLGdCQUFLZzRCLGFBQWEsUUFBYixJQUF5QkEsYUFBYSxPQUEzQyxFQUFxRDtBQUNqRHZDLHVCQUNJM04sR0FESixDQUNTa1EsYUFBYSxPQUFiLEdBQXVCLEVBQXZCLEdBQTRCMWxDLEVBQUUyVixHQUFGLENBQU8rdkIsU0FBUCxFQUFrQjNDLFNBQVMrQyxNQUEzQixDQURyQyxFQUVJMW1CLE9BRkosQ0FFYSxRQUZiO0FBR0g7QUFDSjs7QUFFRDtBQUNBcGYsWUFBRW1rQyxNQUFGO0FBQ0g7O0FBRUQ7QUFDQSxlQUFPejJCLFFBQVFxNEIsS0FBUixHQUFnQi9sQyxDQUFoQixHQUFvQkEsRUFBRW9mLE9BQUYsQ0FBVyxLQUFYLEVBQWtCeW1CLFdBQWxCLENBQTNCO0FBQ0gsT0F4VzBCLEVBd1d4Qjs7O0FBR0g7OztBQUdBbHdCLFdBQUssYUFBVTh2QixLQUFWLEVBQWlCSyxNQUFqQixFQUEwQjs7QUFFM0I7QUFDQUwsZ0JBQVFBLFNBQVMsT0FBakI7O0FBRUE7QUFDQSxZQUFLM0MsTUFBTzJDLEtBQVAsS0FBa0IsSUFBdkIsRUFBOEI7QUFDMUIsaUJBQU8zQyxNQUFPMkMsS0FBUCxDQUFQO0FBQ0g7O0FBRUQ7QUFDQSxZQUFLQSxTQUFTLGFBQWQsRUFBOEI7QUFDMUIsY0FBS3psQyxFQUFFMGtDLE9BQVAsRUFBaUI7QUFDYixtQkFBTzFrQyxFQUFFMGtDLE9BQUYsQ0FBVXRQLEtBQWpCO0FBQ0g7QUFDRHFRLGtCQUFRLE9BQVI7QUFDSDs7QUFFRDtBQUNBLFlBQUtBLFNBQVMsT0FBZCxFQUF3QjtBQUNwQixpQkFBT2hELFFBQVFyTixLQUFmO0FBQ0g7O0FBRUQ7QUFDQSxZQUFLcVEsU0FBU3psQyxFQUFFeWpDLFNBQUYsQ0FBWS9XLElBQTFCLEVBQWlDO0FBQzdCLGNBQUssT0FBT29aLE1BQVAsSUFBaUIsUUFBdEIsRUFBaUM7QUFDN0IsZ0JBQUlILGFBQWEzbEMsRUFBRXlqQyxTQUFGLENBQVk5dEIsR0FBWixDQUFpQjh2QixLQUFqQixDQUFqQjtBQUNBLG1CQUFPRSxhQUNIbkQsa0JBQWtCNXZCLENBQWxCLENBQW9Cd00sT0FBcEIsQ0FDSXBmLEVBQUV5akMsU0FBRixDQUFZdUMsT0FBWixDQUFvQmxuQyxRQUR4QixFQUVJa0IsRUFBRXlqQyxTQUZOLEVBR0ksQ0FBRXFDLE1BQUYsRUFBVUgsVUFBVixDQUhKLENBREcsR0FLQyxFQUxSO0FBTUg7QUFDRCxpQkFBTzNsQyxFQUFFeWpDLFNBQUYsQ0FBWTl0QixHQUFaLENBQWlCOHZCLEtBQWpCLENBQVA7QUFDSDtBQUNKLE9BbFowQixFQWtaeEI7OztBQUlIOzs7QUFHQXRwQixVQUFJLFlBQVVzcEIsS0FBVixFQUFpQlEsTUFBakIsRUFBeUJDLFFBQXpCLEVBQW9DOztBQUVwQyxZQUFJQyxTQUFKO0FBQUEsWUFBZUMsV0FBZjtBQUFBLFlBQ0lSLGdCQUFnQmx1QyxFQUFFdUUsYUFBRixDQUFpQndwQyxLQUFqQixDQURwQjtBQUFBLFlBRUlJLGNBQWNELGdCQUFnQkgsS0FBaEIsR0FBd0IsRUFGMUM7O0FBSUEsWUFBS0EsS0FBTCxFQUFhOztBQUVUO0FBQ0EsY0FBSyxDQUFDRyxhQUFOLEVBQXNCO0FBQ2xCQyx3QkFBYUosS0FBYixJQUF1QlEsTUFBdkI7QUFDSDs7QUFFRDtBQUNBLGVBQU1FLFNBQU4sSUFBbUJOLFdBQW5CLEVBQWlDOztBQUU3QjtBQUNBTywwQkFBY1AsWUFBYU0sU0FBYixDQUFkOztBQUVBO0FBQ0EsZ0JBQUtELFFBQUwsRUFBZ0I7QUFDWkMsMEJBQVksTUFBTUEsU0FBbEI7QUFDSDs7QUFFRDtBQUNBckQsa0JBQU1qYyxPQUFOLENBQWVzZixTQUFmLElBQTZCckQsTUFBTWpjLE9BQU4sQ0FBZXNmLFNBQWYsS0FBOEIsRUFBM0Q7O0FBRUE7QUFDQXJELGtCQUFNamMsT0FBTixDQUFlc2YsU0FBZixFQUEyQm5wQyxJQUEzQixDQUFpQ29wQyxXQUFqQztBQUNIO0FBQ0o7O0FBRUQsZUFBT3BtQyxDQUFQO0FBQ0gsT0ExYjBCLEVBMGJ4Qjs7O0FBSUg7OztBQUdBb2MsV0FBSyxlQUFXO0FBQ1osWUFBSXZnQixDQUFKO0FBQUEsWUFBT3NxQyxTQUFQO0FBQUEsWUFDSTM0QixRQUFRN1EsU0FEWjtBQUVBLGFBQU1kLElBQUksQ0FBSixFQUFPd3FDLGFBQWE3NEIsTUFBTXBTLE1BQWhDLEVBQXdDUyxJQUFJd3FDLFVBQTVDLEVBQXdEeHFDLEtBQUssQ0FBN0QsRUFBaUU7QUFDN0RzcUMsc0JBQVkzNEIsTUFBTTNSLENBQU4sQ0FBWjtBQUNBLGNBQUtzcUMsYUFBYXJELE1BQU1qYyxPQUF4QixFQUFrQztBQUM5QixtQkFBT2ljLE1BQU1qYyxPQUFOLENBQWNzZixTQUFkLENBQVA7QUFDSDtBQUNKO0FBQ0QsZUFBT25tQyxDQUFQO0FBQ0gsT0EzYzBCOztBQThjM0I7OztBQUdBb2YsZUFBUyxpQkFBVTJYLElBQVYsRUFBZ0J4NkIsSUFBaEIsRUFBdUI7QUFDNUIsWUFBSStwQyxXQUFXLFNBQVhBLFFBQVcsQ0FBVXZQLElBQVYsRUFBaUI7QUFDNUIsY0FBSXdQLGFBQWF6RCxNQUFNamMsT0FBTixDQUFla1EsSUFBZixDQUFqQjtBQUNBLGNBQUt3UCxVQUFMLEVBQWtCO0FBQ2RBLHVCQUFXQyxHQUFYLENBQWdCLFVBQVVQLE1BQVYsRUFBbUI7QUFDL0J6RCxnQ0FBa0I1dkIsQ0FBbEIsQ0FBb0J3TSxPQUFwQixDQUE2QjZtQixNQUE3QixFQUFxQ2ptQyxDQUFyQyxFQUF3QyxDQUFFekQsSUFBRixDQUF4QztBQUNILGFBRkQ7QUFHSDtBQUNKLFNBUEQ7QUFRQStwQyxpQkFBVSxNQUFNdlAsSUFBaEI7QUFDQXVQLGlCQUFVdlAsSUFBVjtBQUNBLGVBQU8vMkIsQ0FBUDtBQUNILE9BN2QwQixDQTZkekI7QUFDSjs7O0FBR047OztBQWplbUMsS0E3Qm5DLENBaWdCQSxTQUFTNGpDLHNCQUFULEdBQWtDOztBQUU5QjtBQUNBLGFBQU9wQixrQkFBa0I1dkIsQ0FBbEIsQ0FBb0Ird0IsSUFBcEIsQ0FBMEIsS0FBMUI7O0FBRUg7QUFDQW5CLHdCQUFrQjV2QixDQUFsQixDQUFvQit3QixJQUFwQixDQUEwQixLQUExQjs7QUFFSTtBQUNBbkIsd0JBQWtCNXZCLENBQWxCLENBQW9CK3dCLElBQXBCLENBQTBCLEtBQTFCOztBQUVJO0FBQ0FuQix3QkFBa0I1dkIsQ0FBbEIsQ0FBb0Ird0IsSUFBcEIsQ0FBMEIsS0FBMUI7O0FBRUk7QUFDQTNqQyxRQUFFeWpDLFNBQUYsQ0FBWWdCLEtBQVosQ0FBbUIzQixNQUFNemMsSUFBekIsQ0FISjs7QUFLSTtBQUNBMmMsY0FBUW5ULEdBTlosQ0FISjs7QUFZSTtBQUNBbVQsY0FBUWhhLElBYlosQ0FISjs7QUFtQkk7QUFDQWdhLGNBQVF5RCxLQXBCWixDQUhHOztBQTBCSDtBQUNBekQsY0FBUTBELE1BM0JMLENBQVAsQ0FIOEIsQ0ErQjVCO0FBQ0wsS0F2aUIyRCxDQXVpQjFEOzs7QUFJRjs7O0FBR0EsYUFBU3pDLGNBQVQsR0FBMEI7O0FBRXRCZDs7QUFFSTtBQUNBNW1DLFVBSEosQ0FHU21tQyxJQUhULEVBR2UxaUMsQ0FIZjs7QUFLSTtBQUNBd0osY0FOSixDQU1hdzVCLFFBQVFqc0IsS0FOckI7O0FBUUk7QUFDQWlKLFVBVEosQ0FTUyxVQVRULEVBU3FCLENBQUMsQ0FUdEI7O0FBV0k7QUFDQXdWLFNBWkosQ0FZUzJOLFNBQVM1bUMsSUFBVCxDQUFjLE9BQWQsSUFDRHlELEVBQUUyVixHQUFGLENBQU0sUUFBTixFQUFnQm90QixTQUFTK0MsTUFBekIsQ0FEQyxHQUVEckQsUUFBUXJOLEtBZGhCOztBQWtCQTtBQUNBLFVBQUssQ0FBQzJOLFNBQVNTLFFBQWYsRUFBMEI7O0FBRXRCTDs7QUFFSTtBQUNBaG5CLFVBSEosQ0FHUSxXQUFXMm1CLE1BQU0vdEIsRUFBakIsR0FBc0IsU0FBdEIsR0FBa0MrdEIsTUFBTS90QixFQUhoRCxFQUdvRCxVQUFVeUYsS0FBVixFQUFrQjtBQUM5REEsZ0JBQU1SLGNBQU47QUFDQWhhLFlBQUUwakMsS0FBRixDQUFRaGdCLEVBQVIsQ0FBVyxDQUFYLEVBQWN3YSxLQUFkO0FBQ0gsU0FOTDs7QUFRSTtBQUNBL2hCLFVBVEosQ0FTUSxhQUFhMm1CLE1BQU0vdEIsRUFUM0IsRUFTK0I0eEIsa0JBVC9CO0FBVUg7O0FBR0Q7QUFDQTlCLFdBQUtwQyxPQUFMLEVBQWM7QUFDVm1FLGtCQUFVLElBREE7QUFFVkMsa0JBQVUsS0FGQTtBQUdWQyxrQkFBVSxLQUhBO0FBSVZDLGNBQU10RSxRQUFRMXRCLEVBQVIsR0FBYTtBQUpULE9BQWQ7QUFNSDs7QUFHRDs7O0FBR0EsYUFBUyt1QixrQkFBVCxHQUE4Qjs7QUFFMUI5akMsUUFBRTBqQyxLQUFGLENBRUl2bkIsRUFGSixDQUVPOztBQUVDO0FBQ0E2cUIsaUJBQVNMLGtCQUhWOztBQUtDO0FBQ0E7QUFDQU0saUJBQVMsaUJBQVV6c0IsS0FBVixFQUFrQjtBQUN2QnhhLFlBQUUwakMsS0FBRixDQUFRdmdDLFdBQVIsQ0FBcUI2L0IsUUFBUXVDLE9BQTdCO0FBQ0EvcUIsZ0JBQU04SixlQUFOO0FBQ0gsU0FWRjs7QUFZQztBQUNBO0FBQ0EsMkJBQW1CLHdCQUFVOUosS0FBVixFQUFrQjs7QUFFakMsY0FBSWpMLFNBQVNpTCxNQUFNakwsTUFBbkI7O0FBRUE7QUFDQSxjQUFLQSxVQUFVdlAsRUFBRTBqQyxLQUFGLENBQVE3Z0IsUUFBUixHQUFvQixDQUFwQixDQUFmLEVBQXlDOztBQUVyQ3JJLGtCQUFNOEosZUFBTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFLOUosTUFBTWxmLElBQU4sSUFBYyxXQUFkLElBQTZCLENBQUM1RCxFQUFHNlgsTUFBSCxFQUFZdVQsRUFBWixDQUFnQix5Q0FBaEIsQ0FBbkMsRUFBZ0c7O0FBRTVGdEksb0JBQU1SLGNBQU47O0FBRUE7QUFDQTtBQUNBaGEsZ0JBQUUwakMsS0FBRixDQUFRaGdCLEVBQVIsQ0FBVyxDQUFYLEVBQWN3YSxLQUFkO0FBQ0g7QUFDSjtBQUNKO0FBcENGLE9BRlA7O0FBeUNJO0FBQ0EvaEIsUUExQ0osQ0EwQ087QUFDQytoQixlQUFPLGlCQUFXO0FBQ2RpRixtQkFBUzM1QixRQUFULENBQW1CdzVCLFFBQVF6ekIsTUFBM0I7QUFDSCxTQUhGO0FBSUNwSCxjQUFNLGdCQUFXO0FBQ2JnN0IsbUJBQVNoZ0MsV0FBVCxDQUFzQjYvQixRQUFRenpCLE1BQTlCO0FBQ0g7QUFORixPQTFDUDs7QUFtREk7QUFDQTRNLFFBcERKLENBb0RRLGNBcERSLEVBb0R3Qm1wQixzQkFwRHhCOztBQXNESTtBQUNBbnBCLFFBdkRKLENBdURRLE9BdkRSLEVBdURpQixxREF2RGpCLEVBdUR3RSxZQUFXOztBQUUzRSxZQUFJc2lCLFVBQVUvbUMsRUFBRyxJQUFILENBQWQ7QUFBQSxZQUNJd3ZDLGFBQWF6SSxRQUFRbGlDLElBQVIsRUFEakI7QUFBQSxZQUVJNHFDLGlCQUFpQjFJLFFBQVFsYyxRQUFSLENBQWtCeWdCLFFBQVFvRSxXQUExQixLQUEyQzNJLFFBQVFsYyxRQUFSLENBQWtCeWdCLFFBQVFvQyxRQUExQixDQUZoRTs7O0FBSUk7QUFDQTtBQUNBaUMsd0JBQWdCL0Qsa0JBTnBCO0FBT0krRCx3QkFBZ0JBLGtCQUFtQkEsY0FBYy9yQyxJQUFkLElBQXNCK3JDLGNBQWNDLElBQXZELENBQWhCOztBQUVKO0FBQ0EsWUFBS0gsa0JBQWtCRSxpQkFBaUIsQ0FBQzN2QyxFQUFFNjVCLFFBQUYsQ0FBWXZ4QixFQUFFMGpDLEtBQUYsQ0FBUSxDQUFSLENBQVosRUFBd0IyRCxhQUF4QixDQUF6QyxFQUFtRjtBQUMvRXJuQyxZQUFFMGpDLEtBQUYsQ0FBUWhnQixFQUFSLENBQVcsQ0FBWCxFQUFjd2EsS0FBZDtBQUNIOztBQUVEO0FBQ0EsWUFBSyxDQUFDaUosY0FBRCxJQUFtQkQsV0FBV0ssR0FBbkMsRUFBeUM7QUFDckN2bkMsWUFBRXVVLEdBQUYsQ0FBTyxXQUFQLEVBQW9CdlUsRUFBRXlqQyxTQUFGLENBQVkvVyxJQUFaLENBQWlCeUwsU0FBckMsRUFBZ0QsRUFBRW9QLEtBQUtMLFdBQVdLLEdBQWxCLEVBQWhEO0FBQ0g7O0FBRUQ7QUFKQSxhQUtLLElBQUssQ0FBQ0osY0FBRCxJQUFtQixVQUFVRCxVQUFsQyxFQUErQztBQUNoRGxuQyxjQUFFdVUsR0FBRixDQUFPLFFBQVAsRUFBaUIyeUIsV0FBV00sSUFBNUI7QUFDSDs7QUFFRDtBQUpLLGVBS0EsSUFBS04sV0FBVzFCLEtBQWhCLEVBQXdCO0FBQ3pCeGxDLGdCQUFFd2xDLEtBQUYsR0FBVXJkLEtBQVYsQ0FBaUIsSUFBakI7QUFDSCxhQUZJLE1BSUEsSUFBSytlLFdBQVcvZSxLQUFoQixFQUF3QjtBQUN6Qm5vQixnQkFBRW1vQixLQUFGLENBQVMsSUFBVDtBQUNIO0FBRUosT0ExRkwsRUFGMEIsQ0E0Rm5COztBQUVQMGMsV0FBTTdrQyxFQUFFMGpDLEtBQUYsQ0FBUSxDQUFSLENBQU4sRUFBa0IsUUFBbEIsRUFBNEIsSUFBNUI7QUFDSDs7QUFHQTs7O0FBR0QsYUFBU00sb0JBQVQsR0FBZ0M7O0FBRTVCLFVBQUlqTixJQUFKOztBQUVBLFVBQUtnTSxTQUFTMEUsVUFBVCxLQUF3QixJQUE3QixFQUFvQztBQUNoQzFRLGVBQU8wTCxRQUFRMUwsSUFBZjtBQUNBMEwsZ0JBQVExTCxJQUFSLEdBQWUsRUFBZjtBQUNILE9BSEQsTUFJSztBQUNEQSxlQUFPLENBQ0gsT0FBT2dNLFNBQVMyRSxZQUFoQixJQUFnQyxRQUFoQyxHQUEyQzNFLFNBQVMyRSxZQUFwRCxHQUFtRSxFQURoRSxFQUVILE9BQU8zRSxTQUFTNEUsWUFBaEIsSUFBZ0MsUUFBaEMsR0FBMkM1RSxTQUFTNEUsWUFBcEQsR0FBbUUsU0FGaEUsQ0FBUDtBQUlBNVEsZUFBT0EsS0FBSyxDQUFMLElBQVUwTCxRQUFRMUwsSUFBbEIsR0FBeUJBLEtBQUssQ0FBTCxDQUFoQztBQUNIOztBQUVELzJCLFFBQUUwa0MsT0FBRixHQUFZaHRDLEVBQ1IsWUFDQSxjQURBOztBQUdBO0FBQ0EsY0FKQSxHQUlXcS9CLElBSlgsR0FJa0IsR0FKbEI7O0FBTUE7QUFFSW9NLGVBQVM1bUMsSUFBVCxDQUFjLE9BQWQsS0FBMEJrbUMsUUFBUXJOLEtBQWxDLEdBQ0ksYUFBYXAxQixFQUFFMlYsR0FBRixDQUFNLFFBQU4sRUFBZ0JvdEIsU0FBU2dCLFlBQXpCLENBQWIsR0FBc0QsR0FEMUQsR0FFSSxFQVZSLElBWUEsR0FiUSxFQWNWLENBZFUsQ0FBWjs7QUFnQkFaOztBQUVJO0FBQ0FobkIsUUFISixDQUdPLFlBQVkybUIsTUFBTS90QixFQUh6QixFQUc2QixZQUFXO0FBQ2hDL1UsVUFBRTBrQyxPQUFGLENBQVV0UCxLQUFWLEdBQWtCcU4sUUFBUXJOLEtBQVIsR0FDZHAxQixFQUFFMlYsR0FBRixDQUFNLFFBQU4sRUFBZ0JvdEIsU0FBU2dCLFlBQXpCLENBRGMsR0FFZCxFQUZKO0FBR0gsT0FQTDs7QUFVQTtBQUNBLFVBQUtoQixTQUFTMzRCLFNBQWQsRUFBMEIxUyxFQUFHcXJDLFNBQVMzNEIsU0FBWixFQUF3QjJkLE1BQXhCLENBQWdDL25CLEVBQUUwa0MsT0FBbEMsRUFBMUIsS0FDS3ZCLFNBQVN2ZSxLQUFULENBQWdCNWtCLEVBQUUwa0MsT0FBbEI7QUFDUjs7QUFHRDtBQUNBLGFBQVNpQyxrQkFBVCxDQUE2Qm5zQixLQUE3QixFQUFxQzs7QUFFakMsVUFBSXdxQixVQUFVeHFCLE1BQU15TixPQUFwQjs7O0FBRUk7QUFDQTJmLHdCQUFrQixXQUFXeHBDLElBQVgsQ0FBZ0I0bUMsT0FBaEIsQ0FIdEI7O0FBS0E7QUFDQSxVQUFLQSxXQUFXLEVBQWhCLEVBQXFCO0FBQ2pCaGxDLFVBQUVtb0IsS0FBRjtBQUNBLGVBQU8sS0FBUDtBQUNIOztBQUVEO0FBQ0EsVUFBSzZjLFdBQVcsRUFBWCxJQUFpQjRDLGVBQWpCLElBQW9DLENBQUM5RSxNQUFNemMsSUFBUCxJQUFlcm1CLEVBQUV5akMsU0FBRixDQUFZMUssR0FBWixDQUFnQmlNLE9BQWhCLENBQXhELEVBQW1GOztBQUUvRTtBQUNBeHFCLGNBQU1SLGNBQU47QUFDQVEsY0FBTThKLGVBQU47O0FBRUE7QUFDQTtBQUNBLFlBQUtzakIsZUFBTCxFQUF1QjtBQUFFNW5DLFlBQUV3bEMsS0FBRixHQUFVcmQsS0FBVjtBQUFtQixTQUE1QyxNQUNLO0FBQUVub0IsWUFBRXFtQixJQUFGO0FBQVU7QUFDcEI7QUFDSjs7QUFHRDtBQUNBLGFBQVNpZixzQkFBVCxDQUFpQzlxQixLQUFqQyxFQUF5Qzs7QUFFckM7QUFDQUEsWUFBTThKLGVBQU47O0FBRUE7QUFDQSxVQUFLOUosTUFBTWxmLElBQU4sSUFBYyxPQUFuQixFQUE2QjtBQUN6QjBFLFVBQUUwakMsS0FBRixDQUFRbDZCLFFBQVIsQ0FBa0J3NUIsUUFBUXVDLE9BQTFCO0FBQ0g7O0FBRUQ7QUFDQXZsQyxRQUFFcW1CLElBQUY7QUFDSDs7QUFHRDtBQUNBLFdBQU8sSUFBSStjLGNBQUosRUFBUDtBQUNILEdBN3lCZSxDQTZ5QmQ7OztBQUlGOzs7QUFHQVosb0JBQWtCUyxPQUFsQixHQUE0QixVQUFVNEUsTUFBVixFQUFtQjtBQUMzQ0EsYUFBU0EsVUFBVSxRQUFuQjtBQUNBLFdBQU87O0FBRUhoRSxjQUFRZ0UsTUFGTDtBQUdIL0MsY0FBUStDLFNBQVMsVUFIZDtBQUlIdEMsZUFBU3NDLFNBQVMsV0FKZjs7QUFNSDl3QixhQUFPOHdCLFNBQVMsU0FOYjtBQU9IakQsY0FBUWlELFNBQVMsaUJBUGQ7QUFRSHQ0QixjQUFRczRCLFNBQVMsaUJBUmQ7O0FBVUhuQixjQUFRbUIsU0FBUyxVQVZkOztBQVlIcEIsYUFBT29CLFNBQVMsU0FaYjtBQWFIN2UsWUFBTTZlLFNBQVMsUUFiWjs7QUFlSGhZLFdBQUtnWSxTQUFTO0FBZlgsS0FBUDtBQWlCSCxHQW5CRCxDQXB6QmdCLENBdTBCZDs7O0FBSUY7OztBQUdBLFdBQVN0RCxtQkFBVCxDQUE4QnZqQyxPQUE5QixFQUF3Qzs7QUFFcEMsUUFBSThtQyxLQUFKO0FBQUEsUUFDSWhvQixPQUFPLFVBRFg7O0FBR0E7QUFDQSxRQUFLOWUsUUFBUSttQyxZQUFiLEVBQTRCO0FBQ3hCRCxjQUFROW1DLFFBQVErbUMsWUFBUixDQUFxQmpvQixJQUFyQixDQUFSO0FBQ0g7O0FBRUQ7QUFKQSxTQUtLLElBQUtua0IsT0FBT3NPLGdCQUFaLEVBQStCO0FBQ2hDNjlCLGdCQUFRNzlCLGlCQUFrQmpKLE9BQWxCLEVBQTRCOGUsSUFBNUIsQ0FBUjtBQUNIOztBQUVELFdBQU9nb0IsU0FBUyxPQUFoQjtBQUNIOztBQUlEOzs7O0FBSUEsV0FBUy9DLGlCQUFULEdBQTZCOztBQUV6QixRQUFLeEMsTUFBTW4wQixNQUFOLE1BQWtCazBCLFFBQVFsMEIsTUFBUixFQUF2QixFQUEwQztBQUN0QyxhQUFPLENBQVA7QUFDSDs7QUFFRCxRQUFJNDVCLFNBQVN0d0MsRUFBRywrQ0FBSCxFQUNUbTJCLFFBRFMsQ0FDQyxNQURELENBQWI7O0FBR0E7QUFDQSxRQUFJb2EscUJBQXFCRCxPQUFPLENBQVAsRUFBVWgrQixXQUFuQzs7QUFFQTtBQUNBZytCLFdBQU9sK0IsR0FBUCxDQUFZLFVBQVosRUFBd0IsUUFBeEI7O0FBRUE7QUFDQSxRQUFJbytCLFNBQVN4d0MsRUFBRyw0QkFBSCxFQUFrQ20yQixRQUFsQyxDQUE0Q21hLE1BQTVDLENBQWI7O0FBRUE7QUFDQSxRQUFJRyxrQkFBa0JELE9BQU8sQ0FBUCxFQUFVbCtCLFdBQWhDOztBQUVBO0FBQ0FnK0IsV0FBT3ArQixNQUFQOztBQUVBO0FBQ0EsV0FBT3ErQixxQkFBcUJFLGVBQTVCO0FBQ0g7O0FBSUQ7OztBQUdBM0Ysb0JBQWtCNXZCLENBQWxCLEdBQXNCOztBQUVsQjs7Ozs7Ozs7Ozs7O0FBWUF3MUIsV0FBTyxlQUFVQyxXQUFWLEVBQXdCOztBQUUzQjtBQUNJO0FBQ0FDLHFCQUZKOzs7QUFJSTtBQUNBQyxrQkFBWSxFQUxoQjs7O0FBT0k7QUFDQUMsZ0JBQVVoRyxrQkFBa0I1dkIsQ0FBbEIsQ0FBb0J3TSxPQUFwQixDQUE2QmlwQixZQUFZbG9DLEdBQXpDLEVBQThDa29DLFdBQTlDLENBUmQ7O0FBV0E7QUFDQSxhQUFRRyxXQUFXaEcsa0JBQWtCNXZCLENBQWxCLENBQW9Cd00sT0FBcEIsQ0FBNkJpcEIsWUFBWWpvQyxHQUF6QyxFQUE4Q2lvQyxXQUE5QyxFQUEyRCxDQUFFRyxPQUFGLENBQTNELENBQW5CLEVBQTZGQSxXQUFXSCxZQUFZeHNDLENBQXBILEVBQXdIOztBQUVwSDtBQUNBeXNDLDBCQUFrQjlGLGtCQUFrQjV2QixDQUFsQixDQUFvQndNLE9BQXBCLENBQTZCaXBCLFlBQVkzYixJQUF6QyxFQUErQzJiLFdBQS9DLEVBQTRELENBQUVHLE9BQUYsQ0FBNUQsQ0FBbEI7O0FBRUE7QUFDQUQscUJBQWEvRixrQkFBa0I1dkIsQ0FBbEIsQ0FBb0Ird0IsSUFBcEIsQ0FDVDBFLFlBQVkxRSxJQURILEVBRVQyRSxnQkFBaUIsQ0FBakIsQ0FGUyxFQUVlO0FBQ3hCQSx3QkFBaUIsQ0FBakIsQ0FIUyxFQUdlO0FBQ3hCQSx3QkFBaUIsQ0FBakIsQ0FKUyxDQUllO0FBSmYsU0FBYjtBQU1IOztBQUVEO0FBQ0EsYUFBT0MsU0FBUDtBQUNILEtBNUNpQixFQTRDZjs7O0FBR0g7OztBQUdBNUUsVUFBTSxjQUFVbGUsT0FBVixFQUFtQmlILElBQW5CLEVBQXlCd1csS0FBekIsRUFBZ0N1RixTQUFoQyxFQUE0Qzs7QUFFOUM7QUFDQSxVQUFLLENBQUMvYixJQUFOLEVBQWEsT0FBTyxFQUFQOztBQUViO0FBQ0FBLGFBQU9oMUIsRUFBRXFFLE9BQUYsQ0FBVzJ3QixJQUFYLElBQW9CQSxLQUFLN2tCLElBQUwsQ0FBVyxFQUFYLENBQXBCLEdBQXNDNmtCLElBQTdDOztBQUVBO0FBQ0F3VyxjQUFRQSxRQUFRLGFBQWFBLEtBQWIsR0FBcUIsR0FBN0IsR0FBbUMsRUFBM0M7O0FBRUE7QUFDQXVGLGtCQUFZQSxZQUFZLE1BQU1BLFNBQWxCLEdBQThCLEVBQTFDOztBQUVBO0FBQ0EsYUFBTyxNQUFNaGpCLE9BQU4sR0FBZ0J5ZCxLQUFoQixHQUF3QnVGLFNBQXhCLEdBQW9DLEdBQXBDLEdBQTBDL2IsSUFBMUMsR0FBaUQsSUFBakQsR0FBd0RqSCxPQUF4RCxHQUFrRSxHQUF6RTtBQUNILEtBbEVpQixFQWtFZjs7O0FBR0g7OztBQUdBaWpCLFVBQU0sY0FBVUMsTUFBVixFQUFtQjtBQUNyQixhQUFPLENBQUVBLFNBQVMsRUFBVCxHQUFjLEdBQWQsR0FBbUIsRUFBckIsSUFBNEJBLE1BQW5DO0FBQ0gsS0ExRWlCOztBQTZFbEI7OztBQUdBdnBCLGFBQVMsaUJBQVU5UCxRQUFWLEVBQW9CczVCLEtBQXBCLEVBQTJCMW5CLElBQTNCLEVBQWtDO0FBQ3ZDLGFBQU8sT0FBTzVSLFFBQVAsSUFBbUIsVUFBbkIsR0FBZ0NBLFNBQVNoVCxLQUFULENBQWdCc3NDLEtBQWhCLEVBQXVCMW5CLFFBQVEsRUFBL0IsQ0FBaEMsR0FBc0U1UixRQUE3RTtBQUNILEtBbEZpQjs7QUFxRmxCOzs7QUFHQXU1QixZQUFRLGdCQUFVelEsTUFBVixFQUFtQjtBQUN2QixhQUFTLEtBQUYsQ0FBU2g2QixJQUFULENBQWVnNkIsT0FBUSxDQUFSLENBQWYsSUFBK0IsQ0FBL0IsR0FBbUM7QUFBMUM7QUFDSCxLQTFGaUI7O0FBNkZsQjs7O0FBR0EwUSxZQUFRLGdCQUFVMVQsS0FBVixFQUFrQjtBQUN0QixhQUFPLEdBQUd0MkIsUUFBSCxDQUFZaEQsSUFBWixDQUFrQnM1QixLQUFsQixFQUEwQnRtQixPQUExQixDQUFtQyxNQUFuQyxJQUE4QyxDQUFDLENBQS9DLElBQW9ELEtBQUtpNkIsU0FBTCxDQUFnQjNULE1BQU00VCxPQUFOLEVBQWhCLENBQTNEO0FBQ0gsS0FsR2lCOztBQXFHbEI7OztBQUdBRCxlQUFXLG1CQUFVM1QsS0FBVixFQUFrQjtBQUN6QixhQUFPLEdBQUd0MkIsUUFBSCxDQUFZaEQsSUFBWixDQUFrQnM1QixLQUFsQixFQUEwQnRtQixPQUExQixDQUFtQyxRQUFuQyxJQUFnRCxDQUFDLENBQWpELElBQXNEc21CLFFBQVEsQ0FBUixLQUFjLENBQTNFO0FBQ0gsS0ExR2lCOztBQTZHbEI7OztBQUdBNlQsY0FBVUEsUUFoSFEsQ0FpSHBCOzs7QUFJRjs7O0FBckhzQixHQUF0QixDQXdIQXpHLGtCQUFrQjNxQyxNQUFsQixHQUEyQixVQUFVay9CLElBQVYsRUFBZ0JtUyxTQUFoQixFQUE0Qjs7QUFFbkQ7QUFDQXh4QyxNQUFFK0QsRUFBRixDQUFNczdCLElBQU4sSUFBZSxVQUFVcnBCLE9BQVYsRUFBbUJ5N0IsTUFBbkIsRUFBNEI7O0FBRXZDO0FBQ0EsVUFBSUMsZ0JBQWdCLEtBQUs3c0MsSUFBTCxDQUFXdzZCLElBQVgsQ0FBcEI7O0FBRUE7QUFDQSxVQUFLcnBCLFdBQVcsUUFBaEIsRUFBMkI7QUFDdkIsZUFBTzA3QixhQUFQO0FBQ0g7O0FBRUQ7QUFDQSxVQUFLQSxpQkFBaUIsT0FBTzE3QixPQUFQLElBQWtCLFFBQXhDLEVBQW1EO0FBQy9DLGVBQU84MEIsa0JBQWtCNXZCLENBQWxCLENBQW9Cd00sT0FBcEIsQ0FBNkJncUIsY0FBZTE3QixPQUFmLENBQTdCLEVBQXVEMDdCLGFBQXZELEVBQXNFLENBQUVELE1BQUYsQ0FBdEUsQ0FBUDtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGFBQU8sS0FBSzlzQyxJQUFMLENBQVcsWUFBVztBQUN6QixZQUFJNGxCLFFBQVF2cUIsRUFBRyxJQUFILENBQVo7QUFDQSxZQUFLLENBQUN1cUIsTUFBTTFsQixJQUFOLENBQVl3NkIsSUFBWixDQUFOLEVBQTJCO0FBQ3ZCLGNBQUl5TCxpQkFBSixDQUF1QixJQUF2QixFQUE2QnpMLElBQTdCLEVBQW1DbVMsU0FBbkMsRUFBOEN4N0IsT0FBOUM7QUFDSDtBQUNKLE9BTE0sQ0FBUDtBQU1ILEtBeEJEOztBQTBCQTtBQUNBaFcsTUFBRStELEVBQUYsQ0FBTXM3QixJQUFOLEVBQWFuMkIsUUFBYixHQUF3QnNvQyxVQUFVdG9DLFFBQWxDO0FBQ0gsR0EvQkQsQ0EvL0JnQixDQThoQ2Q7OztBQUlGLFdBQVNpa0MsSUFBVCxDQUFjN2pDLE9BQWQsRUFBdUJ5bkMsU0FBdkIsRUFBa0NyVCxLQUFsQyxFQUF5QztBQUNyQyxRQUFLMTlCLEVBQUV1RSxhQUFGLENBQWdCd3NDLFNBQWhCLENBQUwsRUFBa0M7QUFDOUIsV0FBTSxJQUFJMVAsR0FBVixJQUFpQjBQLFNBQWpCLEVBQTZCO0FBQ3pCWSxnQkFBUXJvQyxPQUFSLEVBQWlCKzNCLEdBQWpCLEVBQXNCMFAsVUFBVTFQLEdBQVYsQ0FBdEI7QUFDSDtBQUNKLEtBSkQsTUFLSztBQUNEc1EsY0FBUXJvQyxPQUFSLEVBQWlCeW5DLFNBQWpCLEVBQTRCclQsS0FBNUI7QUFDSDtBQUNKO0FBQ0QsV0FBU2lVLE9BQVQsQ0FBaUJyb0MsT0FBakIsRUFBMEJ5bkMsU0FBMUIsRUFBcUNyVCxLQUFyQyxFQUE0QztBQUN4Q3AwQixZQUFRd0osWUFBUixDQUNJLENBQUNpK0IsYUFBYSxNQUFiLEdBQXNCLEVBQXRCLEdBQTJCLE9BQTVCLElBQXVDQSxTQUQzQyxFQUVJclQsS0FGSjtBQUlIO0FBQ0QsV0FBUzZULFFBQVQsQ0FBa0JSLFNBQWxCLEVBQTZCbHNDLElBQTdCLEVBQW1DO0FBQy9CLFFBQUssQ0FBQzdFLEVBQUV1RSxhQUFGLENBQWdCd3NDLFNBQWhCLENBQU4sRUFBbUM7QUFDL0JBLGtCQUFZLEVBQUVBLFdBQVdsc0MsSUFBYixFQUFaO0FBQ0g7QUFDREEsV0FBTyxFQUFQO0FBQ0EsU0FBTSxJQUFJdzhCLEdBQVYsSUFBaUIwUCxTQUFqQixFQUE2QjtBQUN6QixVQUFJem9CLE9BQU8sQ0FBQytZLE9BQU8sTUFBUCxHQUFnQixFQUFoQixHQUFxQixPQUF0QixJQUFpQ0EsR0FBNUM7QUFBQSxVQUNJdVEsVUFBVWIsVUFBVTFQLEdBQVYsQ0FEZDtBQUVBeDhCLGNBQVErc0MsV0FBVyxJQUFYLEdBQWtCLEVBQWxCLEdBQXVCdHBCLE9BQU8sSUFBUCxHQUFjeW9CLFVBQVUxUCxHQUFWLENBQWQsR0FBK0IsR0FBOUQ7QUFDSDtBQUNELFdBQU94OEIsSUFBUDtBQUNIOztBQUVEO0FBQ0EsV0FBUyttQyxnQkFBVCxHQUE0QjtBQUN4QixRQUFJO0FBQ0EsYUFBTzVsQyxTQUFTMnBDLGFBQWhCO0FBQ0gsS0FGRCxDQUVFLE9BQVFrQyxHQUFSLEVBQWMsQ0FBRztBQUN0Qjs7QUFJRDtBQUNBLFNBQU8vRyxpQkFBUDtBQUdDLENBemxDQSxDQUFEOztBQTRsQ0EsQyxDQUFDOzs7OztBQUtBLFdBQVc1akIsT0FBWCxFQUFxQjs7QUFFbEI7QUFDQSxNQUFLLElBQUwsRUFDSSxpQ0FBUSxDQUFDLDBCQUFELEVBQVcsc0JBQVgsQ0FBUixvQ0FBOEJBLE9BQTlCO0FBQUE7QUFBQTtBQUFBOztBQUVKO0FBSEEsT0FJSyxJQUFLLFFBQU8xZixPQUFQLHlDQUFPQSxPQUFQLE1BQWtCLFFBQXZCLEVBQ0RELE9BQU9DLE9BQVAsR0FBaUIwZixRQUFTam5CLFFBQVEsYUFBUixDQUFULEVBQWlDQSxRQUFRLFFBQVIsQ0FBakMsQ0FBakI7O0FBRUo7QUFISyxTQUlBaW5CLFFBQVN5akIsTUFBVCxFQUFpQjVxQyxNQUFqQjtBQUVSLENBYkEsRUFhQyxVQUFVNHFDLE1BQVYsRUFBa0IzcUMsQ0FBbEIsRUFBc0I7O0FBR3hCOzs7QUFHQSxNQUFJOHhDLGVBQWUsQ0FBbkI7QUFBQSxNQUNJQyxvQkFBb0IsQ0FEeEI7QUFBQSxNQUVJNzJCLElBQUl5dkIsT0FBT3p2QixDQUZmOztBQU1BOzs7QUFHQSxXQUFTODJCLFVBQVQsQ0FBcUI3RixNQUFyQixFQUE2QjhGLFFBQTdCLEVBQXdDOztBQUVwQyxRQUFJQyxXQUFXLElBQWY7QUFBQSxRQUNJNW9DLFVBQVU2aUMsT0FBT1IsS0FBUCxDQUFjLENBQWQsQ0FEZDtBQUFBLFFBRUl3RyxlQUFlN29DLFFBQVFvMEIsS0FGM0I7QUFBQSxRQUdJMFUsbUJBQW1CakcsT0FBT1IsS0FBUCxDQUFhOW1DLElBQWIsQ0FBbUIsT0FBbkIsQ0FIdkI7QUFBQSxRQUlJd3RDLGNBQWNELG9CQUFvQkQsWUFKdEM7QUFBQSxRQUtJRyxlQUFlRixtQkFBbUJILFNBQVM1RixZQUE1QixHQUEyQzRGLFNBQVM3RCxNQUx2RTtBQUFBLFFBTUltRSxRQUFRLFNBQVJBLEtBQVEsR0FBVzs7QUFFZixhQUFPanBDLFFBQVErbUMsWUFBUjs7QUFFSDtBQUNBL21DLGNBQVErbUMsWUFBUixDQUFxQjE5QixTQUFyQixJQUFrQyxLQUgvQjs7QUFLSDtBQUNBSix1QkFBa0I0NUIsT0FBT0gsS0FBUCxDQUFhLENBQWIsQ0FBbEIsRUFBb0NyNUIsU0FBcEMsSUFBaUQsS0FOckQ7QUFPSCxLQWZMOztBQWlCQXUvQixhQUFTRCxRQUFULEdBQW9CQSxRQUFwQjtBQUNBQyxhQUFTdkcsS0FBVCxHQUFpQlEsT0FBT1IsS0FBeEI7O0FBRUE7QUFDQXVHLGFBQVM5c0MsS0FBVCxHQUFpQjtBQUNicUQsV0FBSyxnQkFEUTtBQUViQyxXQUFLLGdCQUZRO0FBR2JzWCxXQUFLLFlBSFE7QUFJYm9pQixjQUFRLHVCQUpLO0FBS2IzQixpQkFBVyxnQ0FMRTtBQU1iK1IsWUFBTSwrQkFOTztBQU9iQyxlQUFTLFlBUEk7QUFRYno2QixjQUFROztBQUdaO0FBWGlCLEtBQWpCLENBWUFrNkIsU0FBU2xkLElBQVQsR0FBZ0IsRUFBaEI7O0FBRUFrZCxhQUFTbGQsSUFBVCxDQUFjOFksS0FBZCxHQUFzQixJQUF0QjtBQUNBb0UsYUFBU2xkLElBQVQsQ0FBY3lkLE9BQWQsR0FBd0IsQ0FBRVIsU0FBU1EsT0FBVCxJQUFvQixFQUF0QixFQUEyQjlxQyxLQUEzQixDQUFrQyxDQUFsQyxDQUF4QjtBQUNBdXFDLGFBQVNsZCxJQUFULENBQWNoZCxNQUFkLEdBQXVCLENBQUUsVUFBVTA2QixrQkFBVixFQUErQjtBQUNwRCxhQUFPQSxtQkFBb0IsQ0FBcEIsTUFBNEIsSUFBNUIsR0FBbUNBLG1CQUFtQmx0QyxLQUFuQixFQUFuQyxHQUFnRSxDQUFDLENBQXhFO0FBQ0gsS0FGdUIsQ0FFcEIwc0MsU0FBU2xkLElBQVQsQ0FBY3lkLE9BRk0sQ0FBeEI7O0FBSUFQLGFBQ0lyMUIsR0FESixDQUNTLEtBRFQsRUFDZ0JvMUIsU0FBU3hwQyxHQUR6QixFQUVJb1UsR0FGSixDQUVTLEtBRlQsRUFFZ0JvMUIsU0FBU3ZwQyxHQUZ6QixFQUdJbVUsR0FISixDQUdTLEtBSFQ7O0FBS0E7QUFDQTtBQUNBLFFBQUt3MUIsV0FBTCxFQUFtQjtBQUNmSCxlQUFTcjFCLEdBQVQsQ0FBYyxRQUFkLEVBQXdCdzFCLFdBQXhCLEVBQXFDLEVBQUVqRSxRQUFRa0UsWUFBVixFQUFyQztBQUNIOztBQUVEO0FBSkEsU0FLSztBQUNESixpQkFDSXIxQixHQURKLENBQ1MsUUFEVCxFQUNtQixJQURuQixFQUVJQSxHQUZKLENBRVMsV0FGVCxFQUVzQnExQixTQUFTbGQsSUFBVCxDQUFjaFYsR0FGcEM7QUFHSDs7QUFHRDtBQUNBa3lCLGFBQVM3USxHQUFULEdBQWU7QUFDWCxVQUFJLENBRE8sRUFDSjtBQUNQLFVBQUksQ0FBQyxDQUZNLEVBRUg7QUFDUixVQUFJLGFBQVc7QUFBRSxlQUFPa1IsVUFBVSxDQUFDLENBQVgsR0FBZSxDQUF0QjtBQUF5QixPQUgvQixFQUdpQztBQUM1QyxVQUFJLGFBQVc7QUFBRSxlQUFPQSxVQUFVLENBQVYsR0FBYyxDQUFDLENBQXRCO0FBQXlCLE9BSi9CLEVBSWlDO0FBQzVDL0UsVUFBSSxZQUFVbUYsVUFBVixFQUF1QjtBQUN2QixZQUFJQyxvQkFBb0JWLFNBQVNsZCxJQUFULENBQWN5TCxTQUF0QztBQUFBLFlBQ0lvUyxhQUFhLElBQUk1ckMsSUFBSixDQUFVMnJDLGtCQUFrQkUsSUFBNUIsRUFBa0NGLGtCQUFrQkcsS0FBcEQsRUFBMkRILGtCQUFrQkksSUFBbEIsR0FBeUJMLFVBQXBGLENBRGpCO0FBRUFULGlCQUFTcjFCLEdBQVQsQ0FDSSxXQURKLEVBRUlnMkIsVUFGSixFQUdJLEVBQUVydkIsVUFBVW12QixVQUFaLEVBSEo7QUFLQSxhQUFLbEcsTUFBTDtBQUNIOztBQUlMO0FBbEJlLEtBQWYsQ0FtQkFOLE9BQ0kxbkIsRUFESixDQUNRLFFBRFIsRUFDa0IsWUFBVztBQUNyQjBuQixhQUFPSCxLQUFQLENBQWF2aEIsSUFBYixDQUFtQixNQUFNd25CLFNBQVN6RyxLQUFULENBQWV5SCxXQUF4QyxFQUFzRHh1QixFQUF0RCxDQUEwRCxRQUExRCxFQUFvRSxZQUFXO0FBQzNFLFlBQUlpWixRQUFRLEtBQUtBLEtBQWpCO0FBQ0EsWUFBS0EsS0FBTCxFQUFhO0FBQ1R5TyxpQkFBT3R2QixHQUFQLENBQVksV0FBWixFQUF5QixDQUFFc3ZCLE9BQU9sdUIsR0FBUCxDQUFZLE1BQVosRUFBcUI2MEIsSUFBdkIsRUFBNkJwVixLQUE3QixFQUFvQ3lPLE9BQU9sdUIsR0FBUCxDQUFZLFdBQVosRUFBMEIrMEIsSUFBOUQsQ0FBekI7QUFDQTdHLGlCQUFPSCxLQUFQLENBQWF2aEIsSUFBYixDQUFtQixNQUFNd25CLFNBQVN6RyxLQUFULENBQWV5SCxXQUF4QyxFQUFzRHZyQixPQUF0RCxDQUErRCxPQUEvRDtBQUNIO0FBQ0osT0FORDtBQU9BeWtCLGFBQU9ILEtBQVAsQ0FBYXZoQixJQUFiLENBQW1CLE1BQU13bkIsU0FBU3pHLEtBQVQsQ0FBZTBILFVBQXhDLEVBQXFEenVCLEVBQXJELENBQXlELFFBQXpELEVBQW1FLFlBQVc7QUFDMUUsWUFBSWlaLFFBQVEsS0FBS0EsS0FBakI7QUFDQSxZQUFLQSxLQUFMLEVBQWE7QUFDVHlPLGlCQUFPdHZCLEdBQVAsQ0FBWSxXQUFaLEVBQXlCLENBQUU2Z0IsS0FBRixFQUFTeU8sT0FBT2x1QixHQUFQLENBQVksTUFBWixFQUFxQjgwQixLQUE5QixFQUFxQzVHLE9BQU9sdUIsR0FBUCxDQUFZLFdBQVosRUFBMEIrMEIsSUFBL0QsQ0FBekI7QUFDQTdHLGlCQUFPSCxLQUFQLENBQWF2aEIsSUFBYixDQUFtQixNQUFNd25CLFNBQVN6RyxLQUFULENBQWUwSCxVQUF4QyxFQUFxRHhyQixPQUFyRCxDQUE4RCxPQUE5RDtBQUNIO0FBQ0osT0FORDtBQU9ILEtBaEJMLEVBZ0JPLENBaEJQLEVBaUJJakQsRUFqQkosQ0FpQlEsTUFqQlIsRUFpQmdCLFlBQVc7QUFDbkIsVUFBSTB1QixlQUFlLEVBQW5CO0FBQ0EsVUFBS2pCLFNBQVN4RSxRQUFULENBQW1Cd0UsU0FBU2owQixHQUFULENBQWEsS0FBYixDQUFuQixDQUFMLEVBQWdEO0FBQzVDazFCLHVCQUFlLFdBQVdsQixTQUFTekcsS0FBVCxDQUFlNEgsV0FBMUIsR0FBd0MsR0FBdkQ7QUFDSDtBQUNEakgsYUFBT0gsS0FBUCxDQUFhdmhCLElBQWIsQ0FBbUIsV0FBVzBvQixZQUFYLEdBQTBCLFVBQTdDLEVBQTBEN3FCLElBQTFELENBQWdFLFVBQWhFLEVBQTRFLEtBQTVFO0FBQ0gsS0F2QkwsRUF1Qk8sQ0F2QlAsRUF3Qkk3RCxFQXhCSixDQXdCUSxPQXhCUixFQXdCaUIsWUFBVztBQUNwQjBuQixhQUFPSCxLQUFQLENBQWF2aEIsSUFBYixDQUFtQixnQkFBbkIsRUFBc0NuQyxJQUF0QyxDQUE0QyxVQUE1QyxFQUF3RCxJQUF4RDtBQUNILEtBMUJMLEVBMEJPLENBMUJQO0FBNEJILEdBN0h1QixDQTZIdEI7OztBQUdGOzs7QUFHQTBwQixhQUFXdHRDLFNBQVgsQ0FBcUJtWSxHQUFyQixHQUEyQixVQUFValosSUFBVixFQUFnQjg1QixLQUFoQixFQUF1QjFuQixPQUF2QixFQUFpQzs7QUFFeEQsUUFBSWs4QixXQUFXLElBQWY7QUFBQSxRQUNJbUIsZUFBZW5CLFNBQVNsZCxJQUQ1Qjs7QUFHQTtBQUNBLFFBQUswSSxVQUFVLElBQWYsRUFBc0I7QUFDbEIsVUFBSzk1QixRQUFRLE9BQWIsRUFBdUJBLE9BQU8sUUFBUDtBQUN2Qnl2QyxtQkFBY3p2QyxJQUFkLElBQXVCODVCLEtBQXZCO0FBQ0EsYUFBT3dVLFFBQVA7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBbUIsaUJBQWdCenZDLFFBQVEsUUFBUixHQUFtQixTQUFuQixHQUErQkEsUUFBUSxNQUFSLEdBQWlCLFFBQWpCLEdBQTRCQSxJQUEzRSxJQUFzRnN1QyxTQUFTOXNDLEtBQVQsQ0FBZ0J4QixJQUFoQixFQUF1QnlELEtBQXZCLENBQThCLEdBQTlCLEVBQW9DeW5DLEdBQXBDLENBQXlDLFVBQVVQLE1BQVYsRUFBbUI7QUFDOUk3USxjQUFRd1UsU0FBVTNELE1BQVYsRUFBb0IzcUMsSUFBcEIsRUFBMEI4NUIsS0FBMUIsRUFBaUMxbkIsT0FBakMsQ0FBUjtBQUNBLGFBQU8wbkIsS0FBUDtBQUNILEtBSHFGLEVBR25GNFYsR0FIbUYsRUFBdEY7O0FBS0E7QUFDQSxRQUFLMXZDLFFBQVEsUUFBYixFQUF3QjtBQUNwQnN1QyxlQUFTcjFCLEdBQVQsQ0FBYyxXQUFkLEVBQTJCdzJCLGFBQWFqUixNQUF4QyxFQUFnRHBzQixPQUFoRDtBQUNILEtBRkQsTUFHSyxJQUFLcFMsUUFBUSxXQUFiLEVBQTJCO0FBQzVCc3VDLGVBQVNyMUIsR0FBVCxDQUFjLE1BQWQsRUFBc0J3MkIsYUFBYTVTLFNBQW5DLEVBQThDenFCLE9BQTlDO0FBQ0gsS0FGSSxNQUdBLElBQUtwUyxLQUFLc00sS0FBTCxDQUFZLGlDQUFaLENBQUwsRUFBdUQ7QUFDeEQsVUFBS21qQyxhQUFhalIsTUFBYixJQUF1QjhQLFNBQVN4RSxRQUFULENBQW1CMkYsYUFBYWpSLE1BQWhDLENBQTVCLEVBQXVFO0FBQ25FOFAsaUJBQVNyMUIsR0FBVCxDQUFjLFFBQWQsRUFBd0J3MkIsYUFBYWpSLE1BQXJDLEVBQTZDcHNCLE9BQTdDO0FBQ0g7QUFDRCxVQUFLcTlCLGFBQWE1UyxTQUFiLElBQTBCeVIsU0FBU3hFLFFBQVQsQ0FBbUIyRixhQUFhNVMsU0FBaEMsQ0FBL0IsRUFBNkU7QUFDekV5UixpQkFBU3IxQixHQUFULENBQWMsV0FBZCxFQUEyQncyQixhQUFhNVMsU0FBeEMsRUFBbUR6cUIsT0FBbkQ7QUFDSDtBQUNKOztBQUVELFdBQU9rOEIsUUFBUDtBQUNILEdBdENELENBbkl3QixDQXlLdEI7OztBQUdGOzs7QUFHQUYsYUFBV3R0QyxTQUFYLENBQXFCdVosR0FBckIsR0FBMkIsVUFBVXJhLElBQVYsRUFBaUI7QUFDeEMsV0FBTyxLQUFLb3hCLElBQUwsQ0FBV3B4QixJQUFYLENBQVA7QUFDSCxHQUZELENBL0t3QixDQWlMdEI7OztBQUdGOzs7QUFHQW91QyxhQUFXdHRDLFNBQVgsQ0FBcUJ1UyxNQUFyQixHQUE4QixVQUFVclQsSUFBVixFQUFnQjg1QixLQUFoQixFQUF1QjFuQixPQUF2QixFQUFpQzs7QUFFM0QsUUFBSXU5QixlQUFKO0FBQUEsUUFDSXJCLFdBQVcsSUFEZjs7QUFHQTtBQUNBeFUsWUFBUUEsVUFBVTM2QixTQUFWLEdBQXNCYSxJQUF0QixHQUE2Qjg1QixLQUFyQzs7QUFHQTtBQUNBLFFBQUtBLFNBQVMsQ0FBQ3JLLFFBQVYsSUFBc0JxSyxTQUFTckssUUFBcEMsRUFBK0M7QUFDM0NrZ0Isd0JBQWtCN1YsS0FBbEI7QUFDSDs7QUFFRDtBQUpBLFNBS0ssSUFBSzE5QixFQUFFdUUsYUFBRixDQUFpQm01QixLQUFqQixLQUE0QnhpQixFQUFFbTJCLFNBQUYsQ0FBYTNULE1BQU1vUyxJQUFuQixDQUFqQyxFQUE2RDtBQUM5RHBTLGdCQUFRQSxNQUFNeFYsR0FBZDtBQUNIOztBQUVEO0FBQ0E7QUFMSyxXQU1BLElBQUtsb0IsRUFBRXFFLE9BQUYsQ0FBV3E1QixLQUFYLENBQUwsRUFBMEI7QUFDM0JBLGtCQUFRLElBQUl6MkIsSUFBSixDQUFVeTJCLE1BQU8sQ0FBUCxDQUFWLEVBQXNCQSxNQUFPLENBQVAsQ0FBdEIsRUFBa0NBLE1BQU8sQ0FBUCxDQUFsQyxDQUFSO0FBQ0FBLGtCQUFReGlCLEVBQUVrMkIsTUFBRixDQUFVMVQsS0FBVixJQUFvQkEsS0FBcEIsR0FBNEJ3VSxTQUFTajdCLE1BQVQsR0FBa0JpUixHQUF0RDtBQUNIOztBQUVEO0FBTEssYUFNQSxJQUFLaE4sRUFBRW0yQixTQUFGLENBQWEzVCxLQUFiLEtBQXdCeGlCLEVBQUVrMkIsTUFBRixDQUFVMVQsS0FBVixDQUE3QixFQUFpRDtBQUNsREEsb0JBQVF3VSxTQUFTc0IsU0FBVCxDQUFvQixJQUFJdnNDLElBQUosQ0FBVXkyQixLQUFWLENBQXBCLEVBQXVDMW5CLE9BQXZDLENBQVI7QUFDSDs7QUFFRDtBQUpLLGVBS0EseUJBQTBCO0FBQzNCMG5CLHNCQUFRd1UsU0FBU2x5QixHQUFULENBQWNwYyxJQUFkLEVBQW9CODVCLEtBQXBCLEVBQTJCMW5CLE9BQTNCLENBQVI7QUFDSDs7QUFFRDtBQUNBLFdBQU87QUFDSDg4QixZQUFNUyxtQkFBbUI3VixNQUFNK1YsV0FBTixFQUR0QjtBQUVIVixhQUFPUSxtQkFBbUI3VixNQUFNZ1csUUFBTixFQUZ2QjtBQUdIVixZQUFNTyxtQkFBbUI3VixNQUFNNFQsT0FBTixFQUh0QjtBQUlIcUMsV0FBS0osbUJBQW1CN1YsTUFBTWtXLE1BQU4sRUFKckI7QUFLSDFyQixXQUFLcXJCLG1CQUFtQjdWLEtBTHJCO0FBTUhvUyxZQUFNeUQsbUJBQW1CN1YsTUFBTXgyQixPQUFOO0FBTnRCLEtBQVA7QUFRSCxHQTdDRCxDQXZMd0IsQ0FvT3RCOzs7QUFHRjs7OztBQUlBOHFDLGFBQVd0dEMsU0FBWCxDQUFxQm12QyxXQUFyQixHQUFtQyxVQUFVQyxJQUFWLEVBQWdCQyxFQUFoQixFQUFxQjs7QUFFcEQsUUFBSTdCLFdBQVcsSUFBZjtBQUFBLFFBQ0k4QixhQUFhLFNBQWJBLFVBQWEsQ0FBVWhCLElBQVYsRUFBaUI7QUFDMUIsVUFBS0EsU0FBUyxJQUFULElBQWlCaHpDLEVBQUVxRSxPQUFGLENBQVcydUMsSUFBWCxDQUFqQixJQUFzQzkzQixFQUFFazJCLE1BQUYsQ0FBVTRCLElBQVYsQ0FBM0MsRUFBOEQ7QUFDMUQsZUFBT2QsU0FBU2o3QixNQUFULENBQWlCKzdCLElBQWpCLENBQVA7QUFDSDtBQUNELGFBQU9BLElBQVA7QUFDSCxLQU5MOztBQVFBO0FBQ0EsUUFBSyxDQUFDOTNCLEVBQUVtMkIsU0FBRixDQUFheUMsSUFBYixDQUFOLEVBQTRCO0FBQ3hCQSxhQUFPRSxXQUFZRixJQUFaLENBQVA7QUFDSDtBQUNELFFBQUssQ0FBQzU0QixFQUFFbTJCLFNBQUYsQ0FBYTBDLEVBQWIsQ0FBTixFQUEwQjtBQUN0QkEsV0FBS0MsV0FBWUQsRUFBWixDQUFMO0FBQ0g7O0FBRUQ7QUFDQSxRQUFLNzRCLEVBQUVtMkIsU0FBRixDQUFheUMsSUFBYixLQUF1Qjl6QyxFQUFFdUUsYUFBRixDQUFpQnd2QyxFQUFqQixDQUE1QixFQUFvRDtBQUNoREQsYUFBTyxDQUFFQyxHQUFHakIsSUFBTCxFQUFXaUIsR0FBR2hCLEtBQWQsRUFBcUJnQixHQUFHZixJQUFILEdBQVVjLElBQS9CLENBQVA7QUFDSCxLQUZELE1BR0ssSUFBSzU0QixFQUFFbTJCLFNBQUYsQ0FBYTBDLEVBQWIsS0FBcUIvekMsRUFBRXVFLGFBQUYsQ0FBaUJ1dkMsSUFBakIsQ0FBMUIsRUFBb0Q7QUFDckRDLFdBQUssQ0FBRUQsS0FBS2hCLElBQVAsRUFBYWdCLEtBQUtmLEtBQWxCLEVBQXlCZSxLQUFLZCxJQUFMLEdBQVllLEVBQXJDLENBQUw7QUFDSDs7QUFFRCxXQUFPO0FBQ0hELFlBQU1FLFdBQVlGLElBQVosQ0FESDtBQUVIQyxVQUFJQyxXQUFZRCxFQUFaO0FBRkQsS0FBUDtBQUlILEdBOUJELENBM093QixDQXlRdEI7OztBQUdGOzs7QUFHQS9CLGFBQVd0dEMsU0FBWCxDQUFxQnV2QyxXQUFyQixHQUFtQyxVQUFVclUsS0FBVixFQUFpQnNVLFFBQWpCLEVBQTRCO0FBQzNEdFUsWUFBUSxLQUFLaVUsV0FBTCxDQUFpQmpVLE1BQU1rVSxJQUF2QixFQUE2QmxVLE1BQU1tVSxFQUFuQyxDQUFSO0FBQ0EsV0FBT0csU0FBU3BFLElBQVQsSUFBaUJsUSxNQUFNa1UsSUFBTixDQUFXaEUsSUFBNUIsSUFBb0NvRSxTQUFTcEUsSUFBVCxJQUFpQmxRLE1BQU1tVSxFQUFOLENBQVNqRSxJQUFyRTtBQUNILEdBSEQ7O0FBTUE7OztBQUdBa0MsYUFBV3R0QyxTQUFYLENBQXFCeXZDLGFBQXJCLEdBQXFDLFVBQVVuaEIsR0FBVixFQUFlb2hCLEdBQWYsRUFBcUI7O0FBRXRELFFBQUlsQyxXQUFXLElBQWY7O0FBRUE7QUFDQWxmLFVBQU1rZixTQUFTMkIsV0FBVCxDQUFzQjdnQixJQUFJOGdCLElBQTFCLEVBQWdDOWdCLElBQUkrZ0IsRUFBcEMsQ0FBTjtBQUNBSyxVQUFNbEMsU0FBUzJCLFdBQVQsQ0FBc0JPLElBQUlOLElBQTFCLEVBQWdDTSxJQUFJTCxFQUFwQyxDQUFOOztBQUVBLFdBQU83QixTQUFTK0IsV0FBVCxDQUFzQmpoQixHQUF0QixFQUEyQm9oQixJQUFJTixJQUEvQixLQUF5QzVCLFNBQVMrQixXQUFULENBQXNCamhCLEdBQXRCLEVBQTJCb2hCLElBQUlMLEVBQS9CLENBQXpDLElBQ0g3QixTQUFTK0IsV0FBVCxDQUFzQkcsR0FBdEIsRUFBMkJwaEIsSUFBSThnQixJQUEvQixDQURHLElBQ3NDNUIsU0FBUytCLFdBQVQsQ0FBc0JHLEdBQXRCLEVBQTJCcGhCLElBQUkrZ0IsRUFBL0IsQ0FEN0M7QUFFSCxHQVZEOztBQWFBOzs7QUFHQS9CLGFBQVd0dEMsU0FBWCxDQUFxQnNiLEdBQXJCLEdBQTJCLFVBQVVwYyxJQUFWLEVBQWdCODVCLEtBQWhCLEVBQXVCMW5CLE9BQXZCLEVBQWlDO0FBQ3hEMG5CLFlBQVEsSUFBSXoyQixJQUFKLEVBQVI7QUFDQSxRQUFLK08sV0FBV0EsUUFBUXErQixHQUF4QixFQUE4QjtBQUMxQjNXLFlBQU00VyxPQUFOLENBQWU1VyxNQUFNNFQsT0FBTixLQUFrQnQ3QixRQUFRcStCLEdBQXpDO0FBQ0g7QUFDRCxXQUFPLEtBQUtiLFNBQUwsQ0FBZ0I5VixLQUFoQixFQUF1QjFuQixPQUF2QixDQUFQO0FBQ0gsR0FORDs7QUFTQTs7O0FBR0FnOEIsYUFBV3R0QyxTQUFYLENBQXFCNnZDLFFBQXJCLEdBQWdDLFVBQVUzd0MsSUFBVixFQUFnQjg1QixLQUFoQixFQUF1QjFuQixPQUF2QixFQUFpQzs7QUFFN0QsUUFBSXcrQixnQkFBSjtBQUFBLFFBQ0lDLFVBREo7QUFBQSxRQUVJQyxXQUZKO0FBQUEsUUFHSTdCLFVBSEo7QUFBQSxRQUlJOEIsZ0JBQWdCMzBDLEVBQUVxRSxPQUFGLENBQVdxNUIsS0FBWCxDQUpwQjtBQUFBLFFBS0lrWCxpQkFBaUI1MEMsRUFBRXVFLGFBQUYsQ0FBaUJtNUIsS0FBakIsQ0FMckI7QUFBQSxRQU1JbVgsZ0JBQWdCLEtBQUs3ZixJQUFMLENBQVV3ZCxJQU45QixDQUY2RCxDQVEzQjs7O0FBSWxDLFFBQUttQyxpQkFBaUJDLGNBQXRCLEVBQXVDOztBQUVuQyxVQUFLQSxjQUFMLEVBQXNCO0FBQ2xCSCxxQkFBYS9XLE1BQU1vVixJQUFuQjtBQUNBNEIsc0JBQWNoWCxNQUFNcVYsS0FBcEI7QUFDQUYscUJBQWFuVixNQUFNc1YsSUFBbkI7QUFDSCxPQUpELE1BS0s7QUFDRHlCLHFCQUFhLENBQUMvVyxNQUFNLENBQU4sQ0FBZDtBQUNBZ1gsc0JBQWMsQ0FBQ2hYLE1BQU0sQ0FBTixDQUFmO0FBQ0FtVixxQkFBYSxDQUFDblYsTUFBTSxDQUFOLENBQWQ7QUFDSDs7QUFFRDtBQUNBO0FBQ0EsVUFBSzFuQixXQUFXQSxRQUFRNjVCLEdBQW5CLElBQTBCZ0YsYUFBMUIsSUFBMkNBLGNBQWM5QixLQUFkLEtBQXdCMkIsV0FBeEUsRUFBc0Y7QUFDbEZELHFCQUFhSSxjQUFjL0IsSUFBM0I7QUFDQTRCLHNCQUFjRyxjQUFjOUIsS0FBNUI7QUFDSDs7QUFFRDtBQUNBeUIseUJBQW1CLElBQUl2dEMsSUFBSixDQUFVd3RDLFVBQVYsRUFBc0JDLGVBQWdCMStCLFdBQVdBLFFBQVE2NUIsR0FBbkIsR0FBeUI3NUIsUUFBUTY1QixHQUFqQyxHQUF1QyxDQUF2RCxDQUF0QixFQUFrRixDQUFsRixDQUFuQjtBQUNBNEUsbUJBQWFELGlCQUFpQmYsV0FBakIsRUFBYjtBQUNBaUIsb0JBQWNGLGlCQUFpQmQsUUFBakIsRUFBZDs7QUFFQTtBQUNBO0FBQ0EsY0FBUSxhQUFjLElBQUl6c0MsSUFBSixDQUFVd3RDLFVBQVYsRUFBc0JDLFdBQXRCLEVBQW1DN0IsVUFBbkMsRUFBZ0RhLFFBQWhELE9BQStEZ0IsV0FBckYsRUFBbUc7QUFDL0Y3QixzQkFBYyxDQUFkO0FBQ0E7Ozs7QUFJSDs7QUFFRG5WLGNBQVEsQ0FBRStXLFVBQUYsRUFBY0MsV0FBZCxFQUEyQjdCLFVBQTNCLENBQVI7QUFDSDs7QUFFRCxXQUFPblYsS0FBUDtBQUNILEdBbkRELENBcFR3QixDQXVXdEI7OztBQUdGOzs7QUFHQXNVLGFBQVd0dEMsU0FBWCxDQUFxQjh1QyxTQUFyQixHQUFpQyxVQUFVOVYsS0FBVixDQUFlLGFBQWYsRUFBK0I7QUFDNURBLFVBQU1vWCxRQUFOLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCO0FBQ0EsV0FBT3BYLEtBQVA7QUFDSCxHQUhEOztBQU1BOzs7QUFHQXNVLGFBQVd0dEMsU0FBWCxDQUFxQnF3QyxPQUFyQixHQUErQixVQUFVbnhDLElBQVYsRUFBZ0I4NUIsS0FBaEIsQ0FBcUIsYUFBckIsRUFBcUM7O0FBRWhFLFFBQUl3VSxXQUFXLElBQWY7O0FBRUE7QUFDQSxRQUFLLENBQUN4VSxLQUFOLEVBQWM7QUFDVkEsY0FBUTk1QixRQUFRLEtBQVIsR0FBZ0IsQ0FBQ3l2QixRQUFqQixHQUE0QkEsUUFBcEM7QUFDSDs7QUFFRDtBQUpBLFNBS0ssSUFBSyxPQUFPcUssS0FBUCxJQUFnQixRQUFyQixFQUFnQztBQUNqQ0EsZ0JBQVF3VSxTQUFTOEMsS0FBVCxDQUFnQnB4QyxJQUFoQixFQUFzQjg1QixLQUF0QixDQUFSO0FBQ0g7O0FBRUQ7QUFKSyxXQUtBLElBQUt4aUIsRUFBRW0yQixTQUFGLENBQWEzVCxLQUFiLENBQUwsRUFBNEI7QUFDN0JBLGtCQUFRd1UsU0FBU2x5QixHQUFULENBQWNwYyxJQUFkLEVBQW9CODVCLEtBQXBCLEVBQTJCLEVBQUUyVyxLQUFLM1csS0FBUCxFQUEzQixDQUFSO0FBQ0g7O0FBRUQsV0FBT0EsS0FBUDtBQUNILEdBcEJELENBdFh3QixDQTBZdEI7OztBQUdGOzs7QUFHQXNVLGFBQVd0dEMsU0FBWCxDQUFxQnV3QyxPQUFyQixHQUErQixVQUFVcnhDLElBQVYsRUFBZ0JzeEMsVUFBaEIsQ0FBMEIsYUFBMUIsRUFBMEM7QUFDckUsV0FBTyxLQUFLaitCLE1BQUwsQ0FBWSxDQUFFaStCLFdBQVdwQyxJQUFiLEVBQW1Cb0MsV0FBV25DLEtBQTlCLEVBQXFDLENBQXJDLENBQVosQ0FBUDtBQUNILEdBRkQ7O0FBS0E7OztBQUdBZixhQUFXdHRDLFNBQVgsQ0FBcUJ5d0MsUUFBckIsR0FBZ0MsVUFBVXZ4QyxJQUFWLEVBQWdCc3hDLFVBQWhCLEVBQTRCbC9CLE9BQTVCLEVBQXNDOztBQUVsRSxRQUFJazhCLFdBQVcsSUFBZjs7O0FBRUk7QUFDQWtELHlCQUFxQkYsVUFIekI7OztBQUtJO0FBQ0ExeEIsZUFBV3hOLFdBQVdBLFFBQVF3TixRQUFuQixHQUE4QnhOLFFBQVF3TixRQUF0QyxHQUFpRCxDQU5oRTs7O0FBUUk7QUFDQTZ4QixvQkFBZ0JuRCxTQUFTbGQsSUFBVCxDQUFjaGQsTUFBZCxLQUF5QixDQUFDLENBVDlDOzs7QUFXSTtBQUNBczlCLDBCQVpKO0FBQUEsUUFZNEJDLHFCQVo1Qjs7O0FBY0k7QUFDQUMscUJBQWlCdEQsU0FBU2xkLElBQVQsQ0FBY3ZzQixHQWZuQztBQUFBLFFBZ0JJZ3RDLGlCQUFpQnZELFNBQVNsZCxJQUFULENBQWN0c0IsR0FoQm5DOzs7QUFrQkk7QUFDQWd0QyxjQW5CSjtBQUFBLFFBbUJnQkMsVUFuQmhCOzs7QUFxQkk7QUFDQUMseUJBQXFCUCxpQkFBaUJuRCxTQUFTbGQsSUFBVCxDQUFjeWQsT0FBZCxDQUFzQmgyQixNQUF0QixDQUE4QixVQUFVaWhCLEtBQVYsRUFBa0I7O0FBRWxGO0FBQ0EsVUFBSzE5QixFQUFFcUUsT0FBRixDQUFXcTVCLEtBQVgsQ0FBTCxFQUEwQjtBQUN0QixZQUFJbVksV0FBVzNELFNBQVNqN0IsTUFBVCxDQUFpQnltQixLQUFqQixFQUF5Qm9TLElBQXhDO0FBQ0EsWUFBSytGLFdBQVdYLFdBQVdwRixJQUEzQixFQUFrQ3dGLHlCQUF5QixJQUF6QixDQUFsQyxLQUNLLElBQUtPLFdBQVdYLFdBQVdwRixJQUEzQixFQUFrQ3lGLHdCQUF3QixJQUF4QjtBQUMxQzs7QUFFRDtBQUNBLGFBQU9yNkIsRUFBRW0yQixTQUFGLENBQWEzVCxLQUFiLENBQVA7QUFDSCxLQVhxQyxFQVduQ2g2QixNQWpDUCxDQUZrRSxDQW1DckQ7OztBQU1iO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSyxDQUFDc1MsT0FBRCxJQUFZLENBQUNBLFFBQVE2NUIsR0FBMUIsRUFBZ0M7QUFDNUIsV0FBVSxDQUFDd0YsYUFBRCxJQUFrQm5ELFNBQVN4RSxRQUFULENBQW1Cd0gsVUFBbkIsQ0FBcEI7QUFDUixXQUFVRyxpQkFBaUJuRCxTQUFTeEUsUUFBVCxDQUFtQndILFVBQW5CLENBQWpCLEtBQXNEVSxzQkFBc0JOLHNCQUF0QixJQUFnREMscUJBQXRHLENBREY7QUFFUixXQUFVLENBQUNGLGFBQUQsS0FBbUJILFdBQVdwRixJQUFYLElBQW1CMEYsZUFBZTFGLElBQWxDLElBQTBDb0YsV0FBV3BGLElBQVgsSUFBbUIyRixlQUFlM0YsSUFBL0YsQ0FIa0IsRUFJOUI7O0FBR0U7QUFDQTtBQUNBLFVBQUt1RixpQkFBaUIsQ0FBQ08sa0JBQWxCLEtBQTRDLENBQUNMLHFCQUFELElBQTBCL3hCLFdBQVcsQ0FBdkMsSUFBZ0QsQ0FBQzh4QixzQkFBRCxJQUEyQjl4QixXQUFXLENBQWhJLENBQUwsRUFBNkk7QUFDeklBLG9CQUFZLENBQUMsQ0FBYjtBQUNIOztBQUdEO0FBQ0EsY0FBUSxhQUFjMHVCLFNBQVN4RSxRQUFULENBQW1Cd0gsVUFBbkIsQ0FBdEIsRUFBd0Q7O0FBRXBEOzs7OztBQU1BO0FBQ0EsWUFBSzF6QyxLQUFLa0IsR0FBTCxDQUFVOGdCLFFBQVYsSUFBdUIsQ0FBdkIsS0FBOEIweEIsV0FBV25DLEtBQVgsR0FBbUJxQyxtQkFBbUJyQyxLQUF0QyxJQUErQ21DLFdBQVduQyxLQUFYLEdBQW1CcUMsbUJBQW1CckMsS0FBbkgsQ0FBTCxFQUFrSTtBQUM5SG1DLHVCQUFhRSxrQkFBYjtBQUNBNXhCLHFCQUFXQSxXQUFXLENBQVgsR0FBZSxDQUFmLEdBQW1CLENBQUMsQ0FBL0I7QUFDSDs7QUFHRDtBQUNBLFlBQUsweEIsV0FBV3BGLElBQVgsSUFBbUIwRixlQUFlMUYsSUFBdkMsRUFBOEM7QUFDMUM0Rix1QkFBYSxJQUFiO0FBQ0FseUIscUJBQVcsQ0FBWDtBQUNBMHhCLHVCQUFhaEQsU0FBU2o3QixNQUFULENBQWdCLENBQ3pCdStCLGVBQWUxQyxJQURVLEVBRXpCMEMsZUFBZXpDLEtBRlUsRUFHekJ5QyxlQUFleEMsSUFBZixJQUF1QmtDLFdBQVdwRixJQUFYLEtBQW9CMEYsZUFBZTFGLElBQW5DLEdBQTBDLENBQTFDLEdBQThDLENBQUMsQ0FBdEUsQ0FIeUIsQ0FBaEIsQ0FBYjtBQUtILFNBUkQsTUFTSyxJQUFLb0YsV0FBV3BGLElBQVgsSUFBbUIyRixlQUFlM0YsSUFBdkMsRUFBOEM7QUFDL0M2Rix1QkFBYSxJQUFiO0FBQ0FueUIscUJBQVcsQ0FBQyxDQUFaO0FBQ0EweEIsdUJBQWFoRCxTQUFTajdCLE1BQVQsQ0FBZ0IsQ0FDekJ3K0IsZUFBZTNDLElBRFUsRUFFekIyQyxlQUFlMUMsS0FGVSxFQUd6QjBDLGVBQWV6QyxJQUFmLElBQXVCa0MsV0FBV3BGLElBQVgsS0FBb0IyRixlQUFlM0YsSUFBbkMsR0FBMEMsQ0FBMUMsR0FBOEMsQ0FBckUsQ0FIeUIsQ0FBaEIsQ0FBYjtBQUtIOztBQUdEO0FBQ0EsWUFBSzRGLGNBQWNDLFVBQW5CLEVBQWdDO0FBQzVCO0FBQ0g7O0FBR0Q7QUFDQVQscUJBQWFoRCxTQUFTajdCLE1BQVQsQ0FBZ0IsQ0FBRWkrQixXQUFXcEMsSUFBYixFQUFtQm9DLFdBQVduQyxLQUE5QixFQUFxQ21DLFdBQVdsQyxJQUFYLEdBQWtCeHZCLFFBQXZELENBQWhCLENBQWI7QUFDSDtBQUVKLEtBaEhpRSxDQWdIaEU7OztBQUdGO0FBQ0EsV0FBTzB4QixVQUFQO0FBQ0gsR0FySEQsQ0F4WndCLENBNmdCdEI7OztBQUdGOzs7QUFHQWxELGFBQVd0dEMsU0FBWCxDQUFxQmdwQyxRQUFyQixHQUFnQyxVQUFVb0ksWUFBVixFQUF5Qjs7QUFFckQsUUFDSTVELFdBQVcsSUFEZjs7O0FBR0k7QUFDQTZELHNCQUFrQjdELFNBQVNsZCxJQUFULENBQWN5ZCxPQUFkLENBQXNCaDJCLE1BQXRCLENBQThCLFVBQVV1NUIsYUFBVixFQUEwQjs7QUFFdEU7QUFDQSxVQUFLOTZCLEVBQUVtMkIsU0FBRixDQUFhMkUsYUFBYixDQUFMLEVBQW9DO0FBQ2hDLGVBQU9GLGFBQWFuQyxHQUFiLEtBQXFCLENBQUV6QixTQUFTRCxRQUFULENBQWtCZ0UsUUFBbEIsR0FBNkJELGFBQTdCLEdBQTZDQSxnQkFBZ0IsQ0FBL0QsSUFBcUUsQ0FBakc7QUFDSDs7QUFFRDtBQUNBLFVBQUtoMkMsRUFBRXFFLE9BQUYsQ0FBVzJ4QyxhQUFYLEtBQThCOTZCLEVBQUVrMkIsTUFBRixDQUFVNEUsYUFBVixDQUFuQyxFQUErRDtBQUMzRCxlQUFPRixhQUFhaEcsSUFBYixLQUFzQm9DLFNBQVNqN0IsTUFBVCxDQUFpQisrQixhQUFqQixFQUFpQ2xHLElBQTlEO0FBQ0g7O0FBRUQ7QUFDQSxVQUFLOXZDLEVBQUV1RSxhQUFGLENBQWlCeXhDLGFBQWpCLENBQUwsRUFBd0M7QUFDcEMsZUFBTzlELFNBQVMrQixXQUFULENBQXNCK0IsYUFBdEIsRUFBcUNGLFlBQXJDLENBQVA7QUFDSDtBQUNKLEtBaEJpQixDQUp0Qjs7QUFzQkE7QUFDQUMsc0JBQWtCQSxnQkFBZ0JyeUMsTUFBaEIsSUFBMEIsQ0FBQ3F5QyxnQkFBZ0J0NUIsTUFBaEIsQ0FBdUIsVUFBVXU1QixhQUFWLEVBQTBCO0FBQzFGLGFBQU9oMkMsRUFBRXFFLE9BQUYsQ0FBVzJ4QyxhQUFYLEtBQThCQSxjQUFjLENBQWQsS0FBb0IsVUFBbEQsSUFDSGgyQyxFQUFFdUUsYUFBRixDQUFpQnl4QyxhQUFqQixLQUFvQ0EsY0FBY0UsUUFEdEQ7QUFFSCxLQUg0QyxFQUcxQ3h5QyxNQUhIOztBQUtBO0FBQ0E7QUFDQSxXQUFPd3VDLFNBQVNsZCxJQUFULENBQWNoZCxNQUFkLEtBQXlCLENBQUMsQ0FBMUIsR0FBOEIsQ0FBQys5QixlQUEvQixHQUFpREEsbUJBQ3BERCxhQUFhaEcsSUFBYixHQUFvQm9DLFNBQVNsZCxJQUFULENBQWN2c0IsR0FBZCxDQUFrQnFuQyxJQURjLElBRXBEZ0csYUFBYWhHLElBQWIsR0FBb0JvQyxTQUFTbGQsSUFBVCxDQUFjdHNCLEdBQWQsQ0FBa0JvbkMsSUFGMUM7QUFJSCxHQXBDRCxDQW5oQndCLENBdWpCdEI7OztBQUdGOzs7QUFHQWtDLGFBQVd0dEMsU0FBWCxDQUFxQnN3QyxLQUFyQixHQUE2QixVQUFVcHhDLElBQVYsRUFBZ0I4NUIsS0FBaEIsRUFBdUIxbkIsT0FBdkIsRUFBaUM7O0FBRTFELFFBQUlrOEIsV0FBVyxJQUFmO0FBQUEsUUFDSWlFLGdCQUFnQixFQURwQjs7QUFHQTtBQUNBLFFBQUssQ0FBQ3pZLEtBQUQsSUFBVSxPQUFPQSxLQUFQLElBQWdCLFFBQS9CLEVBQTBDO0FBQ3RDLGFBQU9BLEtBQVA7QUFDSDs7QUFFRDtBQUNBLFFBQUssRUFBRzFuQixXQUFXQSxRQUFRbzRCLE1BQXRCLENBQUwsRUFBc0M7QUFDbENwNEIsZ0JBQVVBLFdBQVcsRUFBckI7QUFDQUEsY0FBUW80QixNQUFSLEdBQWlCOEQsU0FBU0QsUUFBVCxDQUFrQjdELE1BQW5DO0FBQ0g7O0FBRUQ7QUFDQThELGFBQVM1RCxPQUFULENBQWlCOEgsT0FBakIsQ0FBMEJwZ0MsUUFBUW80QixNQUFsQyxFQUEyQ1UsR0FBM0MsQ0FBZ0QsVUFBVTVNLEtBQVYsRUFBa0I7O0FBRTlEO0FBQ0k7QUFDQW1VLHdCQUFrQm5FLFNBQVM1RCxPQUFULENBQWtCcE0sS0FBbEIsQ0FGdEI7OztBQUlJO0FBQ0E7QUFDQW9VLHFCQUFlRCxrQkFBa0JuN0IsRUFBRXdNLE9BQUYsQ0FBVzJ1QixlQUFYLEVBQTRCbkUsUUFBNUIsRUFBc0MsQ0FBRXhVLEtBQUYsRUFBU3lZLGFBQVQsQ0FBdEMsQ0FBbEIsR0FBcUZqVSxNQUFNMXhCLE9BQU4sQ0FBZSxJQUFmLEVBQXFCLEVBQXJCLEVBQTBCOU0sTUFObEk7O0FBUUE7QUFDQTtBQUNBLFVBQUsyeUMsZUFBTCxFQUF1QjtBQUNuQkYsc0JBQWVqVSxLQUFmLElBQXlCeEUsTUFBTTdzQixNQUFOLENBQWMsQ0FBZCxFQUFpQnlsQyxZQUFqQixDQUF6QjtBQUNIOztBQUVEO0FBQ0E1WSxjQUFRQSxNQUFNN3NCLE1BQU4sQ0FBY3lsQyxZQUFkLENBQVI7QUFDSCxLQWxCRDs7QUFvQkE7QUFDQSxXQUFPLENBQ0hILGNBQWNJLElBQWQsSUFBc0JKLGNBQWNLLEVBRGpDLEVBRUgsRUFBR0wsY0FBY00sRUFBZCxJQUFvQk4sY0FBYzF1QyxDQUFyQyxJQUEyQyxDQUZ4QyxFQUdIMHVDLGNBQWNPLEVBQWQsSUFBb0JQLGNBQWN6MUMsQ0FIL0IsQ0FBUDtBQUtILEdBM0NELENBN2pCd0IsQ0F3bUJ0Qjs7O0FBR0Y7OztBQUdBc3hDLGFBQVd0dEMsU0FBWCxDQUFxQjRwQyxPQUFyQixHQUFnQyxZQUFXOztBQUV2QztBQUNBLGFBQVNxSSwyQkFBVCxDQUFzQ2pXLE1BQXRDLEVBQThDeUMsVUFBOUMsRUFBMEQrUixVQUExRCxFQUF1RTs7QUFFbkU7QUFDQSxVQUFJMEIsT0FBT2xXLE9BQU94d0IsS0FBUCxDQUFjLEtBQWQsRUFBdUIsQ0FBdkIsQ0FBWDs7QUFFQTtBQUNBLFVBQUssQ0FBQ2dsQyxXQUFXdUIsRUFBWixJQUFrQixDQUFDdkIsV0FBV3p0QyxDQUFuQyxFQUF1QztBQUNuQ3l0QyxtQkFBV3p0QyxDQUFYLEdBQWUwN0IsV0FBVy9yQixPQUFYLENBQW9Cdy9CLElBQXBCLElBQTZCLENBQTVDO0FBQ0g7O0FBRUQ7QUFDQSxhQUFPQSxLQUFLbHpDLE1BQVo7QUFDSDs7QUFFRDtBQUNBLGFBQVNtekMsa0JBQVQsQ0FBNkJuVyxNQUE3QixFQUFzQztBQUNsQyxhQUFPQSxPQUFPeHdCLEtBQVAsQ0FBYyxLQUFkLEVBQXVCLENBQXZCLEVBQTJCeE0sTUFBbEM7QUFDSDs7QUFFRCxXQUFPOztBQUVIaEQsU0FBRyxXQUFVZ2dDLE1BQVYsRUFBa0J3VSxVQUFsQixFQUErQjs7QUFFOUI7QUFDQTtBQUNBLGVBQU94VSxTQUFTeGxCLEVBQUVpMkIsTUFBRixDQUFVelEsTUFBVixDQUFULEdBQThCd1UsV0FBV2xDLElBQWhEO0FBQ0gsT0FQRTtBQVFIMEQsVUFBSSxZQUFVaFcsTUFBVixFQUFrQndVLFVBQWxCLEVBQStCOztBQUUvQjtBQUNBO0FBQ0EsZUFBT3hVLFNBQVMsQ0FBVCxHQUFheGxCLEVBQUU4MUIsSUFBRixDQUFRa0UsV0FBV2xDLElBQW5CLENBQXBCO0FBQ0gsT0FiRTtBQWNIOEQsV0FBSyxhQUFVcFcsTUFBVixFQUFrQndVLFVBQWxCLEVBQStCOztBQUVoQztBQUNBO0FBQ0EsZUFBT3hVLFNBQVNtVyxtQkFBb0JuVyxNQUFwQixDQUFULEdBQXdDLEtBQUt1UixRQUFMLENBQWM4RSxhQUFkLENBQTZCN0IsV0FBV3ZCLEdBQXhDLENBQS9DO0FBQ0gsT0FuQkU7QUFvQkhxRCxZQUFNLGNBQVV0VyxNQUFWLEVBQWtCd1UsVUFBbEIsRUFBK0I7O0FBRWpDO0FBQ0E7QUFDQSxlQUFPeFUsU0FBU21XLG1CQUFvQm5XLE1BQXBCLENBQVQsR0FBd0MsS0FBS3VSLFFBQUwsQ0FBY2dGLFlBQWQsQ0FBNEIvQixXQUFXdkIsR0FBdkMsQ0FBL0M7QUFDSCxPQXpCRTtBQTBCSGxzQyxTQUFHLFdBQVVpNUIsTUFBVixFQUFrQndVLFVBQWxCLEVBQStCOztBQUU5QjtBQUNBO0FBQ0EsZUFBT3hVLFNBQVN4bEIsRUFBRWkyQixNQUFGLENBQVV6USxNQUFWLENBQVQsR0FBOEJ3VSxXQUFXbkMsS0FBWCxHQUFtQixDQUF4RDtBQUNILE9BL0JFO0FBZ0NIMEQsVUFBSSxZQUFVL1YsTUFBVixFQUFrQndVLFVBQWxCLEVBQStCOztBQUUvQjtBQUNBO0FBQ0EsZUFBT3hVLFNBQVMsQ0FBVCxHQUFheGxCLEVBQUU4MUIsSUFBRixDQUFRa0UsV0FBV25DLEtBQVgsR0FBbUIsQ0FBM0IsQ0FBcEI7QUFDSCxPQXJDRTtBQXNDSG1FLFdBQUssYUFBVXhXLE1BQVYsRUFBa0J3VSxVQUFsQixFQUErQjs7QUFFaEMsWUFBSS9SLGFBQWEsS0FBSzhPLFFBQUwsQ0FBY2tGLFdBQS9COztBQUVBO0FBQ0E7QUFDQSxlQUFPelcsU0FBU2lXLDRCQUE2QmpXLE1BQTdCLEVBQXFDeUMsVUFBckMsRUFBaUQrUixVQUFqRCxDQUFULEdBQXlFL1IsV0FBWStSLFdBQVduQyxLQUF2QixDQUFoRjtBQUNILE9BN0NFO0FBOENIcUUsWUFBTSxjQUFVMVcsTUFBVixFQUFrQndVLFVBQWxCLEVBQStCOztBQUVqQyxZQUFJL1IsYUFBYSxLQUFLOE8sUUFBTCxDQUFjb0YsVUFBL0I7O0FBRUE7QUFDQTtBQUNBLGVBQU8zVyxTQUFTaVcsNEJBQTZCalcsTUFBN0IsRUFBcUN5QyxVQUFyQyxFQUFpRCtSLFVBQWpELENBQVQsR0FBeUUvUixXQUFZK1IsV0FBV25DLEtBQXZCLENBQWhGO0FBQ0gsT0FyREU7QUFzREh5RCxVQUFJLFlBQVU5VixNQUFWLEVBQWtCd1UsVUFBbEIsRUFBK0I7O0FBRS9CO0FBQ0E7QUFDQSxlQUFPeFUsU0FBUyxDQUFULEdBQWEsQ0FBRSxLQUFLd1UsV0FBV3BDLElBQWxCLEVBQXlCbnJDLEtBQXpCLENBQWdDLENBQWhDLENBQXBCO0FBQ0gsT0EzREU7QUE0REg0dUMsWUFBTSxjQUFVN1YsTUFBVixFQUFrQndVLFVBQWxCLEVBQStCOztBQUVqQztBQUNBO0FBQ0EsZUFBT3hVLFNBQVMsQ0FBVCxHQUFhd1UsV0FBV3BDLElBQS9CO0FBQ0gsT0FqRUU7O0FBbUVIO0FBQ0FzRCxlQUFTLGlCQUFVOUQsWUFBVixFQUF5QjtBQUFFLGVBQU9BLGFBQWFqckMsS0FBYixDQUFvQiw2QkFBcEIsQ0FBUDtBQUE0RCxPQXBFN0Y7O0FBc0VIO0FBQ0FELGdCQUFVLGtCQUFXa3JDLFlBQVgsRUFBeUJnRixVQUF6QixFQUFzQztBQUM1QyxZQUFJcEYsV0FBVyxJQUFmO0FBQ0EsZUFBT0EsU0FBUzVELE9BQVQsQ0FBaUI4SCxPQUFqQixDQUEwQjlELFlBQTFCLEVBQXlDeEQsR0FBekMsQ0FBOEMsVUFBVTVNLEtBQVYsRUFBa0I7QUFDbkUsaUJBQU9obkIsRUFBRXdNLE9BQUYsQ0FBV3dxQixTQUFTNUQsT0FBVCxDQUFrQnBNLEtBQWxCLENBQVgsRUFBc0NnUSxRQUF0QyxFQUFnRCxDQUFFLENBQUYsRUFBS29GLFVBQUwsQ0FBaEQsS0FBdUVwVixNQUFNMXhCLE9BQU4sQ0FBZSxJQUFmLEVBQXFCLEVBQXJCLENBQTlFO0FBQ0gsU0FGTSxFQUVKTCxJQUZJLENBRUUsRUFGRixDQUFQO0FBR0g7QUE1RUUsS0FBUDtBQThFSCxHQXBHOEIsRUFBL0IsQ0E5bUJ3QixDQWt0Qm5COzs7QUFLTDs7O0FBR0E2aEMsYUFBV3R0QyxTQUFYLENBQXFCNnlDLFdBQXJCLEdBQW1DLFVBQVV2a0IsR0FBVixFQUFlb2hCLEdBQWYsRUFBcUI7O0FBRXBELFFBQUlsQyxXQUFXLElBQWY7O0FBRUE7QUFDQSxRQUNNaDNCLEVBQUVtMkIsU0FBRixDQUFhcmUsR0FBYixLQUFzQjlYLEVBQUVtMkIsU0FBRixDQUFhK0MsR0FBYixDQUF4QixJQUNFLE9BQU9waEIsR0FBUCxJQUFjLFNBQWQsSUFBMkIsT0FBT29oQixHQUFQLElBQWMsU0FGL0MsRUFHRztBQUNDLGFBQU9waEIsUUFBUW9oQixHQUFmO0FBQ0g7O0FBRUQ7QUFDQSxRQUNJLENBQUVsNUIsRUFBRWsyQixNQUFGLENBQVVwZSxHQUFWLEtBQW1CaHpCLEVBQUVxRSxPQUFGLENBQVcydUIsR0FBWCxDQUFyQixNQUNFOVgsRUFBRWsyQixNQUFGLENBQVVnRCxHQUFWLEtBQW1CcDBDLEVBQUVxRSxPQUFGLENBQVcrdkMsR0FBWCxDQURyQixDQURKLEVBR0U7QUFDRSxhQUFPbEMsU0FBU2o3QixNQUFULENBQWlCK2IsR0FBakIsRUFBdUI4YyxJQUF2QixLQUFnQ29DLFNBQVNqN0IsTUFBVCxDQUFpQm05QixHQUFqQixFQUF1QnRFLElBQTlEO0FBQ0g7O0FBRUQ7QUFDQSxRQUFLOXZDLEVBQUV1RSxhQUFGLENBQWlCeXVCLEdBQWpCLEtBQTBCaHpCLEVBQUV1RSxhQUFGLENBQWlCNnZDLEdBQWpCLENBQS9CLEVBQXdEO0FBQ3BELGFBQU9sQyxTQUFTcUYsV0FBVCxDQUFzQnZrQixJQUFJOGdCLElBQTFCLEVBQWdDTSxJQUFJTixJQUFwQyxLQUE4QzVCLFNBQVNxRixXQUFULENBQXNCdmtCLElBQUkrZ0IsRUFBMUIsRUFBOEJLLElBQUlMLEVBQWxDLENBQXJEO0FBQ0g7O0FBRUQsV0FBTyxLQUFQO0FBQ0gsR0ExQkQ7O0FBNkJBOzs7QUFHQS9CLGFBQVd0dEMsU0FBWCxDQUFxQjh5QyxhQUFyQixHQUFxQyxVQUFVeGtCLEdBQVYsRUFBZW9oQixHQUFmLEVBQXFCOztBQUV0RCxRQUFJbEMsV0FBVyxJQUFmO0FBQUEsUUFDSStELFdBQVcvRCxTQUFTRCxRQUFULENBQWtCZ0UsUUFBbEIsR0FBNkIsQ0FBN0IsR0FBaUMsQ0FEaEQ7O0FBR0E7QUFDQSxRQUFLLzZCLEVBQUVtMkIsU0FBRixDQUFhcmUsR0FBYixNQUF3QjlYLEVBQUVrMkIsTUFBRixDQUFVZ0QsR0FBVixLQUFtQnAwQyxFQUFFcUUsT0FBRixDQUFXK3ZDLEdBQVgsQ0FBM0MsQ0FBTCxFQUFxRTtBQUNqRXBoQixZQUFNQSxNQUFNLENBQU4sR0FBVWlqQixRQUFoQjtBQUNBLGFBQU9qakIsUUFBUWtmLFNBQVNqN0IsTUFBVCxDQUFpQm05QixHQUFqQixFQUF1QlQsR0FBdkIsR0FBNkIsQ0FBNUM7QUFDSDtBQUNELFFBQUt6NEIsRUFBRW0yQixTQUFGLENBQWErQyxHQUFiLE1BQXdCbDVCLEVBQUVrMkIsTUFBRixDQUFVcGUsR0FBVixLQUFtQmh6QixFQUFFcUUsT0FBRixDQUFXMnVCLEdBQVgsQ0FBM0MsQ0FBTCxFQUFxRTtBQUNqRW9oQixZQUFNQSxNQUFNLENBQU4sR0FBVTZCLFFBQWhCO0FBQ0EsYUFBTzdCLFFBQVFsQyxTQUFTajdCLE1BQVQsQ0FBaUIrYixHQUFqQixFQUF1QjJnQixHQUF2QixHQUE2QixDQUE1QztBQUNIOztBQUVEO0FBQ0EsUUFBSzN6QyxFQUFFdUUsYUFBRixDQUFpQnl1QixHQUFqQixLQUEwQmh6QixFQUFFdUUsYUFBRixDQUFpQjZ2QyxHQUFqQixDQUEvQixFQUF3RDtBQUNwRCxhQUFPbEMsU0FBU2lDLGFBQVQsQ0FBd0JuaEIsR0FBeEIsRUFBNkJvaEIsR0FBN0IsQ0FBUDtBQUNIOztBQUVELFdBQU8sS0FBUDtBQUNILEdBckJEOztBQXdCQTs7O0FBR0FwQyxhQUFXdHRDLFNBQVgsQ0FBcUIreUMsVUFBckIsR0FBa0MsVUFBUzNaLEdBQVQsRUFBYztBQUM1QyxRQUFJd1osYUFBYSxLQUFLdGlCLElBQXRCO0FBQ0FzaUIsZUFBV3QvQixNQUFYLEdBQW9COGxCLFFBQVF3WixXQUFXdC9CLE1BQVgsSUFBcUIsQ0FBQyxDQUF0QixHQUEwQixDQUExQixHQUE4QixDQUFDLENBQXZDLENBQXBCO0FBQ0gsR0FIRDs7QUFNQTs7O0FBR0FnNkIsYUFBV3R0QyxTQUFYLENBQXFCZ3pDLFVBQXJCLEdBQWtDLFVBQVU5ekMsSUFBVixFQUFnQit6QyxjQUFoQixFQUFpQzs7QUFFL0QsUUFBSXpGLFdBQVcsSUFBZjtBQUFBLFFBQ0kwRixnQkFBZ0IxRixTQUFTbGQsSUFBVCxDQUFjeWQsT0FBZCxDQUFzQjlxQyxLQUF0QixDQUE0QixDQUE1QixDQURwQjs7QUFJQTtBQUNBLFFBQUtnd0Msa0JBQWtCLE1BQXZCLEVBQWdDO0FBQzVCekYsZUFBU3VGLFVBQVQ7QUFDSCxLQUZELE1BSUssSUFBS0UsbUJBQW1CLEtBQXhCLEVBQWdDO0FBQ2pDekYsZUFBU3VGLFVBQVQsQ0FBb0IsQ0FBcEI7QUFDQUcsc0JBQWdCLEVBQWhCO0FBQ0gsS0FISSxNQUtBLElBQUtELG1CQUFtQixJQUF4QixFQUErQjtBQUNoQ3pGLGVBQVN1RixVQUFULENBQW9CLENBQUMsQ0FBckI7QUFDQUcsc0JBQWdCLEVBQWhCO0FBQ0g7O0FBRUQ7QUFMSyxTQU1BOztBQUVERCx1QkFBZTdJLEdBQWYsQ0FBbUIsVUFBVStJLGFBQVYsRUFBMEI7O0FBRXpDLGNBQUlDLFVBQUo7O0FBRUE7QUFDQTtBQUNBLGVBQU0sSUFBSTlqQixRQUFRLENBQWxCLEVBQXFCQSxRQUFRNGpCLGNBQWNsMEMsTUFBM0MsRUFBbURzd0IsU0FBUyxDQUE1RCxFQUFnRTtBQUM1RCxnQkFBS2tlLFNBQVNxRixXQUFULENBQXNCTSxhQUF0QixFQUFxQ0QsY0FBYzVqQixLQUFkLENBQXJDLENBQUwsRUFBbUU7QUFDL0Q4akIsMkJBQWEsSUFBYjtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLGNBQUssQ0FBQ0EsVUFBTixFQUFtQjtBQUNmLGdCQUNJNThCLEVBQUVtMkIsU0FBRixDQUFhd0csYUFBYixLQUNBMzhCLEVBQUVrMkIsTUFBRixDQUFVeUcsYUFBVixDQURBLElBRUE3M0MsRUFBRXFFLE9BQUYsQ0FBV3d6QyxhQUFYLENBRkEsSUFHRTczQyxFQUFFdUUsYUFBRixDQUFpQnN6QyxhQUFqQixLQUFvQ0EsY0FBYy9ELElBQWxELElBQTBEK0QsY0FBYzlELEVBSjlFLEVBS0U7QUFDRTZELDRCQUFjdHlDLElBQWQsQ0FBb0J1eUMsYUFBcEI7QUFDSDtBQUNKO0FBQ0osU0F4QkQ7QUF5Qkg7O0FBRUQ7QUFDQSxXQUFPRCxhQUFQO0FBQ0gsR0FyREQsQ0E5eEJ3QixDQW0xQnRCOzs7QUFHRjs7O0FBR0E1RixhQUFXdHRDLFNBQVgsQ0FBcUJxekMsUUFBckIsR0FBZ0MsVUFBVW4wQyxJQUFWLEVBQWdCbzBDLGFBQWhCLEVBQWdDOztBQUU1RCxRQUFJOUYsV0FBVyxJQUFmO0FBQUEsUUFDSTBGLGdCQUFnQjFGLFNBQVNsZCxJQUFULENBQWN5ZCxPQURsQztBQUFBLFFBRUl3RixxQkFBcUJMLGNBQWNsMEMsTUFGdkM7O0FBSUE7QUFDQSxRQUFLczBDLGlCQUFpQixNQUF0QixFQUErQjtBQUMzQjlGLGVBQVN1RixVQUFUO0FBQ0gsS0FGRCxNQUlLLElBQUtPLGtCQUFrQixJQUF2QixFQUE4QjtBQUMvQjlGLGVBQVN1RixVQUFULENBQW9CLENBQXBCO0FBQ0FHLHNCQUFnQixFQUFoQjtBQUNILEtBSEksTUFLQSxJQUFLSSxrQkFBa0IsS0FBdkIsRUFBK0I7QUFDaEM5RixlQUFTdUYsVUFBVCxDQUFvQixDQUFDLENBQXJCO0FBQ0FHLHNCQUFnQixFQUFoQjtBQUNIOztBQUVEO0FBTEssU0FNQTs7QUFFREksc0JBQWNsSixHQUFkLENBQWtCLFVBQVVvSixZQUFWLEVBQXlCOztBQUV2QyxjQUFJSixVQUFKLEVBQ0lLLFlBREosRUFFSW5rQixLQUZKLEVBR0lva0IsWUFISjs7QUFLQTtBQUNBLGVBQU1wa0IsUUFBUSxDQUFkLEVBQWlCQSxRQUFRaWtCLGtCQUF6QixFQUE2Q2prQixTQUFTLENBQXRELEVBQTBEOztBQUV0RG1rQiwyQkFBZVAsY0FBYzVqQixLQUFkLENBQWY7O0FBRUE7QUFDQSxnQkFBS2tlLFNBQVNxRixXQUFULENBQXNCWSxZQUF0QixFQUFvQ0QsWUFBcEMsQ0FBTCxFQUEwRDtBQUN0REosMkJBQWFGLGNBQWM1akIsS0FBZCxJQUF1QixJQUFwQztBQUNBb2tCLDZCQUFlLElBQWY7QUFDQTtBQUNIOztBQUVEO0FBTkEsaUJBT0ssSUFBS2xHLFNBQVNzRixhQUFULENBQXdCVyxZQUF4QixFQUFzQ0QsWUFBdEMsQ0FBTCxFQUE0RDtBQUM3RCxvQkFBS2w0QyxFQUFFdUUsYUFBRixDQUFpQjJ6QyxZQUFqQixDQUFMLEVBQXVDO0FBQ25DQSwrQkFBYWhDLFFBQWIsR0FBd0IsSUFBeEI7QUFDQTRCLCtCQUFhSSxZQUFiO0FBQ0gsaUJBSEQsTUFJSyxJQUFLbDRDLEVBQUVxRSxPQUFGLENBQVc2ekMsWUFBWCxDQUFMLEVBQWlDO0FBQ2xDSiwrQkFBYUksWUFBYjtBQUNBLHNCQUFLLENBQUNKLFdBQVcsQ0FBWCxDQUFOLEVBQXNCQSxXQUFXeHlDLElBQVgsQ0FBaUIsVUFBakI7QUFDekIsaUJBSEksTUFJQSxJQUFLNFYsRUFBRWsyQixNQUFGLENBQVU4RyxZQUFWLENBQUwsRUFBZ0M7QUFDakNKLCtCQUFhLENBQUVJLGFBQWF6RSxXQUFiLEVBQUYsRUFBOEJ5RSxhQUFheEUsUUFBYixFQUE5QixFQUF1RHdFLGFBQWE1RyxPQUFiLEVBQXZELEVBQStFLFVBQS9FLENBQWI7QUFDSDtBQUNEO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLGNBQUt3RyxVQUFMLEVBQWtCLEtBQU05akIsUUFBUSxDQUFkLEVBQWlCQSxRQUFRaWtCLGtCQUF6QixFQUE2Q2prQixTQUFTLENBQXRELEVBQTBEO0FBQ3hFLGdCQUFLa2UsU0FBU3FGLFdBQVQsQ0FBc0JLLGNBQWM1akIsS0FBZCxDQUF0QixFQUE0Q2trQixZQUE1QyxDQUFMLEVBQWtFO0FBQzlETiw0QkFBYzVqQixLQUFkLElBQXVCLElBQXZCO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQSxjQUFLb2tCLFlBQUwsRUFBb0IsS0FBTXBrQixRQUFRLENBQWQsRUFBaUJBLFFBQVFpa0Isa0JBQXpCLEVBQTZDamtCLFNBQVMsQ0FBdEQsRUFBMEQ7QUFDMUUsZ0JBQUtrZSxTQUFTc0YsYUFBVCxDQUF3QkksY0FBYzVqQixLQUFkLENBQXhCLEVBQThDa2tCLFlBQTlDLENBQUwsRUFBb0U7QUFDaEVOLDRCQUFjNWpCLEtBQWQsSUFBdUIsSUFBdkI7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQSxjQUFLOGpCLFVBQUwsRUFBa0I7QUFDZEYsMEJBQWN0eUMsSUFBZCxDQUFvQnd5QyxVQUFwQjtBQUNIO0FBQ0osU0F6REQ7QUEwREg7O0FBRUQ7QUFDQSxXQUFPRixjQUFjbjdCLE1BQWQsQ0FBcUIsVUFBVXFoQixHQUFWLEVBQWdCO0FBQUUsYUFBT0EsT0FBTyxJQUFkO0FBQW9CLEtBQTNELENBQVA7QUFDSCxHQXRGRCxDQXoxQndCLENBKzZCdEI7OztBQUdGOzs7QUFHQWtVLGFBQVd0dEMsU0FBWCxDQUFxQnFvQyxLQUFyQixHQUE2QixVQUFVc0wsTUFBVixFQUFtQjs7QUFFNUMsUUFDSW5HLFdBQVcsSUFEZjtBQUFBLFFBRUlELFdBQVdDLFNBQVNELFFBRnhCO0FBQUEsUUFHSW9CLGVBQWVuQixTQUFTbGQsSUFINUI7QUFBQSxRQUlJc2pCLFlBQVlqRixhQUFhcnpCLEdBSjdCO0FBQUEsUUFLSXU0QixpQkFBaUJsRixhQUFhalIsTUFMbEM7QUFBQSxRQU1Jd1Esb0JBQW9CUyxhQUFhNVMsU0FOckM7QUFBQSxRQU9Jb1UsZ0JBQWdCeEIsYUFBYWIsSUFQakM7QUFBQSxRQVFJZ0cscUJBQXFCbkYsYUFBYVosT0FSdEM7QUFBQSxRQVNJK0MsaUJBQWlCbkMsYUFBYTVxQyxHQVRsQztBQUFBLFFBVUlndEMsaUJBQWlCcEMsYUFBYTNxQyxHQVZsQzs7O0FBYUk7QUFDQTtBQUNBK3ZDLGdCQUFhLFVBQVV0VixVQUFWLEVBQXNCdVYsY0FBdEIsRUFBdUM7O0FBRWhEO0FBQ0EsVUFBS3pHLFNBQVNnRSxRQUFkLEVBQXlCO0FBQ3JCOVMsbUJBQVc3OUIsSUFBWCxDQUFpQjY5QixXQUFXMzlCLEtBQVgsRUFBakI7QUFDQWt6Qyx1QkFBZXB6QyxJQUFmLENBQXFCb3pDLGVBQWVsekMsS0FBZixFQUFyQjtBQUNIOztBQUVEO0FBQ0EsYUFBTzBWLEVBQUUrd0IsSUFBRixDQUNILE9BREcsRUFFSC93QixFQUFFK3dCLElBQUYsQ0FDSSxJQURKLEVBRUkvd0IsRUFBRXcxQixLQUFGLENBQVE7QUFDSmpvQyxhQUFLLENBREQ7QUFFSkMsYUFBS29wQyxlQUFlLENBRmhCO0FBR0ozdEMsV0FBRyxDQUhDO0FBSUo4bkMsY0FBTSxJQUpGO0FBS0pqWCxjQUFNLGNBQVU4YixPQUFWLEVBQW9CO0FBQ3RCLGlCQUFPLENBQ0gzTixXQUFZMk4sT0FBWixDQURHLEVBRUhtQixTQUFTekcsS0FBVCxDQUFlbU4sUUFGWixFQUdILHNCQUFzQkQsZUFBZ0I1SCxPQUFoQixDQUF0QixHQUFrRCxHQUgvQyxDQUFQO0FBS0g7QUFYRyxPQUFSLENBRkosQ0FGRyxDQUFQLENBVGdELENBMkI5Qzs7QUFFTjtBQUNDLEtBOUJXLENBOEJSLENBQUVtQixTQUFTMkcsZ0JBQVQsR0FBNEIzRyxTQUFTZ0YsWUFBckMsR0FBb0RoRixTQUFTNEcsY0FBL0QsRUFBZ0ZseEMsS0FBaEYsQ0FBdUYsQ0FBdkYsQ0E5QlEsRUE4Qm9Gc3FDLFNBQVNnRixZQUFULENBQXNCdHZDLEtBQXRCLENBQTZCLENBQTdCLENBOUJwRixDQWZoQjtBQUFBLFFBNkN3STs7O0FBR3BJO0FBQ0FteEMscUJBQWlCLFNBQWpCQSxjQUFpQixDQUFVbGpDLElBQVYsRUFBaUI7O0FBRTlCO0FBQ0EsYUFBT3NGLEVBQUUrd0IsSUFBRixDQUNILEtBREcsRUFFSCxHQUZHLEVBR0hnRyxTQUFTekcsS0FBVCxDQUFnQixTQUFVNTFCLE9BQU8sTUFBUCxHQUFnQixNQUExQixDQUFoQjs7QUFFSTtBQUNFQSxjQUFRaS9CLGNBQWMvQixJQUFkLElBQXNCMkMsZUFBZTNDLElBQTdDLElBQXFEK0IsY0FBYzlCLEtBQWQsSUFBdUIwQyxlQUFlMUMsS0FBN0YsSUFDRSxDQUFDbjlCLElBQUQsSUFBU2kvQixjQUFjL0IsSUFBZCxJQUFzQjBDLGVBQWUxQyxJQUE5QyxJQUFzRCtCLGNBQWM5QixLQUFkLElBQXVCeUMsZUFBZXpDLEtBRDlGLEdBRUEsTUFBTWQsU0FBU3pHLEtBQVQsQ0FBZWtFLFdBRnJCLEdBRW1DLEVBTHZDLENBSEcsRUFVSCxlQUFnQjk1QixRQUFRLENBQUMsQ0FBekIsSUFBK0IsR0FBL0IsR0FDQXNGLEVBQUVxMkIsUUFBRixDQUFXO0FBQ1B3SCxjQUFNLFFBREM7QUFFUEMsa0JBQVU5RyxTQUFTdkcsS0FBVCxDQUFlLENBQWYsRUFBa0J0dUIsRUFBbEIsR0FBdUI7QUFGMUIsT0FBWCxDQURBLEdBSUssR0FKTCxHQUtBLFNBTEEsSUFLYXpILE9BQU9xOEIsU0FBU2dILGNBQWhCLEdBQWlDaEgsU0FBU2lILGNBTHZELElBSzBFLEdBZnZFLENBQVAsQ0FIOEIsQ0FtQjVCO0FBQ0wsS0FyRUw7QUFBQSxRQXFFTzs7O0FBR0g7QUFDQTtBQUNBQyx1QkFBbUIsU0FBbkJBLGdCQUFtQixDQUFTQyxRQUFULEVBQW1COztBQUVsQyxVQUFJQyxtQkFBbUJwSCxTQUFTcUgsZUFBVCxHQUEyQnJILFNBQVNrRixXQUFwQyxHQUFrRGxGLFNBQVNvRixVQUFsRjs7QUFFQztBQUNELFVBQUkrQixZQUFZLGNBQWhCLEVBQWdDO0FBQzlCQywyQkFBbUJwSCxTQUFTa0YsV0FBNUI7QUFDRDs7QUFFRDtBQUNBLFVBQUtsRixTQUFTc0gsWUFBVCxJQUEwQkgsWUFBWXIyQyxTQUEzQyxFQUFzRDs7QUFFbEQsZUFBT21ZLEVBQUUrd0IsSUFBRixDQUFRLFFBQVIsRUFDSC93QixFQUFFdzFCLEtBQUYsQ0FBUTtBQUNKam9DLGVBQUssQ0FERDtBQUVKQyxlQUFLLEVBRkQ7QUFHSnZFLGFBQUcsQ0FIQztBQUlKOG5DLGdCQUFNLFFBSkY7QUFLSmpYLGdCQUFNLGNBQVV3a0IsV0FBVixFQUF3Qjs7QUFFMUIsbUJBQU87O0FBRUg7QUFDQUgsNkJBQWtCRyxXQUFsQixDQUhHLEVBRzhCLENBSDlCOztBQUtIO0FBQ0EsdUJBQVdBLFdBQVgsSUFDRTNFLGNBQWM5QixLQUFkLElBQXVCeUcsV0FBdkIsR0FBcUMsV0FBckMsR0FBbUQsRUFEckQsS0FJVTNFLGNBQWMvQixJQUFkLElBQXNCMEMsZUFBZTFDLElBQXJDLElBQTZDMEcsY0FBY2hFLGVBQWV6QyxLQUE1RSxJQUNFOEIsY0FBYy9CLElBQWQsSUFBc0IyQyxlQUFlM0MsSUFBckMsSUFBNkMwRyxjQUFjL0QsZUFBZTFDLEtBRmhGLEdBSUEsV0FKQSxHQUljLEVBUGxCLENBTkcsQ0FBUDtBQWdCSDtBQXZCRyxTQUFSLENBREcsRUEwQkhkLFNBQVN6RyxLQUFULENBQWV5SCxXQUFmLEdBQTZCLGtCQTFCMUIsRUEyQkgsQ0FBRW9GLFNBQVMsRUFBVCxHQUFjLFVBQWhCLElBQStCLEdBQS9CLEdBQ0FuOUIsRUFBRXEyQixRQUFGLENBQVcsRUFBRXlILFVBQVU5RyxTQUFTdkcsS0FBVCxDQUFlLENBQWYsRUFBa0J0dUIsRUFBbEIsR0FBdUIsUUFBbkMsRUFBWCxDQURBLEdBQzRELEdBRDVELEdBRUEsU0FGQSxHQUVZNDBCLFNBQVN3SCxnQkFGckIsR0FFd0MsR0E3QnJDLENBQVA7QUErQkg7O0FBRUQ7QUFDQSxVQUFJTCxZQUFZLGNBQWhCLEVBQ0ksSUFBSWIsa0JBQWtCLElBQXRCLEVBQ0EsT0FBT3I5QixFQUFFK3dCLElBQUYsQ0FBUSxLQUFSLEVBQWVvTixpQkFBa0JkLGVBQWV4RixLQUFqQyxDQUFmLENBQVAsQ0FEQSxLQUVLLE9BQU83M0IsRUFBRSt3QixJQUFGLENBQVEsS0FBUixFQUFlb04saUJBQWtCeEUsY0FBYzlCLEtBQWhDLENBQWYsQ0FBUDs7QUFFVDtBQUNBLGFBQU83M0IsRUFBRSt3QixJQUFGLENBQVEsS0FBUixFQUFlb04saUJBQWtCeEUsY0FBYzlCLEtBQWhDLENBQWYsRUFBd0RkLFNBQVN6RyxLQUFULENBQWV1SCxLQUF2RSxDQUFQO0FBQ0gsS0EvSEw7QUFBQSxRQStITzs7O0FBR0g7QUFDQTtBQUNBMkcsc0JBQWtCLFNBQWxCQSxlQUFrQixDQUFTTixRQUFULEVBQW1COztBQUVqQyxVQUFJTyxjQUFjOUUsY0FBYy9CLElBQWhDOzs7QUFFQTtBQUNBO0FBQ0E4RyxvQkFBYzNILFNBQVM0SCxXQUFULEtBQXlCLElBQXpCLEdBQWdDLENBQWhDLEdBQW9DLENBQUMsRUFBRzVILFNBQVM0SCxXQUFULEdBQXVCLENBQTFCLENBSm5EOztBQU1BO0FBQ0EsVUFBS0QsV0FBTCxFQUFtQjs7QUFFZixZQUNJRSxVQUFVdEUsZUFBZTFDLElBRDdCO0FBQUEsWUFFSWlILFVBQVV0RSxlQUFlM0MsSUFGN0I7QUFBQSxZQUdJa0gsYUFBYUwsY0FBY0MsV0FIL0I7QUFBQSxZQUlJSyxjQUFjTixjQUFjQyxXQUpoQzs7QUFNQTtBQUNBO0FBQ0EsWUFBS0UsVUFBVUUsVUFBZixFQUE0QjtBQUN4QkMseUJBQWVILFVBQVVFLFVBQXpCO0FBQ0FBLHVCQUFhRixPQUFiO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsWUFBS0MsVUFBVUUsV0FBZixFQUE2Qjs7QUFFekIsY0FBSUMsaUJBQWlCRixhQUFhRixPQUFsQztBQUFBLGNBQ0lLLGNBQWNGLGNBQWNGLE9BRGhDOztBQUdBQyx3QkFBY0UsaUJBQWlCQyxXQUFqQixHQUErQkEsV0FBL0IsR0FBNkNELGNBQTNEO0FBQ0FELHdCQUFjRixPQUFkO0FBQ0g7O0FBRUQsWUFBSzlILFNBQVM0SCxXQUFULElBQXlCVCxZQUFZcjJDLFNBQTFDLEVBQXNEO0FBQ2xELGlCQUFPbVksRUFBRSt3QixJQUFGLENBQVEsUUFBUixFQUNIL3dCLEVBQUV3MUIsS0FBRixDQUFRO0FBQ0pqb0MsaUJBQUt1eEMsVUFERDtBQUVKdHhDLGlCQUFLdXhDLFdBRkQ7QUFHSjkxQyxlQUFHLENBSEM7QUFJSjhuQyxrQkFBTSxRQUpGO0FBS0pqWCxrQkFBTSxjQUFVb2xCLFVBQVYsRUFBdUI7QUFDekIscUJBQU87O0FBRUg7QUFDQUEsd0JBSEcsRUFHUyxDQUhUOztBQUtIO0FBQ0EseUJBQVdBLFVBQVgsSUFBMEJULGVBQWVTLFVBQWYsR0FBNEIsV0FBNUIsR0FBMEMsRUFBcEUsQ0FORyxDQUFQO0FBUUg7QUFkRyxXQUFSLENBREcsRUFpQkhuSSxTQUFTekcsS0FBVCxDQUFlMEgsVUFBZixHQUE0QixrQkFqQnpCLEVBa0JILENBQUVtRixTQUFTLEVBQVQsR0FBYyxVQUFoQixJQUErQixHQUEvQixHQUFxQ245QixFQUFFcTJCLFFBQUYsQ0FBVyxFQUFFeUgsVUFBVTlHLFNBQVN2RyxLQUFULENBQWUsQ0FBZixFQUFrQnR1QixFQUFsQixHQUF1QixRQUFuQyxFQUFYLENBQXJDLEdBQWlHLEdBQWpHLEdBQ0EsU0FEQSxHQUNZNDBCLFNBQVNvSSxlQURyQixHQUN1QyxHQW5CcEMsQ0FBUDtBQXFCSDtBQUNKOztBQUVEO0FBQ0EsVUFBSWpCLFlBQVksS0FBaEIsRUFDSSxPQUFPbCtCLEVBQUUrd0IsSUFBRixDQUFRLEtBQVIsRUFBZTBOLFdBQWYsQ0FBUDs7QUFFSjtBQUNBLGFBQU96K0IsRUFBRSt3QixJQUFGLENBQVEsS0FBUixFQUFlME4sV0FBZixFQUE0QjFILFNBQVN6RyxLQUFULENBQWVzSCxJQUEzQyxDQUFQO0FBQ0gsS0F2TUwsQ0FGNEMsQ0F5TXRDOzs7QUFHRjtBQUNBd0gscUJBQWlCLDBCQUFXO0FBQ3BCLFVBQUkvQixrQkFBa0IsSUFBdEIsRUFDSSxPQUFPcjlCLEVBQUUrd0IsSUFBRixDQUFRLEtBQVIsRUFBZXNNLGVBQWV2RixJQUE5QixDQUFQLENBREosS0FFSyxPQUFPOTNCLEVBQUUrd0IsSUFBRixDQUFRLEtBQVIsRUFBZXFNLFVBQVV0RixJQUF6QixDQUFQO0FBQ1IsS0FKTDtBQUtBdUgseUJBQXFCLDhCQUFXO0FBQzVCLFVBQUlDLFdBQUo7O0FBRUEsVUFBSWpDLGtCQUFrQixJQUF0QixFQUNJaUMsY0FBY2pDLGVBQWU1RSxHQUE3QixDQURKLEtBR0k2RyxjQUFjbEMsVUFBVTNFLEdBQXhCO0FBQ0osVUFBSThHLFVBQVV4SSxTQUFTZ0YsWUFBVCxDQUF1QnVELFdBQXZCLENBQWQ7QUFDQSxhQUFPQyxPQUFQO0FBQ0gsS0FURDs7QUFZSjtBQUNKLFdBQU92L0IsRUFBRSt3QixJQUFGO0FBQ0M7QUFDQSxTQUZELEVBR0svd0IsRUFBRSt3QixJQUFGLENBQ0ksS0FESixFQUVJc08sb0JBRkosRUFHSSx5QkFISixJQUtBci9CLEVBQUUrd0IsSUFBRjtBQUNJO0FBQ0EsU0FGSixFQUdJa04saUJBQWlCLGNBQWpCLENBSEosRUFJSWxILFNBQVN6RyxLQUFULENBQWVrUCxhQUpuQixDQUxBLEdBV0F4L0IsRUFBRSt3QixJQUFGO0FBQ0k7QUFDQSxTQUZKLEVBR0lxTyxnQkFISixFQUlJckksU0FBU3pHLEtBQVQsQ0FBZW1QLFdBSm5CLENBWEEsR0FpQkF6L0IsRUFBRSt3QixJQUFGO0FBQ0k7QUFDQSxTQUZKLEVBR0l5TixnQkFBZ0IsS0FBaEIsQ0FISixFQUlJekgsU0FBU3pHLEtBQVQsQ0FBZW9QLFlBSm5CLENBcEJMLEVBMEJDM0ksU0FBU3pHLEtBQVQsQ0FBZXFQLFlBMUJoQjtBQTRCSDtBQUNBMy9CLE1BQUUrd0IsSUFBRixDQUFPLEtBQVAsRUFDSS93QixFQUFFK3dCLElBQUYsQ0FBTyxLQUFQLEVBQ0EsQ0FBRWdHLFNBQVM0SCxXQUFULEdBQXdCVixxQkFBcUJPLGlCQUE3QyxHQUFpRVAscUJBQXFCTyxpQkFBeEYsSUFDQVosZ0JBREEsR0FDbUJBLGVBQWdCLENBQWhCLENBRm5CLEVBR0E3RyxTQUFTekcsS0FBVCxDQUFlc1AsTUFIZixJQUlBNS9CLEVBQUUrd0IsSUFBRixDQUNBLE9BREEsRUFFQXdNLFlBQ0F2OUIsRUFBRSt3QixJQUFGLENBQ0ksT0FESixFQUVJL3dCLEVBQUV3MUIsS0FBRixDQUFRO0FBQ0pqb0MsV0FBSyxDQUREO0FBRUpDLFdBQUtxcEMsb0JBQW9CLENBRnJCO0FBR0o1dEMsU0FBRyxDQUhDO0FBSUo4bkMsWUFBTSxJQUpGO0FBS0pqWCxZQUFNLGNBQVUrbEIsVUFBVixFQUF1Qjs7QUFFekI7QUFDQSxZQUFJQyxjQUFjL0ksU0FBU2dFLFFBQVQsSUFBcUIvRCxTQUFTajdCLE1BQVQsQ0FBZ0IsQ0FBRTQ5QixjQUFjL0IsSUFBaEIsRUFBc0IrQixjQUFjOUIsS0FBcEMsRUFBMkMsQ0FBM0MsQ0FBaEIsRUFBZ0VZLEdBQWhFLEtBQXdFLENBQTdGLEdBQWlHLENBQUMsQ0FBbEcsR0FBc0csQ0FBeEg7O0FBRUEsZUFBTyxDQUNIejRCLEVBQUV3MUIsS0FBRixDQUFRO0FBQ0pqb0MsZUFBS3FwQyxlQUFlaUosVUFBZixHQUE0QmxHLGNBQWNsQixHQUExQyxHQUFnRHFILFdBQWhELEdBQThELENBRC9ELEVBQ2tFO0FBQ3RFdHlDLGVBQUssZUFBVztBQUNaLG1CQUFPLEtBQUtELEdBQUwsR0FBV3FwQyxZQUFYLEdBQTBCLENBQWpDO0FBQ0gsV0FKRztBQUtKM3RDLGFBQUcsQ0FMQztBQU1KOG5DLGdCQUFNLElBTkY7QUFPSmpYLGdCQUFNLGNBQVU2ZCxVQUFWLEVBQXVCOztBQUV6QjtBQUNBQSx5QkFBYVgsU0FBU2o3QixNQUFULENBQWdCLENBQUU0OUIsY0FBYy9CLElBQWhCLEVBQXNCK0IsY0FBYzlCLEtBQXBDLEVBQTJDRixjQUFlWixTQUFTZ0UsUUFBVCxHQUFvQixDQUFwQixHQUF3QixDQUF2QyxDQUEzQyxDQUFoQixDQUFiOztBQUVBLGdCQUFJZ0YsYUFBYTFDLGtCQUFrQkEsZUFBZXpJLElBQWYsSUFBdUIrQyxXQUFXL0MsSUFBckU7QUFBQSxnQkFDSW9MLGdCQUFnQnRJLHFCQUFxQkEsa0JBQWtCOUMsSUFBbEIsSUFBMEIrQyxXQUFXL0MsSUFEOUU7QUFBQSxnQkFFSXFMLGFBQWEzQyxzQkFBc0J0RyxTQUFTeEUsUUFBVCxDQUFtQm1GLFVBQW5CLENBQXRCLElBQXlEQSxXQUFXL0MsSUFBWCxHQUFrQjBGLGVBQWUxRixJQUExRixJQUFrRytDLFdBQVcvQyxJQUFYLEdBQWtCMkYsZUFBZTNGLElBRnBKO0FBQUEsZ0JBR0lzTCxnQkFBZ0JsZ0MsRUFBRXdNLE9BQUYsQ0FBV3dxQixTQUFTNUQsT0FBVCxDQUFpQmxuQyxRQUE1QixFQUFzQzhxQyxRQUF0QyxFQUFnRCxDQUFFRCxTQUFTN0QsTUFBWCxFQUFtQnlFLFVBQW5CLENBQWhELENBSHBCOztBQUtBLG1CQUFPLENBQ0gzM0IsRUFBRSt3QixJQUFGLENBQ0ksS0FESixFQUVJNEcsV0FBV0csSUFGZixFQUdLLFVBQVV6SCxPQUFWLEVBQW9COztBQUVqQjtBQUNBQSxzQkFBUWptQyxJQUFSLENBQWN1dkMsY0FBYzlCLEtBQWQsSUFBdUJGLFdBQVdFLEtBQWxDLEdBQTBDZCxTQUFTekcsS0FBVCxDQUFlNlAsT0FBekQsR0FBbUVwSixTQUFTekcsS0FBVCxDQUFlOFAsUUFBaEc7O0FBRUE7QUFDQSxrQkFBS2hELFVBQVV4SSxJQUFWLElBQWtCK0MsV0FBVy9DLElBQWxDLEVBQXlDO0FBQ3JDdkUsd0JBQVFqbUMsSUFBUixDQUFjMnNDLFNBQVN6RyxLQUFULENBQWV4ckIsR0FBN0I7QUFDSDs7QUFFRDtBQUNBLGtCQUFLaTdCLFVBQUwsRUFBa0I7QUFDZDFQLHdCQUFRam1DLElBQVIsQ0FBYzJzQyxTQUFTekcsS0FBVCxDQUFlNUksUUFBN0I7QUFDSDs7QUFFRDtBQUNBLGtCQUFLc1ksYUFBTCxFQUFxQjtBQUNqQjNQLHdCQUFRam1DLElBQVIsQ0FBYzJzQyxTQUFTekcsS0FBVCxDQUFlaUMsV0FBN0I7QUFDSDs7QUFFRDtBQUNBLGtCQUFLME4sVUFBTCxFQUFrQjtBQUNkNVAsd0JBQVFqbUMsSUFBUixDQUFjMnNDLFNBQVN6RyxLQUFULENBQWVrQyxRQUE3QjtBQUNIOztBQUVELHFCQUFPbkMsUUFBUXA3QixJQUFSLENBQWMsR0FBZCxDQUFQO0FBQ0gsYUExQkQsQ0EwQkcsQ0FBRThoQyxTQUFTekcsS0FBVCxDQUFlbUksR0FBakIsQ0ExQkgsQ0FISixFQThCSSxlQUFlZCxXQUFXL0MsSUFBMUIsR0FBaUMsR0FBakMsR0FBdUM1MEIsRUFBRXEyQixRQUFGLENBQVc7QUFDOUN3SCxvQkFBTSxVQUR3QztBQUU5QzdXLHFCQUFPa1osYUFGdUM7QUFHOUN4WSx3QkFBVXFZLGNBQWMvSSxTQUFTdkcsS0FBVCxDQUFlN04sR0FBZixPQUF5QnNkLGFBQXZDLEdBQXVELElBQXZELEdBQThELElBSDFCO0FBSTlDRyxnQ0FBa0JMLGdCQUFnQixJQUFoQixHQUF1QixJQUpLO0FBSzlDeE4sd0JBQVV5TixhQUFhLElBQWIsR0FBb0I7QUFMZ0IsYUFBWCxDQTlCM0MsQ0FERyxFQXVDSCxFQXZDRyxFQXdDSGpnQyxFQUFFcTJCLFFBQUYsQ0FBVyxFQUFFd0gsTUFBTSxjQUFSLEVBQVgsQ0F4Q0csQ0FBUCxDQVZ5QixDQW1EdkI7QUFDTDtBQTNERyxTQUFSLENBREcsQ0FBUCxDQUx5QixDQW1FdkI7QUFDTDtBQXpFRyxLQUFSLENBRkosQ0FIQSxFQWlGQTlHLFNBQVN6RyxLQUFULENBQWVnUSxLQWpGZixFQWtGQSxTQUFTdEosU0FBU3ZHLEtBQVQsQ0FBZSxDQUFmLEVBQWtCdHVCLEVBQTNCLEdBQWdDLFFBQWhDLEdBQTJDLElBQTNDLEdBQWtEbkMsRUFBRXEyQixRQUFGLENBQVc7QUFDekR3SCxZQUFNLE1BRG1EO0FBRXpEQyxnQkFBVTlHLFNBQVN2RyxLQUFULENBQWUsQ0FBZixFQUFrQnR1QixFQUY2QjtBQUd6RCt4QixnQkFBVTtBQUgrQyxLQUFYLENBbEZsRCxDQUxKLEVBNkZFNkMsU0FBU3pHLEtBQVQsQ0FBZWlRLGtCQTdGakIsQ0E3QkcsQ0EwSGtDOztBQTFIbEM7O0FBOEhIO0FBQ0F2Z0MsTUFBRSt3QixJQUFGLENBQ0ksS0FESixFQUVJL3dCLEVBQUUrd0IsSUFBRixDQUFRLFFBQVIsRUFBa0JnRyxTQUFTeUosS0FBM0IsRUFBa0Msd0JBQWxDLEVBQ0ksMkJBQTJCcEQsVUFBVXhJLElBQXJDLElBQ0V1SSxVQUFVLENBQUNuRyxTQUFTeEUsUUFBVCxDQUFrQjRLLFNBQWxCLENBQVgsR0FBMEMsRUFBMUMsR0FBK0MsV0FEakQsSUFDaUUsR0FEakUsR0FFQXA5QixFQUFFcTJCLFFBQUYsQ0FBVyxFQUFFeUgsVUFBVTlHLFNBQVN2RyxLQUFULENBQWUsQ0FBZixFQUFrQnR1QixFQUE5QixFQUFYLENBSEosSUFJQW5DLEVBQUUrd0IsSUFBRixDQUFRLFFBQVIsRUFBa0JnRyxTQUFTbkUsS0FBM0IsRUFBa0Msd0JBQWxDLEVBQ0ksOEJBQ0V1SyxTQUFTLEVBQVQsR0FBYyxXQURoQixJQUNnQyxHQURoQyxHQUVBbjlCLEVBQUVxMkIsUUFBRixDQUFXLEVBQUV5SCxVQUFVOUcsU0FBU3ZHLEtBQVQsQ0FBZSxDQUFmLEVBQWtCdHVCLEVBQTlCLEVBQVgsQ0FISixDQUpBLEdBUUFuQyxFQUFFK3dCLElBQUYsQ0FBTyxRQUFQLEVBQWlCZ0csU0FBU3hoQixLQUExQixFQUFpQyx3QkFBakMsRUFDSSxrQ0FDRTRuQixTQUFTLEVBQVQsR0FBYyxXQURoQixJQUNnQyxHQURoQyxHQUVBbjlCLEVBQUVxMkIsUUFBRixDQUFXLEVBQUV5SCxVQUFVOUcsU0FBU3ZHLEtBQVQsQ0FBZSxDQUFmLEVBQWtCdHVCLEVBQTlCLEVBQVgsQ0FISixDQVZKLEVBY0k0MEIsU0FBU3pHLEtBQVQsQ0FBZW1RLE1BZG5CLENBL0hKLENBL05nRCxDQTZXMUM7QUFDTCxHQTlXRCxDQXI3QndCLENBbXlDdEI7OztBQUtGOzs7QUFHQTNKLGFBQVc5b0MsUUFBWCxHQUF1QixVQUFVaW5DLE1BQVYsRUFBbUI7O0FBRXRDLFdBQU87O0FBRUg7QUFDQThJLHNCQUFnQixZQUhiO0FBSUhDLHNCQUFnQixnQkFKYjs7QUFNSDtBQUNBTyx3QkFBa0IsZ0JBUGY7QUFRSFksdUJBQWlCLGVBUmQ7O0FBVUg7QUFDQWhELGtCQUFZLENBQUUsU0FBRixFQUFhLFVBQWIsRUFBeUIsT0FBekIsRUFBa0MsT0FBbEMsRUFBMkMsS0FBM0MsRUFBa0QsTUFBbEQsRUFBMEQsTUFBMUQsRUFBa0UsUUFBbEUsRUFBNEUsV0FBNUUsRUFBeUYsU0FBekYsRUFBb0csVUFBcEcsRUFBZ0gsVUFBaEgsQ0FYVDtBQVlIRixtQkFBYSxDQUFFLEtBQUYsRUFBUyxLQUFULEVBQWdCLEtBQWhCLEVBQXVCLEtBQXZCLEVBQThCLEtBQTlCLEVBQXFDLEtBQXJDLEVBQTRDLEtBQTVDLEVBQW1ELEtBQW5ELEVBQTBELEtBQTFELEVBQWlFLEtBQWpFLEVBQXdFLEtBQXhFLEVBQStFLEtBQS9FLENBWlY7QUFhSEYsb0JBQWMsQ0FBRSxRQUFGLEVBQVksUUFBWixFQUFzQixTQUF0QixFQUFpQyxXQUFqQyxFQUE4QyxVQUE5QyxFQUEwRCxRQUExRCxFQUFvRSxVQUFwRSxDQWJYO0FBY0hGLHFCQUFlLENBQUUsS0FBRixFQUFTLEtBQVQsRUFBZ0IsS0FBaEIsRUFBdUIsS0FBdkIsRUFBOEIsS0FBOUIsRUFBcUMsS0FBckMsRUFBNEMsS0FBNUMsQ0FkWjs7QUFnQkg7QUFDQThCLHNCQUFnQixDQUFFLEdBQUYsRUFBTyxHQUFQLEVBQVksR0FBWixFQUFpQixHQUFqQixFQUFzQixHQUF0QixFQUEyQixHQUEzQixFQUFnQyxHQUFoQyxDQWpCYjs7QUFtQkg7QUFDQTZDLGFBQU8sT0FwQko7QUFxQkg1TixhQUFPLE9BckJKO0FBc0JIcmQsYUFBTyxPQXRCSjs7QUF3Qkg7QUFDQTJkLGNBQVEsY0F6Qkw7O0FBMkJIO0FBQ0E1QyxhQUFPOztBQUVIZ1EsZUFBT3JMLFNBQVMsT0FGYjs7QUFJSDJLLGdCQUFRM0ssU0FBUyxRQUpkOztBQU9IO0FBQ0EwSyxzQkFBYzFLLFNBQVMsY0FScEI7QUFTSHdLLHFCQUFheEssU0FBUyxhQVRuQjtBQVVIdUssdUJBQWV2SyxTQUFTLGVBVnJCO0FBV0h5SyxzQkFBY3pLLFNBQVMsY0FYcEI7QUFZSHNMLDRCQUFvQnRMLFNBQVMsb0JBWjFCO0FBYUg7OztBQUlBeUwsaUJBQVN6TCxTQUFTLFdBakJmO0FBa0JIMEwsaUJBQVMxTCxTQUFTLFdBbEJmO0FBbUJIVCxxQkFBYVMsU0FBUyxlQW5CbkI7O0FBcUJINEMsZUFBTzVDLFNBQVMsT0FyQmI7QUFzQkgyQyxjQUFNM0MsU0FBUyxNQXRCWjs7QUF3Qkg4QyxxQkFBYTlDLFNBQVMsZUF4Qm5CO0FBeUJIK0Msb0JBQVkvQyxTQUFTLGNBekJsQjs7QUEyQkh3SSxrQkFBVXhJLFNBQVMsU0EzQmhCOztBQTZCSHdELGFBQUt4RCxTQUFTLEtBN0JYO0FBOEJIekMsa0JBQVV5QyxTQUFTLGVBOUJoQjtBQStCSHZOLGtCQUFVdU4sU0FBUyxlQS9CaEI7QUFnQ0gxQyxxQkFBYTBDLFNBQVMsa0JBaENuQjtBQWlDSG53QixhQUFLbXdCLFNBQVMsWUFqQ1g7QUFrQ0hrTCxpQkFBU2xMLFNBQVMsY0FsQ2Y7QUFtQ0htTCxrQkFBVW5MLFNBQVMsZUFuQ2hCOztBQXFDSHdMLGdCQUFReEwsU0FBUyxRQXJDZDs7QUF1Q0gyTCxxQkFBYTNMLFNBQVMsZUF2Q25CO0FBd0NIaUQscUJBQWFqRCxTQUFTLGVBeENuQjtBQXlDSDRMLHFCQUFhNUwsU0FBUztBQXpDbkI7QUE1QkosS0FBUDtBQXdFSCxHQTFFcUIsQ0EwRWxCeEYsT0FBT1ksT0FBUCxHQUFpQlksTUFBakIsR0FBMEIsSUExRVIsQ0FBdEI7O0FBZ0ZBOzs7QUFHQXhCLFNBQU94cUMsTUFBUCxDQUFlLFdBQWYsRUFBNEI2eEMsVUFBNUI7QUFHQyxDQTk0Q0EsQ0FBRDs7QUFpNUNBLENBQUUsV0FBVWh5QyxDQUFWLEVBQWE7O0FBRWJBLElBQUUrRCxFQUFGLENBQUtpNEMsZ0JBQUwsR0FBd0IsWUFBVTtBQUNoQyxXQUFPLEtBQUtyM0MsSUFBTCxDQUFVLFlBQVU7QUFDekIsVUFBSXc3QixTQUFTbmdDLEVBQUUsSUFBRixDQUFiO0FBQ0EsVUFBSWk4QyxrQkFBa0I5YixPQUFPclYsTUFBUCxHQUFnQkwsSUFBaEIsQ0FBcUIsaUNBQXJCLENBQXRCOztBQUVBO0FBQ0EsVUFBSXd4QixnQkFBZ0J2NEMsTUFBcEIsRUFBNEI7QUFDMUI7QUFDRDs7QUFFRCxVQUFJdzRDLHVCQUF1Qi9iLE9BQU83WCxJQUFQLENBQVksYUFBWixNQUErQnZsQixTQUExRDs7QUFFQSxVQUFHbTVDLG9CQUFILEVBQXdCO0FBQ3RCL2IsZUFBTzFiLEVBQVAsQ0FBVSxPQUFWLEVBQW1CMDNCLGFBQW5CO0FBQ0FoYyxlQUFPMWIsRUFBUCxDQUFVLE9BQVYsRUFBbUIwM0IsYUFBbkI7QUFDQWhjLGVBQU8xYixFQUFQLENBQVUsTUFBVixFQUFrQjIzQixvQkFBbEI7O0FBRUFDLDBCQUFrQmxjLE1BQWxCO0FBQ0Q7QUFFRixLQW5CTSxDQUFQO0FBb0JELEdBckJEOztBQXVCQSxXQUFTZ2MsYUFBVCxHQUF3QjtBQUN0QixRQUFJRyxZQUFnQixDQUFDdDhDLEVBQUUsSUFBRixFQUFRc29CLElBQVIsQ0FBYSxhQUFiLENBQXJCO0FBQUEsUUFDQWkwQixlQUFvQixDQUFDdjhDLEVBQUUsSUFBRixFQUFRODlCLEdBQVIsR0FBY3A2QixNQURuQztBQUFBLFFBRUE4NEMsZ0JBQW9CRCxnQkFBZ0JELFNBRnBDOztBQUlBdDhDLE1BQUUsSUFBRixFQUFROHFCLE1BQVIsR0FBaUJMLElBQWpCLENBQXNCLGlDQUF0QixFQUNpQmdMLElBRGpCLENBQ3VCOG1CLGVBQWUsR0FBZixHQUFxQkQsU0FENUM7O0FBR0FHLGtCQUFjRCxhQUFkLEVBQTZCeDhDLEVBQUUsSUFBRixDQUE3QjtBQUNEOztBQUVELFdBQVNxOEMsaUJBQVQsQ0FBMkJsYyxNQUEzQixFQUFtQztBQUNqQyxRQUFJOGIsa0JBQWtCOWIsT0FBT3JWLE1BQVAsR0FBZ0JMLElBQWhCLENBQXFCLGlDQUFyQixDQUF0Qjs7QUFFQSxRQUFJd3hCLGdCQUFnQnY0QyxNQUFwQixFQUE0QjtBQUMxQjtBQUNEOztBQUVEdTRDLHNCQUFrQmo4QyxFQUFFLFNBQUYsRUFDRzhSLFFBREgsQ0FDWSxtQkFEWixFQUVHTSxHQUZILENBRU8sT0FGUCxFQUVlLE9BRmYsRUFHR0EsR0FISCxDQUdPLFdBSFAsRUFHbUIsTUFIbkIsRUFJR0EsR0FKSCxDQUlPLFFBSlAsRUFJaUIsQ0FKakIsQ0FBbEI7O0FBTUErdEIsV0FBT3JWLE1BQVAsR0FBZ0J1RixNQUFoQixDQUF1QjRyQixlQUF2QjtBQUNEOztBQUVELFdBQVNHLG9CQUFULEdBQStCO0FBQzdCcDhDLE1BQUUsSUFBRixFQUFROHFCLE1BQVIsR0FBaUJMLElBQWpCLENBQXNCLGlDQUF0QixFQUF5RGdMLElBQXpELENBQThELEVBQTlEO0FBQ0Q7O0FBRUQsV0FBU2duQixhQUFULENBQXVCRCxhQUF2QixFQUFzQ3JjLE1BQXRDLEVBQTZDO0FBQzNDLFFBQUl1Yyx1QkFBdUJ2YyxPQUFPdFYsUUFBUCxDQUFnQixTQUFoQixDQUEzQjtBQUNBLFFBQUkyeEIsaUJBQWlCRSxvQkFBckIsRUFBMkM7QUFDekN2YyxhQUFPMTBCLFdBQVAsQ0FBbUIsU0FBbkI7QUFDRCxLQUZELE1BR0ssSUFBRyxDQUFDK3dDLGFBQUQsSUFBa0IsQ0FBQ0Usb0JBQXRCLEVBQTJDO0FBQzlDdmMsYUFBTzEwQixXQUFQLENBQW1CLE9BQW5CO0FBQ0EwMEIsYUFBT3J1QixRQUFQLENBQWdCLFNBQWhCO0FBQ0Q7QUFDRjs7QUFFRDlSLElBQUVnRyxRQUFGLEVBQVlrbUIsS0FBWixDQUFrQixZQUFVO0FBQzFCbHNCLE1BQUUsaUJBQUYsRUFBcUJnOEMsZ0JBQXJCO0FBQ0QsR0FGRDtBQUlELENBdkVDLEVBdUVDajhDLE1BdkVELENBQUQ7QUF3RUQsQ0FBRSxXQUFVQyxDQUFWLEVBQWE7O0FBRWIsTUFBSW12QixVQUFVOztBQUVabnJCLFVBQU8sY0FBU2dTLE9BQVQsRUFBa0I7QUFDdkIsVUFBSTlNLFdBQVc7QUFDYkcsa0JBQVUsR0FERyxFQUNFO0FBQ2ZzekMsY0FBTSxDQUFDLEdBRk0sRUFFRDtBQUNabjNDLGVBQU8sQ0FITSxFQUdIO0FBQ1Z5a0MsaUJBQVMsQ0FKSSxFQUlEO0FBQ1pwVixtQkFBVyxLQUxFLEVBS0s7QUFDbEJxUCxvQkFBWSxLQU5DLEVBTU07QUFDbkJwUCxnQkFBUSxLQVBLLEVBT0U7QUFDZkMsbUJBQVcsSUFSRSxDQVFHO0FBUkgsT0FBZjtBQVVBL2UsZ0JBQVVoVyxFQUFFRyxNQUFGLENBQVMrSSxRQUFULEVBQW1COE0sT0FBbkIsQ0FBVjtBQUNBLFVBQUlzZCxZQUFZMUwsWUFBWUssb0JBQVosQ0FBaUNqb0IsRUFBRSxJQUFGLENBQWpDLENBQWhCOztBQUVBLGFBQU8sS0FBSzJFLElBQUwsQ0FBVSxVQUFTUixDQUFULEVBQVk7O0FBRTNCLFlBQUlvdkIsa0JBQWtCRCxZQUFVbnZCLENBQWhDO0FBQ0EsWUFBSXk0QyxNQUFKLEVBQVlDLFVBQVosRUFBd0JDLFdBQXhCLEVBQXFDbjNDLE1BQXJDLEVBQTZDMlQsTUFBN0MsRUFBcURrQyxPQUFyRCxFQUE4RHVoQyxHQUE5RCxFQUFtRWgrQixLQUFuRSxFQUNJaStCLFNBREosRUFDZUMsVUFEZixFQUMyQkMsU0FEM0IsRUFDc0NybEMsTUFEdEMsRUFDOENoTCxRQUQ5QyxFQUN3RHN3QyxTQUR4RCxFQUVJQyxLQUZKLEVBRVdyTyxLQUZYLEVBRWtCc08sU0FGbEIsRUFFNkJDLE1BRjdCLEVBRXFDQyxPQUZyQyxFQUU4Q0MsZ0JBRjlDO0FBR0EsWUFBSWxaLGNBQWN0a0MsRUFBRSw4QkFBRixDQUFsQjtBQUNBLFlBQUl5OUMsbUJBQW1CLElBQXZCOztBQUdBO0FBQ0EsWUFBSWpMLE9BQU94eUMsRUFBRSxJQUFGLENBQVg7QUFDQSxZQUFJMDlDLGlCQUFpQmxMLEtBQUtscUIsSUFBTCxDQUFVLGlCQUFWLEtBQWdDdFMsUUFBUWt1QixVQUE3RDs7QUFHQTtBQUNBLFlBQUl5WixvQkFBb0IsU0FBcEJBLGlCQUFvQixHQUFXO0FBQ2pDLGNBQUlDLGFBQWFwTCxLQUFLL25CLElBQUwsQ0FBVSxvQkFBVixFQUFnQ3dCLEtBQWhDLEVBQWpCO0FBQ0EsY0FBSTJ4QixXQUFXbDZDLE1BQWYsRUFBdUI7QUFDckIsZ0JBQUlrNkMsV0FBV3gxQixJQUFYLENBQWdCLFVBQWhCLENBQUosRUFBaUM7QUFDL0JvcUIsbUJBQUtwZ0MsR0FBTCxDQUFTLFFBQVQsRUFBbUJ3ckMsV0FBV2xuQyxNQUFYLEVBQW5CO0FBQ0QsYUFGRCxNQUVPO0FBQ0xrbkMseUJBQVduNUIsRUFBWCxDQUFjLE1BQWQsRUFBc0IsWUFBVTtBQUM5Qit0QixxQkFBS3BnQyxHQUFMLENBQVMsUUFBVCxFQUFtQnBTLEVBQUUsSUFBRixFQUFRMFcsTUFBUixFQUFuQjtBQUNELGVBRkQ7QUFHRDtBQUNGLFdBUkQsTUFRTztBQUNMLGdCQUFJbW5DLGNBQWNyTCxLQUFLL25CLElBQUwsQ0FBVSxnQkFBVixFQUE0QndCLEtBQTVCLEdBQW9DdlYsTUFBcEMsRUFBbEI7QUFDQTg3QixpQkFBS3BnQyxHQUFMLENBQVMsUUFBVCxFQUFtQnlyQyxXQUFuQjtBQUNEO0FBQ0YsU0FkRDs7QUFnQkEsWUFBSTduQyxRQUFRNmUsU0FBWixFQUF1QjtBQUNyQjdlLGtCQUFRMm1DLElBQVIsR0FBZSxDQUFmO0FBQ0FnQjs7QUFFQTtBQUNBLGNBQUlELGNBQUosRUFBb0I7QUFDbEJsTCxpQkFBSy9uQixJQUFMLENBQVUsc0JBQVYsRUFBa0MzWSxRQUFsQyxDQUEyQyxpQkFBM0M7QUFDRDtBQUNGOztBQUdEO0FBQ0EsWUFBSTBnQyxLQUFLM25CLFFBQUwsQ0FBYyxhQUFkLENBQUosRUFBa0M7QUFDaEM7QUFDQTdxQixZQUFFaUUsTUFBRixFQUFVeWpCLE9BQVYsQ0FBa0IsUUFBbEI7O0FBRUE7QUFDQTFuQixZQUFFLElBQUYsRUFBUTBuQixPQUFSLENBQWdCLGNBQWhCLEVBQWdDLENBQUMsUUFBRCxDQUFoQztBQUNBLGlCQUFPLElBQVA7QUFDRDs7QUFHRDhxQixhQUFLMWdDLFFBQUwsQ0FBYyxhQUFkO0FBQ0EwSixrQkFBVSxLQUFWO0FBQ0E3VixpQkFBU2tTLFNBQVMsQ0FBbEI7QUFDQStrQyxpQkFBUyxFQUFUO0FBQ0FDLHFCQUFhckssS0FBSy9uQixJQUFMLENBQVUsZ0JBQVYsRUFBNEJ3QixLQUE1QixHQUFvQzVYLFVBQXBDLEVBQWI7QUFDQXlvQyxzQkFBY3RLLEtBQUsvbkIsSUFBTCxDQUFVLGdCQUFWLEVBQTRCd0IsS0FBNUIsR0FBb0MxWCxXQUFwQyxFQUFkO0FBQ0F3b0MsY0FBTUYsYUFBYSxDQUFiLEdBQWlCN21DLFFBQVFpMEIsT0FBL0I7O0FBRUF1SSxhQUFLL25CLElBQUwsQ0FBVSxnQkFBVixFQUE0QjlsQixJQUE1QixDQUFpQyxVQUFVUixDQUFWLEVBQWE7QUFDNUN5NEMsaUJBQU90M0MsSUFBUCxDQUFZdEYsRUFBRSxJQUFGLEVBQVEsQ0FBUixDQUFaO0FBQ0EsY0FBSTA5QyxjQUFKLEVBQW9CO0FBQ2xCLGdCQUFJM3BCLGFBQWEvekIsRUFBRSxrQ0FBRixDQUFqQjs7QUFFQTtBQUNBLGdCQUFJbUUsTUFBTSxDQUFWLEVBQWE7QUFDWDR2Qix5QkFBV2ppQixRQUFYLENBQW9CLFFBQXBCO0FBQ0Q7O0FBRUQ7QUFDQWlpQix1QkFBV3pELEtBQVgsQ0FBaUIsVUFBVTdzQixDQUFWLEVBQWE7QUFDNUJBLGdCQUFFbXBCLGVBQUY7O0FBRUEsa0JBQUlvSCxRQUFRaDBCLEVBQUUsSUFBRixFQUFRZzBCLEtBQVIsRUFBWjtBQUNBOHBCLHNCQUFROXBCLEtBQVI7QUFDRCxhQUxEO0FBTUFzUSx3QkFBWWpVLE1BQVosQ0FBbUIwRCxVQUFuQjtBQUNEO0FBQ0YsU0FuQkQ7O0FBcUJBLFlBQUkycEIsY0FBSixFQUFvQjtBQUNsQmxMLGVBQUtuaUIsTUFBTCxDQUFZaVUsV0FBWjtBQUNEO0FBQ0R2bEIsZ0JBQVE2OUIsT0FBT2w1QyxNQUFmOztBQUdBLGlCQUFTcTZDLFdBQVQsR0FBdUI7QUFDckIsY0FBSSxPQUFPOTVDLE9BQU8rNUMsWUFBZCxLQUErQixXQUFuQyxFQUFnRDtBQUM5Q3hMLGlCQUFLLENBQUwsRUFBUS83QixnQkFBUixDQUF5QixZQUF6QixFQUF1Q3duQyxHQUF2QztBQUNBekwsaUJBQUssQ0FBTCxFQUFRLzdCLGdCQUFSLENBQXlCLFdBQXpCLEVBQXNDSCxJQUF0QztBQUNBazhCLGlCQUFLLENBQUwsRUFBUS83QixnQkFBUixDQUF5QixVQUF6QixFQUFxQ3luQyxPQUFyQztBQUNEO0FBQ0QxTCxlQUFLLENBQUwsRUFBUS83QixnQkFBUixDQUF5QixXQUF6QixFQUFzQ3duQyxHQUF0QztBQUNBekwsZUFBSyxDQUFMLEVBQVEvN0IsZ0JBQVIsQ0FBeUIsV0FBekIsRUFBc0NILElBQXRDO0FBQ0FrOEIsZUFBSyxDQUFMLEVBQVEvN0IsZ0JBQVIsQ0FBeUIsU0FBekIsRUFBb0N5bkMsT0FBcEM7QUFDQTFMLGVBQUssQ0FBTCxFQUFRLzdCLGdCQUFSLENBQXlCLFlBQXpCLEVBQXVDeW5DLE9BQXZDO0FBQ0ExTCxlQUFLLENBQUwsRUFBUS83QixnQkFBUixDQUF5QixPQUF6QixFQUFrQzZaLEtBQWxDO0FBQ0Q7O0FBRUQsaUJBQVM2dEIsSUFBVCxDQUFjMTZDLENBQWQsRUFBaUI7QUFDZjtBQUNBLGNBQUlBLEVBQUUyNkMsYUFBRixJQUFvQjM2QyxFQUFFMjZDLGFBQUYsQ0FBZ0IxNkMsTUFBaEIsSUFBMEIsQ0FBbEQsRUFBc0Q7QUFDcEQsbUJBQU9ELEVBQUUyNkMsYUFBRixDQUFnQixDQUFoQixFQUFtQnRqQyxPQUExQjtBQUNEOztBQUVEO0FBQ0EsaUJBQU9yWCxFQUFFcVgsT0FBVDtBQUNEOztBQUVELGlCQUFTdWpDLElBQVQsQ0FBYzU2QyxDQUFkLEVBQWlCO0FBQ2Y7QUFDQSxjQUFJQSxFQUFFMjZDLGFBQUYsSUFBb0IzNkMsRUFBRTI2QyxhQUFGLENBQWdCMTZDLE1BQWhCLElBQTBCLENBQWxELEVBQXNEO0FBQ3BELG1CQUFPRCxFQUFFMjZDLGFBQUYsQ0FBZ0IsQ0FBaEIsRUFBbUJyakMsT0FBMUI7QUFDRDs7QUFFRDtBQUNBLGlCQUFPdFgsRUFBRXNYLE9BQVQ7QUFDRDs7QUFFRCxpQkFBU3VXLElBQVQsQ0FBY2h4QixDQUFkLEVBQWlCO0FBQ2YsaUJBQVFBLEtBQUt5ZSxLQUFOLEdBQWdCemUsSUFBSXllLEtBQXBCLEdBQThCemUsSUFBSSxDQUFMLEdBQVVneEIsS0FBS3ZTLFFBQVN6ZSxJQUFJeWUsS0FBbEIsQ0FBVixHQUFzQ3plLENBQTFFO0FBQ0Q7O0FBRUQsaUJBQVNxVSxNQUFULENBQWdCclUsQ0FBaEIsRUFBbUI7QUFDakI7QUFDQTY4QyxzQkFBWSxJQUFaO0FBQ0EsY0FBSSxDQUFDM0ssS0FBSzNuQixRQUFMLENBQWMsV0FBZCxDQUFMLEVBQWlDO0FBQy9CMm5CLGlCQUFLMWdDLFFBQUwsQ0FBYyxXQUFkO0FBQ0Q7QUFDRCxjQUFJMnJDLG9CQUFvQixJQUF4QixFQUE4QjtBQUM1Qng1QyxtQkFBT2lTLFlBQVAsQ0FBb0J1bkMsZ0JBQXBCO0FBQ0Q7QUFDREEsNkJBQW1CeDVDLE9BQU8wSCxVQUFQLENBQWtCLFlBQVc7QUFDOUN3eEMsd0JBQVksS0FBWjtBQUNBM0ssaUJBQUsvbUMsV0FBTCxDQUFpQixXQUFqQjtBQUNELFdBSGtCLEVBR2hCdUssUUFBUTNNLFFBSFEsQ0FBbkI7O0FBS0E7QUFDQSxjQUFJbEYsQ0FBSixFQUFPbTZDLElBQVAsRUFBYUMsS0FBYixFQUFvQkMsR0FBcEIsRUFBeUJDLEtBQXpCLEVBQWdDbjNCLEVBQWhDLEVBQW9DcUYsU0FBcEMsRUFBK0MreEIsWUFBL0M7QUFDQSxjQUFJQyxhQUFhcmxDLE1BQWpCOztBQUVBM1QsbUJBQVUsT0FBT3JGLENBQVAsS0FBYSxRQUFkLEdBQTBCQSxDQUExQixHQUE4QnFGLE1BQXZDO0FBQ0EyVCxtQkFBUzlYLEtBQUtrbkIsS0FBTCxDQUFXLENBQUMvaUIsU0FBU28zQyxNQUFNLENBQWhCLElBQXFCQSxHQUFoQyxDQUFUO0FBQ0F3QixrQkFBUTU0QyxTQUFTMlQsU0FBU3lqQyxHQUExQjtBQUNBeUIsZ0JBQU9ELFFBQVEsQ0FBVCxHQUFjLENBQWQsR0FBa0IsQ0FBQyxDQUF6QjtBQUNBRSxrQkFBUSxDQUFDRCxHQUFELEdBQU9ELEtBQVAsR0FBZSxDQUFmLEdBQW1CeEIsR0FBM0I7QUFDQXVCLGlCQUFPdi9CLFNBQVMsQ0FBaEI7O0FBRUEsY0FBSSxDQUFDL0ksUUFBUTZlLFNBQWIsRUFBd0I7QUFDdEJsSSx3QkFBWSxnQkFBZ0IsQ0FBQzZsQixLQUFLLENBQUwsRUFBUXJrQixXQUFSLEdBQXNCMHVCLFVBQXZCLElBQXFDLENBQXJELEdBQXlELE1BQXJFO0FBQ0Fsd0IseUJBQWEsZ0JBQWdCLENBQUM2bEIsS0FBSyxDQUFMLEVBQVF2a0IsWUFBUixHQUF1QjZ1QixXQUF4QixJQUF1QyxDQUF2RCxHQUEyRCxLQUF4RTtBQUNELFdBSEQsTUFHTztBQUNMbndCLHdCQUFZLGVBQVo7QUFDRDs7QUFFRDtBQUNBLGNBQUkrd0IsY0FBSixFQUFvQjtBQUNsQixnQkFBSXZrQixPQUFRN2YsU0FBU3lGLEtBQXJCO0FBQ0EsZ0JBQUk2L0Isa0JBQWtCdGEsWUFBWTdaLElBQVosQ0FBaUIsd0JBQWpCLENBQXRCO0FBQ0EsZ0JBQUltMEIsZ0JBQWdCNXFCLEtBQWhCLE9BQTRCbUYsSUFBaEMsRUFBc0M7QUFDcEN5bEIsOEJBQWdCbnpDLFdBQWhCLENBQTRCLFFBQTVCO0FBQ0E2NEIsMEJBQVk3WixJQUFaLENBQWlCLGlCQUFqQixFQUFvQ3VCLEVBQXBDLENBQXVDbU4sSUFBdkMsRUFBNkNybkIsUUFBN0MsQ0FBc0QsUUFBdEQ7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQSxjQUFJLENBQUNrRSxRQUFROGUsTUFBVCxJQUFvQnhiLFVBQVUsQ0FBVixJQUFlQSxTQUFTeUYsS0FBaEQsRUFBd0Q7QUFDdER1SSxpQkFBS3MxQixPQUFPdHJCLEtBQUtoWSxNQUFMLENBQVAsQ0FBTDs7QUFFQTtBQUNBLGdCQUFJLENBQUN0WixFQUFFc25CLEVBQUYsRUFBTXVELFFBQU4sQ0FBZSxRQUFmLENBQUwsRUFBK0I7QUFDN0IybkIsbUJBQUsvbkIsSUFBTCxDQUFVLGdCQUFWLEVBQTRCaGYsV0FBNUIsQ0FBd0MsUUFBeEM7QUFDQXpMLGdCQUFFc25CLEVBQUYsRUFBTXhWLFFBQU4sQ0FBZSxRQUFmO0FBQ0Q7QUFDRHdWLGVBQUc3Z0IsS0FBSCxDQUFTMjJDLEtBQVQsSUFBa0J6d0IsWUFDaEIsY0FEZ0IsR0FDRSxDQUFDNHhCLEtBQUQsR0FBUyxDQURYLEdBQ2dCLEtBRGhCLEdBRWhCLGNBRmdCLEdBRUVDLE1BQU14b0MsUUFBUXhRLEtBQWQsR0FBc0JpNUMsS0FBdEIsR0FBOEJ0NkMsQ0FGaEMsR0FFcUMsS0FGckMsR0FHaEIsY0FIZ0IsR0FHRTZSLFFBQVEybUMsSUFBUixHQUFlOEIsS0FIakIsR0FHMEIsS0FINUM7QUFJQW4zQixlQUFHN2dCLEtBQUgsQ0FBU280QyxNQUFULEdBQWtCLENBQWxCO0FBQ0EsZ0JBQUk3b0MsUUFBUTZlLFNBQVosRUFBdUI7QUFBRWlxQiwrQkFBaUIsQ0FBakI7QUFBcUIsYUFBOUMsTUFDSztBQUFFQSwrQkFBaUIsSUFBSSxNQUFNTCxLQUEzQjtBQUFtQztBQUMxQ24zQixlQUFHN2dCLEtBQUgsQ0FBU2lLLE9BQVQsR0FBbUJvdUMsY0FBbkI7QUFDQXgzQixlQUFHN2dCLEtBQUgsQ0FBUzhDLE9BQVQsR0FBbUIsT0FBbkI7QUFDRDs7QUFFRCxlQUFLcEYsSUFBSSxDQUFULEVBQVlBLEtBQUttNkMsSUFBakIsRUFBdUIsRUFBRW42QyxDQUF6QixFQUE0QjtBQUMxQjtBQUNBLGdCQUFJNlIsUUFBUTZlLFNBQVosRUFBdUI7QUFDckJrcUIsNkJBQWUvb0MsUUFBUTJtQyxJQUF2QjtBQUNBbUMsK0JBQWtCMzZDLE1BQU1tNkMsSUFBTixJQUFjQyxRQUFRLENBQXZCLEdBQTRCLElBQUlFLEtBQWhDLEdBQXdDLENBQXpEO0FBQ0QsYUFIRCxNQUdPO0FBQ0xNLDZCQUFlL29DLFFBQVEybUMsSUFBUixJQUFnQng0QyxJQUFJLENBQUosR0FBUXM2QyxRQUFRRCxHQUFoQyxDQUFmO0FBQ0FNLCtCQUFpQixJQUFJLE9BQU8zNkMsSUFBSSxDQUFKLEdBQVFzNkMsUUFBUUQsR0FBdkIsQ0FBckI7QUFDRDtBQUNEO0FBQ0EsZ0JBQUksQ0FBQ3hvQyxRQUFROGUsTUFBVCxJQUFtQnhiLFNBQVNuVixDQUFULEdBQWE0YSxLQUFwQyxFQUEyQztBQUN6Q3VJLG1CQUFLczFCLE9BQU90ckIsS0FBS2hZLFNBQVNuVixDQUFkLENBQVAsQ0FBTDtBQUNBbWpCLGlCQUFHN2dCLEtBQUgsQ0FBUzIyQyxLQUFULElBQWtCendCLFlBQ2hCLGNBRGdCLElBQ0UzVyxRQUFReFEsS0FBUixHQUFnQixDQUFDdTNDLE1BQU01NEMsQ0FBTixHQUFVbzZDLEtBQVgsSUFBb0IsQ0FEdEMsSUFDMkMsS0FEM0MsR0FFaEIsY0FGZ0IsR0FFQ1EsWUFGRCxHQUVnQixLQUZsQztBQUdBejNCLGlCQUFHN2dCLEtBQUgsQ0FBU280QyxNQUFULEdBQWtCLENBQUMxNkMsQ0FBbkI7QUFDQW1qQixpQkFBRzdnQixLQUFILENBQVNpSyxPQUFULEdBQW1Cb3VDLGNBQW5CO0FBQ0F4M0IsaUJBQUc3Z0IsS0FBSCxDQUFTOEMsT0FBVCxHQUFtQixPQUFuQjtBQUNEOztBQUdEO0FBQ0EsZ0JBQUl5TSxRQUFRNmUsU0FBWixFQUF1QjtBQUNyQmtxQiw2QkFBZS9vQyxRQUFRMm1DLElBQXZCO0FBQ0FtQywrQkFBa0IzNkMsTUFBTW02QyxJQUFOLElBQWNDLFFBQVEsQ0FBdkIsR0FBNEIsSUFBSUUsS0FBaEMsR0FBd0MsQ0FBekQ7QUFDRCxhQUhELE1BR087QUFDTE0sNkJBQWUvb0MsUUFBUTJtQyxJQUFSLElBQWdCeDRDLElBQUksQ0FBSixHQUFRczZDLFFBQVFELEdBQWhDLENBQWY7QUFDQU0sK0JBQWlCLElBQUksT0FBTzM2QyxJQUFJLENBQUosR0FBUXM2QyxRQUFRRCxHQUF2QixDQUFyQjtBQUNEO0FBQ0Q7QUFDQSxnQkFBSSxDQUFDeG9DLFFBQVE4ZSxNQUFULElBQW1CeGIsU0FBU25WLENBQVQsSUFBYyxDQUFyQyxFQUF3QztBQUN0Q21qQixtQkFBS3MxQixPQUFPdHJCLEtBQUtoWSxTQUFTblYsQ0FBZCxDQUFQLENBQUw7QUFDQW1qQixpQkFBRzdnQixLQUFILENBQVMyMkMsS0FBVCxJQUFrQnp3QixZQUNoQixjQURnQixJQUNFLENBQUMzVyxRQUFReFEsS0FBVCxHQUFpQixDQUFDLENBQUN1M0MsR0FBRCxHQUFPNTRDLENBQVAsR0FBV282QyxLQUFaLElBQXFCLENBRHhDLElBQzZDLEtBRDdDLEdBRWhCLGNBRmdCLEdBRUNRLFlBRkQsR0FFZ0IsS0FGbEM7QUFHQXozQixpQkFBRzdnQixLQUFILENBQVNvNEMsTUFBVCxHQUFrQixDQUFDMTZDLENBQW5CO0FBQ0FtakIsaUJBQUc3Z0IsS0FBSCxDQUFTaUssT0FBVCxHQUFtQm91QyxjQUFuQjtBQUNBeDNCLGlCQUFHN2dCLEtBQUgsQ0FBUzhDLE9BQVQsR0FBbUIsT0FBbkI7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQSxjQUFJLENBQUN5TSxRQUFROGUsTUFBVCxJQUFvQnhiLFVBQVUsQ0FBVixJQUFlQSxTQUFTeUYsS0FBaEQsRUFBd0Q7QUFDdER1SSxpQkFBS3MxQixPQUFPdHJCLEtBQUtoWSxNQUFMLENBQVAsQ0FBTDtBQUNBZ08sZUFBRzdnQixLQUFILENBQVMyMkMsS0FBVCxJQUFrQnp3QixZQUNoQixjQURnQixHQUNFLENBQUM0eEIsS0FBRCxHQUFTLENBRFgsR0FDZ0IsS0FEaEIsR0FFaEIsY0FGZ0IsR0FFRUMsTUFBTXhvQyxRQUFReFEsS0FBZCxHQUFzQmk1QyxLQUZ4QixHQUVpQyxLQUZqQyxHQUdoQixjQUhnQixHQUdFem9DLFFBQVEybUMsSUFBUixHQUFlOEIsS0FIakIsR0FHMEIsS0FINUM7QUFJQW4zQixlQUFHN2dCLEtBQUgsQ0FBU280QyxNQUFULEdBQWtCLENBQWxCO0FBQ0EsZ0JBQUk3b0MsUUFBUTZlLFNBQVosRUFBdUI7QUFBRWlxQiwrQkFBaUIsQ0FBakI7QUFBcUIsYUFBOUMsTUFDSztBQUFFQSwrQkFBaUIsSUFBSSxNQUFNTCxLQUEzQjtBQUFtQztBQUMxQ24zQixlQUFHN2dCLEtBQUgsQ0FBU2lLLE9BQVQsR0FBbUJvdUMsY0FBbkI7QUFDQXgzQixlQUFHN2dCLEtBQUgsQ0FBUzhDLE9BQVQsR0FBbUIsT0FBbkI7QUFDRDs7QUFFRDtBQUNBLGNBQUlvMUMsZUFBZXJsQyxNQUFmLElBQ0EsT0FBT3RELFFBQVErZSxTQUFmLEtBQThCLFVBRGxDLEVBQzhDO0FBQzVDLGdCQUFJaXFCLGFBQWF4TSxLQUFLL25CLElBQUwsQ0FBVSxnQkFBVixFQUE0QnVCLEVBQTVCLENBQStCc0YsS0FBS2hZLE1BQUwsQ0FBL0IsQ0FBakI7QUFDQXRELG9CQUFRK2UsU0FBUixDQUFrQjN3QixJQUFsQixDQUF1QixJQUF2QixFQUE2QjQ2QyxVQUE3QixFQUF5Q3pCLE9BQXpDO0FBQ0Q7QUFDRjs7QUFFRCxpQkFBUzBCLEtBQVQsR0FBaUI7QUFDZixjQUFJai9CLEdBQUosRUFBU2svQixPQUFULEVBQWtCWCxLQUFsQixFQUF5QnQyQyxDQUF6Qjs7QUFFQStYLGdCQUFNL1ksS0FBSytZLEdBQUwsRUFBTjtBQUNBay9CLG9CQUFVbC9CLE1BQU1xOUIsU0FBaEI7QUFDQUEsc0JBQVlyOUIsR0FBWjtBQUNBdStCLGtCQUFRNTRDLFNBQVNvcEMsS0FBakI7QUFDQUEsa0JBQVFwcEMsTUFBUjs7QUFFQXNDLGNBQUksT0FBT3MyQyxLQUFQLElBQWdCLElBQUlXLE9BQXBCLENBQUo7QUFDQXJ5QyxxQkFBVyxNQUFNNUUsQ0FBTixHQUFVLE1BQU00RSxRQUEzQjtBQUNEOztBQUVELGlCQUFTc3lDLFVBQVQsR0FBc0I7QUFDcEIsY0FBSUQsT0FBSixFQUFhWCxLQUFiOztBQUVBLGNBQUlyQixTQUFKLEVBQWU7QUFDYmdDLHNCQUFVajRDLEtBQUsrWSxHQUFMLEtBQWFxOUIsU0FBdkI7QUFDQWtCLG9CQUFRckIsWUFBWTE3QyxLQUFLME4sR0FBTCxDQUFTLENBQUNnd0MsT0FBRCxHQUFXbHBDLFFBQVEzTSxRQUE1QixDQUFwQjtBQUNBLGdCQUFJazFDLFFBQVEsQ0FBUixJQUFhQSxRQUFRLENBQUMsQ0FBMUIsRUFBNkI7QUFDekI1cEMscUJBQU9rRCxTQUFTMG1DLEtBQWhCO0FBQ0Fob0Msb0NBQXNCNG9DLFVBQXRCO0FBQ0gsYUFIRCxNQUdPO0FBQ0h4cUMscUJBQU9rRCxNQUFQO0FBQ0g7QUFDRjtBQUNGOztBQUVELGlCQUFTeVksS0FBVCxDQUFlN3NCLENBQWYsRUFBa0I7QUFDaEI7QUFDQSxjQUFJODVDLE9BQUosRUFBYTtBQUNYOTVDLGNBQUU2ZSxjQUFGO0FBQ0E3ZSxjQUFFbXBCLGVBQUY7QUFDQSxtQkFBTyxLQUFQO0FBRUQsV0FMRCxNQUtPLElBQUksQ0FBQzVXLFFBQVE2ZSxTQUFiLEVBQXdCO0FBQzdCLGdCQUFJdXFCLGVBQWVwL0MsRUFBRXlELEVBQUVvVSxNQUFKLEVBQVlnVSxPQUFaLENBQW9CLGdCQUFwQixFQUFzQ21JLEtBQXRDLEVBQW5CO0FBQ0EsZ0JBQUltRixPQUFRN2YsU0FBU3lGLEtBQVYsR0FBbUJxZ0MsWUFBOUI7O0FBRUE7QUFDQSxnQkFBSWptQixTQUFTLENBQWIsRUFBZ0I7QUFDZDExQixnQkFBRTZlLGNBQUY7QUFDQTdlLGdCQUFFbXBCLGVBQUY7QUFDRDtBQUNEa3hCLG9CQUFRc0IsWUFBUjtBQUNEO0FBQ0Y7O0FBRUQsaUJBQVN0QixPQUFULENBQWlCNTVDLENBQWpCLEVBQW9CO0FBQ2xCLGNBQUlpMUIsT0FBUTdmLFNBQVN5RixLQUFWLEdBQW1CN2EsQ0FBOUI7O0FBRUE7QUFDQSxjQUFJLENBQUM4UixRQUFROGUsTUFBYixFQUFxQjtBQUNuQixnQkFBSXFFLE9BQU8sQ0FBWCxFQUFjO0FBQ1osa0JBQUkzM0IsS0FBS2tCLEdBQUwsQ0FBU3kyQixPQUFPcGEsS0FBaEIsSUFBeUJ2ZCxLQUFLa0IsR0FBTCxDQUFTeTJCLElBQVQsQ0FBN0IsRUFBNkM7QUFBRUEsd0JBQVFwYSxLQUFSO0FBQWdCO0FBRWhFLGFBSEQsTUFHTyxJQUFJb2EsT0FBTyxDQUFYLEVBQWM7QUFDbkIsa0JBQUkzM0IsS0FBS2tCLEdBQUwsQ0FBU3kyQixPQUFPcGEsS0FBaEIsSUFBeUJvYSxJQUE3QixFQUFtQztBQUFFQSx3QkFBUXBhLEtBQVI7QUFBZ0I7QUFDdEQ7QUFDRjs7QUFFRDtBQUNBLGNBQUlvYSxPQUFPLENBQVgsRUFBYztBQUNacVosaUJBQUs5cUIsT0FBTCxDQUFhLGNBQWIsRUFBNkIsQ0FBQ2xtQixLQUFLa0IsR0FBTCxDQUFTeTJCLElBQVQsQ0FBRCxDQUE3QjtBQUVELFdBSEQsTUFHTyxJQUFJQSxPQUFPLENBQVgsRUFBYztBQUNuQnFaLGlCQUFLOXFCLE9BQUwsQ0FBYSxjQUFiLEVBQTZCLENBQUN5UixJQUFELENBQTdCO0FBQ0Q7QUFDRjs7QUFFRCxpQkFBUzhrQixHQUFULENBQWF4NkMsQ0FBYixFQUFnQjtBQUNkQSxZQUFFNmUsY0FBRjtBQUNBOUcsb0JBQVUsSUFBVjtBQUNBK2hDLG9CQUFVLEtBQVY7QUFDQUMsNkJBQW1CLEtBQW5CO0FBQ0FSLHNCQUFZbUIsS0FBSzE2QyxDQUFMLENBQVo7QUFDQXc1Qyx1QkFBYW9CLEtBQUs1NkMsQ0FBTCxDQUFiOztBQUVBb0oscUJBQVdxd0MsWUFBWSxDQUF2QjtBQUNBbk8sa0JBQVFwcEMsTUFBUjtBQUNBMDNDLHNCQUFZcDJDLEtBQUsrWSxHQUFMLEVBQVo7QUFDQTJhLHdCQUFjMmlCLE1BQWQ7QUFDQUEsbUJBQVM1aUIsWUFBWXVrQixLQUFaLEVBQW1CLEdBQW5CLENBQVQ7QUFDRDs7QUFFRCxpQkFBUzNvQyxJQUFULENBQWM3UyxDQUFkLEVBQWlCO0FBQ2YsY0FBSW5ELENBQUosRUFBT2krQyxLQUFQLEVBQWNya0MsTUFBZDtBQUNBLGNBQUlzQixPQUFKLEVBQWE7QUFDWGxiLGdCQUFJNjlDLEtBQUsxNkMsQ0FBTCxDQUFKO0FBQ0F5RSxnQkFBSW0yQyxLQUFLNTZDLENBQUwsQ0FBSjtBQUNBODZDLG9CQUFRdkIsWUFBWTE4QyxDQUFwQjtBQUNBNFoscUJBQVMxWSxLQUFLa0IsR0FBTCxDQUFTdTZDLGFBQWEvMEMsQ0FBdEIsQ0FBVDtBQUNBLGdCQUFJZ1MsU0FBUyxFQUFULElBQWUsQ0FBQ3NqQyxnQkFBcEIsRUFBc0M7QUFDcEM7QUFDQSxrQkFBSWUsUUFBUSxDQUFSLElBQWFBLFFBQVEsQ0FBQyxDQUExQixFQUE2QjtBQUMzQmhCLDBCQUFVLElBQVY7QUFDQVAsNEJBQVkxOEMsQ0FBWjtBQUNBcVUsdUJBQU9oUCxTQUFTNDRDLEtBQWhCO0FBQ0Q7QUFFRixhQVJELE1BUU8sSUFBSWhCLE9BQUosRUFBYTtBQUNsQjtBQUNBOTVDLGdCQUFFNmUsY0FBRjtBQUNBN2UsZ0JBQUVtcEIsZUFBRjtBQUNBLHFCQUFPLEtBQVA7QUFFRCxhQU5NLE1BTUE7QUFDTDtBQUNBNHdCLGlDQUFtQixJQUFuQjtBQUNEO0FBQ0Y7O0FBRUQsY0FBSUQsT0FBSixFQUFhO0FBQ1g7QUFDQTk1QyxjQUFFNmUsY0FBRjtBQUNBN2UsY0FBRW1wQixlQUFGO0FBQ0EsbUJBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsaUJBQVNzeEIsT0FBVCxDQUFpQno2QyxDQUFqQixFQUFvQjtBQUNsQixjQUFJK1gsT0FBSixFQUFhO0FBQ1hBLHNCQUFVLEtBQVY7QUFDRCxXQUZELE1BRU87QUFDTDtBQUNEOztBQUVEbWYsd0JBQWMyaUIsTUFBZDtBQUNBemxDLG1CQUFTbFMsTUFBVDtBQUNBLGNBQUlrSCxXQUFXLEVBQVgsSUFBaUJBLFdBQVcsQ0FBQyxFQUFqQyxFQUFxQztBQUNuQ3F3Qyx3QkFBWSxNQUFNcndDLFFBQWxCO0FBQ0FnTCxxQkFBU2xTLFNBQVN1M0MsU0FBbEI7QUFDRDtBQUNEcmxDLG1CQUFTclcsS0FBS3NHLEtBQUwsQ0FBVytQLFNBQVNrbEMsR0FBcEIsSUFBMkJBLEdBQXBDOztBQUVBO0FBQ0EsY0FBSS9tQyxRQUFROGUsTUFBWixFQUFvQjtBQUNsQixnQkFBSWpkLFVBQVVrbEMsT0FBT2grQixRQUFRLENBQWYsQ0FBZCxFQUFpQztBQUMvQmxILHVCQUFTa2xDLE9BQU9oK0IsUUFBUSxDQUFmLENBQVQ7QUFDRCxhQUZELE1BRU8sSUFBSWxILFNBQVMsQ0FBYixFQUFnQjtBQUNyQkEsdUJBQVMsQ0FBVDtBQUNEO0FBQ0Y7QUFDRHFsQyxzQkFBWXJsQyxTQUFTbFMsTUFBckI7QUFDQTAzQyxzQkFBWXAyQyxLQUFLK1ksR0FBTCxFQUFaO0FBQ0F6SixnQ0FBc0I0b0MsVUFBdEI7O0FBRUEsY0FBSTVCLE9BQUosRUFBYTtBQUNYOTVDLGNBQUU2ZSxjQUFGO0FBQ0E3ZSxjQUFFbXBCLGVBQUY7QUFDRDtBQUNELGlCQUFPLEtBQVA7QUFDRDs7QUFFRHd3QixnQkFBUSxXQUFSO0FBQ0EsU0FBQyxRQUFELEVBQVcsS0FBWCxFQUFrQixHQUFsQixFQUF1QixJQUF2QixFQUE2QmlDLEtBQTdCLENBQW1DLFVBQVVsUCxNQUFWLEVBQWtCO0FBQ25ELGNBQUkxc0MsSUFBSTBzQyxTQUFTLFdBQWpCO0FBQ0EsY0FBSSxPQUFPbnFDLFNBQVMwSSxJQUFULENBQWNqSSxLQUFkLENBQW9CaEQsQ0FBcEIsQ0FBUCxLQUFrQyxXQUF0QyxFQUFtRDtBQUNqRDI1QyxvQkFBUTM1QyxDQUFSO0FBQ0EsbUJBQU8sS0FBUDtBQUNEO0FBQ0QsaUJBQU8sSUFBUDtBQUNELFNBUEQ7O0FBVUF6RCxVQUFFaUUsTUFBRixFQUFVeWdCLEdBQVYsQ0FBYyxxQkFBbUI2TyxlQUFqQyxFQUFrRDlPLEVBQWxELENBQXFELHFCQUFtQjhPLGVBQXhFLEVBQXlGLFlBQVc7QUFDbEcsY0FBSXZkLFFBQVE2ZSxTQUFaLEVBQXVCO0FBQ3JCZ29CLHlCQUFhckssS0FBSy9uQixJQUFMLENBQVUsZ0JBQVYsRUFBNEJ3QixLQUE1QixHQUFvQzVYLFVBQXBDLEVBQWI7QUFDQXlvQywwQkFBY3RLLEtBQUsvbkIsSUFBTCxDQUFVLGdCQUFWLEVBQTRCd0IsS0FBNUIsR0FBb0MxWCxXQUFwQyxFQUFkO0FBQ0F3b0Msa0JBQU1GLGFBQWEsQ0FBYixHQUFpQjdtQyxRQUFRaTBCLE9BQS9CO0FBQ0F0a0MscUJBQVMyVCxTQUFTLENBQVQsR0FBYXVqQyxVQUF0QjtBQUNBaGxDLHFCQUFTbFMsTUFBVDtBQUNELFdBTkQsTUFNTztBQUNMZ1A7QUFDRDtBQUNGLFNBVkQ7O0FBWUFvcEM7QUFDQXBwQyxlQUFPaFAsTUFBUDs7QUFFQTNGLFVBQUUsSUFBRixFQUFReWtCLEVBQVIsQ0FBVyxjQUFYLEVBQTJCLFVBQVNoaEIsQ0FBVCxFQUFZUyxDQUFaLEVBQWU7QUFDeEMsY0FBSUEsTUFBTW5CLFNBQVYsRUFBcUI7QUFDbkJtQixnQkFBSSxDQUFKO0FBQ0Q7QUFDRDJULG1CQUFVa2xDLE1BQU12N0MsS0FBS3NHLEtBQUwsQ0FBV25DLFNBQVNvM0MsR0FBcEIsQ0FBUCxHQUFvQ0EsTUFBTTc0QyxDQUFuRDtBQUNBLGNBQUl5QixXQUFXa1MsTUFBZixFQUF1QjtBQUNyQnFsQyx3QkFBWXJsQyxTQUFTbFMsTUFBckI7QUFDQTAzQyx3QkFBWXAyQyxLQUFLK1ksR0FBTCxFQUFaO0FBQ0F6SixrQ0FBc0I0b0MsVUFBdEI7QUFDRDtBQUNGLFNBVkQ7O0FBWUFuL0MsVUFBRSxJQUFGLEVBQVF5a0IsRUFBUixDQUFXLGNBQVgsRUFBMkIsVUFBU2hoQixDQUFULEVBQVlTLENBQVosRUFBZTtBQUN4QyxjQUFJQSxNQUFNbkIsU0FBVixFQUFxQjtBQUNuQm1CLGdCQUFJLENBQUo7QUFDRDtBQUNEMlQsbUJBQVVrbEMsTUFBTXY3QyxLQUFLc0csS0FBTCxDQUFXbkMsU0FBU28zQyxHQUFwQixDQUFQLEdBQW9DQSxNQUFNNzRDLENBQW5EO0FBQ0EsY0FBSXlCLFdBQVdrUyxNQUFmLEVBQXVCO0FBQ3JCcWxDLHdCQUFZcmxDLFNBQVNsUyxNQUFyQjtBQUNBMDNDLHdCQUFZcDJDLEtBQUsrWSxHQUFMLEVBQVo7QUFDQXpKLGtDQUFzQjRvQyxVQUF0QjtBQUNEO0FBQ0YsU0FWRDs7QUFZQW4vQyxVQUFFLElBQUYsRUFBUXlrQixFQUFSLENBQVcsYUFBWCxFQUEwQixVQUFTaGhCLENBQVQsRUFBWVMsQ0FBWixFQUFlO0FBQ3ZDLGNBQUlBLE1BQU1uQixTQUFWLEVBQXFCO0FBQ25CbUIsZ0JBQUksQ0FBSjtBQUNEO0FBQ0Q0NUMsa0JBQVE1NUMsQ0FBUjtBQUNELFNBTEQ7QUFPRCxPQWhkTSxDQUFQO0FBb2RELEtBcGVXO0FBcWVaMFIsVUFBTyxjQUFTMVIsQ0FBVCxFQUFZO0FBQ2pCbEUsUUFBRSxJQUFGLEVBQVEwbkIsT0FBUixDQUFnQixjQUFoQixFQUFnQyxDQUFDeGpCLENBQUQsQ0FBaEM7QUFDRCxLQXZlVztBQXdlWjIvQixVQUFPLGNBQVMzL0IsQ0FBVCxFQUFZO0FBQ2pCbEUsUUFBRSxJQUFGLEVBQVEwbkIsT0FBUixDQUFnQixjQUFoQixFQUFnQyxDQUFDeGpCLENBQUQsQ0FBaEM7QUFDRCxLQTFlVztBQTJlWjJZLFNBQU0sYUFBUzNZLENBQVQsRUFBWTtBQUNoQmxFLFFBQUUsSUFBRixFQUFRMG5CLE9BQVIsQ0FBZ0IsYUFBaEIsRUFBK0IsQ0FBQ3hqQixDQUFELENBQS9CO0FBQ0Q7QUE3ZVcsR0FBZDs7QUFpZkVsRSxJQUFFK0QsRUFBRixDQUFLNndCLFFBQUwsR0FBZ0IsVUFBU2pFLGVBQVQsRUFBMEI7QUFDeEMsUUFBS3hCLFFBQVF3QixlQUFSLENBQUwsRUFBZ0M7QUFDOUIsYUFBT3hCLFFBQVN3QixlQUFULEVBQTJCL3JCLEtBQTNCLENBQWtDLElBQWxDLEVBQXdDTixNQUFNSSxTQUFOLENBQWdCaUQsS0FBaEIsQ0FBc0J2RCxJQUF0QixDQUE0QmEsU0FBNUIsRUFBdUMsQ0FBdkMsQ0FBeEMsQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFLLFFBQU8wckIsZUFBUCx5Q0FBT0EsZUFBUCxPQUEyQixRQUEzQixJQUF1QyxDQUFFQSxlQUE5QyxFQUFnRTtBQUNyRTtBQUNBLGFBQU94QixRQUFRbnJCLElBQVIsQ0FBYVksS0FBYixDQUFvQixJQUFwQixFQUEwQkssU0FBMUIsQ0FBUDtBQUNELEtBSE0sTUFHQTtBQUNMakYsUUFBRTR3QixLQUFGLENBQVMsWUFBYUQsZUFBYixHQUErQixvQ0FBeEM7QUFDRDtBQUNGLEdBVEQsQ0FuZlcsQ0E0ZlI7QUFDTixDQTdmQyxFQTZmQzV3QixNQTdmRCxDQUFELENBNmZZLENBQUUsV0FBVUMsQ0FBVixFQUFhOztBQUUxQixNQUFJbXZCLFVBQVU7QUFDZG5yQixVQUFNLGNBQVVnUyxPQUFWLEVBQW1CO0FBQ3ZCLGFBQU8sS0FBS3JSLElBQUwsQ0FBVSxZQUFXO0FBQzVCLFlBQUlrb0IsU0FBUzdzQixFQUFFLE1BQUlBLEVBQUUsSUFBRixFQUFRc29CLElBQVIsQ0FBYSxnQkFBYixDQUFOLENBQWI7QUFDQSxZQUFJZzNCLFNBQVN0L0MsRUFBRSxNQUFGLENBQWI7O0FBRUE7QUFDQSxZQUFJdS9DLGNBQWN2L0MsRUFBRSxJQUFGLENBQWxCO0FBQ0EsWUFBSXcvQyxtQkFBbUJELFlBQVl6MEIsTUFBWixDQUFtQixxQkFBbkIsQ0FBdkI7QUFDQSxZQUFJMjBCLGdCQUFnQkQsaUJBQWlCLzBCLElBQWpCLENBQXNCLGtCQUF0QixDQUFwQjtBQUNBLFlBQUlpMUIsb0JBQW9CRixpQkFBaUIvMEIsSUFBakIsQ0FBc0Isb0JBQXRCLENBQXhCO0FBQ0EsWUFBSWsxQixxQkFBcUJKLFlBQVk5MEIsSUFBWixDQUFpQixxQkFBakIsQ0FBekI7O0FBRUE7QUFDQSxZQUFJLENBQUMrMEIsaUJBQWlCOTdDLE1BQXRCLEVBQThCO0FBQzVCODdDLDZCQUFtQkQsWUFBWWp1QixJQUFaLENBQWlCdHhCLEVBQUUsd0NBQUYsQ0FBakIsRUFBOEQ4cUIsTUFBOUQsRUFBbkI7QUFDRDs7QUFFRDtBQUNBLFlBQUksQ0FBQzYwQixtQkFBbUJqOEMsTUFBeEIsRUFBZ0M7QUFDOUJpOEMsK0JBQXFCMy9DLEVBQUUsd0NBQUYsQ0FBckI7QUFDQXUvQyxzQkFBWWx2QixNQUFaLENBQW1Cc3ZCLGtCQUFuQjtBQUNEOztBQUVEO0FBQ0EsWUFBSSxDQUFDRixjQUFjLzdDLE1BQW5CLEVBQTJCO0FBQ3pCKzdDLDBCQUFnQnovQyxFQUFFLHFDQUFGLENBQWhCOztBQUVBO0FBQ0EsY0FBSSxDQUFDMC9DLGtCQUFrQmg4QyxNQUF2QixFQUErQjtBQUM3Qmc4QyxnQ0FBb0I3eUIsT0FBTyt5QixLQUFQLENBQWEsSUFBYixFQUFtQixJQUFuQixDQUFwQjtBQUNBRiw4QkFBa0I1dEMsUUFBbEIsQ0FBMkIsbUJBQTNCO0FBQ0E0dEMsOEJBQWtCcnRCLFVBQWxCLENBQTZCLElBQTdCO0FBQ0FxdEIsOEJBQWtCcnRCLFVBQWxCLENBQTZCLE9BQTdCO0FBQ0FvdEIsMEJBQWNwdkIsTUFBZCxDQUFxQnF2QixpQkFBckI7QUFDRDs7QUFFREYsMkJBQWlCbnZCLE1BQWpCLENBQXdCb3ZCLGFBQXhCO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFJSSxnQkFBZ0IsU0FBaEJBLGFBQWdCLEdBQVc7QUFDN0IsY0FBSUwsaUJBQWlCcDBCLEVBQWpCLENBQW9CLE9BQXBCLENBQUosRUFBa0M7QUFDaEM7QUFDRDs7QUFFRDtBQUNBbzBCLDJCQUFpQjF0QyxRQUFqQixDQUEwQixNQUExQjs7QUFFQW5HLHFCQUFXLFlBQVc7QUFDcEIrekMsOEJBQWtCaDdCLEdBQWxCLENBQXNCLGlCQUF0QixFQUF5Q0QsRUFBekMsQ0FBNEMsaUJBQTVDLEVBQStELFVBQVNoaEIsQ0FBVCxFQUFZO0FBQ3pFcThDO0FBQ0FKLGdDQUFrQmg3QixHQUFsQixDQUFzQixpQkFBdEI7QUFDRCxhQUhEOztBQUtBMWtCLGNBQUVnRyxRQUFGLEVBQVkwZSxHQUFaLENBQWdCLGlCQUFoQixFQUFtQ0QsRUFBbkMsQ0FBc0MsaUJBQXRDLEVBQXlELFVBQVNoaEIsQ0FBVCxFQUFZO0FBQ25FcThDO0FBQ0E5L0MsZ0JBQUVnRyxRQUFGLEVBQVkwZSxHQUFaLENBQWdCLGlCQUFoQjtBQUNELGFBSEQ7O0FBS0EsZ0JBQUlxN0IsZ0JBQWdCbjRCLFlBQVl3QixRQUFaLENBQXFCLFlBQVc7QUFDbEQ0MkI7QUFDRCxhQUZtQixFQUVqQixHQUZpQixDQUFwQjtBQUdBaGdELGNBQUVpRSxNQUFGLEVBQVV5Z0IsR0FBVixDQUFjLGtCQUFkLEVBQWtDRCxFQUFsQyxDQUFxQyxrQkFBckMsRUFBeURzN0IsYUFBekQ7QUFDRCxXQWZELEVBZUcsQ0FmSDtBQWdCRCxTQXhCRDs7QUEwQkE7QUFDQSxZQUFJRCxpQkFBaUIsU0FBakJBLGNBQWlCLEdBQVU7QUFDN0IsY0FBSSxDQUFDTixpQkFBaUJwMEIsRUFBakIsQ0FBb0IsT0FBcEIsQ0FBTCxFQUFtQztBQUNqQztBQUNEOztBQUVEbzBCLDJCQUFpQi96QyxXQUFqQixDQUE2QixNQUE3QjtBQUNBaTBDLDRCQUFrQmg3QixHQUFsQixDQUFzQixpQkFBdEI7QUFDQTFrQixZQUFFZ0csUUFBRixFQUFZMGUsR0FBWixDQUFnQixpQkFBaEI7QUFDQTFrQixZQUFFaUUsTUFBRixFQUFVeWdCLEdBQVYsQ0FBYyxrQkFBZDtBQUNELFNBVEQ7O0FBV0E7QUFDQSxZQUFJczdCLHFCQUFxQixTQUFyQkEsa0JBQXFCLEdBQVc7QUFDbEM7QUFDQSxjQUFJNzJCLFVBQVUwRCxPQUFPemEsR0FBUCxDQUFXLFVBQVgsTUFBMkIsT0FBekM7QUFDQSxjQUFJLENBQUMrVyxPQUFMLEVBQWM7QUFDWixnQkFBSUQsVUFBVTJELE9BQU8zRCxPQUFQLEVBQWQ7QUFDQSxpQkFBSSxJQUFJL2tCLElBQUksQ0FBWixFQUFlQSxJQUFJK2tCLFFBQVF4bEIsTUFBM0IsRUFBbUNTLEdBQW5DLEVBQXdDO0FBQ3RDZ2xCLHdCQUFVbnBCLEVBQUVrcEIsUUFBUS9rQixDQUFSLENBQUYsRUFBY2lPLEdBQWQsQ0FBa0IsVUFBbEIsS0FBaUMsT0FBM0M7QUFDQSxrQkFBSStXLE9BQUosRUFBYTtBQUNYO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0EsY0FBSW1OLGNBQWN6SixPQUFPTyxVQUFQLEVBQWxCO0FBQ0EsY0FBSUUsZUFBZVQsT0FBTzBKLFdBQVAsRUFBbkI7QUFDQSxjQUFJMHBCLFlBQVk5MkIsVUFBVTBELE9BQU9sbkIsTUFBUCxHQUFnQkUsR0FBaEIsR0FBc0I3RixFQUFFZ0csUUFBRixFQUFZQyxTQUFaLEVBQWhDLEdBQTBENG1CLE9BQU9sbkIsTUFBUCxHQUFnQkUsR0FBMUY7QUFDQSxjQUFJcTZDLGFBQWEvMkIsVUFBVTBELE9BQU9sbkIsTUFBUCxHQUFnQkcsSUFBaEIsR0FBdUI5RixFQUFFZ0csUUFBRixFQUFZSSxVQUFaLEVBQWpDLEdBQTREeW1CLE9BQU9sbkIsTUFBUCxHQUFnQkcsSUFBN0Y7O0FBRUE7QUFDQSxjQUFJeXJCLGNBQWN2eEIsRUFBRWlFLE1BQUYsRUFBVW1xQixLQUFWLEVBQWxCO0FBQ0EsY0FBSWYsZUFBZXJ0QixFQUFFaUUsTUFBRixFQUFVeVMsTUFBVixFQUFuQjtBQUNBLGNBQUl5cEMsVUFBVTV1QixjQUFjLENBQTVCO0FBQ0EsY0FBSTZ1QixVQUFVL3lCLGVBQWUsQ0FBN0I7QUFDQSxjQUFJZ3pCLFNBQVNILGNBQWNDLE9BQTNCO0FBQ0EsY0FBSUcsVUFBVUosYUFBYUMsT0FBM0I7QUFDQSxjQUFJSSxRQUFRTixhQUFhRyxPQUF6QjtBQUNBLGNBQUlJLFdBQVdQLFlBQVlHLE9BQTNCO0FBQ0EsY0FBSUssWUFBWVAsY0FBYzN1QixjQUFZLElBQTFCLElBQWtDMnVCLGNBQWMzdUIsY0FBWSxJQUE1RTtBQUNBLGNBQUltdkIsWUFBWVQsYUFBYTV5QixlQUFhLElBQTFCLElBQWtDNHlCLGFBQWE1eUIsZUFBYSxJQUE1RTs7QUFFQTtBQUNBLGNBQUlzekIsaUJBQWlCcEIsWUFBWW55QixVQUFaLEVBQXJCO0FBQ0EsY0FBSXd6QixrQkFBa0JyQixZQUFZaHBCLFdBQVosRUFBdEI7QUFDQSxjQUFJc3FCLGVBQWVaLFlBQVkzeUIsZUFBYSxDQUF6QixHQUE2QnN6QixrQkFBZ0IsQ0FBaEU7QUFDQSxjQUFJRSxnQkFBZ0JaLGFBQWE1cEIsY0FBWSxDQUF6QixHQUE2QnFxQixpQkFBZSxDQUFoRTtBQUNBLGNBQUlJLG9CQUFvQjUzQixVQUFVLE9BQVYsR0FBb0IsVUFBNUM7O0FBRUE7QUFDQSxjQUFJNjNCLHFCQUFxQlAsWUFBWUUsY0FBWixHQUE2QkEsaUJBQWUsQ0FBZixHQUFtQnJxQixXQUF6RTtBQUNBLGNBQUkycUIsc0JBQXNCTCxrQkFBZ0IsQ0FBMUM7QUFDQSxjQUFJTSxtQkFBbUJYLFFBQVFLLGtCQUFnQixDQUF4QixHQUE0QixDQUFuRDtBQUNBLGNBQUlPLHNCQUFzQixDQUExQjtBQUNBLGNBQUlDLG9CQUFvQmYsVUFBVSxDQUFDSSxTQUFYLEdBQXVCRSxpQkFBZSxDQUFmLEdBQW1CcnFCLFdBQTFDLEdBQXdELENBQWhGO0FBQ0EsY0FBSStxQixxQkFBcUIsQ0FBekI7QUFDQSxjQUFJQyx1QkFBdUJockIsV0FBM0I7QUFDQSxjQUFJaXJCLHFCQUFxQmYsV0FBVyxRQUFYLEdBQXNCLEtBQS9DOztBQUVBO0FBQ0EsY0FBSWdCLHFCQUFxQmxyQixjQUFjaEosWUFBZCxHQUE2QmdKLGNBQVksQ0FBekMsR0FBNkNBLGNBQVksQ0FBbEY7QUFDQSxjQUFJbXJCLHNCQUFzQkQsa0JBQTFCO0FBQ0EsY0FBSUUsbUJBQW1CZCxrQkFBZ0IsQ0FBaEIsR0FBb0JhLHNCQUFvQixDQUEvRDtBQUNBLGNBQUlFLG9CQUFvQmhCLGlCQUFlLENBQWYsR0FBbUJhLHFCQUFtQixDQUE5RDs7QUFFQTtBQUNBLGNBQUlJLHlCQUF5QixFQUE3QjtBQUNBQSxpQ0FBdUIvN0MsR0FBdkIsR0FBNkIwNkMsUUFBUU0sWUFBUixHQUF1QixFQUFwRDtBQUNBZSxpQ0FBdUJ0cUIsS0FBdkIsR0FBK0JncEIsVUFBVS91QixjQUFjdXZCLGFBQWQsR0FBOEJILGNBQXhDLEdBQXlELEVBQXhGO0FBQ0FpQixpQ0FBdUI5eEIsTUFBdkIsR0FBZ0Mwd0IsV0FBV256QixlQUFld3pCLFlBQWYsR0FBOEJELGVBQXpDLEdBQTJELEVBQTNGO0FBQ0FnQixpQ0FBdUI5N0MsSUFBdkIsR0FBOEJ1NkMsU0FBU1MsYUFBVCxHQUF5QixFQUF2RDtBQUNBYyxpQ0FBdUJ0N0MsUUFBdkIsR0FBa0N5NkMsaUJBQWxDO0FBQ0F2QiwyQkFBaUJwdEMsR0FBakIsQ0FBcUJ3dkMsc0JBQXJCOztBQUVBO0FBQ0FqQyw2QkFBbUJ2dEMsR0FBbkIsQ0FBdUI7QUFDckJnYyxtQkFBTzR5QixrQkFEYztBQUVyQnRxQyxvQkFBUXVxQyxtQkFGYTtBQUdyQnA3QyxpQkFBS3E3QyxnQkFIZ0I7QUFJckI1cEIsbUJBQU8rcEIsa0JBSmM7QUFLckJ2eEIsb0JBQVFxeEIsbUJBTGE7QUFNckJyN0Msa0JBQU1zN0MsaUJBTmU7QUFPckJuWCxxQkFBU3FYLG9CQVBZO0FBUXJCTywyQkFBZU47QUFSTSxXQUF2Qjs7QUFXQTtBQUNBOUIsd0JBQWNydEMsR0FBZCxDQUFrQjtBQUNoQnZNLGlCQUFLNjdDLGdCQURXO0FBRWhCNTdDLGtCQUFNNjdDLGlCQUZVO0FBR2hCdnpCLG1CQUFPb3pCLGtCQUhTO0FBSWhCOXFDLG9CQUFRK3FDO0FBSlEsV0FBbEI7QUFNRCxTQWxGRDs7QUFvRkEsWUFBSXpyQyxXQUFXLE1BQWYsRUFBdUI7QUFDckJncUM7QUFDQUg7QUFDRDs7QUFFRCxZQUFJN3BDLFdBQVcsT0FBZixFQUNFOHBDO0FBQ0QsT0F6S00sQ0FBUDtBQTBLRCxLQTVLYTtBQTZLZG54QixVQUFNLGdCQUFXLENBQUUsQ0E3S0w7QUE4S2Q4QixXQUFPLGlCQUFXLENBQUU7QUE5S04sR0FBZDs7QUFpTEF6d0IsSUFBRStELEVBQUYsQ0FBSys5QyxTQUFMLEdBQWlCLFVBQVNueEIsZUFBVCxFQUEwQjtBQUMzQyxRQUFJeEIsUUFBUXdCLGVBQVIsS0FBNEIsUUFBT0EsZUFBUCx5Q0FBT0EsZUFBUCxPQUEyQixRQUEzRCxFQUNFLE9BQU94QixRQUFRbnJCLElBQVIsQ0FBYVksS0FBYixDQUFvQixJQUFwQixFQUEwQkssU0FBMUIsQ0FBUDs7QUFFRmpGLE1BQUU0d0IsS0FBRixDQUFTLFlBQWFELGVBQWIsR0FBK0Isc0NBQXhDO0FBQ0MsR0FMRDtBQU9ELENBMUxjLEVBMExaNXdCLE1BMUxZLENBQUQsQzs7Ozs7OztBQzk2UGQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVTs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTSxPQUFPLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSztBQUMzQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTSxHQUFHLEtBQUssRUFBRSxLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLEtBQUs7QUFDdkIsV0FBVyxPQUFPLEtBQUs7QUFDdkIsV0FBVyxNQUFNO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFVBQVU7QUFDVixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4Qjs7QUFFMUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0Esa0NBQWtDLEVBQUU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQyxFQUFFOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFdBQVc7QUFDdEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFB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LEVBQTBCdXRDLEdBQTFCLEVBQVA7QUFDQSxFQUZEOztBQUlBO0FBQ0E7QUFDQW5pRCxHQUFFMkUsSUFBRixDQUFRbzlDLFNBQVIsRUFBbUIsVUFBVzM1QixJQUFYLEVBQWlCMFYsR0FBakIsRUFBdUI7QUFDekM5OUIsSUFBRStELEVBQUYsQ0FBS2crQyxTQUFMLENBQWdCMzVCLElBQWhCLElBQXlCMFYsR0FBekI7QUFDQSxFQUZEOztBQUtBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7O0FBUUE7Ozs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7QUFVQSxRQUFPOTlCLEVBQUUrRCxFQUFGLENBQUtva0QsU0FBWjtBQUNBLENBdDlkQSxDQUFELEMiLCJmaWxlIjoiL2pzL2FkbWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDgzZWU3YzEwMmU0ODU4YjJkMDdkIiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjIuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDMtMjBUMTg6NTlaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjIuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2csXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHRcdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0XHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHRcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRcdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0RE9NRXZhbCggY29kZSApO1xuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA4LTA4XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgKFwiZm9ybVwiIGluIGVsZW0gfHwgXCJsYWJlbFwiIGluIGVsZW0pO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0ZGlzYWJsZWRBbmNlc3RvciggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufTtcbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2ltcGxlIHNlbGVjdG9yIHRoYXQgY2FuIGJlIGZpbHRlcmVkIGRpcmVjdGx5LCByZW1vdmluZyBub24tRWxlbWVudHNcblx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHR9XG5cblx0Ly8gQ29tcGxleCBzZWxlY3RvciwgY29tcGFyZSB0aGUgdHdvIHNldHMsIHJlbW92aW5nIG5vbi1FbGVtZW50c1xuXHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3QgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG4gICAgICAgIC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IGl0LlxuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGpRdWVyeS5jYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLFxuXHRcdHNjYWxlID0gMSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHRkbyB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxuXHRcdFx0Ly8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcblx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHQvLyBBZGp1c3QgYW5kIGFwcGx5XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKClcblx0XHQvLyBCcmVhayB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoLlxuXHRcdH0gd2hpbGUgKFxuXHRcdFx0c2NhbGUgIT09ICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgKSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnNcblx0XHQpO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogalF1ZXJ5LmlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIFwiPnRib2R5XCIsIGVsZW0gKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcImJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwidG9wOjElO3dpZHRoOjUwJVwiO1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IGRpdlN0eWxlLm1hcmdpbkxlZnQgPT09IFwiMnB4XCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjUwJVwiO1xuXHRcdHBpeGVsTWFyZ2luUmlnaHRWYWwgPSBkaXZTdHlsZS5tYXJnaW5SaWdodCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHBpeGVsTWFyZ2luUmlnaHRWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O1wiICtcblx0XHRcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbE1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxNYXJnaW5SaWdodFZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHByb3BlcnR5IG1hcHBlZCBhbG9uZyB3aGF0IGpRdWVyeS5jc3NQcm9wcyBzdWdnZXN0cyBvciB0b1xuLy8gYSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkuXG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgcmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF07XG5cdGlmICggIXJldCApIHtcblx0XHRyZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpLFxuXHRcdHZhbCA9IDA7XG5cblx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdGlmICggZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRpID0gNDtcblxuXHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cdH0gZWxzZSB7XG5cdFx0aSA9IG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvSGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHRpZiAoIHZhbCA9PT0gXCJhdXRvXCIgKSB7XG5cdFx0dmFsID0gZWxlbVsgXCJvZmZzZXRcIiArIG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApIF07XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvYywgZG9jRWxlbSwgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHR3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhbm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0ID0ge1xuXHRcdFx0XHR0b3A6IHBhcmVudE9mZnNldC50b3AgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICksXG5cdFx0XHRcdGxlZnQ6IHBhcmVudE9mZnNldC5sZWZ0ICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIVxuICogTWF0ZXJpYWxpemUgdjAuOTguMiAoaHR0cDovL21hdGVyaWFsaXplY3NzLmNvbSlcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUgTWF0ZXJpYWxpemVcbiAqIE1JVCBMaWNlbnNlIChodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vRG9nZmFsby9tYXRlcmlhbGl6ZS9tYXN0ZXIvTElDRU5TRSlcbiAqL1xuLy8gQ2hlY2sgZm9yIGpRdWVyeS5cbmlmICh0eXBlb2YoalF1ZXJ5KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIGpRdWVyeTtcbiAgLy8gQ2hlY2sgaWYgcmVxdWlyZSBpcyBhIGRlZmluZWQgZnVuY3Rpb24uXG4gIGlmICh0eXBlb2YocmVxdWlyZSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBqUXVlcnkgPSAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG4gIC8vIEVsc2UgdXNlIHRoZSBkb2xsYXIgc2lnbiBhbGlhcy5cbiAgfSBlbHNlIHtcbiAgICBqUXVlcnkgPSAkO1xuICB9XG59XG47LypcbiAqIGpRdWVyeSBFYXNpbmcgdjEuMyAtIGh0dHA6Ly9nc2dkLmNvLnVrL3NhbmRib3gvanF1ZXJ5L2Vhc2luZy9cbiAqXG4gKiBVc2VzIHRoZSBidWlsdCBpbiBlYXNpbmcgY2FwYWJpbGl0aWVzIGFkZGVkIEluIGpRdWVyeSAxLjFcbiAqIHRvIG9mZmVyIG11bHRpcGxlIGVhc2luZyBvcHRpb25zXG4gKlxuICogVEVSTVMgT0YgVVNFIC0galF1ZXJ5IEVhc2luZ1xuICpcbiAqIE9wZW4gc291cmNlIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgwqkgMjAwOCBHZW9yZ2UgTWNHaW5sZXkgU21pdGhcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxuICogY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcbiAqIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gKiBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2VcbiAqIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqICBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gKiAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFXG4gKiAgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEXG4gKiBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEXG4gKiBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuKi9cblxuLy8gdDogY3VycmVudCB0aW1lLCBiOiBiZWdJbm5JbmcgdmFsdWUsIGM6IGNoYW5nZSBJbiB2YWx1ZSwgZDogZHVyYXRpb25cbmpRdWVyeS5lYXNpbmdbJ2pzd2luZyddID0galF1ZXJ5LmVhc2luZ1snc3dpbmcnXTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmVhc2luZyxcbntcblx0ZGVmOiAnZWFzZU91dFF1YWQnLFxuXHRzd2luZzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHQvL2FsZXJ0KGpRdWVyeS5lYXNpbmcuZGVmYXVsdCk7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYXNpbmdbalF1ZXJ5LmVhc2luZy5kZWZdKHgsIHQsIGIsIGMsIGQpO1xuXHR9LFxuXHRlYXNlSW5RdWFkOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuXHRcdHJldHVybiBjKih0Lz1kKSp0ICsgYjtcblx0fSxcblx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG5cdFx0cmV0dXJuIC1jICoodC89ZCkqKHQtMikgKyBiO1xuXHR9LFxuXHRlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuXHRcdGlmICgodC89ZC8yKSA8IDEpIHJldHVybiBjLzIqdCp0ICsgYjtcblx0XHRyZXR1cm4gLWMvMiAqICgoLS10KSoodC0yKSAtIDEpICsgYjtcblx0fSxcblx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG5cdFx0cmV0dXJuIGMqKHQvPWQpKnQqdCArIGI7XG5cdH0sXG5cdGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRyZXR1cm4gYyooKHQ9dC9kLTEpKnQqdCArIDEpICsgYjtcblx0fSxcblx0ZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG5cdFx0aWYgKCh0Lz1kLzIpIDwgMSkgcmV0dXJuIGMvMip0KnQqdCArIGI7XG5cdFx0cmV0dXJuIGMvMiooKHQtPTIpKnQqdCArIDIpICsgYjtcblx0fSxcblx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG5cdFx0cmV0dXJuIGMqKHQvPWQpKnQqdCp0ICsgYjtcblx0fSxcblx0ZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuXHRcdHJldHVybiAtYyAqICgodD10L2QtMSkqdCp0KnQgLSAxKSArIGI7XG5cdH0sXG5cdGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuXHRcdGlmICgodC89ZC8yKSA8IDEpIHJldHVybiBjLzIqdCp0KnQqdCArIGI7XG5cdFx0cmV0dXJuIC1jLzIgKiAoKHQtPTIpKnQqdCp0IC0gMikgKyBiO1xuXHR9LFxuXHRlYXNlSW5RdWludDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRyZXR1cm4gYyoodC89ZCkqdCp0KnQqdCArIGI7XG5cdH0sXG5cdGVhc2VPdXRRdWludDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRyZXR1cm4gYyooKHQ9dC9kLTEpKnQqdCp0KnQgKyAxKSArIGI7XG5cdH0sXG5cdGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuXHRcdGlmICgodC89ZC8yKSA8IDEpIHJldHVybiBjLzIqdCp0KnQqdCp0ICsgYjtcblx0XHRyZXR1cm4gYy8yKigodC09MikqdCp0KnQqdCArIDIpICsgYjtcblx0fSxcblx0ZWFzZUluU2luZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRyZXR1cm4gLWMgKiBNYXRoLmNvcyh0L2QgKiAoTWF0aC5QSS8yKSkgKyBjICsgYjtcblx0fSxcblx0ZWFzZU91dFNpbmU6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG5cdFx0cmV0dXJuIGMgKiBNYXRoLnNpbih0L2QgKiAoTWF0aC5QSS8yKSkgKyBiO1xuXHR9LFxuXHRlYXNlSW5PdXRTaW5lOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuXHRcdHJldHVybiAtYy8yICogKE1hdGguY29zKE1hdGguUEkqdC9kKSAtIDEpICsgYjtcblx0fSxcblx0ZWFzZUluRXhwbzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRyZXR1cm4gKHQ9PTApID8gYiA6IGMgKiBNYXRoLnBvdygyLCAxMCAqICh0L2QgLSAxKSkgKyBiO1xuXHR9LFxuXHRlYXNlT3V0RXhwbzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRyZXR1cm4gKHQ9PWQpID8gYitjIDogYyAqICgtTWF0aC5wb3coMiwgLTEwICogdC9kKSArIDEpICsgYjtcblx0fSxcblx0ZWFzZUluT3V0RXhwbzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRpZiAodD09MCkgcmV0dXJuIGI7XG5cdFx0aWYgKHQ9PWQpIHJldHVybiBiK2M7XG5cdFx0aWYgKCh0Lz1kLzIpIDwgMSkgcmV0dXJuIGMvMiAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKyBiO1xuXHRcdHJldHVybiBjLzIgKiAoLU1hdGgucG93KDIsIC0xMCAqIC0tdCkgKyAyKSArIGI7XG5cdH0sXG5cdGVhc2VJbkNpcmM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG5cdFx0cmV0dXJuIC1jICogKE1hdGguc3FydCgxIC0gKHQvPWQpKnQpIC0gMSkgKyBiO1xuXHR9LFxuXHRlYXNlT3V0Q2lyYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRyZXR1cm4gYyAqIE1hdGguc3FydCgxIC0gKHQ9dC9kLTEpKnQpICsgYjtcblx0fSxcblx0ZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRpZiAoKHQvPWQvMikgPCAxKSByZXR1cm4gLWMvMiAqIChNYXRoLnNxcnQoMSAtIHQqdCkgLSAxKSArIGI7XG5cdFx0cmV0dXJuIGMvMiAqIChNYXRoLnNxcnQoMSAtICh0LT0yKSp0KSArIDEpICsgYjtcblx0fSxcblx0ZWFzZUluRWxhc3RpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHR2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9Yztcblx0XHRpZiAodD09MCkgcmV0dXJuIGI7ICBpZiAoKHQvPWQpPT0xKSByZXR1cm4gYitjOyAgaWYgKCFwKSBwPWQqLjM7XG5cdFx0aWYgKGEgPCBNYXRoLmFicyhjKSkgeyBhPWM7IHZhciBzPXAvNDsgfVxuXHRcdGVsc2UgdmFyIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luIChjL2EpO1xuXHRcdHJldHVybiAtKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oICh0KmQtcykqKDIqTWF0aC5QSSkvcCApKSArIGI7XG5cdH0sXG5cdGVhc2VPdXRFbGFzdGljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuXHRcdHZhciBzPTEuNzAxNTg7dmFyIHA9MDt2YXIgYT1jO1xuXHRcdGlmICh0PT0wKSByZXR1cm4gYjsgIGlmICgodC89ZCk9PTEpIHJldHVybiBiK2M7ICBpZiAoIXApIHA9ZCouMztcblx0XHRpZiAoYSA8IE1hdGguYWJzKGMpKSB7IGE9YzsgdmFyIHM9cC80OyB9XG5cdFx0ZWxzZSB2YXIgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4gKGMvYSk7XG5cdFx0cmV0dXJuIGEqTWF0aC5wb3coMiwtMTAqdCkgKiBNYXRoLnNpbiggKHQqZC1zKSooMipNYXRoLlBJKS9wICkgKyBjICsgYjtcblx0fSxcblx0ZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHR2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9Yztcblx0XHRpZiAodD09MCkgcmV0dXJuIGI7ICBpZiAoKHQvPWQvMik9PTIpIHJldHVybiBiK2M7ICBpZiAoIXApIHA9ZCooLjMqMS41KTtcblx0XHRpZiAoYSA8IE1hdGguYWJzKGMpKSB7IGE9YzsgdmFyIHM9cC80OyB9XG5cdFx0ZWxzZSB2YXIgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4gKGMvYSk7XG5cdFx0aWYgKHQgPCAxKSByZXR1cm4gLS41KihhKk1hdGgucG93KDIsMTAqKHQtPTEpKSAqIE1hdGguc2luKCAodCpkLXMpKigyKk1hdGguUEkpL3AgKSkgKyBiO1xuXHRcdHJldHVybiBhKk1hdGgucG93KDIsLTEwKih0LT0xKSkgKiBNYXRoLnNpbiggKHQqZC1zKSooMipNYXRoLlBJKS9wICkqLjUgKyBjICsgYjtcblx0fSxcblx0ZWFzZUluQmFjazogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQsIHMpIHtcblx0XHRpZiAocyA9PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiBjKih0Lz1kKSp0KigocysxKSp0IC0gcykgKyBiO1xuXHR9LFxuXHRlYXNlT3V0QmFjazogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQsIHMpIHtcblx0XHRpZiAocyA9PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiBjKigodD10L2QtMSkqdCooKHMrMSkqdCArIHMpICsgMSkgKyBiO1xuXHR9LFxuXHRlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCwgcykge1xuXHRcdGlmIChzID09IHVuZGVmaW5lZCkgcyA9IDEuNzAxNTg7XG5cdFx0aWYgKCh0Lz1kLzIpIDwgMSkgcmV0dXJuIGMvMioodCp0KigoKHMqPSgxLjUyNSkpKzEpKnQgLSBzKSkgKyBiO1xuXHRcdHJldHVybiBjLzIqKCh0LT0yKSp0KigoKHMqPSgxLjUyNSkpKzEpKnQgKyBzKSArIDIpICsgYjtcblx0fSxcblx0ZWFzZUluQm91bmNlOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuXHRcdHJldHVybiBjIC0galF1ZXJ5LmVhc2luZy5lYXNlT3V0Qm91bmNlICh4LCBkLXQsIDAsIGMsIGQpICsgYjtcblx0fSxcblx0ZWFzZU91dEJvdW5jZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRpZiAoKHQvPWQpIDwgKDEvMi43NSkpIHtcblx0XHRcdHJldHVybiBjKig3LjU2MjUqdCp0KSArIGI7XG5cdFx0fSBlbHNlIGlmICh0IDwgKDIvMi43NSkpIHtcblx0XHRcdHJldHVybiBjKig3LjU2MjUqKHQtPSgxLjUvMi43NSkpKnQgKyAuNzUpICsgYjtcblx0XHR9IGVsc2UgaWYgKHQgPCAoMi41LzIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gYyooNy41NjI1Kih0LT0oMi4yNS8yLjc1KSkqdCArIC45Mzc1KSArIGI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBjKig3LjU2MjUqKHQtPSgyLjYyNS8yLjc1KSkqdCArIC45ODQzNzUpICsgYjtcblx0XHR9XG5cdH0sXG5cdGVhc2VJbk91dEJvdW5jZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRpZiAodCA8IGQvMikgcmV0dXJuIGpRdWVyeS5lYXNpbmcuZWFzZUluQm91bmNlICh4LCB0KjIsIDAsIGMsIGQpICogLjUgKyBiO1xuXHRcdHJldHVybiBqUXVlcnkuZWFzaW5nLmVhc2VPdXRCb3VuY2UgKHgsIHQqMi1kLCAwLCBjLCBkKSAqIC41ICsgYyouNSArIGI7XG5cdH1cbn0pO1xuXG4vKlxuICpcbiAqIFRFUk1TIE9GIFVTRSAtIEVBU0lORyBFUVVBVElPTlNcbiAqXG4gKiBPcGVuIHNvdXJjZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG4gKlxuICogQ29weXJpZ2h0IMKpIDIwMDEgUm9iZXJ0IFBlbm5lclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXG4gKiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxuICogb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAqIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZVxuICogb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiAqICBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEVcbiAqICBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRURcbiAqIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiAgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRURcbiAqIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKi87Ly8gQ3VzdG9tIEVhc2luZ1xualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmVhc2luZyxcbntcbiAgZWFzZUluT3V0TWF0ZXJpYWw6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG4gICAgaWYgKCh0Lz1kLzIpIDwgMSkgcmV0dXJuIGMvMip0KnQgKyBiO1xuICAgIHJldHVybiBjLzQqKCh0LT0yKSp0KnQgKyAyKSArIGI7XG4gIH1cbn0pOzsvKiEgVmVsb2NpdHlKUy5vcmcgKDEuMi4zKS4gKEMpIDIwMTQgSnVsaWFuIFNoYXBpcm8uIE1JVCBAbGljZW5zZTogZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG4vKiEgVmVsb2NpdHlKUy5vcmcgalF1ZXJ5IFNoaW0gKDEuMC4xKS4gKEMpIDIwMTQgVGhlIGpRdWVyeSBGb3VuZGF0aW9uLiBNSVQgQGxpY2Vuc2U6IGVuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZS4gKi9cbi8qISBOb3RlIHRoYXQgdGhpcyBoYXMgYmVlbiBtb2RpZmllZCBieSBNYXRlcmlhbGl6ZSB0byBjb25maXJtIHRoYXQgVmVsb2NpdHkgaXMgbm90IGFscmVhZHkgYmVpbmcgaW1wb3J0ZWQuICovXG5qUXVlcnkuVmVsb2NpdHk/Y29uc29sZS5sb2coXCJWZWxvY2l0eSBpcyBhbHJlYWR5IGxvYWRlZC4gWW91IG1heSBiZSBuZWVkbGVzc2x5IGltcG9ydGluZyBWZWxvY2l0eSBhZ2Fpbjsgbm90ZSB0aGF0IE1hdGVyaWFsaXplIGluY2x1ZGVzIFZlbG9jaXR5LlwiKTooIWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSl7dmFyIHQ9ZS5sZW5ndGgsYT1yLnR5cGUoZSk7cmV0dXJuXCJmdW5jdGlvblwiPT09YXx8ci5pc1dpbmRvdyhlKT8hMToxPT09ZS5ub2RlVHlwZSYmdD8hMDpcImFycmF5XCI9PT1hfHwwPT09dHx8XCJudW1iZXJcIj09dHlwZW9mIHQmJnQ+MCYmdC0xIGluIGV9aWYoIWUualF1ZXJ5KXt2YXIgcj1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcgci5mbi5pbml0KGUsdCl9O3IuaXNXaW5kb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWUmJmU9PWUud2luZG93fSxyLnR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/ZStcIlwiOlwib2JqZWN0XCI9PXR5cGVvZiBlfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP25baS5jYWxsKGUpXXx8XCJvYmplY3RcIjp0eXBlb2YgZX0sci5pc0FycmF5PUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGUpe3JldHVyblwiYXJyYXlcIj09PXIudHlwZShlKX0sci5pc1BsYWluT2JqZWN0PWZ1bmN0aW9uKGUpe3ZhciB0O2lmKCFlfHxcIm9iamVjdFwiIT09ci50eXBlKGUpfHxlLm5vZGVUeXBlfHxyLmlzV2luZG93KGUpKXJldHVybiExO3RyeXtpZihlLmNvbnN0cnVjdG9yJiYhby5jYWxsKGUsXCJjb25zdHJ1Y3RvclwiKSYmIW8uY2FsbChlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxcImlzUHJvdG90eXBlT2ZcIikpcmV0dXJuITF9Y2F0Y2goYSl7cmV0dXJuITF9Zm9yKHQgaW4gZSk7cmV0dXJuIHZvaWQgMD09PXR8fG8uY2FsbChlLHQpfSxyLmVhY2g9ZnVuY3Rpb24oZSxyLGEpe3ZhciBuLG89MCxpPWUubGVuZ3RoLHM9dChlKTtpZihhKXtpZihzKWZvcig7aT5vJiYobj1yLmFwcGx5KGVbb10sYSksbiE9PSExKTtvKyspO2Vsc2UgZm9yKG8gaW4gZSlpZihuPXIuYXBwbHkoZVtvXSxhKSxuPT09ITEpYnJlYWt9ZWxzZSBpZihzKWZvcig7aT5vJiYobj1yLmNhbGwoZVtvXSxvLGVbb10pLG4hPT0hMSk7bysrKTtlbHNlIGZvcihvIGluIGUpaWYobj1yLmNhbGwoZVtvXSxvLGVbb10pLG49PT0hMSlicmVhaztyZXR1cm4gZX0sci5kYXRhPWZ1bmN0aW9uKGUsdCxuKXtpZih2b2lkIDA9PT1uKXt2YXIgbz1lW3IuZXhwYW5kb10saT1vJiZhW29dO2lmKHZvaWQgMD09PXQpcmV0dXJuIGk7aWYoaSYmdCBpbiBpKXJldHVybiBpW3RdfWVsc2UgaWYodm9pZCAwIT09dCl7dmFyIG89ZVtyLmV4cGFuZG9dfHwoZVtyLmV4cGFuZG9dPSsrci51dWlkKTtyZXR1cm4gYVtvXT1hW29dfHx7fSxhW29dW3RdPW4sbn19LHIucmVtb3ZlRGF0YT1mdW5jdGlvbihlLHQpe3ZhciBuPWVbci5leHBhbmRvXSxvPW4mJmFbbl07byYmci5lYWNoKHQsZnVuY3Rpb24oZSx0KXtkZWxldGUgb1t0XX0pfSxyLmV4dGVuZD1mdW5jdGlvbigpe3ZhciBlLHQsYSxuLG8saSxzPWFyZ3VtZW50c1swXXx8e30sbD0xLHU9YXJndW1lbnRzLmxlbmd0aCxjPSExO2ZvcihcImJvb2xlYW5cIj09dHlwZW9mIHMmJihjPXMscz1hcmd1bWVudHNbbF18fHt9LGwrKyksXCJvYmplY3RcIiE9dHlwZW9mIHMmJlwiZnVuY3Rpb25cIiE9PXIudHlwZShzKSYmKHM9e30pLGw9PT11JiYocz10aGlzLGwtLSk7dT5sO2wrKylpZihudWxsIT0obz1hcmd1bWVudHNbbF0pKWZvcihuIGluIG8pZT1zW25dLGE9b1tuXSxzIT09YSYmKGMmJmEmJihyLmlzUGxhaW5PYmplY3QoYSl8fCh0PXIuaXNBcnJheShhKSkpPyh0Pyh0PSExLGk9ZSYmci5pc0FycmF5KGUpP2U6W10pOmk9ZSYmci5pc1BsYWluT2JqZWN0KGUpP2U6e30sc1tuXT1yLmV4dGVuZChjLGksYSkpOnZvaWQgMCE9PWEmJihzW25dPWEpKTtyZXR1cm4gc30sci5xdWV1ZT1mdW5jdGlvbihlLGEsbil7ZnVuY3Rpb24gbyhlLHIpe3ZhciBhPXJ8fFtdO3JldHVybiBudWxsIT1lJiYodChPYmplY3QoZSkpPyFmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj0rdC5sZW5ndGgsYT0wLG49ZS5sZW5ndGg7cj5hOyllW24rK109dFthKytdO2lmKHIhPT1yKWZvcig7dm9pZCAwIT09dFthXTspZVtuKytdPXRbYSsrXTtyZXR1cm4gZS5sZW5ndGg9bixlfShhLFwic3RyaW5nXCI9PXR5cGVvZiBlP1tlXTplKTpbXS5wdXNoLmNhbGwoYSxlKSksYX1pZihlKXthPShhfHxcImZ4XCIpK1wicXVldWVcIjt2YXIgaT1yLmRhdGEoZSxhKTtyZXR1cm4gbj8oIWl8fHIuaXNBcnJheShuKT9pPXIuZGF0YShlLGEsbyhuKSk6aS5wdXNoKG4pLGkpOml8fFtdfX0sci5kZXF1ZXVlPWZ1bmN0aW9uKGUsdCl7ci5lYWNoKGUubm9kZVR5cGU/W2VdOmUsZnVuY3Rpb24oZSxhKXt0PXR8fFwiZnhcIjt2YXIgbj1yLnF1ZXVlKGEsdCksbz1uLnNoaWZ0KCk7XCJpbnByb2dyZXNzXCI9PT1vJiYobz1uLnNoaWZ0KCkpLG8mJihcImZ4XCI9PT10JiZuLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpLG8uY2FsbChhLGZ1bmN0aW9uKCl7ci5kZXF1ZXVlKGEsdCl9KSl9KX0sci5mbj1yLnByb3RvdHlwZT17aW5pdDpmdW5jdGlvbihlKXtpZihlLm5vZGVUeXBlKXJldHVybiB0aGlzWzBdPWUsdGhpczt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBET00gbm9kZS5cIil9LG9mZnNldDpmdW5jdGlvbigpe3ZhciB0PXRoaXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0P3RoaXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk6e3RvcDowLGxlZnQ6MH07cmV0dXJue3RvcDp0LnRvcCsoZS5wYWdlWU9mZnNldHx8ZG9jdW1lbnQuc2Nyb2xsVG9wfHwwKS0oZG9jdW1lbnQuY2xpZW50VG9wfHwwKSxsZWZ0OnQubGVmdCsoZS5wYWdlWE9mZnNldHx8ZG9jdW1lbnQuc2Nyb2xsTGVmdHx8MCktKGRvY3VtZW50LmNsaWVudExlZnR8fDApfX0scG9zaXRpb246ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7Zm9yKHZhciBlPXRoaXMub2Zmc2V0UGFyZW50fHxkb2N1bWVudDtlJiZcImh0bWxcIj09PSFlLm5vZGVUeXBlLnRvTG93ZXJDYXNlJiZcInN0YXRpY1wiPT09ZS5zdHlsZS5wb3NpdGlvbjspZT1lLm9mZnNldFBhcmVudDtyZXR1cm4gZXx8ZG9jdW1lbnR9dmFyIHQ9dGhpc1swXSxlPWUuYXBwbHkodCksYT10aGlzLm9mZnNldCgpLG49L14oPzpib2R5fGh0bWwpJC9pLnRlc3QoZS5ub2RlTmFtZSk/e3RvcDowLGxlZnQ6MH06cihlKS5vZmZzZXQoKTtyZXR1cm4gYS50b3AtPXBhcnNlRmxvYXQodC5zdHlsZS5tYXJnaW5Ub3ApfHwwLGEubGVmdC09cGFyc2VGbG9hdCh0LnN0eWxlLm1hcmdpbkxlZnQpfHwwLGUuc3R5bGUmJihuLnRvcCs9cGFyc2VGbG9hdChlLnN0eWxlLmJvcmRlclRvcFdpZHRoKXx8MCxuLmxlZnQrPXBhcnNlRmxvYXQoZS5zdHlsZS5ib3JkZXJMZWZ0V2lkdGgpfHwwKSx7dG9wOmEudG9wLW4udG9wLGxlZnQ6YS5sZWZ0LW4ubGVmdH19fTt2YXIgYT17fTtyLmV4cGFuZG89XCJ2ZWxvY2l0eVwiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpLHIudXVpZD0wO2Zvcih2YXIgbj17fSxvPW4uaGFzT3duUHJvcGVydHksaT1uLnRvU3RyaW5nLHM9XCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpLGw9MDtsPHMubGVuZ3RoO2wrKyluW1wiW29iamVjdCBcIitzW2xdK1wiXVwiXT1zW2xdLnRvTG93ZXJDYXNlKCk7ci5mbi5pbml0LnByb3RvdHlwZT1yLmZuLGUuVmVsb2NpdHk9e1V0aWxpdGllczpyfX19KHdpbmRvdyksZnVuY3Rpb24oZSl7XCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGUpOmUoKX0oZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIsYSl7ZnVuY3Rpb24gbihlKXtmb3IodmFyIHQ9LTEscj1lP2UubGVuZ3RoOjAsYT1bXTsrK3Q8cjspe3ZhciBuPWVbdF07biYmYS5wdXNoKG4pfXJldHVybiBhfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIG0uaXNXcmFwcGVkKGUpP2U9W10uc2xpY2UuY2FsbChlKTptLmlzTm9kZShlKSYmKGU9W2VdKSxlfWZ1bmN0aW9uIGkoZSl7dmFyIHQ9Zi5kYXRhKGUsXCJ2ZWxvY2l0eVwiKTtyZXR1cm4gbnVsbD09PXQ/YTp0fWZ1bmN0aW9uIHMoZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnJvdW5kKHQqZSkqKDEvZSl9fWZ1bmN0aW9uIGwoZSxyLGEsbil7ZnVuY3Rpb24gbyhlLHQpe3JldHVybiAxLTMqdCszKmV9ZnVuY3Rpb24gaShlLHQpe3JldHVybiAzKnQtNiplfWZ1bmN0aW9uIHMoZSl7cmV0dXJuIDMqZX1mdW5jdGlvbiBsKGUsdCxyKXtyZXR1cm4oKG8odCxyKSplK2kodCxyKSkqZStzKHQpKSplfWZ1bmN0aW9uIHUoZSx0LHIpe3JldHVybiAzKm8odCxyKSplKmUrMippKHQscikqZStzKHQpfWZ1bmN0aW9uIGModCxyKXtmb3IodmFyIG49MDttPm47KytuKXt2YXIgbz11KHIsZSxhKTtpZigwPT09bylyZXR1cm4gcjt2YXIgaT1sKHIsZSxhKS10O3ItPWkvb31yZXR1cm4gcn1mdW5jdGlvbiBwKCl7Zm9yKHZhciB0PTA7Yj50OysrdCl3W3RdPWwodCp4LGUsYSl9ZnVuY3Rpb24gZih0LHIsbil7dmFyIG8saSxzPTA7ZG8gaT1yKyhuLXIpLzIsbz1sKGksZSxhKS10LG8+MD9uPWk6cj1pO3doaWxlKE1hdGguYWJzKG8pPmgmJisrczx2KTtyZXR1cm4gaX1mdW5jdGlvbiBkKHQpe2Zvcih2YXIgcj0wLG49MSxvPWItMTtuIT1vJiZ3W25dPD10OysrbilyKz14Oy0tbjt2YXIgaT0odC13W25dKS8od1tuKzFdLXdbbl0pLHM9citpKngsbD11KHMsZSxhKTtyZXR1cm4gbD49eT9jKHQscyk6MD09bD9zOmYodCxyLHIreCl9ZnVuY3Rpb24gZygpe1Y9ITAsKGUhPXJ8fGEhPW4pJiZwKCl9dmFyIG09NCx5PS4wMDEsaD0xZS03LHY9MTAsYj0xMSx4PTEvKGItMSksUz1cIkZsb2F0MzJBcnJheVwiaW4gdDtpZig0IT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIFA9MDs0PlA7KytQKWlmKFwibnVtYmVyXCIhPXR5cGVvZiBhcmd1bWVudHNbUF18fGlzTmFOKGFyZ3VtZW50c1tQXSl8fCFpc0Zpbml0ZShhcmd1bWVudHNbUF0pKXJldHVybiExO2U9TWF0aC5taW4oZSwxKSxhPU1hdGgubWluKGEsMSksZT1NYXRoLm1heChlLDApLGE9TWF0aC5tYXgoYSwwKTt2YXIgdz1TP25ldyBGbG9hdDMyQXJyYXkoYik6bmV3IEFycmF5KGIpLFY9ITEsQz1mdW5jdGlvbih0KXtyZXR1cm4gVnx8ZygpLGU9PT1yJiZhPT09bj90OjA9PT10PzA6MT09PXQ/MTpsKGQodCkscixuKX07Qy5nZXRDb250cm9sUG9pbnRzPWZ1bmN0aW9uKCl7cmV0dXJuW3t4OmUseTpyfSx7eDphLHk6bn1dfTt2YXIgVD1cImdlbmVyYXRlQmV6aWVyKFwiK1tlLHIsYSxuXStcIilcIjtyZXR1cm4gQy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBUfSxDfWZ1bmN0aW9uIHUoZSx0KXt2YXIgcj1lO3JldHVybiBtLmlzU3RyaW5nKGUpP2IuRWFzaW5nc1tlXXx8KHI9ITEpOnI9bS5pc0FycmF5KGUpJiYxPT09ZS5sZW5ndGg/cy5hcHBseShudWxsLGUpOm0uaXNBcnJheShlKSYmMj09PWUubGVuZ3RoP3guYXBwbHkobnVsbCxlLmNvbmNhdChbdF0pKTptLmlzQXJyYXkoZSkmJjQ9PT1lLmxlbmd0aD9sLmFwcGx5KG51bGwsZSk6ITEscj09PSExJiYocj1iLkVhc2luZ3NbYi5kZWZhdWx0cy5lYXNpbmddP2IuZGVmYXVsdHMuZWFzaW5nOnYpLHJ9ZnVuY3Rpb24gYyhlKXtpZihlKXt2YXIgdD0obmV3IERhdGUpLmdldFRpbWUoKSxyPWIuU3RhdGUuY2FsbHMubGVuZ3RoO3I+MWU0JiYoYi5TdGF0ZS5jYWxscz1uKGIuU3RhdGUuY2FsbHMpKTtmb3IodmFyIG89MDtyPm87bysrKWlmKGIuU3RhdGUuY2FsbHNbb10pe3ZhciBzPWIuU3RhdGUuY2FsbHNbb10sbD1zWzBdLHU9c1syXSxkPXNbM10sZz0hIWQseT1udWxsO2R8fChkPWIuU3RhdGUuY2FsbHNbb11bM109dC0xNik7Zm9yKHZhciBoPU1hdGgubWluKCh0LWQpL3UuZHVyYXRpb24sMSksdj0wLHg9bC5sZW5ndGg7eD52O3YrKyl7dmFyIFA9bFt2XSxWPVAuZWxlbWVudDtpZihpKFYpKXt2YXIgQz0hMTtpZih1LmRpc3BsYXkhPT1hJiZudWxsIT09dS5kaXNwbGF5JiZcIm5vbmVcIiE9PXUuZGlzcGxheSl7aWYoXCJmbGV4XCI9PT11LmRpc3BsYXkpe3ZhciBUPVtcIi13ZWJraXQtYm94XCIsXCItbW96LWJveFwiLFwiLW1zLWZsZXhib3hcIixcIi13ZWJraXQtZmxleFwiXTtmLmVhY2goVCxmdW5jdGlvbihlLHQpe1Muc2V0UHJvcGVydHlWYWx1ZShWLFwiZGlzcGxheVwiLHQpfSl9Uy5zZXRQcm9wZXJ0eVZhbHVlKFYsXCJkaXNwbGF5XCIsdS5kaXNwbGF5KX11LnZpc2liaWxpdHkhPT1hJiZcImhpZGRlblwiIT09dS52aXNpYmlsaXR5JiZTLnNldFByb3BlcnR5VmFsdWUoVixcInZpc2liaWxpdHlcIix1LnZpc2liaWxpdHkpO2Zvcih2YXIgayBpbiBQKWlmKFwiZWxlbWVudFwiIT09ayl7dmFyIEEsRj1QW2tdLGo9bS5pc1N0cmluZyhGLmVhc2luZyk/Yi5FYXNpbmdzW0YuZWFzaW5nXTpGLmVhc2luZztpZigxPT09aClBPUYuZW5kVmFsdWU7ZWxzZXt2YXIgRT1GLmVuZFZhbHVlLUYuc3RhcnRWYWx1ZTtpZihBPUYuc3RhcnRWYWx1ZStFKmooaCx1LEUpLCFnJiZBPT09Ri5jdXJyZW50VmFsdWUpY29udGludWV9aWYoRi5jdXJyZW50VmFsdWU9QSxcInR3ZWVuXCI9PT1rKXk9QTtlbHNle2lmKFMuSG9va3MucmVnaXN0ZXJlZFtrXSl7dmFyIEg9Uy5Ib29rcy5nZXRSb290KGspLE49aShWKS5yb290UHJvcGVydHlWYWx1ZUNhY2hlW0hdO04mJihGLnJvb3RQcm9wZXJ0eVZhbHVlPU4pfXZhciBMPVMuc2V0UHJvcGVydHlWYWx1ZShWLGssRi5jdXJyZW50VmFsdWUrKDA9PT1wYXJzZUZsb2F0KEEpP1wiXCI6Ri51bml0VHlwZSksRi5yb290UHJvcGVydHlWYWx1ZSxGLnNjcm9sbERhdGEpO1MuSG9va3MucmVnaXN0ZXJlZFtrXSYmKGkoVikucm9vdFByb3BlcnR5VmFsdWVDYWNoZVtIXT1TLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbSF0/Uy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW0hdKFwiZXh0cmFjdFwiLG51bGwsTFsxXSk6TFsxXSksXCJ0cmFuc2Zvcm1cIj09PUxbMF0mJihDPSEwKX19dS5tb2JpbGVIQSYmaShWKS50cmFuc2Zvcm1DYWNoZS50cmFuc2xhdGUzZD09PWEmJihpKFYpLnRyYW5zZm9ybUNhY2hlLnRyYW5zbGF0ZTNkPVwiKDBweCwgMHB4LCAwcHgpXCIsQz0hMCksQyYmUy5mbHVzaFRyYW5zZm9ybUNhY2hlKFYpfX11LmRpc3BsYXkhPT1hJiZcIm5vbmVcIiE9PXUuZGlzcGxheSYmKGIuU3RhdGUuY2FsbHNbb11bMl0uZGlzcGxheT0hMSksdS52aXNpYmlsaXR5IT09YSYmXCJoaWRkZW5cIiE9PXUudmlzaWJpbGl0eSYmKGIuU3RhdGUuY2FsbHNbb11bMl0udmlzaWJpbGl0eT0hMSksdS5wcm9ncmVzcyYmdS5wcm9ncmVzcy5jYWxsKHNbMV0sc1sxXSxoLE1hdGgubWF4KDAsZCt1LmR1cmF0aW9uLXQpLGQseSksMT09PWgmJnAobyl9fWIuU3RhdGUuaXNUaWNraW5nJiZ3KGMpfWZ1bmN0aW9uIHAoZSx0KXtpZighYi5TdGF0ZS5jYWxsc1tlXSlyZXR1cm4hMTtmb3IodmFyIHI9Yi5TdGF0ZS5jYWxsc1tlXVswXSxuPWIuU3RhdGUuY2FsbHNbZV1bMV0sbz1iLlN0YXRlLmNhbGxzW2VdWzJdLHM9Yi5TdGF0ZS5jYWxsc1tlXVs0XSxsPSExLHU9MCxjPXIubGVuZ3RoO2M+dTt1Kyspe3ZhciBwPXJbdV0uZWxlbWVudDtpZih0fHxvLmxvb3B8fChcIm5vbmVcIj09PW8uZGlzcGxheSYmUy5zZXRQcm9wZXJ0eVZhbHVlKHAsXCJkaXNwbGF5XCIsby5kaXNwbGF5KSxcImhpZGRlblwiPT09by52aXNpYmlsaXR5JiZTLnNldFByb3BlcnR5VmFsdWUocCxcInZpc2liaWxpdHlcIixvLnZpc2liaWxpdHkpKSxvLmxvb3AhPT0hMCYmKGYucXVldWUocClbMV09PT1hfHwhL1xcLnZlbG9jaXR5UXVldWVFbnRyeUZsYWcvaS50ZXN0KGYucXVldWUocClbMV0pKSYmaShwKSl7aShwKS5pc0FuaW1hdGluZz0hMSxpKHApLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGU9e307dmFyIGQ9ITE7Zi5lYWNoKFMuTGlzdHMudHJhbnNmb3JtczNELGZ1bmN0aW9uKGUsdCl7dmFyIHI9L15zY2FsZS8udGVzdCh0KT8xOjAsbj1pKHApLnRyYW5zZm9ybUNhY2hlW3RdO2kocCkudHJhbnNmb3JtQ2FjaGVbdF0hPT1hJiZuZXcgUmVnRXhwKFwiXlxcXFwoXCIrcitcIlteLl1cIikudGVzdChuKSYmKGQ9ITAsZGVsZXRlIGkocCkudHJhbnNmb3JtQ2FjaGVbdF0pfSksby5tb2JpbGVIQSYmKGQ9ITAsZGVsZXRlIGkocCkudHJhbnNmb3JtQ2FjaGUudHJhbnNsYXRlM2QpLGQmJlMuZmx1c2hUcmFuc2Zvcm1DYWNoZShwKSxTLlZhbHVlcy5yZW1vdmVDbGFzcyhwLFwidmVsb2NpdHktYW5pbWF0aW5nXCIpfWlmKCF0JiZvLmNvbXBsZXRlJiYhby5sb29wJiZ1PT09Yy0xKXRyeXtvLmNvbXBsZXRlLmNhbGwobixuKX1jYXRjaChnKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZ30sMSl9cyYmby5sb29wIT09ITAmJnMobiksaShwKSYmby5sb29wPT09ITAmJiF0JiYoZi5lYWNoKGkocCkudHdlZW5zQ29udGFpbmVyLGZ1bmN0aW9uKGUsdCl7L15yb3RhdGUvLnRlc3QoZSkmJjM2MD09PXBhcnNlRmxvYXQodC5lbmRWYWx1ZSkmJih0LmVuZFZhbHVlPTAsdC5zdGFydFZhbHVlPTM2MCksL15iYWNrZ3JvdW5kUG9zaXRpb24vLnRlc3QoZSkmJjEwMD09PXBhcnNlRmxvYXQodC5lbmRWYWx1ZSkmJlwiJVwiPT09dC51bml0VHlwZSYmKHQuZW5kVmFsdWU9MCx0LnN0YXJ0VmFsdWU9MTAwKX0pLGIocCxcInJldmVyc2VcIix7bG9vcDohMCxkZWxheTpvLmRlbGF5fSkpLG8ucXVldWUhPT0hMSYmZi5kZXF1ZXVlKHAsby5xdWV1ZSl9Yi5TdGF0ZS5jYWxsc1tlXT0hMTtmb3IodmFyIG09MCx5PWIuU3RhdGUuY2FsbHMubGVuZ3RoO3k+bTttKyspaWYoYi5TdGF0ZS5jYWxsc1ttXSE9PSExKXtsPSEwO2JyZWFrfWw9PT0hMSYmKGIuU3RhdGUuaXNUaWNraW5nPSExLGRlbGV0ZSBiLlN0YXRlLmNhbGxzLGIuU3RhdGUuY2FsbHM9W10pfXZhciBmLGQ9ZnVuY3Rpb24oKXtpZihyLmRvY3VtZW50TW9kZSlyZXR1cm4gci5kb2N1bWVudE1vZGU7Zm9yKHZhciBlPTc7ZT40O2UtLSl7dmFyIHQ9ci5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2lmKHQuaW5uZXJIVE1MPVwiPCEtLVtpZiBJRSBcIitlK1wiXT48c3Bhbj48L3NwYW4+PCFbZW5kaWZdLS0+XCIsdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNwYW5cIikubGVuZ3RoKXJldHVybiB0PW51bGwsZX1yZXR1cm4gYX0oKSxnPWZ1bmN0aW9uKCl7dmFyIGU9MDtyZXR1cm4gdC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHQubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbih0KXt2YXIgcixhPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3JldHVybiByPU1hdGgubWF4KDAsMTYtKGEtZSkpLGU9YStyLHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0KGErcil9LHIpfX0oKSxtPXtpc1N0cmluZzpmdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZX0saXNBcnJheTpBcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LGlzRnVuY3Rpb246ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpfSxpc05vZGU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUubm9kZVR5cGV9LGlzTm9kZUxpc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGUmJi9eXFxbb2JqZWN0IChIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdHxPYmplY3QpXFxdJC8udGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpJiZlLmxlbmd0aCE9PWEmJigwPT09ZS5sZW5ndGh8fFwib2JqZWN0XCI9PXR5cGVvZiBlWzBdJiZlWzBdLm5vZGVUeXBlPjApfSxpc1dyYXBwZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJihlLmpxdWVyeXx8dC5aZXB0byYmdC5aZXB0by56ZXB0by5pc1ooZSkpfSxpc1NWRzpmdW5jdGlvbihlKXtyZXR1cm4gdC5TVkdFbGVtZW50JiZlIGluc3RhbmNlb2YgdC5TVkdFbGVtZW50fSxpc0VtcHR5T2JqZWN0OmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiBlKXJldHVybiExO3JldHVybiEwfX0seT0hMTtpZihlLmZuJiZlLmZuLmpxdWVyeT8oZj1lLHk9ITApOmY9dC5WZWxvY2l0eS5VdGlsaXRpZXMsOD49ZCYmIXkpdGhyb3cgbmV3IEVycm9yKFwiVmVsb2NpdHk6IElFOCBhbmQgYmVsb3cgcmVxdWlyZSBqUXVlcnkgdG8gYmUgbG9hZGVkIGJlZm9yZSBWZWxvY2l0eS5cIik7aWYoNz49ZClyZXR1cm4gdm9pZChqUXVlcnkuZm4udmVsb2NpdHk9alF1ZXJ5LmZuLmFuaW1hdGUpO3ZhciBoPTQwMCx2PVwic3dpbmdcIixiPXtTdGF0ZTp7aXNNb2JpbGU6L0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLGlzQW5kcm9pZDovQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksaXNHaW5nZXJicmVhZDovQW5kcm9pZCAyXFwuM1xcLlszLTddL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxpc0Nocm9tZTp0LmNocm9tZSxpc0ZpcmVmb3g6L0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLHByZWZpeEVsZW1lbnQ6ci5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHByZWZpeE1hdGNoZXM6e30sc2Nyb2xsQW5jaG9yOm51bGwsc2Nyb2xsUHJvcGVydHlMZWZ0Om51bGwsc2Nyb2xsUHJvcGVydHlUb3A6bnVsbCxpc1RpY2tpbmc6ITEsY2FsbHM6W119LENTUzp7fSxVdGlsaXRpZXM6ZixSZWRpcmVjdHM6e30sRWFzaW5nczp7fSxQcm9taXNlOnQuUHJvbWlzZSxkZWZhdWx0czp7cXVldWU6XCJcIixkdXJhdGlvbjpoLGVhc2luZzp2LGJlZ2luOmEsY29tcGxldGU6YSxwcm9ncmVzczphLGRpc3BsYXk6YSx2aXNpYmlsaXR5OmEsbG9vcDohMSxkZWxheTohMSxtb2JpbGVIQTohMCxfY2FjaGVWYWx1ZXM6ITB9LGluaXQ6ZnVuY3Rpb24oZSl7Zi5kYXRhKGUsXCJ2ZWxvY2l0eVwiLHtpc1NWRzptLmlzU1ZHKGUpLGlzQW5pbWF0aW5nOiExLGNvbXB1dGVkU3R5bGU6bnVsbCx0d2VlbnNDb250YWluZXI6bnVsbCxyb290UHJvcGVydHlWYWx1ZUNhY2hlOnt9LHRyYW5zZm9ybUNhY2hlOnt9fSl9LGhvb2s6bnVsbCxtb2NrOiExLHZlcnNpb246e21ham9yOjEsbWlub3I6MixwYXRjaDoyfSxkZWJ1ZzohMX07dC5wYWdlWU9mZnNldCE9PWE/KGIuU3RhdGUuc2Nyb2xsQW5jaG9yPXQsYi5TdGF0ZS5zY3JvbGxQcm9wZXJ0eUxlZnQ9XCJwYWdlWE9mZnNldFwiLGIuU3RhdGUuc2Nyb2xsUHJvcGVydHlUb3A9XCJwYWdlWU9mZnNldFwiKTooYi5TdGF0ZS5zY3JvbGxBbmNob3I9ci5kb2N1bWVudEVsZW1lbnR8fHIuYm9keS5wYXJlbnROb2RlfHxyLmJvZHksYi5TdGF0ZS5zY3JvbGxQcm9wZXJ0eUxlZnQ9XCJzY3JvbGxMZWZ0XCIsYi5TdGF0ZS5zY3JvbGxQcm9wZXJ0eVRvcD1cInNjcm9sbFRvcFwiKTt2YXIgeD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuLWUudGVuc2lvbiplLngtZS5mcmljdGlvbiplLnZ9ZnVuY3Rpb24gdCh0LHIsYSl7dmFyIG49e3g6dC54K2EuZHgqcix2OnQudithLmR2KnIsdGVuc2lvbjp0LnRlbnNpb24sZnJpY3Rpb246dC5mcmljdGlvbn07cmV0dXJue2R4Om4udixkdjplKG4pfX1mdW5jdGlvbiByKHIsYSl7dmFyIG49e2R4OnIudixkdjplKHIpfSxvPXQociwuNSphLG4pLGk9dChyLC41KmEsbykscz10KHIsYSxpKSxsPTEvNioobi5keCsyKihvLmR4K2kuZHgpK3MuZHgpLHU9MS82KihuLmR2KzIqKG8uZHYraS5kdikrcy5kdik7cmV0dXJuIHIueD1yLngrbCphLHIudj1yLnYrdSphLHJ9cmV0dXJuIGZ1bmN0aW9uIGEoZSx0LG4pe3ZhciBvLGkscyxsPXt4Oi0xLHY6MCx0ZW5zaW9uOm51bGwsZnJpY3Rpb246bnVsbH0sdT1bMF0sYz0wLHA9MWUtNCxmPS4wMTY7Zm9yKGU9cGFyc2VGbG9hdChlKXx8NTAwLHQ9cGFyc2VGbG9hdCh0KXx8MjAsbj1ufHxudWxsLGwudGVuc2lvbj1lLGwuZnJpY3Rpb249dCxvPW51bGwhPT1uLG8/KGM9YShlLHQpLGk9Yy9uKmYpOmk9ZjtzPXIoc3x8bCxpKSx1LnB1c2goMStzLngpLGMrPTE2LE1hdGguYWJzKHMueCk+cCYmTWF0aC5hYnMocy52KT5wOyk7cmV0dXJuIG8/ZnVuY3Rpb24oZSl7cmV0dXJuIHVbZSoodS5sZW5ndGgtMSl8MF19OmN9fSgpO2IuRWFzaW5ncz17bGluZWFyOmZ1bmN0aW9uKGUpe3JldHVybiBlfSxzd2luZzpmdW5jdGlvbihlKXtyZXR1cm4uNS1NYXRoLmNvcyhlKk1hdGguUEkpLzJ9LHNwcmluZzpmdW5jdGlvbihlKXtyZXR1cm4gMS1NYXRoLmNvcyg0LjUqZSpNYXRoLlBJKSpNYXRoLmV4cCg2Ki1lKX19LGYuZWFjaChbW1wiZWFzZVwiLFsuMjUsLjEsLjI1LDFdXSxbXCJlYXNlLWluXCIsWy40MiwwLDEsMV1dLFtcImVhc2Utb3V0XCIsWzAsMCwuNTgsMV1dLFtcImVhc2UtaW4tb3V0XCIsWy40MiwwLC41OCwxXV0sW1wiZWFzZUluU2luZVwiLFsuNDcsMCwuNzQ1LC43MTVdXSxbXCJlYXNlT3V0U2luZVwiLFsuMzksLjU3NSwuNTY1LDFdXSxbXCJlYXNlSW5PdXRTaW5lXCIsWy40NDUsLjA1LC41NSwuOTVdXSxbXCJlYXNlSW5RdWFkXCIsWy41NSwuMDg1LC42OCwuNTNdXSxbXCJlYXNlT3V0UXVhZFwiLFsuMjUsLjQ2LC40NSwuOTRdXSxbXCJlYXNlSW5PdXRRdWFkXCIsWy40NTUsLjAzLC41MTUsLjk1NV1dLFtcImVhc2VJbkN1YmljXCIsWy41NSwuMDU1LC42NzUsLjE5XV0sW1wiZWFzZU91dEN1YmljXCIsWy4yMTUsLjYxLC4zNTUsMV1dLFtcImVhc2VJbk91dEN1YmljXCIsWy42NDUsLjA0NSwuMzU1LDFdXSxbXCJlYXNlSW5RdWFydFwiLFsuODk1LC4wMywuNjg1LC4yMl1dLFtcImVhc2VPdXRRdWFydFwiLFsuMTY1LC44NCwuNDQsMV1dLFtcImVhc2VJbk91dFF1YXJ0XCIsWy43NywwLC4xNzUsMV1dLFtcImVhc2VJblF1aW50XCIsWy43NTUsLjA1LC44NTUsLjA2XV0sW1wiZWFzZU91dFF1aW50XCIsWy4yMywxLC4zMiwxXV0sW1wiZWFzZUluT3V0UXVpbnRcIixbLjg2LDAsLjA3LDFdXSxbXCJlYXNlSW5FeHBvXCIsWy45NSwuMDUsLjc5NSwuMDM1XV0sW1wiZWFzZU91dEV4cG9cIixbLjE5LDEsLjIyLDFdXSxbXCJlYXNlSW5PdXRFeHBvXCIsWzEsMCwwLDFdXSxbXCJlYXNlSW5DaXJjXCIsWy42LC4wNCwuOTgsLjMzNV1dLFtcImVhc2VPdXRDaXJjXCIsWy4wNzUsLjgyLC4xNjUsMV1dLFtcImVhc2VJbk91dENpcmNcIixbLjc4NSwuMTM1LC4xNSwuODZdXV0sZnVuY3Rpb24oZSx0KXtiLkVhc2luZ3NbdFswXV09bC5hcHBseShudWxsLHRbMV0pfSk7dmFyIFM9Yi5DU1M9e1JlZ0V4Ontpc0hleDovXiMoW0EtZlxcZF17M30pezEsMn0kL2ksdmFsdWVVbndyYXA6L15bQS16XStcXCgoLiopXFwpJC9pLHdyYXBwZWRWYWx1ZUFscmVhZHlFeHRyYWN0ZWQ6L1swLTkuXSsgWzAtOS5dKyBbMC05Ll0rKCBbMC05Ll0rKT8vLHZhbHVlU3BsaXQ6LyhbQS16XStcXCguK1xcKSl8KChbQS16MC05Iy0uXSs/KSg/PVxcc3wkKSkvZ2l9LExpc3RzOntjb2xvcnM6W1wiZmlsbFwiLFwic3Ryb2tlXCIsXCJzdG9wQ29sb3JcIixcImNvbG9yXCIsXCJiYWNrZ3JvdW5kQ29sb3JcIixcImJvcmRlckNvbG9yXCIsXCJib3JkZXJUb3BDb2xvclwiLFwiYm9yZGVyUmlnaHRDb2xvclwiLFwiYm9yZGVyQm90dG9tQ29sb3JcIixcImJvcmRlckxlZnRDb2xvclwiLFwib3V0bGluZUNvbG9yXCJdLHRyYW5zZm9ybXNCYXNlOltcInRyYW5zbGF0ZVhcIixcInRyYW5zbGF0ZVlcIixcInNjYWxlXCIsXCJzY2FsZVhcIixcInNjYWxlWVwiLFwic2tld1hcIixcInNrZXdZXCIsXCJyb3RhdGVaXCJdLHRyYW5zZm9ybXMzRDpbXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLFwidHJhbnNsYXRlWlwiLFwic2NhbGVaXCIsXCJyb3RhdGVYXCIsXCJyb3RhdGVZXCJdfSxIb29rczp7dGVtcGxhdGVzOnt0ZXh0U2hhZG93OltcIkNvbG9yIFggWSBCbHVyXCIsXCJibGFjayAwcHggMHB4IDBweFwiXSxib3hTaGFkb3c6W1wiQ29sb3IgWCBZIEJsdXIgU3ByZWFkXCIsXCJibGFjayAwcHggMHB4IDBweCAwcHhcIl0sY2xpcDpbXCJUb3AgUmlnaHQgQm90dG9tIExlZnRcIixcIjBweCAwcHggMHB4IDBweFwiXSxiYWNrZ3JvdW5kUG9zaXRpb246W1wiWCBZXCIsXCIwJSAwJVwiXSx0cmFuc2Zvcm1PcmlnaW46W1wiWCBZIFpcIixcIjUwJSA1MCUgMHB4XCJdLHBlcnNwZWN0aXZlT3JpZ2luOltcIlggWVwiLFwiNTAlIDUwJVwiXX0scmVnaXN0ZXJlZDp7fSxyZWdpc3RlcjpmdW5jdGlvbigpe2Zvcih2YXIgZT0wO2U8Uy5MaXN0cy5jb2xvcnMubGVuZ3RoO2UrKyl7dmFyIHQ9XCJjb2xvclwiPT09Uy5MaXN0cy5jb2xvcnNbZV0/XCIwIDAgMCAxXCI6XCIyNTUgMjU1IDI1NSAxXCI7Uy5Ib29rcy50ZW1wbGF0ZXNbUy5MaXN0cy5jb2xvcnNbZV1dPVtcIlJlZCBHcmVlbiBCbHVlIEFscGhhXCIsdF19dmFyIHIsYSxuO2lmKGQpZm9yKHIgaW4gUy5Ib29rcy50ZW1wbGF0ZXMpe2E9Uy5Ib29rcy50ZW1wbGF0ZXNbcl0sbj1hWzBdLnNwbGl0KFwiIFwiKTt2YXIgbz1hWzFdLm1hdGNoKFMuUmVnRXgudmFsdWVTcGxpdCk7XCJDb2xvclwiPT09blswXSYmKG4ucHVzaChuLnNoaWZ0KCkpLG8ucHVzaChvLnNoaWZ0KCkpLFMuSG9va3MudGVtcGxhdGVzW3JdPVtuLmpvaW4oXCIgXCIpLG8uam9pbihcIiBcIildKX1mb3IociBpbiBTLkhvb2tzLnRlbXBsYXRlcyl7YT1TLkhvb2tzLnRlbXBsYXRlc1tyXSxuPWFbMF0uc3BsaXQoXCIgXCIpO2Zvcih2YXIgZSBpbiBuKXt2YXIgaT1yK25bZV0scz1lO1MuSG9va3MucmVnaXN0ZXJlZFtpXT1bcixzXX19fSxnZXRSb290OmZ1bmN0aW9uKGUpe3ZhciB0PVMuSG9va3MucmVnaXN0ZXJlZFtlXTtyZXR1cm4gdD90WzBdOmV9LGNsZWFuUm9vdFByb3BlcnR5VmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gUy5SZWdFeC52YWx1ZVVud3JhcC50ZXN0KHQpJiYodD10Lm1hdGNoKFMuUmVnRXgudmFsdWVVbndyYXApWzFdKSxTLlZhbHVlcy5pc0NTU051bGxWYWx1ZSh0KSYmKHQ9Uy5Ib29rcy50ZW1wbGF0ZXNbZV1bMV0pLHR9LGV4dHJhY3RWYWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPVMuSG9va3MucmVnaXN0ZXJlZFtlXTtpZihyKXt2YXIgYT1yWzBdLG49clsxXTtyZXR1cm4gdD1TLkhvb2tzLmNsZWFuUm9vdFByb3BlcnR5VmFsdWUoYSx0KSx0LnRvU3RyaW5nKCkubWF0Y2goUy5SZWdFeC52YWx1ZVNwbGl0KVtuXX1yZXR1cm4gdH0saW5qZWN0VmFsdWU6ZnVuY3Rpb24oZSx0LHIpe3ZhciBhPVMuSG9va3MucmVnaXN0ZXJlZFtlXTtpZihhKXt2YXIgbixvLGk9YVswXSxzPWFbMV07cmV0dXJuIHI9Uy5Ib29rcy5jbGVhblJvb3RQcm9wZXJ0eVZhbHVlKGksciksbj1yLnRvU3RyaW5nKCkubWF0Y2goUy5SZWdFeC52YWx1ZVNwbGl0KSxuW3NdPXQsbz1uLmpvaW4oXCIgXCIpfXJldHVybiByfX0sTm9ybWFsaXphdGlvbnM6e3JlZ2lzdGVyZWQ6e2NsaXA6ZnVuY3Rpb24oZSx0LHIpe3N3aXRjaChlKXtjYXNlXCJuYW1lXCI6cmV0dXJuXCJjbGlwXCI7Y2FzZVwiZXh0cmFjdFwiOnZhciBhO3JldHVybiBTLlJlZ0V4LndyYXBwZWRWYWx1ZUFscmVhZHlFeHRyYWN0ZWQudGVzdChyKT9hPXI6KGE9ci50b1N0cmluZygpLm1hdGNoKFMuUmVnRXgudmFsdWVVbndyYXApLGE9YT9hWzFdLnJlcGxhY2UoLywoXFxzKyk/L2csXCIgXCIpOnIpLGE7Y2FzZVwiaW5qZWN0XCI6cmV0dXJuXCJyZWN0KFwiK3IrXCIpXCJ9fSxibHVyOmZ1bmN0aW9uKGUsdCxyKXtzd2l0Y2goZSl7Y2FzZVwibmFtZVwiOnJldHVybiBiLlN0YXRlLmlzRmlyZWZveD9cImZpbHRlclwiOlwiLXdlYmtpdC1maWx0ZXJcIjtjYXNlXCJleHRyYWN0XCI6dmFyIGE9cGFyc2VGbG9hdChyKTtpZighYSYmMCE9PWEpe3ZhciBuPXIudG9TdHJpbmcoKS5tYXRjaCgvYmx1clxcKChbMC05XStbQS16XSspXFwpL2kpO2E9bj9uWzFdOjB9cmV0dXJuIGE7Y2FzZVwiaW5qZWN0XCI6cmV0dXJuIHBhcnNlRmxvYXQocik/XCJibHVyKFwiK3IrXCIpXCI6XCJub25lXCJ9fSxvcGFjaXR5OmZ1bmN0aW9uKGUsdCxyKXtpZig4Pj1kKXN3aXRjaChlKXtjYXNlXCJuYW1lXCI6cmV0dXJuXCJmaWx0ZXJcIjtjYXNlXCJleHRyYWN0XCI6dmFyIGE9ci50b1N0cmluZygpLm1hdGNoKC9hbHBoYVxcKG9wYWNpdHk9KC4qKVxcKS9pKTtyZXR1cm4gcj1hP2FbMV0vMTAwOjE7Y2FzZVwiaW5qZWN0XCI6cmV0dXJuIHQuc3R5bGUuem9vbT0xLHBhcnNlRmxvYXQocik+PTE/XCJcIjpcImFscGhhKG9wYWNpdHk9XCIrcGFyc2VJbnQoMTAwKnBhcnNlRmxvYXQociksMTApK1wiKVwifWVsc2Ugc3dpdGNoKGUpe2Nhc2VcIm5hbWVcIjpyZXR1cm5cIm9wYWNpdHlcIjtjYXNlXCJleHRyYWN0XCI6cmV0dXJuIHI7Y2FzZVwiaW5qZWN0XCI6cmV0dXJuIHJ9fX0scmVnaXN0ZXI6ZnVuY3Rpb24oKXs5Pj1kfHxiLlN0YXRlLmlzR2luZ2VyYnJlYWR8fChTLkxpc3RzLnRyYW5zZm9ybXNCYXNlPVMuTGlzdHMudHJhbnNmb3Jtc0Jhc2UuY29uY2F0KFMuTGlzdHMudHJhbnNmb3JtczNEKSk7Zm9yKHZhciBlPTA7ZTxTLkxpc3RzLnRyYW5zZm9ybXNCYXNlLmxlbmd0aDtlKyspIWZ1bmN0aW9uKCl7dmFyIHQ9Uy5MaXN0cy50cmFuc2Zvcm1zQmFzZVtlXTtTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbdF09ZnVuY3Rpb24oZSxyLG4pe3N3aXRjaChlKXtjYXNlXCJuYW1lXCI6cmV0dXJuXCJ0cmFuc2Zvcm1cIjtjYXNlXCJleHRyYWN0XCI6cmV0dXJuIGkocik9PT1hfHxpKHIpLnRyYW5zZm9ybUNhY2hlW3RdPT09YT8vXnNjYWxlL2kudGVzdCh0KT8xOjA6aShyKS50cmFuc2Zvcm1DYWNoZVt0XS5yZXBsYWNlKC9bKCldL2csXCJcIik7Y2FzZVwiaW5qZWN0XCI6dmFyIG89ITE7c3dpdGNoKHQuc3Vic3RyKDAsdC5sZW5ndGgtMSkpe2Nhc2VcInRyYW5zbGF0ZVwiOm89IS8oJXxweHxlbXxyZW18dnd8dmh8XFxkKSQvaS50ZXN0KG4pO2JyZWFrO2Nhc2VcInNjYWxcIjpjYXNlXCJzY2FsZVwiOmIuU3RhdGUuaXNBbmRyb2lkJiZpKHIpLnRyYW5zZm9ybUNhY2hlW3RdPT09YSYmMT5uJiYobj0xKSxvPSEvKFxcZCkkL2kudGVzdChuKTticmVhaztjYXNlXCJza2V3XCI6bz0hLyhkZWd8XFxkKSQvaS50ZXN0KG4pO2JyZWFrO2Nhc2VcInJvdGF0ZVwiOm89IS8oZGVnfFxcZCkkL2kudGVzdChuKX1yZXR1cm4gb3x8KGkocikudHJhbnNmb3JtQ2FjaGVbdF09XCIoXCIrbitcIilcIiksaShyKS50cmFuc2Zvcm1DYWNoZVt0XX19fSgpO2Zvcih2YXIgZT0wO2U8Uy5MaXN0cy5jb2xvcnMubGVuZ3RoO2UrKykhZnVuY3Rpb24oKXt2YXIgdD1TLkxpc3RzLmNvbG9yc1tlXTtTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbdF09ZnVuY3Rpb24oZSxyLG4pe3N3aXRjaChlKXtjYXNlXCJuYW1lXCI6cmV0dXJuIHQ7Y2FzZVwiZXh0cmFjdFwiOnZhciBvO2lmKFMuUmVnRXgud3JhcHBlZFZhbHVlQWxyZWFkeUV4dHJhY3RlZC50ZXN0KG4pKW89bjtlbHNle3ZhciBpLHM9e2JsYWNrOlwicmdiKDAsIDAsIDApXCIsYmx1ZTpcInJnYigwLCAwLCAyNTUpXCIsZ3JheTpcInJnYigxMjgsIDEyOCwgMTI4KVwiLGdyZWVuOlwicmdiKDAsIDEyOCwgMClcIixyZWQ6XCJyZ2IoMjU1LCAwLCAwKVwiLHdoaXRlOlwicmdiKDI1NSwgMjU1LCAyNTUpXCJ9Oy9eW0Etel0rJC9pLnRlc3Qobik/aT1zW25dIT09YT9zW25dOnMuYmxhY2s6Uy5SZWdFeC5pc0hleC50ZXN0KG4pP2k9XCJyZ2IoXCIrUy5WYWx1ZXMuaGV4VG9SZ2Iobikuam9pbihcIiBcIikrXCIpXCI6L15yZ2JhP1xcKC9pLnRlc3Qobil8fChpPXMuYmxhY2spLG89KGl8fG4pLnRvU3RyaW5nKCkubWF0Y2goUy5SZWdFeC52YWx1ZVVud3JhcClbMV0ucmVwbGFjZSgvLChcXHMrKT8vZyxcIiBcIil9cmV0dXJuIDg+PWR8fDMhPT1vLnNwbGl0KFwiIFwiKS5sZW5ndGh8fChvKz1cIiAxXCIpLG87Y2FzZVwiaW5qZWN0XCI6cmV0dXJuIDg+PWQ/ND09PW4uc3BsaXQoXCIgXCIpLmxlbmd0aCYmKG49bi5zcGxpdCgvXFxzKy8pLnNsaWNlKDAsMykuam9pbihcIiBcIikpOjM9PT1uLnNwbGl0KFwiIFwiKS5sZW5ndGgmJihuKz1cIiAxXCIpLCg4Pj1kP1wicmdiXCI6XCJyZ2JhXCIpK1wiKFwiK24ucmVwbGFjZSgvXFxzKy9nLFwiLFwiKS5yZXBsYWNlKC9cXC4oXFxkKSsoPz0sKS9nLFwiXCIpK1wiKVwifX19KCl9fSxOYW1lczp7Y2FtZWxDYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoLy0oXFx3KS9nLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQudG9VcHBlckNhc2UoKX0pfSxTVkdBdHRyaWJ1dGU6ZnVuY3Rpb24oZSl7dmFyIHQ9XCJ3aWR0aHxoZWlnaHR8eHx5fGN4fGN5fHJ8cnh8cnl8eDF8eDJ8eTF8eTJcIjtyZXR1cm4oZHx8Yi5TdGF0ZS5pc0FuZHJvaWQmJiFiLlN0YXRlLmlzQ2hyb21lKSYmKHQrPVwifHRyYW5zZm9ybVwiKSxuZXcgUmVnRXhwKFwiXihcIit0K1wiKSRcIixcImlcIikudGVzdChlKX0scHJlZml4Q2hlY2s6ZnVuY3Rpb24oZSl7aWYoYi5TdGF0ZS5wcmVmaXhNYXRjaGVzW2VdKXJldHVybltiLlN0YXRlLnByZWZpeE1hdGNoZXNbZV0sITBdO2Zvcih2YXIgdD1bXCJcIixcIldlYmtpdFwiLFwiTW96XCIsXCJtc1wiLFwiT1wiXSxyPTAsYT10Lmxlbmd0aDthPnI7cisrKXt2YXIgbjtpZihuPTA9PT1yP2U6dFtyXStlLnJlcGxhY2UoL15cXHcvLGZ1bmN0aW9uKGUpe3JldHVybiBlLnRvVXBwZXJDYXNlKCl9KSxtLmlzU3RyaW5nKGIuU3RhdGUucHJlZml4RWxlbWVudC5zdHlsZVtuXSkpcmV0dXJuIGIuU3RhdGUucHJlZml4TWF0Y2hlc1tlXT1uLFtuLCEwXX1yZXR1cm5bZSwhMV19fSxWYWx1ZXM6e2hleFRvUmdiOmZ1bmN0aW9uKGUpe3ZhciB0LHI9L14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaSxhPS9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7cmV0dXJuIGU9ZS5yZXBsYWNlKHIsZnVuY3Rpb24oZSx0LHIsYSl7cmV0dXJuIHQrdCtyK3IrYSthfSksdD1hLmV4ZWMoZSksdD9bcGFyc2VJbnQodFsxXSwxNikscGFyc2VJbnQodFsyXSwxNikscGFyc2VJbnQodFszXSwxNildOlswLDAsMF19LGlzQ1NTTnVsbFZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiAwPT1lfHwvXihub25lfGF1dG98dHJhbnNwYXJlbnR8KHJnYmFcXCgwLCA/MCwgPzAsID8wXFwpKSkkL2kudGVzdChlKX0sZ2V0VW5pdFR5cGU6ZnVuY3Rpb24oZSl7cmV0dXJuL14ocm90YXRlfHNrZXcpL2kudGVzdChlKT9cImRlZ1wiOi8oXihzY2FsZXxzY2FsZVh8c2NhbGVZfHNjYWxlWnxhbHBoYXxmbGV4R3Jvd3xmbGV4SGVpZ2h0fHpJbmRleHxmb250V2VpZ2h0KSQpfCgob3BhY2l0eXxyZWR8Z3JlZW58Ymx1ZXxhbHBoYSkkKS9pLnRlc3QoZSk/XCJcIjpcInB4XCJ9LGdldERpc3BsYXlUeXBlOmZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUudGFnTmFtZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7cmV0dXJuL14oYnxiaWd8aXxzbWFsbHx0dHxhYmJyfGFjcm9ueW18Y2l0ZXxjb2RlfGRmbnxlbXxrYmR8c3Ryb25nfHNhbXB8dmFyfGF8YmRvfGJyfGltZ3xtYXB8b2JqZWN0fHF8c2NyaXB0fHNwYW58c3VifHN1cHxidXR0b258aW5wdXR8bGFiZWx8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KHQpP1wiaW5saW5lXCI6L14obGkpJC9pLnRlc3QodCk/XCJsaXN0LWl0ZW1cIjovXih0cikkL2kudGVzdCh0KT9cInRhYmxlLXJvd1wiOi9eKHRhYmxlKSQvaS50ZXN0KHQpP1widGFibGVcIjovXih0Ym9keSkkL2kudGVzdCh0KT9cInRhYmxlLXJvdy1ncm91cFwiOlwiYmxvY2tcIn0sYWRkQ2xhc3M6ZnVuY3Rpb24oZSx0KXtlLmNsYXNzTGlzdD9lLmNsYXNzTGlzdC5hZGQodCk6ZS5jbGFzc05hbWUrPShlLmNsYXNzTmFtZS5sZW5ndGg/XCIgXCI6XCJcIikrdH0scmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oZSx0KXtlLmNsYXNzTGlzdD9lLmNsYXNzTGlzdC5yZW1vdmUodCk6ZS5jbGFzc05hbWU9ZS5jbGFzc05hbWUudG9TdHJpbmcoKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIit0LnNwbGl0KFwiIFwiKS5qb2luKFwifFwiKStcIihcXFxcc3wkKVwiLFwiZ2lcIiksXCIgXCIpfX0sZ2V0UHJvcGVydHlWYWx1ZTpmdW5jdGlvbihlLHIsbixvKXtmdW5jdGlvbiBzKGUscil7ZnVuY3Rpb24gbigpe3UmJlMuc2V0UHJvcGVydHlWYWx1ZShlLFwiZGlzcGxheVwiLFwibm9uZVwiKX12YXIgbD0wO2lmKDg+PWQpbD1mLmNzcyhlLHIpO2Vsc2V7dmFyIHU9ITE7aWYoL14od2lkdGh8aGVpZ2h0KSQvLnRlc3QocikmJjA9PT1TLmdldFByb3BlcnR5VmFsdWUoZSxcImRpc3BsYXlcIikmJih1PSEwLFMuc2V0UHJvcGVydHlWYWx1ZShlLFwiZGlzcGxheVwiLFMuVmFsdWVzLmdldERpc3BsYXlUeXBlKGUpKSksIW8pe2lmKFwiaGVpZ2h0XCI9PT1yJiZcImJvcmRlci1ib3hcIiE9PVMuZ2V0UHJvcGVydHlWYWx1ZShlLFwiYm94U2l6aW5nXCIpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSl7dmFyIGM9ZS5vZmZzZXRIZWlnaHQtKHBhcnNlRmxvYXQoUy5nZXRQcm9wZXJ0eVZhbHVlKGUsXCJib3JkZXJUb3BXaWR0aFwiKSl8fDApLShwYXJzZUZsb2F0KFMuZ2V0UHJvcGVydHlWYWx1ZShlLFwiYm9yZGVyQm90dG9tV2lkdGhcIikpfHwwKS0ocGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUoZSxcInBhZGRpbmdUb3BcIikpfHwwKS0ocGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUoZSxcInBhZGRpbmdCb3R0b21cIikpfHwwKTtyZXR1cm4gbigpLGN9aWYoXCJ3aWR0aFwiPT09ciYmXCJib3JkZXItYm94XCIhPT1TLmdldFByb3BlcnR5VmFsdWUoZSxcImJveFNpemluZ1wiKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpe3ZhciBwPWUub2Zmc2V0V2lkdGgtKHBhcnNlRmxvYXQoUy5nZXRQcm9wZXJ0eVZhbHVlKGUsXCJib3JkZXJMZWZ0V2lkdGhcIikpfHwwKS0ocGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUoZSxcImJvcmRlclJpZ2h0V2lkdGhcIikpfHwwKS0ocGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUoZSxcInBhZGRpbmdMZWZ0XCIpKXx8MCktKHBhcnNlRmxvYXQoUy5nZXRQcm9wZXJ0eVZhbHVlKGUsXCJwYWRkaW5nUmlnaHRcIikpfHwwKTtyZXR1cm4gbigpLHB9fXZhciBnO2c9aShlKT09PWE/dC5nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCk6aShlKS5jb21wdXRlZFN0eWxlP2koZSkuY29tcHV0ZWRTdHlsZTppKGUpLmNvbXB1dGVkU3R5bGU9dC5nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCksXCJib3JkZXJDb2xvclwiPT09ciYmKHI9XCJib3JkZXJUb3BDb2xvclwiKSxsPTk9PT1kJiZcImZpbHRlclwiPT09cj9nLmdldFByb3BlcnR5VmFsdWUocik6Z1tyXSwoXCJcIj09PWx8fG51bGw9PT1sKSYmKGw9ZS5zdHlsZVtyXSksbigpfWlmKFwiYXV0b1wiPT09bCYmL14odG9wfHJpZ2h0fGJvdHRvbXxsZWZ0KSQvaS50ZXN0KHIpKXt2YXIgbT1zKGUsXCJwb3NpdGlvblwiKTsoXCJmaXhlZFwiPT09bXx8XCJhYnNvbHV0ZVwiPT09bSYmL3RvcHxsZWZ0L2kudGVzdChyKSkmJihsPWYoZSkucG9zaXRpb24oKVtyXStcInB4XCIpfXJldHVybiBsfXZhciBsO2lmKFMuSG9va3MucmVnaXN0ZXJlZFtyXSl7dmFyIHU9cixjPVMuSG9va3MuZ2V0Um9vdCh1KTtuPT09YSYmKG49Uy5nZXRQcm9wZXJ0eVZhbHVlKGUsUy5OYW1lcy5wcmVmaXhDaGVjayhjKVswXSkpLFMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtjXSYmKG49Uy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW2NdKFwiZXh0cmFjdFwiLGUsbikpLGw9Uy5Ib29rcy5leHRyYWN0VmFsdWUodSxuKX1lbHNlIGlmKFMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyXSl7dmFyIHAsZztwPVMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyXShcIm5hbWVcIixlKSxcInRyYW5zZm9ybVwiIT09cCYmKGc9cyhlLFMuTmFtZXMucHJlZml4Q2hlY2socClbMF0pLFMuVmFsdWVzLmlzQ1NTTnVsbFZhbHVlKGcpJiZTLkhvb2tzLnRlbXBsYXRlc1tyXSYmKGc9Uy5Ib29rcy50ZW1wbGF0ZXNbcl1bMV0pKSxsPVMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyXShcImV4dHJhY3RcIixlLGcpfWlmKCEvXltcXGQtXS8udGVzdChsKSlpZihpKGUpJiZpKGUpLmlzU1ZHJiZTLk5hbWVzLlNWR0F0dHJpYnV0ZShyKSlpZigvXihoZWlnaHR8d2lkdGgpJC9pLnRlc3QocikpdHJ5e2w9ZS5nZXRCQm94KClbcl19Y2F0Y2gobSl7bD0wfWVsc2UgbD1lLmdldEF0dHJpYnV0ZShyKTtlbHNlIGw9cyhlLFMuTmFtZXMucHJlZml4Q2hlY2socilbMF0pO3JldHVybiBTLlZhbHVlcy5pc0NTU051bGxWYWx1ZShsKSYmKGw9MCksYi5kZWJ1Zz49MiYmY29uc29sZS5sb2coXCJHZXQgXCIrcitcIjogXCIrbCksbH0sc2V0UHJvcGVydHlWYWx1ZTpmdW5jdGlvbihlLHIsYSxuLG8pe3ZhciBzPXI7aWYoXCJzY3JvbGxcIj09PXIpby5jb250YWluZXI/by5jb250YWluZXJbXCJzY3JvbGxcIitvLmRpcmVjdGlvbl09YTpcIkxlZnRcIj09PW8uZGlyZWN0aW9uP3Quc2Nyb2xsVG8oYSxvLmFsdGVybmF0ZVZhbHVlKTp0LnNjcm9sbFRvKG8uYWx0ZXJuYXRlVmFsdWUsYSk7ZWxzZSBpZihTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcl0mJlwidHJhbnNmb3JtXCI9PT1TLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcl0oXCJuYW1lXCIsZSkpUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3JdKFwiaW5qZWN0XCIsZSxhKSxzPVwidHJhbnNmb3JtXCIsYT1pKGUpLnRyYW5zZm9ybUNhY2hlW3JdO2Vsc2V7aWYoUy5Ib29rcy5yZWdpc3RlcmVkW3JdKXt2YXIgbD1yLHU9Uy5Ib29rcy5nZXRSb290KHIpO249bnx8Uy5nZXRQcm9wZXJ0eVZhbHVlKGUsdSksYT1TLkhvb2tzLmluamVjdFZhbHVlKGwsYSxuKSxyPXV9aWYoUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3JdJiYoYT1TLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcl0oXCJpbmplY3RcIixlLGEpLHI9Uy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3JdKFwibmFtZVwiLGUpKSxzPVMuTmFtZXMucHJlZml4Q2hlY2socilbMF0sOD49ZCl0cnl7ZS5zdHlsZVtzXT1hfWNhdGNoKGMpe2IuZGVidWcmJmNvbnNvbGUubG9nKFwiQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFtcIithK1wiXSBmb3IgW1wiK3MrXCJdXCIpfWVsc2UgaShlKSYmaShlKS5pc1NWRyYmUy5OYW1lcy5TVkdBdHRyaWJ1dGUocik/ZS5zZXRBdHRyaWJ1dGUocixhKTplLnN0eWxlW3NdPWE7Yi5kZWJ1Zz49MiYmY29uc29sZS5sb2coXCJTZXQgXCIrcitcIiAoXCIrcytcIik6IFwiK2EpfXJldHVybltzLGFdfSxmbHVzaFRyYW5zZm9ybUNhY2hlOmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIHBhcnNlRmxvYXQoUy5nZXRQcm9wZXJ0eVZhbHVlKGUsdCkpfXZhciByPVwiXCI7aWYoKGR8fGIuU3RhdGUuaXNBbmRyb2lkJiYhYi5TdGF0ZS5pc0Nocm9tZSkmJmkoZSkuaXNTVkcpe3ZhciBhPXt0cmFuc2xhdGU6W3QoXCJ0cmFuc2xhdGVYXCIpLHQoXCJ0cmFuc2xhdGVZXCIpXSxza2V3WDpbdChcInNrZXdYXCIpXSxza2V3WTpbdChcInNrZXdZXCIpXSxzY2FsZToxIT09dChcInNjYWxlXCIpP1t0KFwic2NhbGVcIiksdChcInNjYWxlXCIpXTpbdChcInNjYWxlWFwiKSx0KFwic2NhbGVZXCIpXSxyb3RhdGU6W3QoXCJyb3RhdGVaXCIpLDAsMF19O2YuZWFjaChpKGUpLnRyYW5zZm9ybUNhY2hlLGZ1bmN0aW9uKGUpey9edHJhbnNsYXRlL2kudGVzdChlKT9lPVwidHJhbnNsYXRlXCI6L15zY2FsZS9pLnRlc3QoZSk/ZT1cInNjYWxlXCI6L15yb3RhdGUvaS50ZXN0KGUpJiYoZT1cInJvdGF0ZVwiKSxhW2VdJiYocis9ZStcIihcIithW2VdLmpvaW4oXCIgXCIpK1wiKSBcIixkZWxldGUgYVtlXSl9KX1lbHNle3ZhciBuLG87Zi5lYWNoKGkoZSkudHJhbnNmb3JtQ2FjaGUsZnVuY3Rpb24odCl7cmV0dXJuIG49aShlKS50cmFuc2Zvcm1DYWNoZVt0XSxcInRyYW5zZm9ybVBlcnNwZWN0aXZlXCI9PT10PyhvPW4sITApOig5PT09ZCYmXCJyb3RhdGVaXCI9PT10JiYodD1cInJvdGF0ZVwiKSx2b2lkKHIrPXQrbitcIiBcIikpfSksbyYmKHI9XCJwZXJzcGVjdGl2ZVwiK28rXCIgXCIrcil9Uy5zZXRQcm9wZXJ0eVZhbHVlKGUsXCJ0cmFuc2Zvcm1cIixyKX19O1MuSG9va3MucmVnaXN0ZXIoKSxTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyKCksYi5ob29rPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1hO3JldHVybiBlPW8oZSksZi5lYWNoKGUsZnVuY3Rpb24oZSxvKXtpZihpKG8pPT09YSYmYi5pbml0KG8pLHI9PT1hKW49PT1hJiYobj1iLkNTUy5nZXRQcm9wZXJ0eVZhbHVlKG8sdCkpO2Vsc2V7dmFyIHM9Yi5DU1Muc2V0UHJvcGVydHlWYWx1ZShvLHQscik7XCJ0cmFuc2Zvcm1cIj09PXNbMF0mJmIuQ1NTLmZsdXNoVHJhbnNmb3JtQ2FjaGUobyksbj1zfX0pLG59O3ZhciBQPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3JldHVybiBzP2sucHJvbWlzZXx8bnVsbDpsfWZ1bmN0aW9uIG4oKXtmdW5jdGlvbiBlKGUpe2Z1bmN0aW9uIHAoZSx0KXt2YXIgcj1hLG49YSxpPWE7cmV0dXJuIG0uaXNBcnJheShlKT8ocj1lWzBdLCFtLmlzQXJyYXkoZVsxXSkmJi9eW1xcZC1dLy50ZXN0KGVbMV0pfHxtLmlzRnVuY3Rpb24oZVsxXSl8fFMuUmVnRXguaXNIZXgudGVzdChlWzFdKT9pPWVbMV06KG0uaXNTdHJpbmcoZVsxXSkmJiFTLlJlZ0V4LmlzSGV4LnRlc3QoZVsxXSl8fG0uaXNBcnJheShlWzFdKSkmJihuPXQ/ZVsxXTp1KGVbMV0scy5kdXJhdGlvbiksZVsyXSE9PWEmJihpPWVbMl0pKSk6cj1lLHR8fChuPW58fHMuZWFzaW5nKSxtLmlzRnVuY3Rpb24ocikmJihyPXIuY2FsbChvLFYsdykpLG0uaXNGdW5jdGlvbihpKSYmKGk9aS5jYWxsKG8sVix3KSksW3J8fDAsbixpXX1mdW5jdGlvbiBkKGUsdCl7dmFyIHIsYTtyZXR1cm4gYT0odHx8XCIwXCIpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bJUEtel0rJC8sZnVuY3Rpb24oZSl7cmV0dXJuIHI9ZSxcIlwifSkscnx8KHI9Uy5WYWx1ZXMuZ2V0VW5pdFR5cGUoZSkpLFthLHJdfWZ1bmN0aW9uIGgoKXt2YXIgZT17bXlQYXJlbnQ6by5wYXJlbnROb2RlfHxyLmJvZHkscG9zaXRpb246Uy5nZXRQcm9wZXJ0eVZhbHVlKG8sXCJwb3NpdGlvblwiKSxmb250U2l6ZTpTLmdldFByb3BlcnR5VmFsdWUobyxcImZvbnRTaXplXCIpfSxhPWUucG9zaXRpb249PT1MLmxhc3RQb3NpdGlvbiYmZS5teVBhcmVudD09PUwubGFzdFBhcmVudCxuPWUuZm9udFNpemU9PT1MLmxhc3RGb250U2l6ZTtMLmxhc3RQYXJlbnQ9ZS5teVBhcmVudCxMLmxhc3RQb3NpdGlvbj1lLnBvc2l0aW9uLEwubGFzdEZvbnRTaXplPWUuZm9udFNpemU7dmFyIHM9MTAwLGw9e307aWYobiYmYSlsLmVtVG9QeD1MLmxhc3RFbVRvUHgsbC5wZXJjZW50VG9QeFdpZHRoPUwubGFzdFBlcmNlbnRUb1B4V2lkdGgsbC5wZXJjZW50VG9QeEhlaWdodD1MLmxhc3RQZXJjZW50VG9QeEhlaWdodDtlbHNle3ZhciB1PWkobykuaXNTVkc/ci5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwicmVjdFwiKTpyLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Yi5pbml0KHUpLGUubXlQYXJlbnQuYXBwZW5kQ2hpbGQodSksZi5lYWNoKFtcIm92ZXJmbG93XCIsXCJvdmVyZmxvd1hcIixcIm92ZXJmbG93WVwiXSxmdW5jdGlvbihlLHQpe2IuQ1NTLnNldFByb3BlcnR5VmFsdWUodSx0LFwiaGlkZGVuXCIpfSksYi5DU1Muc2V0UHJvcGVydHlWYWx1ZSh1LFwicG9zaXRpb25cIixlLnBvc2l0aW9uKSxiLkNTUy5zZXRQcm9wZXJ0eVZhbHVlKHUsXCJmb250U2l6ZVwiLGUuZm9udFNpemUpLGIuQ1NTLnNldFByb3BlcnR5VmFsdWUodSxcImJveFNpemluZ1wiLFwiY29udGVudC1ib3hcIiksZi5lYWNoKFtcIm1pbldpZHRoXCIsXCJtYXhXaWR0aFwiLFwid2lkdGhcIixcIm1pbkhlaWdodFwiLFwibWF4SGVpZ2h0XCIsXCJoZWlnaHRcIl0sZnVuY3Rpb24oZSx0KXtiLkNTUy5zZXRQcm9wZXJ0eVZhbHVlKHUsdCxzK1wiJVwiKX0pLGIuQ1NTLnNldFByb3BlcnR5VmFsdWUodSxcInBhZGRpbmdMZWZ0XCIscytcImVtXCIpLGwucGVyY2VudFRvUHhXaWR0aD1MLmxhc3RQZXJjZW50VG9QeFdpZHRoPShwYXJzZUZsb2F0KFMuZ2V0UHJvcGVydHlWYWx1ZSh1LFwid2lkdGhcIixudWxsLCEwKSl8fDEpL3MsbC5wZXJjZW50VG9QeEhlaWdodD1MLmxhc3RQZXJjZW50VG9QeEhlaWdodD0ocGFyc2VGbG9hdChTLmdldFByb3BlcnR5VmFsdWUodSxcImhlaWdodFwiLG51bGwsITApKXx8MSkvcyxsLmVtVG9QeD1MLmxhc3RFbVRvUHg9KHBhcnNlRmxvYXQoUy5nZXRQcm9wZXJ0eVZhbHVlKHUsXCJwYWRkaW5nTGVmdFwiKSl8fDEpL3MsZS5teVBhcmVudC5yZW1vdmVDaGlsZCh1KX1yZXR1cm4gbnVsbD09PUwucmVtVG9QeCYmKEwucmVtVG9QeD1wYXJzZUZsb2F0KFMuZ2V0UHJvcGVydHlWYWx1ZShyLmJvZHksXCJmb250U2l6ZVwiKSl8fDE2KSxudWxsPT09TC52d1RvUHgmJihMLnZ3VG9QeD1wYXJzZUZsb2F0KHQuaW5uZXJXaWR0aCkvMTAwLEwudmhUb1B4PXBhcnNlRmxvYXQodC5pbm5lckhlaWdodCkvMTAwKSxsLnJlbVRvUHg9TC5yZW1Ub1B4LGwudndUb1B4PUwudndUb1B4LGwudmhUb1B4PUwudmhUb1B4LGIuZGVidWc+PTEmJmNvbnNvbGUubG9nKFwiVW5pdCByYXRpb3M6IFwiK0pTT04uc3RyaW5naWZ5KGwpLG8pLGx9aWYocy5iZWdpbiYmMD09PVYpdHJ5e3MuYmVnaW4uY2FsbChnLGcpfWNhdGNoKHgpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyB4fSwxKX1pZihcInNjcm9sbFwiPT09QSl7dmFyIFAsQyxULEY9L154JC9pLnRlc3Qocy5heGlzKT9cIkxlZnRcIjpcIlRvcFwiLGo9cGFyc2VGbG9hdChzLm9mZnNldCl8fDA7cy5jb250YWluZXI/bS5pc1dyYXBwZWQocy5jb250YWluZXIpfHxtLmlzTm9kZShzLmNvbnRhaW5lcik/KHMuY29udGFpbmVyPXMuY29udGFpbmVyWzBdfHxzLmNvbnRhaW5lcixQPXMuY29udGFpbmVyW1wic2Nyb2xsXCIrRl0sVD1QK2YobykucG9zaXRpb24oKVtGLnRvTG93ZXJDYXNlKCldK2opOnMuY29udGFpbmVyPW51bGw6KFA9Yi5TdGF0ZS5zY3JvbGxBbmNob3JbYi5TdGF0ZVtcInNjcm9sbFByb3BlcnR5XCIrRl1dLEM9Yi5TdGF0ZS5zY3JvbGxBbmNob3JbYi5TdGF0ZVtcInNjcm9sbFByb3BlcnR5XCIrKFwiTGVmdFwiPT09Rj9cIlRvcFwiOlwiTGVmdFwiKV1dLFQ9ZihvKS5vZmZzZXQoKVtGLnRvTG93ZXJDYXNlKCldK2opLGw9e3Njcm9sbDp7cm9vdFByb3BlcnR5VmFsdWU6ITEsc3RhcnRWYWx1ZTpQLGN1cnJlbnRWYWx1ZTpQLGVuZFZhbHVlOlQsdW5pdFR5cGU6XCJcIixlYXNpbmc6cy5lYXNpbmcsc2Nyb2xsRGF0YTp7Y29udGFpbmVyOnMuY29udGFpbmVyLGRpcmVjdGlvbjpGLGFsdGVybmF0ZVZhbHVlOkN9fSxlbGVtZW50Om99LGIuZGVidWcmJmNvbnNvbGUubG9nKFwidHdlZW5zQ29udGFpbmVyIChzY3JvbGwpOiBcIixsLnNjcm9sbCxvKX1lbHNlIGlmKFwicmV2ZXJzZVwiPT09QSl7aWYoIWkobykudHdlZW5zQ29udGFpbmVyKXJldHVybiB2b2lkIGYuZGVxdWV1ZShvLHMucXVldWUpO1wibm9uZVwiPT09aShvKS5vcHRzLmRpc3BsYXkmJihpKG8pLm9wdHMuZGlzcGxheT1cImF1dG9cIiksXCJoaWRkZW5cIj09PWkobykub3B0cy52aXNpYmlsaXR5JiYoaShvKS5vcHRzLnZpc2liaWxpdHk9XCJ2aXNpYmxlXCIpLGkobykub3B0cy5sb29wPSExLGkobykub3B0cy5iZWdpbj1udWxsLGkobykub3B0cy5jb21wbGV0ZT1udWxsLHYuZWFzaW5nfHxkZWxldGUgcy5lYXNpbmcsdi5kdXJhdGlvbnx8ZGVsZXRlIHMuZHVyYXRpb24scz1mLmV4dGVuZCh7fSxpKG8pLm9wdHMscyk7dmFyIEU9Zi5leHRlbmQoITAse30saShvKS50d2VlbnNDb250YWluZXIpO2Zvcih2YXIgSCBpbiBFKWlmKFwiZWxlbWVudFwiIT09SCl7dmFyIE49RVtIXS5zdGFydFZhbHVlO0VbSF0uc3RhcnRWYWx1ZT1FW0hdLmN1cnJlbnRWYWx1ZT1FW0hdLmVuZFZhbHVlLEVbSF0uZW5kVmFsdWU9TixtLmlzRW1wdHlPYmplY3Qodil8fChFW0hdLmVhc2luZz1zLmVhc2luZyksYi5kZWJ1ZyYmY29uc29sZS5sb2coXCJyZXZlcnNlIHR3ZWVuc0NvbnRhaW5lciAoXCIrSCtcIik6IFwiK0pTT04uc3RyaW5naWZ5KEVbSF0pLG8pfWw9RX1lbHNlIGlmKFwic3RhcnRcIj09PUEpe3ZhciBFO2kobykudHdlZW5zQ29udGFpbmVyJiZpKG8pLmlzQW5pbWF0aW5nPT09ITAmJihFPWkobykudHdlZW5zQ29udGFpbmVyKSxmLmVhY2goeSxmdW5jdGlvbihlLHQpe2lmKFJlZ0V4cChcIl5cIitTLkxpc3RzLmNvbG9ycy5qb2luKFwiJHxeXCIpK1wiJFwiKS50ZXN0KGUpKXt2YXIgcj1wKHQsITApLG49clswXSxvPXJbMV0saT1yWzJdO2lmKFMuUmVnRXguaXNIZXgudGVzdChuKSl7Zm9yKHZhciBzPVtcIlJlZFwiLFwiR3JlZW5cIixcIkJsdWVcIl0sbD1TLlZhbHVlcy5oZXhUb1JnYihuKSx1PWk/Uy5WYWx1ZXMuaGV4VG9SZ2IoaSk6YSxjPTA7YzxzLmxlbmd0aDtjKyspe3ZhciBmPVtsW2NdXTtvJiZmLnB1c2gobyksdSE9PWEmJmYucHVzaCh1W2NdKSx5W2Urc1tjXV09Zn1kZWxldGUgeVtlXX19fSk7Zm9yKHZhciB6IGluIHkpe3ZhciBPPXAoeVt6XSkscT1PWzBdLCQ9T1sxXSxNPU9bMl07ej1TLk5hbWVzLmNhbWVsQ2FzZSh6KTt2YXIgST1TLkhvb2tzLmdldFJvb3QoeiksQj0hMTtpZihpKG8pLmlzU1ZHfHxcInR3ZWVuXCI9PT1JfHxTLk5hbWVzLnByZWZpeENoZWNrKEkpWzFdIT09ITF8fFMuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtJXSE9PWEpeyhzLmRpc3BsYXkhPT1hJiZudWxsIT09cy5kaXNwbGF5JiZcIm5vbmVcIiE9PXMuZGlzcGxheXx8cy52aXNpYmlsaXR5IT09YSYmXCJoaWRkZW5cIiE9PXMudmlzaWJpbGl0eSkmJi9vcGFjaXR5fGZpbHRlci8udGVzdCh6KSYmIU0mJjAhPT1xJiYoTT0wKSxzLl9jYWNoZVZhbHVlcyYmRSYmRVt6XT8oTT09PWEmJihNPUVbel0uZW5kVmFsdWUrRVt6XS51bml0VHlwZSksQj1pKG8pLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGVbSV0pOlMuSG9va3MucmVnaXN0ZXJlZFt6XT9NPT09YT8oQj1TLmdldFByb3BlcnR5VmFsdWUobyxJKSxNPVMuZ2V0UHJvcGVydHlWYWx1ZShvLHosQikpOkI9Uy5Ib29rcy50ZW1wbGF0ZXNbSV1bMV06TT09PWEmJihNPVMuZ2V0UHJvcGVydHlWYWx1ZShvLHopKTt2YXIgVyxHLFksRD0hMTtpZihXPWQoeixNKSxNPVdbMF0sWT1XWzFdLFc9ZCh6LHEpLHE9V1swXS5yZXBsYWNlKC9eKFsrLVxcLypdKT0vLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIEQ9dCxcIlwifSksRz1XWzFdLE09cGFyc2VGbG9hdChNKXx8MCxxPXBhcnNlRmxvYXQocSl8fDAsXCIlXCI9PT1HJiYoL14oZm9udFNpemV8bGluZUhlaWdodCkkLy50ZXN0KHopPyhxLz0xMDAsRz1cImVtXCIpOi9ec2NhbGUvLnRlc3Qoeik/KHEvPTEwMCxHPVwiXCIpOi8oUmVkfEdyZWVufEJsdWUpJC9pLnRlc3QoeikmJihxPXEvMTAwKjI1NSxHPVwiXCIpKSwvW1xcLypdLy50ZXN0KEQpKUc9WTtlbHNlIGlmKFkhPT1HJiYwIT09TSlpZigwPT09cSlHPVk7ZWxzZXtuPW58fGgoKTt2YXIgUT0vbWFyZ2lufHBhZGRpbmd8bGVmdHxyaWdodHx3aWR0aHx0ZXh0fHdvcmR8bGV0dGVyL2kudGVzdCh6KXx8L1gkLy50ZXN0KHopfHxcInhcIj09PXo/XCJ4XCI6XCJ5XCI7c3dpdGNoKFkpe2Nhc2VcIiVcIjpNKj1cInhcIj09PVE/bi5wZXJjZW50VG9QeFdpZHRoOm4ucGVyY2VudFRvUHhIZWlnaHQ7YnJlYWs7Y2FzZVwicHhcIjpicmVhaztkZWZhdWx0Ok0qPW5bWStcIlRvUHhcIl19c3dpdGNoKEcpe2Nhc2VcIiVcIjpNKj0xLyhcInhcIj09PVE/bi5wZXJjZW50VG9QeFdpZHRoOm4ucGVyY2VudFRvUHhIZWlnaHQpO2JyZWFrO2Nhc2VcInB4XCI6YnJlYWs7ZGVmYXVsdDpNKj0xL25bRytcIlRvUHhcIl19fXN3aXRjaChEKXtjYXNlXCIrXCI6cT1NK3E7YnJlYWs7Y2FzZVwiLVwiOnE9TS1xO2JyZWFrO2Nhc2VcIipcIjpxPU0qcTticmVhaztjYXNlXCIvXCI6cT1NL3F9bFt6XT17cm9vdFByb3BlcnR5VmFsdWU6QixzdGFydFZhbHVlOk0sY3VycmVudFZhbHVlOk0sZW5kVmFsdWU6cSx1bml0VHlwZTpHLGVhc2luZzokfSxiLmRlYnVnJiZjb25zb2xlLmxvZyhcInR3ZWVuc0NvbnRhaW5lciAoXCIreitcIik6IFwiK0pTT04uc3RyaW5naWZ5KGxbel0pLG8pfWVsc2UgYi5kZWJ1ZyYmY29uc29sZS5sb2coXCJTa2lwcGluZyBbXCIrSStcIl0gZHVlIHRvIGEgbGFjayBvZiBicm93c2VyIHN1cHBvcnQuXCIpfWwuZWxlbWVudD1vfWwuZWxlbWVudCYmKFMuVmFsdWVzLmFkZENsYXNzKG8sXCJ2ZWxvY2l0eS1hbmltYXRpbmdcIiksUi5wdXNoKGwpLFwiXCI9PT1zLnF1ZXVlJiYoaShvKS50d2VlbnNDb250YWluZXI9bCxpKG8pLm9wdHM9cyksaShvKS5pc0FuaW1hdGluZz0hMCxWPT09dy0xPyhiLlN0YXRlLmNhbGxzLnB1c2goW1IsZyxzLG51bGwsay5yZXNvbHZlcl0pLGIuU3RhdGUuaXNUaWNraW5nPT09ITEmJihiLlN0YXRlLmlzVGlja2luZz0hMCxjKCkpKTpWKyspfXZhciBuLG89dGhpcyxzPWYuZXh0ZW5kKHt9LGIuZGVmYXVsdHMsdiksbD17fTtzd2l0Y2goaShvKT09PWEmJmIuaW5pdChvKSxwYXJzZUZsb2F0KHMuZGVsYXkpJiZzLnF1ZXVlIT09ITEmJmYucXVldWUobyxzLnF1ZXVlLGZ1bmN0aW9uKGUpe2IudmVsb2NpdHlRdWV1ZUVudHJ5RmxhZz0hMCxpKG8pLmRlbGF5VGltZXI9e3NldFRpbWVvdXQ6c2V0VGltZW91dChlLHBhcnNlRmxvYXQocy5kZWxheSkpLG5leHQ6ZX19KSxzLmR1cmF0aW9uLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSl7Y2FzZVwiZmFzdFwiOnMuZHVyYXRpb249MjAwO2JyZWFrO2Nhc2VcIm5vcm1hbFwiOnMuZHVyYXRpb249aDticmVhaztjYXNlXCJzbG93XCI6cy5kdXJhdGlvbj02MDA7YnJlYWs7ZGVmYXVsdDpzLmR1cmF0aW9uPXBhcnNlRmxvYXQocy5kdXJhdGlvbil8fDF9Yi5tb2NrIT09ITEmJihiLm1vY2s9PT0hMD9zLmR1cmF0aW9uPXMuZGVsYXk9MToocy5kdXJhdGlvbio9cGFyc2VGbG9hdChiLm1vY2spfHwxLHMuZGVsYXkqPXBhcnNlRmxvYXQoYi5tb2NrKXx8MSkpLHMuZWFzaW5nPXUocy5lYXNpbmcscy5kdXJhdGlvbikscy5iZWdpbiYmIW0uaXNGdW5jdGlvbihzLmJlZ2luKSYmKHMuYmVnaW49bnVsbCkscy5wcm9ncmVzcyYmIW0uaXNGdW5jdGlvbihzLnByb2dyZXNzKSYmKHMucHJvZ3Jlc3M9bnVsbCkscy5jb21wbGV0ZSYmIW0uaXNGdW5jdGlvbihzLmNvbXBsZXRlKSYmKHMuY29tcGxldGU9bnVsbCkscy5kaXNwbGF5IT09YSYmbnVsbCE9PXMuZGlzcGxheSYmKHMuZGlzcGxheT1zLmRpc3BsYXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLFwiYXV0b1wiPT09cy5kaXNwbGF5JiYocy5kaXNwbGF5PWIuQ1NTLlZhbHVlcy5nZXREaXNwbGF5VHlwZShvKSkpLHMudmlzaWJpbGl0eSE9PWEmJm51bGwhPT1zLnZpc2liaWxpdHkmJihzLnZpc2liaWxpdHk9cy52aXNpYmlsaXR5LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSkscy5tb2JpbGVIQT1zLm1vYmlsZUhBJiZiLlN0YXRlLmlzTW9iaWxlJiYhYi5TdGF0ZS5pc0dpbmdlcmJyZWFkLHMucXVldWU9PT0hMT9zLmRlbGF5P3NldFRpbWVvdXQoZSxzLmRlbGF5KTplKCk6Zi5xdWV1ZShvLHMucXVldWUsZnVuY3Rpb24odCxyKXtyZXR1cm4gcj09PSEwPyhrLnByb21pc2UmJmsucmVzb2x2ZXIoZyksITApOihiLnZlbG9jaXR5UXVldWVFbnRyeUZsYWc9ITAsdm9pZCBlKHQpKX0pLFwiXCIhPT1zLnF1ZXVlJiZcImZ4XCIhPT1zLnF1ZXVlfHxcImlucHJvZ3Jlc3NcIj09PWYucXVldWUobylbMF18fGYuZGVxdWV1ZShvKX12YXIgcyxsLGQsZyx5LHYseD1hcmd1bWVudHNbMF0mJihhcmd1bWVudHNbMF0ucHx8Zi5pc1BsYWluT2JqZWN0KGFyZ3VtZW50c1swXS5wcm9wZXJ0aWVzKSYmIWFyZ3VtZW50c1swXS5wcm9wZXJ0aWVzLm5hbWVzfHxtLmlzU3RyaW5nKGFyZ3VtZW50c1swXS5wcm9wZXJ0aWVzKSk7aWYobS5pc1dyYXBwZWQodGhpcyk/KHM9ITEsZD0wLGc9dGhpcyxsPXRoaXMpOihzPSEwLGQ9MSxnPXg/YXJndW1lbnRzWzBdLmVsZW1lbnRzfHxhcmd1bWVudHNbMF0uZTphcmd1bWVudHNbMF0pLGc9byhnKSl7eD8oeT1hcmd1bWVudHNbMF0ucHJvcGVydGllc3x8YXJndW1lbnRzWzBdLnAsdj1hcmd1bWVudHNbMF0ub3B0aW9uc3x8YXJndW1lbnRzWzBdLm8pOih5PWFyZ3VtZW50c1tkXSx2PWFyZ3VtZW50c1tkKzFdKTt2YXIgdz1nLmxlbmd0aCxWPTA7aWYoIS9eKHN0b3B8ZmluaXNoKSQvaS50ZXN0KHkpJiYhZi5pc1BsYWluT2JqZWN0KHYpKXt2YXIgQz1kKzE7dj17fTtmb3IodmFyIFQ9QztUPGFyZ3VtZW50cy5sZW5ndGg7VCsrKW0uaXNBcnJheShhcmd1bWVudHNbVF0pfHwhL14oZmFzdHxub3JtYWx8c2xvdykkL2kudGVzdChhcmd1bWVudHNbVF0pJiYhL15cXGQvLnRlc3QoYXJndW1lbnRzW1RdKT9tLmlzU3RyaW5nKGFyZ3VtZW50c1tUXSl8fG0uaXNBcnJheShhcmd1bWVudHNbVF0pP3YuZWFzaW5nPWFyZ3VtZW50c1tUXTptLmlzRnVuY3Rpb24oYXJndW1lbnRzW1RdKSYmKHYuY29tcGxldGU9YXJndW1lbnRzW1RdKTp2LmR1cmF0aW9uPWFyZ3VtZW50c1tUXX12YXIgaz17cHJvbWlzZTpudWxsLHJlc29sdmVyOm51bGwscmVqZWN0ZXI6bnVsbH07cyYmYi5Qcm9taXNlJiYoay5wcm9taXNlPW5ldyBiLlByb21pc2UoZnVuY3Rpb24oZSx0KXtrLnJlc29sdmVyPWUsay5yZWplY3Rlcj10fSkpO3ZhciBBO3N3aXRjaCh5KXtjYXNlXCJzY3JvbGxcIjpBPVwic2Nyb2xsXCI7YnJlYWs7Y2FzZVwicmV2ZXJzZVwiOkE9XCJyZXZlcnNlXCI7YnJlYWs7Y2FzZVwiZmluaXNoXCI6Y2FzZVwic3RvcFwiOmYuZWFjaChnLGZ1bmN0aW9uKGUsdCl7aSh0KSYmaSh0KS5kZWxheVRpbWVyJiYoY2xlYXJUaW1lb3V0KGkodCkuZGVsYXlUaW1lci5zZXRUaW1lb3V0KSxpKHQpLmRlbGF5VGltZXIubmV4dCYmaSh0KS5kZWxheVRpbWVyLm5leHQoKSxkZWxldGUgaSh0KS5kZWxheVRpbWVyKX0pO3ZhciBGPVtdO3JldHVybiBmLmVhY2goYi5TdGF0ZS5jYWxscyxmdW5jdGlvbihlLHQpe3QmJmYuZWFjaCh0WzFdLGZ1bmN0aW9uKHIsbil7dmFyIG89dj09PWE/XCJcIjp2O3JldHVybiBvPT09ITB8fHRbMl0ucXVldWU9PT1vfHx2PT09YSYmdFsyXS5xdWV1ZT09PSExP3ZvaWQgZi5lYWNoKGcsZnVuY3Rpb24ocixhKXthPT09biYmKCh2PT09ITB8fG0uaXNTdHJpbmcodikpJiYoZi5lYWNoKGYucXVldWUoYSxtLmlzU3RyaW5nKHYpP3Y6XCJcIiksZnVuY3Rpb24oZSx0KXtcbm0uaXNGdW5jdGlvbih0KSYmdChudWxsLCEwKX0pLGYucXVldWUoYSxtLmlzU3RyaW5nKHYpP3Y6XCJcIixbXSkpLFwic3RvcFwiPT09eT8oaShhKSYmaShhKS50d2VlbnNDb250YWluZXImJm8hPT0hMSYmZi5lYWNoKGkoYSkudHdlZW5zQ29udGFpbmVyLGZ1bmN0aW9uKGUsdCl7dC5lbmRWYWx1ZT10LmN1cnJlbnRWYWx1ZX0pLEYucHVzaChlKSk6XCJmaW5pc2hcIj09PXkmJih0WzJdLmR1cmF0aW9uPTEpKX0pOiEwfSl9KSxcInN0b3BcIj09PXkmJihmLmVhY2goRixmdW5jdGlvbihlLHQpe3AodCwhMCl9KSxrLnByb21pc2UmJmsucmVzb2x2ZXIoZykpLGUoKTtkZWZhdWx0OmlmKCFmLmlzUGxhaW5PYmplY3QoeSl8fG0uaXNFbXB0eU9iamVjdCh5KSl7aWYobS5pc1N0cmluZyh5KSYmYi5SZWRpcmVjdHNbeV0pe3ZhciBqPWYuZXh0ZW5kKHt9LHYpLEU9ai5kdXJhdGlvbixIPWouZGVsYXl8fDA7cmV0dXJuIGouYmFja3dhcmRzPT09ITAmJihnPWYuZXh0ZW5kKCEwLFtdLGcpLnJldmVyc2UoKSksZi5lYWNoKGcsZnVuY3Rpb24oZSx0KXtwYXJzZUZsb2F0KGouc3RhZ2dlcik/ai5kZWxheT1IK3BhcnNlRmxvYXQoai5zdGFnZ2VyKSplOm0uaXNGdW5jdGlvbihqLnN0YWdnZXIpJiYoai5kZWxheT1IK2ouc3RhZ2dlci5jYWxsKHQsZSx3KSksai5kcmFnJiYoai5kdXJhdGlvbj1wYXJzZUZsb2F0KEUpfHwoL14oY2FsbG91dHx0cmFuc2l0aW9uKS8udGVzdCh5KT8xZTM6aCksai5kdXJhdGlvbj1NYXRoLm1heChqLmR1cmF0aW9uKihqLmJhY2t3YXJkcz8xLWUvdzooZSsxKS93KSwuNzUqai5kdXJhdGlvbiwyMDApKSxiLlJlZGlyZWN0c1t5XS5jYWxsKHQsdCxqfHx7fSxlLHcsZyxrLnByb21pc2U/azphKX0pLGUoKX12YXIgTj1cIlZlbG9jaXR5OiBGaXJzdCBhcmd1bWVudCAoXCIreStcIikgd2FzIG5vdCBhIHByb3BlcnR5IG1hcCwgYSBrbm93biBhY3Rpb24sIG9yIGEgcmVnaXN0ZXJlZCByZWRpcmVjdC4gQWJvcnRpbmcuXCI7cmV0dXJuIGsucHJvbWlzZT9rLnJlamVjdGVyKG5ldyBFcnJvcihOKSk6Y29uc29sZS5sb2coTiksZSgpfUE9XCJzdGFydFwifXZhciBMPXtsYXN0UGFyZW50Om51bGwsbGFzdFBvc2l0aW9uOm51bGwsbGFzdEZvbnRTaXplOm51bGwsbGFzdFBlcmNlbnRUb1B4V2lkdGg6bnVsbCxsYXN0UGVyY2VudFRvUHhIZWlnaHQ6bnVsbCxsYXN0RW1Ub1B4Om51bGwscmVtVG9QeDpudWxsLHZ3VG9QeDpudWxsLHZoVG9QeDpudWxsfSxSPVtdO2YuZWFjaChnLGZ1bmN0aW9uKGUsdCl7bS5pc05vZGUodCkmJm4uY2FsbCh0KX0pO3ZhciB6LGo9Zi5leHRlbmQoe30sYi5kZWZhdWx0cyx2KTtpZihqLmxvb3A9cGFyc2VJbnQoai5sb29wKSx6PTIqai5sb29wLTEsai5sb29wKWZvcih2YXIgTz0wO3o+TztPKyspe3ZhciBxPXtkZWxheTpqLmRlbGF5LHByb2dyZXNzOmoucHJvZ3Jlc3N9O089PT16LTEmJihxLmRpc3BsYXk9ai5kaXNwbGF5LHEudmlzaWJpbGl0eT1qLnZpc2liaWxpdHkscS5jb21wbGV0ZT1qLmNvbXBsZXRlKSxQKGcsXCJyZXZlcnNlXCIscSl9cmV0dXJuIGUoKX19O2I9Zi5leHRlbmQoUCxiKSxiLmFuaW1hdGU9UDt2YXIgdz10LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8ZztyZXR1cm4gYi5TdGF0ZS5pc01vYmlsZXx8ci5oaWRkZW49PT1hfHxyLmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsZnVuY3Rpb24oKXtyLmhpZGRlbj8odz1mdW5jdGlvbihlKXtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe2UoITApfSwxNil9LGMoKSk6dz10LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8Z30pLGUuVmVsb2NpdHk9YixlIT09dCYmKGUuZm4udmVsb2NpdHk9UCxlLmZuLnZlbG9jaXR5LmRlZmF1bHRzPWIuZGVmYXVsdHMpLGYuZWFjaChbXCJEb3duXCIsXCJVcFwiXSxmdW5jdGlvbihlLHQpe2IuUmVkaXJlY3RzW1wic2xpZGVcIit0XT1mdW5jdGlvbihlLHIsbixvLGkscyl7dmFyIGw9Zi5leHRlbmQoe30sciksdT1sLmJlZ2luLGM9bC5jb21wbGV0ZSxwPXtoZWlnaHQ6XCJcIixtYXJnaW5Ub3A6XCJcIixtYXJnaW5Cb3R0b206XCJcIixwYWRkaW5nVG9wOlwiXCIscGFkZGluZ0JvdHRvbTpcIlwifSxkPXt9O2wuZGlzcGxheT09PWEmJihsLmRpc3BsYXk9XCJEb3duXCI9PT10P1wiaW5saW5lXCI9PT1iLkNTUy5WYWx1ZXMuZ2V0RGlzcGxheVR5cGUoZSk/XCJpbmxpbmUtYmxvY2tcIjpcImJsb2NrXCI6XCJub25lXCIpLGwuYmVnaW49ZnVuY3Rpb24oKXt1JiZ1LmNhbGwoaSxpKTtmb3IodmFyIHIgaW4gcCl7ZFtyXT1lLnN0eWxlW3JdO3ZhciBhPWIuQ1NTLmdldFByb3BlcnR5VmFsdWUoZSxyKTtwW3JdPVwiRG93blwiPT09dD9bYSwwXTpbMCxhXX1kLm92ZXJmbG93PWUuc3R5bGUub3ZlcmZsb3csZS5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwifSxsLmNvbXBsZXRlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIGQpZS5zdHlsZVt0XT1kW3RdO2MmJmMuY2FsbChpLGkpLHMmJnMucmVzb2x2ZXIoaSl9LGIoZSxwLGwpfX0pLGYuZWFjaChbXCJJblwiLFwiT3V0XCJdLGZ1bmN0aW9uKGUsdCl7Yi5SZWRpcmVjdHNbXCJmYWRlXCIrdF09ZnVuY3Rpb24oZSxyLG4sbyxpLHMpe3ZhciBsPWYuZXh0ZW5kKHt9LHIpLHU9e29wYWNpdHk6XCJJblwiPT09dD8xOjB9LGM9bC5jb21wbGV0ZTtsLmNvbXBsZXRlPW4hPT1vLTE/bC5iZWdpbj1udWxsOmZ1bmN0aW9uKCl7YyYmYy5jYWxsKGksaSkscyYmcy5yZXNvbHZlcihpKX0sbC5kaXNwbGF5PT09YSYmKGwuZGlzcGxheT1cIkluXCI9PT10P1wiYXV0b1wiOlwibm9uZVwiKSxiKHRoaXMsdSxsKX19KSxifSh3aW5kb3cualF1ZXJ5fHx3aW5kb3cuWmVwdG98fHdpbmRvdyx3aW5kb3csZG9jdW1lbnQpfSkpO1xuOyFmdW5jdGlvbihhLGIsYyxkKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBrKGEsYixjKXtyZXR1cm4gc2V0VGltZW91dChxKGEsYyksYil9ZnVuY3Rpb24gbChhLGIsYyl7cmV0dXJuIEFycmF5LmlzQXJyYXkoYSk/KG0oYSxjW2JdLGMpLCEwKTohMX1mdW5jdGlvbiBtKGEsYixjKXt2YXIgZTtpZihhKWlmKGEuZm9yRWFjaClhLmZvckVhY2goYixjKTtlbHNlIGlmKGEubGVuZ3RoIT09ZClmb3IoZT0wO2U8YS5sZW5ndGg7KWIuY2FsbChjLGFbZV0sZSxhKSxlKys7ZWxzZSBmb3IoZSBpbiBhKWEuaGFzT3duUHJvcGVydHkoZSkmJmIuY2FsbChjLGFbZV0sZSxhKX1mdW5jdGlvbiBuKGEsYixjKXtmb3IodmFyIGU9T2JqZWN0LmtleXMoYiksZj0wO2Y8ZS5sZW5ndGg7KSghY3x8YyYmYVtlW2ZdXT09PWQpJiYoYVtlW2ZdXT1iW2VbZl1dKSxmKys7cmV0dXJuIGF9ZnVuY3Rpb24gbyhhLGIpe3JldHVybiBuKGEsYiwhMCl9ZnVuY3Rpb24gcChhLGIsYyl7dmFyIGUsZD1iLnByb3RvdHlwZTtlPWEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZCksZS5jb25zdHJ1Y3Rvcj1hLGUuX3N1cGVyPWQsYyYmbihlLGMpfWZ1bmN0aW9uIHEoYSxiKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShiLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHIoYSxiKXtyZXR1cm4gdHlwZW9mIGE9PWc/YS5hcHBseShiP2JbMF18fGQ6ZCxiKTphfWZ1bmN0aW9uIHMoYSxiKXtyZXR1cm4gYT09PWQ/YjphfWZ1bmN0aW9uIHQoYSxiLGMpe20oeChiKSxmdW5jdGlvbihiKXthLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKX0pfWZ1bmN0aW9uIHUoYSxiLGMpe20oeChiKSxmdW5jdGlvbihiKXthLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjLCExKX0pfWZ1bmN0aW9uIHYoYSxiKXtmb3IoO2E7KXtpZihhPT1iKXJldHVybiEwO2E9YS5wYXJlbnROb2RlfXJldHVybiExfWZ1bmN0aW9uIHcoYSxiKXtyZXR1cm4gYS5pbmRleE9mKGIpPi0xfWZ1bmN0aW9uIHgoYSl7cmV0dXJuIGEudHJpbSgpLnNwbGl0KC9cXHMrL2cpfWZ1bmN0aW9uIHkoYSxiLGMpe2lmKGEuaW5kZXhPZiYmIWMpcmV0dXJuIGEuaW5kZXhPZihiKTtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoOyl7aWYoYyYmYVtkXVtjXT09Ynx8IWMmJmFbZF09PT1iKXJldHVybiBkO2QrK31yZXR1cm4tMX1mdW5jdGlvbiB6KGEpe3JldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLDApfWZ1bmN0aW9uIEEoYSxiLGMpe2Zvcih2YXIgZD1bXSxlPVtdLGY9MDtmPGEubGVuZ3RoOyl7dmFyIGc9Yj9hW2ZdW2JdOmFbZl07eShlLGcpPDAmJmQucHVzaChhW2ZdKSxlW2ZdPWcsZisrfXJldHVybiBjJiYoZD1iP2Quc29ydChmdW5jdGlvbihhLGMpe3JldHVybiBhW2JdPmNbYl19KTpkLnNvcnQoKSksZH1mdW5jdGlvbiBCKGEsYil7Zm9yKHZhciBjLGYsZz1iWzBdLnRvVXBwZXJDYXNlKCkrYi5zbGljZSgxKSxoPTA7aDxlLmxlbmd0aDspe2lmKGM9ZVtoXSxmPWM/YytnOmIsZiBpbiBhKXJldHVybiBmO2grK31yZXR1cm4gZH1mdW5jdGlvbiBEKCl7cmV0dXJuIEMrK31mdW5jdGlvbiBFKGEpe3ZhciBiPWEub3duZXJEb2N1bWVudDtyZXR1cm4gYi5kZWZhdWx0Vmlld3x8Yi5wYXJlbnRXaW5kb3d9ZnVuY3Rpb24gYWIoYSxiKXt2YXIgYz10aGlzO3RoaXMubWFuYWdlcj1hLHRoaXMuY2FsbGJhY2s9Yix0aGlzLmVsZW1lbnQ9YS5lbGVtZW50LHRoaXMudGFyZ2V0PWEub3B0aW9ucy5pbnB1dFRhcmdldCx0aGlzLmRvbUhhbmRsZXI9ZnVuY3Rpb24oYil7cihhLm9wdGlvbnMuZW5hYmxlLFthXSkmJmMuaGFuZGxlcihiKX0sdGhpcy5pbml0KCl9ZnVuY3Rpb24gYmIoYSl7dmFyIGIsYz1hLm9wdGlvbnMuaW5wdXRDbGFzcztyZXR1cm4gYj1jP2M6SD93YjpJP0ViOkc/R2I6cmIsbmV3IGIoYSxjYil9ZnVuY3Rpb24gY2IoYSxiLGMpe3ZhciBkPWMucG9pbnRlcnMubGVuZ3RoLGU9Yy5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoLGY9YiZPJiYwPT09ZC1lLGc9YiYoUXxSKSYmMD09PWQtZTtjLmlzRmlyc3Q9ISFmLGMuaXNGaW5hbD0hIWcsZiYmKGEuc2Vzc2lvbj17fSksYy5ldmVudFR5cGU9YixkYihhLGMpLGEuZW1pdChcImhhbW1lci5pbnB1dFwiLGMpLGEucmVjb2duaXplKGMpLGEuc2Vzc2lvbi5wcmV2SW5wdXQ9Y31mdW5jdGlvbiBkYihhLGIpe3ZhciBjPWEuc2Vzc2lvbixkPWIucG9pbnRlcnMsZT1kLmxlbmd0aDtjLmZpcnN0SW5wdXR8fChjLmZpcnN0SW5wdXQ9Z2IoYikpLGU+MSYmIWMuZmlyc3RNdWx0aXBsZT9jLmZpcnN0TXVsdGlwbGU9Z2IoYik6MT09PWUmJihjLmZpcnN0TXVsdGlwbGU9ITEpO3ZhciBmPWMuZmlyc3RJbnB1dCxnPWMuZmlyc3RNdWx0aXBsZSxoPWc/Zy5jZW50ZXI6Zi5jZW50ZXIsaT1iLmNlbnRlcj1oYihkKTtiLnRpbWVTdGFtcD1qKCksYi5kZWx0YVRpbWU9Yi50aW1lU3RhbXAtZi50aW1lU3RhbXAsYi5hbmdsZT1sYihoLGkpLGIuZGlzdGFuY2U9a2IoaCxpKSxlYihjLGIpLGIub2Zmc2V0RGlyZWN0aW9uPWpiKGIuZGVsdGFYLGIuZGVsdGFZKSxiLnNjYWxlPWc/bmIoZy5wb2ludGVycyxkKToxLGIucm90YXRpb249Zz9tYihnLnBvaW50ZXJzLGQpOjAsZmIoYyxiKTt2YXIgaz1hLmVsZW1lbnQ7dihiLnNyY0V2ZW50LnRhcmdldCxrKSYmKGs9Yi5zcmNFdmVudC50YXJnZXQpLGIudGFyZ2V0PWt9ZnVuY3Rpb24gZWIoYSxiKXt2YXIgYz1iLmNlbnRlcixkPWEub2Zmc2V0RGVsdGF8fHt9LGU9YS5wcmV2RGVsdGF8fHt9LGY9YS5wcmV2SW5wdXR8fHt9OyhiLmV2ZW50VHlwZT09PU98fGYuZXZlbnRUeXBlPT09USkmJihlPWEucHJldkRlbHRhPXt4OmYuZGVsdGFYfHwwLHk6Zi5kZWx0YVl8fDB9LGQ9YS5vZmZzZXREZWx0YT17eDpjLngseTpjLnl9KSxiLmRlbHRhWD1lLngrKGMueC1kLngpLGIuZGVsdGFZPWUueSsoYy55LWQueSl9ZnVuY3Rpb24gZmIoYSxiKXt2YXIgZixnLGgsaixjPWEubGFzdEludGVydmFsfHxiLGU9Yi50aW1lU3RhbXAtYy50aW1lU3RhbXA7aWYoYi5ldmVudFR5cGUhPVImJihlPk58fGMudmVsb2NpdHk9PT1kKSl7dmFyIGs9Yy5kZWx0YVgtYi5kZWx0YVgsbD1jLmRlbHRhWS1iLmRlbHRhWSxtPWliKGUsayxsKTtnPW0ueCxoPW0ueSxmPWkobS54KT5pKG0ueSk/bS54Om0ueSxqPWpiKGssbCksYS5sYXN0SW50ZXJ2YWw9Yn1lbHNlIGY9Yy52ZWxvY2l0eSxnPWMudmVsb2NpdHlYLGg9Yy52ZWxvY2l0eVksaj1jLmRpcmVjdGlvbjtiLnZlbG9jaXR5PWYsYi52ZWxvY2l0eVg9ZyxiLnZlbG9jaXR5WT1oLGIuZGlyZWN0aW9uPWp9ZnVuY3Rpb24gZ2IoYSl7Zm9yKHZhciBiPVtdLGM9MDtjPGEucG9pbnRlcnMubGVuZ3RoOyliW2NdPXtjbGllbnRYOmgoYS5wb2ludGVyc1tjXS5jbGllbnRYKSxjbGllbnRZOmgoYS5wb2ludGVyc1tjXS5jbGllbnRZKX0sYysrO3JldHVybnt0aW1lU3RhbXA6aigpLHBvaW50ZXJzOmIsY2VudGVyOmhiKGIpLGRlbHRhWDphLmRlbHRhWCxkZWx0YVk6YS5kZWx0YVl9fWZ1bmN0aW9uIGhiKGEpe3ZhciBiPWEubGVuZ3RoO2lmKDE9PT1iKXJldHVybnt4OmgoYVswXS5jbGllbnRYKSx5OmgoYVswXS5jbGllbnRZKX07Zm9yKHZhciBjPTAsZD0wLGU9MDtiPmU7KWMrPWFbZV0uY2xpZW50WCxkKz1hW2VdLmNsaWVudFksZSsrO3JldHVybnt4OmgoYy9iKSx5OmgoZC9iKX19ZnVuY3Rpb24gaWIoYSxiLGMpe3JldHVybnt4OmIvYXx8MCx5OmMvYXx8MH19ZnVuY3Rpb24gamIoYSxiKXtyZXR1cm4gYT09PWI/UzppKGEpPj1pKGIpP2E+MD9UOlU6Yj4wP1Y6V31mdW5jdGlvbiBrYihhLGIsYyl7Y3x8KGM9JCk7dmFyIGQ9YltjWzBdXS1hW2NbMF1dLGU9YltjWzFdXS1hW2NbMV1dO3JldHVybiBNYXRoLnNxcnQoZCpkK2UqZSl9ZnVuY3Rpb24gbGIoYSxiLGMpe2N8fChjPSQpO3ZhciBkPWJbY1swXV0tYVtjWzBdXSxlPWJbY1sxXV0tYVtjWzFdXTtyZXR1cm4gMTgwKk1hdGguYXRhbjIoZSxkKS9NYXRoLlBJfWZ1bmN0aW9uIG1iKGEsYil7cmV0dXJuIGxiKGJbMV0sYlswXSxfKS1sYihhWzFdLGFbMF0sXyl9ZnVuY3Rpb24gbmIoYSxiKXtyZXR1cm4ga2IoYlswXSxiWzFdLF8pL2tiKGFbMF0sYVsxXSxfKX1mdW5jdGlvbiByYigpe3RoaXMuZXZFbD1wYix0aGlzLmV2V2luPXFiLHRoaXMuYWxsb3c9ITAsdGhpcy5wcmVzc2VkPSExLGFiLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiB3Yigpe3RoaXMuZXZFbD11Yix0aGlzLmV2V2luPXZiLGFiLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0aGlzLnN0b3JlPXRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHM9W119ZnVuY3Rpb24gQWIoKXt0aGlzLmV2VGFyZ2V0PXliLHRoaXMuZXZXaW49emIsdGhpcy5zdGFydGVkPSExLGFiLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBCYihhLGIpe3ZhciBjPXooYS50b3VjaGVzKSxkPXooYS5jaGFuZ2VkVG91Y2hlcyk7cmV0dXJuIGImKFF8UikmJihjPUEoYy5jb25jYXQoZCksXCJpZGVudGlmaWVyXCIsITApKSxbYyxkXX1mdW5jdGlvbiBFYigpe3RoaXMuZXZUYXJnZXQ9RGIsdGhpcy50YXJnZXRJZHM9e30sYWIuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIEZiKGEsYil7dmFyIGM9eihhLnRvdWNoZXMpLGQ9dGhpcy50YXJnZXRJZHM7aWYoYiYoT3xQKSYmMT09PWMubGVuZ3RoKXJldHVybiBkW2NbMF0uaWRlbnRpZmllcl09ITAsW2MsY107dmFyIGUsZixnPXooYS5jaGFuZ2VkVG91Y2hlcyksaD1bXSxpPXRoaXMudGFyZ2V0O2lmKGY9Yy5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIHYoYS50YXJnZXQsaSl9KSxiPT09Tylmb3IoZT0wO2U8Zi5sZW5ndGg7KWRbZltlXS5pZGVudGlmaWVyXT0hMCxlKys7Zm9yKGU9MDtlPGcubGVuZ3RoOylkW2dbZV0uaWRlbnRpZmllcl0mJmgucHVzaChnW2VdKSxiJihRfFIpJiZkZWxldGUgZFtnW2VdLmlkZW50aWZpZXJdLGUrKztyZXR1cm4gaC5sZW5ndGg/W0EoZi5jb25jYXQoaCksXCJpZGVudGlmaWVyXCIsITApLGhdOnZvaWQgMH1mdW5jdGlvbiBHYigpe2FiLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYT1xKHRoaXMuaGFuZGxlcix0aGlzKTt0aGlzLnRvdWNoPW5ldyBFYih0aGlzLm1hbmFnZXIsYSksdGhpcy5tb3VzZT1uZXcgcmIodGhpcy5tYW5hZ2VyLGEpfWZ1bmN0aW9uIFBiKGEsYil7dGhpcy5tYW5hZ2VyPWEsdGhpcy5zZXQoYil9ZnVuY3Rpb24gUWIoYSl7aWYodyhhLE1iKSlyZXR1cm4gTWI7dmFyIGI9dyhhLE5iKSxjPXcoYSxPYik7cmV0dXJuIGImJmM/TmIrXCIgXCIrT2I6Ynx8Yz9iP05iOk9iOncoYSxMYik/TGI6S2J9ZnVuY3Rpb24gWWIoYSl7dGhpcy5pZD1EKCksdGhpcy5tYW5hZ2VyPW51bGwsdGhpcy5vcHRpb25zPW8oYXx8e30sdGhpcy5kZWZhdWx0cyksdGhpcy5vcHRpb25zLmVuYWJsZT1zKHRoaXMub3B0aW9ucy5lbmFibGUsITApLHRoaXMuc3RhdGU9UmIsdGhpcy5zaW11bHRhbmVvdXM9e30sdGhpcy5yZXF1aXJlRmFpbD1bXX1mdW5jdGlvbiBaYihhKXtyZXR1cm4gYSZXYj9cImNhbmNlbFwiOmEmVWI/XCJlbmRcIjphJlRiP1wibW92ZVwiOmEmU2I/XCJzdGFydFwiOlwiXCJ9ZnVuY3Rpb24gJGIoYSl7cmV0dXJuIGE9PVc/XCJkb3duXCI6YT09Vj9cInVwXCI6YT09VD9cImxlZnRcIjphPT1VP1wicmlnaHRcIjpcIlwifWZ1bmN0aW9uIF9iKGEsYil7dmFyIGM9Yi5tYW5hZ2VyO3JldHVybiBjP2MuZ2V0KGEpOmF9ZnVuY3Rpb24gYWMoKXtZYi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYmMoKXthYy5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5wWD1udWxsLHRoaXMucFk9bnVsbH1mdW5jdGlvbiBjYygpe2FjLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBkYygpe1liLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0aGlzLl90aW1lcj1udWxsLHRoaXMuX2lucHV0PW51bGx9ZnVuY3Rpb24gZWMoKXthYy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gZmMoKXthYy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gZ2MoKXtZYi5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5wVGltZT0hMSx0aGlzLnBDZW50ZXI9ITEsdGhpcy5fdGltZXI9bnVsbCx0aGlzLl9pbnB1dD1udWxsLHRoaXMuY291bnQ9MH1mdW5jdGlvbiBoYyhhLGIpe3JldHVybiBiPWJ8fHt9LGIucmVjb2duaXplcnM9cyhiLnJlY29nbml6ZXJzLGhjLmRlZmF1bHRzLnByZXNldCksbmV3IGtjKGEsYil9ZnVuY3Rpb24ga2MoYSxiKXtiPWJ8fHt9LHRoaXMub3B0aW9ucz1vKGIsaGMuZGVmYXVsdHMpLHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldD10aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXR8fGEsdGhpcy5oYW5kbGVycz17fSx0aGlzLnNlc3Npb249e30sdGhpcy5yZWNvZ25pemVycz1bXSx0aGlzLmVsZW1lbnQ9YSx0aGlzLmlucHV0PWJiKHRoaXMpLHRoaXMudG91Y2hBY3Rpb249bmV3IFBiKHRoaXMsdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKSxsYyh0aGlzLCEwKSxtKGIucmVjb2duaXplcnMsZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hZGQobmV3IGFbMF0oYVsxXSkpO2FbMl0mJmIucmVjb2duaXplV2l0aChhWzJdKSxhWzNdJiZiLnJlcXVpcmVGYWlsdXJlKGFbM10pfSx0aGlzKX1mdW5jdGlvbiBsYyhhLGIpe3ZhciBjPWEuZWxlbWVudDttKGEub3B0aW9ucy5jc3NQcm9wcyxmdW5jdGlvbihhLGQpe2Muc3R5bGVbQihjLnN0eWxlLGQpXT1iP2E6XCJcIn0pfWZ1bmN0aW9uIG1jKGEsYyl7dmFyIGQ9Yi5jcmVhdGVFdmVudChcIkV2ZW50XCIpO2QuaW5pdEV2ZW50KGEsITAsITApLGQuZ2VzdHVyZT1jLGMudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZCl9dmFyIGU9W1wiXCIsXCJ3ZWJraXRcIixcIm1velwiLFwiTVNcIixcIm1zXCIsXCJvXCJdLGY9Yi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGc9XCJmdW5jdGlvblwiLGg9TWF0aC5yb3VuZCxpPU1hdGguYWJzLGo9RGF0ZS5ub3csQz0xLEY9L21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pLEc9XCJvbnRvdWNoc3RhcnRcImluIGEsSD1CKGEsXCJQb2ludGVyRXZlbnRcIikhPT1kLEk9RyYmRi50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLEo9XCJ0b3VjaFwiLEs9XCJwZW5cIixMPVwibW91c2VcIixNPVwia2luZWN0XCIsTj0yNSxPPTEsUD0yLFE9NCxSPTgsUz0xLFQ9MixVPTQsVj04LFc9MTYsWD1UfFUsWT1WfFcsWj1YfFksJD1bXCJ4XCIsXCJ5XCJdLF89W1wiY2xpZW50WFwiLFwiY2xpZW50WVwiXTthYi5wcm90b3R5cGU9e2hhbmRsZXI6ZnVuY3Rpb24oKXt9LGluaXQ6ZnVuY3Rpb24oKXt0aGlzLmV2RWwmJnQodGhpcy5lbGVtZW50LHRoaXMuZXZFbCx0aGlzLmRvbUhhbmRsZXIpLHRoaXMuZXZUYXJnZXQmJnQodGhpcy50YXJnZXQsdGhpcy5ldlRhcmdldCx0aGlzLmRvbUhhbmRsZXIpLHRoaXMuZXZXaW4mJnQoRSh0aGlzLmVsZW1lbnQpLHRoaXMuZXZXaW4sdGhpcy5kb21IYW5kbGVyKX0sZGVzdHJveTpmdW5jdGlvbigpe3RoaXMuZXZFbCYmdSh0aGlzLmVsZW1lbnQsdGhpcy5ldkVsLHRoaXMuZG9tSGFuZGxlciksdGhpcy5ldlRhcmdldCYmdSh0aGlzLnRhcmdldCx0aGlzLmV2VGFyZ2V0LHRoaXMuZG9tSGFuZGxlciksdGhpcy5ldldpbiYmdShFKHRoaXMuZWxlbWVudCksdGhpcy5ldldpbix0aGlzLmRvbUhhbmRsZXIpfX07dmFyIG9iPXttb3VzZWRvd246Tyxtb3VzZW1vdmU6UCxtb3VzZXVwOlF9LHBiPVwibW91c2Vkb3duXCIscWI9XCJtb3VzZW1vdmUgbW91c2V1cFwiO3AocmIsYWIse2hhbmRsZXI6ZnVuY3Rpb24oYSl7dmFyIGI9b2JbYS50eXBlXTtiJk8mJjA9PT1hLmJ1dHRvbiYmKHRoaXMucHJlc3NlZD0hMCksYiZQJiYxIT09YS53aGljaCYmKGI9USksdGhpcy5wcmVzc2VkJiZ0aGlzLmFsbG93JiYoYiZRJiYodGhpcy5wcmVzc2VkPSExKSx0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlcixiLHtwb2ludGVyczpbYV0sY2hhbmdlZFBvaW50ZXJzOlthXSxwb2ludGVyVHlwZTpMLHNyY0V2ZW50OmF9KSl9fSk7dmFyIHNiPXtwb2ludGVyZG93bjpPLHBvaW50ZXJtb3ZlOlAscG9pbnRlcnVwOlEscG9pbnRlcmNhbmNlbDpSLHBvaW50ZXJvdXQ6Un0sdGI9ezI6SiwzOkssNDpMLDU6TX0sdWI9XCJwb2ludGVyZG93blwiLHZiPVwicG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWxcIjthLk1TUG9pbnRlckV2ZW50JiYodWI9XCJNU1BvaW50ZXJEb3duXCIsdmI9XCJNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbFwiKSxwKHdiLGFiLHtoYW5kbGVyOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3RvcmUsYz0hMSxkPWEudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoXCJtc1wiLFwiXCIpLGU9c2JbZF0sZj10YlthLnBvaW50ZXJUeXBlXXx8YS5wb2ludGVyVHlwZSxnPWY9PUosaD15KGIsYS5wb2ludGVySWQsXCJwb2ludGVySWRcIik7ZSZPJiYoMD09PWEuYnV0dG9ufHxnKT8wPmgmJihiLnB1c2goYSksaD1iLmxlbmd0aC0xKTplJihRfFIpJiYoYz0hMCksMD5ofHwoYltoXT1hLHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLGUse3BvaW50ZXJzOmIsY2hhbmdlZFBvaW50ZXJzOlthXSxwb2ludGVyVHlwZTpmLHNyY0V2ZW50OmF9KSxjJiZiLnNwbGljZShoLDEpKX19KTt2YXIgeGI9e3RvdWNoc3RhcnQ6Tyx0b3VjaG1vdmU6UCx0b3VjaGVuZDpRLHRvdWNoY2FuY2VsOlJ9LHliPVwidG91Y2hzdGFydFwiLHpiPVwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWxcIjtwKEFiLGFiLHtoYW5kbGVyOmZ1bmN0aW9uKGEpe3ZhciBiPXhiW2EudHlwZV07aWYoYj09PU8mJih0aGlzLnN0YXJ0ZWQ9ITApLHRoaXMuc3RhcnRlZCl7dmFyIGM9QmIuY2FsbCh0aGlzLGEsYik7YiYoUXxSKSYmMD09PWNbMF0ubGVuZ3RoLWNbMV0ubGVuZ3RoJiYodGhpcy5zdGFydGVkPSExKSx0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlcixiLHtwb2ludGVyczpjWzBdLGNoYW5nZWRQb2ludGVyczpjWzFdLHBvaW50ZXJUeXBlOkosc3JjRXZlbnQ6YX0pfX19KTt2YXIgQ2I9e3RvdWNoc3RhcnQ6Tyx0b3VjaG1vdmU6UCx0b3VjaGVuZDpRLHRvdWNoY2FuY2VsOlJ9LERiPVwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWxcIjtwKEViLGFiLHtoYW5kbGVyOmZ1bmN0aW9uKGEpe3ZhciBiPUNiW2EudHlwZV0sYz1GYi5jYWxsKHRoaXMsYSxiKTtjJiZ0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlcixiLHtwb2ludGVyczpjWzBdLGNoYW5nZWRQb2ludGVyczpjWzFdLHBvaW50ZXJUeXBlOkosc3JjRXZlbnQ6YX0pfX0pLHAoR2IsYWIse2hhbmRsZXI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWMucG9pbnRlclR5cGU9PUosZT1jLnBvaW50ZXJUeXBlPT1MO2lmKGQpdGhpcy5tb3VzZS5hbGxvdz0hMTtlbHNlIGlmKGUmJiF0aGlzLm1vdXNlLmFsbG93KXJldHVybjtiJihRfFIpJiYodGhpcy5tb3VzZS5hbGxvdz0hMCksdGhpcy5jYWxsYmFjayhhLGIsYyl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLnRvdWNoLmRlc3Ryb3koKSx0aGlzLm1vdXNlLmRlc3Ryb3koKX19KTt2YXIgSGI9QihmLnN0eWxlLFwidG91Y2hBY3Rpb25cIiksSWI9SGIhPT1kLEpiPVwiY29tcHV0ZVwiLEtiPVwiYXV0b1wiLExiPVwibWFuaXB1bGF0aW9uXCIsTWI9XCJub25lXCIsTmI9XCJwYW4teFwiLE9iPVwicGFuLXlcIjtQYi5wcm90b3R5cGU9e3NldDpmdW5jdGlvbihhKXthPT1KYiYmKGE9dGhpcy5jb21wdXRlKCkpLEliJiYodGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbSGJdPWEpLHRoaXMuYWN0aW9ucz1hLnRvTG93ZXJDYXNlKCkudHJpbSgpfSx1cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbil9LGNvbXB1dGU6ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gbSh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsZnVuY3Rpb24oYil7cihiLm9wdGlvbnMuZW5hYmxlLFtiXSkmJihhPWEuY29uY2F0KGIuZ2V0VG91Y2hBY3Rpb24oKSkpfSksUWIoYS5qb2luKFwiIFwiKSl9LHByZXZlbnREZWZhdWx0czpmdW5jdGlvbihhKXtpZighSWIpe3ZhciBiPWEuc3JjRXZlbnQsYz1hLm9mZnNldERpcmVjdGlvbjtpZih0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpcmV0dXJuIGIucHJldmVudERlZmF1bHQoKSx2b2lkIDA7dmFyIGQ9dGhpcy5hY3Rpb25zLGU9dyhkLE1iKSxmPXcoZCxPYiksZz13KGQsTmIpO3JldHVybiBlfHxmJiZjJlh8fGcmJmMmWT90aGlzLnByZXZlbnRTcmMoYik6dm9pZCAwfX0scHJldmVudFNyYzpmdW5jdGlvbihhKXt0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQ9ITAsYS5wcmV2ZW50RGVmYXVsdCgpfX07dmFyIFJiPTEsU2I9MixUYj00LFViPTgsVmI9VWIsV2I9MTYsWGI9MzI7WWIucHJvdG90eXBlPXtkZWZhdWx0czp7fSxzZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG4odGhpcy5vcHRpb25zLGEpLHRoaXMubWFuYWdlciYmdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpLHRoaXN9LHJlY29nbml6ZVdpdGg6ZnVuY3Rpb24oYSl7aWYobChhLFwicmVjb2duaXplV2l0aFwiLHRoaXMpKXJldHVybiB0aGlzO3ZhciBiPXRoaXMuc2ltdWx0YW5lb3VzO3JldHVybiBhPV9iKGEsdGhpcyksYlthLmlkXXx8KGJbYS5pZF09YSxhLnJlY29nbml6ZVdpdGgodGhpcykpLHRoaXN9LGRyb3BSZWNvZ25pemVXaXRoOmZ1bmN0aW9uKGEpe3JldHVybiBsKGEsXCJkcm9wUmVjb2duaXplV2l0aFwiLHRoaXMpP3RoaXM6KGE9X2IoYSx0aGlzKSxkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbYS5pZF0sdGhpcyl9LHJlcXVpcmVGYWlsdXJlOmZ1bmN0aW9uKGEpe2lmKGwoYSxcInJlcXVpcmVGYWlsdXJlXCIsdGhpcykpcmV0dXJuIHRoaXM7dmFyIGI9dGhpcy5yZXF1aXJlRmFpbDtyZXR1cm4gYT1fYihhLHRoaXMpLC0xPT09eShiLGEpJiYoYi5wdXNoKGEpLGEucmVxdWlyZUZhaWx1cmUodGhpcykpLHRoaXN9LGRyb3BSZXF1aXJlRmFpbHVyZTpmdW5jdGlvbihhKXtpZihsKGEsXCJkcm9wUmVxdWlyZUZhaWx1cmVcIix0aGlzKSlyZXR1cm4gdGhpczthPV9iKGEsdGhpcyk7dmFyIGI9eSh0aGlzLnJlcXVpcmVGYWlsLGEpO3JldHVybiBiPi0xJiZ0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShiLDEpLHRoaXN9LGhhc1JlcXVpcmVGYWlsdXJlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aD4wfSxjYW5SZWNvZ25pemVXaXRoOmZ1bmN0aW9uKGEpe3JldHVybiEhdGhpcy5zaW11bHRhbmVvdXNbYS5pZF19LGVtaXQ6ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZChkKXtiLm1hbmFnZXIuZW1pdChiLm9wdGlvbnMuZXZlbnQrKGQ/WmIoYyk6XCJcIiksYSl9dmFyIGI9dGhpcyxjPXRoaXMuc3RhdGU7VWI+YyYmZCghMCksZCgpLGM+PVViJiZkKCEwKX0sdHJ5RW1pdDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jYW5FbWl0KCk/dGhpcy5lbWl0KGEpOih0aGlzLnN0YXRlPVhiLHZvaWQgMCl9LGNhbkVtaXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoOyl7aWYoISh0aGlzLnJlcXVpcmVGYWlsW2FdLnN0YXRlJihYYnxSYikpKXJldHVybiExO2ErK31yZXR1cm4hMH0scmVjb2duaXplOmZ1bmN0aW9uKGEpe3ZhciBiPW4oe30sYSk7cmV0dXJuIHIodGhpcy5vcHRpb25zLmVuYWJsZSxbdGhpcyxiXSk/KHRoaXMuc3RhdGUmKFZifFdifFhiKSYmKHRoaXMuc3RhdGU9UmIpLHRoaXMuc3RhdGU9dGhpcy5wcm9jZXNzKGIpLHRoaXMuc3RhdGUmKFNifFRifFVifFdiKSYmdGhpcy50cnlFbWl0KGIpLHZvaWQgMCk6KHRoaXMucmVzZXQoKSx0aGlzLnN0YXRlPVhiLHZvaWQgMCl9LHByb2Nlc3M6ZnVuY3Rpb24oKXt9LGdldFRvdWNoQWN0aW9uOmZ1bmN0aW9uKCl7fSxyZXNldDpmdW5jdGlvbigpe319LHAoYWMsWWIse2RlZmF1bHRzOntwb2ludGVyczoxfSxhdHRyVGVzdDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnMucG9pbnRlcnM7cmV0dXJuIDA9PT1ifHxhLnBvaW50ZXJzLmxlbmd0aD09PWJ9LHByb2Nlc3M6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zdGF0ZSxjPWEuZXZlbnRUeXBlLGQ9YiYoU2J8VGIpLGU9dGhpcy5hdHRyVGVzdChhKTtyZXR1cm4gZCYmKGMmUnx8IWUpP2J8V2I6ZHx8ZT9jJlE/YnxVYjpiJlNiP2J8VGI6U2I6WGJ9fSkscChiYyxhYyx7ZGVmYXVsdHM6e2V2ZW50OlwicGFuXCIsdGhyZXNob2xkOjEwLHBvaW50ZXJzOjEsZGlyZWN0aW9uOlp9LGdldFRvdWNoQWN0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLmRpcmVjdGlvbixiPVtdO3JldHVybiBhJlgmJmIucHVzaChPYiksYSZZJiZiLnB1c2goTmIpLGJ9LGRpcmVjdGlvblRlc3Q6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zLGM9ITAsZD1hLmRpc3RhbmNlLGU9YS5kaXJlY3Rpb24sZj1hLmRlbHRhWCxnPWEuZGVsdGFZO3JldHVybiBlJmIuZGlyZWN0aW9ufHwoYi5kaXJlY3Rpb24mWD8oZT0wPT09Zj9TOjA+Zj9UOlUsYz1mIT10aGlzLnBYLGQ9TWF0aC5hYnMoYS5kZWx0YVgpKTooZT0wPT09Zz9TOjA+Zz9WOlcsYz1nIT10aGlzLnBZLGQ9TWF0aC5hYnMoYS5kZWx0YVkpKSksYS5kaXJlY3Rpb249ZSxjJiZkPmIudGhyZXNob2xkJiZlJmIuZGlyZWN0aW9ufSxhdHRyVGVzdDpmdW5jdGlvbihhKXtyZXR1cm4gYWMucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcyxhKSYmKHRoaXMuc3RhdGUmU2J8fCEodGhpcy5zdGF0ZSZTYikmJnRoaXMuZGlyZWN0aW9uVGVzdChhKSl9LGVtaXQ6ZnVuY3Rpb24oYSl7dGhpcy5wWD1hLmRlbHRhWCx0aGlzLnBZPWEuZGVsdGFZO3ZhciBiPSRiKGEuZGlyZWN0aW9uKTtiJiZ0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQrYixhKSx0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcyxhKX19KSxwKGNjLGFjLHtkZWZhdWx0czp7ZXZlbnQ6XCJwaW5jaFwiLHRocmVzaG9sZDowLHBvaW50ZXJzOjJ9LGdldFRvdWNoQWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuW01iXX0sYXR0clRlc3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcyxhKSYmKE1hdGguYWJzKGEuc2NhbGUtMSk+dGhpcy5vcHRpb25zLnRocmVzaG9sZHx8dGhpcy5zdGF0ZSZTYil9LGVtaXQ6ZnVuY3Rpb24oYSl7aWYodGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsYSksMSE9PWEuc2NhbGUpe3ZhciBiPWEuc2NhbGU8MT9cImluXCI6XCJvdXRcIjt0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQrYixhKX19fSkscChkYyxZYix7ZGVmYXVsdHM6e2V2ZW50OlwicHJlc3NcIixwb2ludGVyczoxLHRpbWU6NTAwLHRocmVzaG9sZDo1fSxnZXRUb3VjaEFjdGlvbjpmdW5jdGlvbigpe3JldHVybltLYl19LHByb2Nlc3M6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zLGM9YS5wb2ludGVycy5sZW5ndGg9PT1iLnBvaW50ZXJzLGQ9YS5kaXN0YW5jZTxiLnRocmVzaG9sZCxlPWEuZGVsdGFUaW1lPmIudGltZTtpZih0aGlzLl9pbnB1dD1hLCFkfHwhY3x8YS5ldmVudFR5cGUmKFF8UikmJiFlKXRoaXMucmVzZXQoKTtlbHNlIGlmKGEuZXZlbnRUeXBlJk8pdGhpcy5yZXNldCgpLHRoaXMuX3RpbWVyPWsoZnVuY3Rpb24oKXt0aGlzLnN0YXRlPVZiLHRoaXMudHJ5RW1pdCgpfSxiLnRpbWUsdGhpcyk7ZWxzZSBpZihhLmV2ZW50VHlwZSZRKXJldHVybiBWYjtyZXR1cm4gWGJ9LHJlc2V0OmZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKX0sZW1pdDpmdW5jdGlvbihhKXt0aGlzLnN0YXRlPT09VmImJihhJiZhLmV2ZW50VHlwZSZRP3RoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCtcInVwXCIsYSk6KHRoaXMuX2lucHV0LnRpbWVTdGFtcD1qKCksdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LHRoaXMuX2lucHV0KSkpfX0pLHAoZWMsYWMse2RlZmF1bHRzOntldmVudDpcInJvdGF0ZVwiLHRocmVzaG9sZDowLHBvaW50ZXJzOjJ9LGdldFRvdWNoQWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuW01iXX0sYXR0clRlc3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcyxhKSYmKE1hdGguYWJzKGEucm90YXRpb24pPnRoaXMub3B0aW9ucy50aHJlc2hvbGR8fHRoaXMuc3RhdGUmU2IpfX0pLHAoZmMsYWMse2RlZmF1bHRzOntldmVudDpcInN3aXBlXCIsdGhyZXNob2xkOjEwLHZlbG9jaXR5Oi42NSxkaXJlY3Rpb246WHxZLHBvaW50ZXJzOjF9LGdldFRvdWNoQWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGJjLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpfSxhdHRyVGVzdDpmdW5jdGlvbihhKXt2YXIgYyxiPXRoaXMub3B0aW9ucy5kaXJlY3Rpb247cmV0dXJuIGImKFh8WSk/Yz1hLnZlbG9jaXR5OmImWD9jPWEudmVsb2NpdHlYOmImWSYmKGM9YS52ZWxvY2l0eVkpLHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcyxhKSYmYiZhLmRpcmVjdGlvbiYmYS5kaXN0YW5jZT50aGlzLm9wdGlvbnMudGhyZXNob2xkJiZpKGMpPnRoaXMub3B0aW9ucy52ZWxvY2l0eSYmYS5ldmVudFR5cGUmUX0sZW1pdDpmdW5jdGlvbihhKXt2YXIgYj0kYihhLmRpcmVjdGlvbik7YiYmdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50K2IsYSksdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LGEpfX0pLHAoZ2MsWWIse2RlZmF1bHRzOntldmVudDpcInRhcFwiLHBvaW50ZXJzOjEsdGFwczoxLGludGVydmFsOjMwMCx0aW1lOjI1MCx0aHJlc2hvbGQ6Mixwb3NUaHJlc2hvbGQ6MTB9LGdldFRvdWNoQWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuW0xiXX0scHJvY2VzczpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnMsYz1hLnBvaW50ZXJzLmxlbmd0aD09PWIucG9pbnRlcnMsZD1hLmRpc3RhbmNlPGIudGhyZXNob2xkLGU9YS5kZWx0YVRpbWU8Yi50aW1lO2lmKHRoaXMucmVzZXQoKSxhLmV2ZW50VHlwZSZPJiYwPT09dGhpcy5jb3VudClyZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO2lmKGQmJmUmJmMpe2lmKGEuZXZlbnRUeXBlIT1RKXJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7dmFyIGY9dGhpcy5wVGltZT9hLnRpbWVTdGFtcC10aGlzLnBUaW1lPGIuaW50ZXJ2YWw6ITAsZz0hdGhpcy5wQ2VudGVyfHxrYih0aGlzLnBDZW50ZXIsYS5jZW50ZXIpPGIucG9zVGhyZXNob2xkO3RoaXMucFRpbWU9YS50aW1lU3RhbXAsdGhpcy5wQ2VudGVyPWEuY2VudGVyLGcmJmY/dGhpcy5jb3VudCs9MTp0aGlzLmNvdW50PTEsdGhpcy5faW5wdXQ9YTt2YXIgaD10aGlzLmNvdW50JWIudGFwcztpZigwPT09aClyZXR1cm4gdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKT8odGhpcy5fdGltZXI9ayhmdW5jdGlvbigpe3RoaXMuc3RhdGU9VmIsdGhpcy50cnlFbWl0KCl9LGIuaW50ZXJ2YWwsdGhpcyksU2IpOlZifXJldHVybiBYYn0sZmFpbFRpbWVvdXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGltZXI9ayhmdW5jdGlvbigpe3RoaXMuc3RhdGU9WGJ9LHRoaXMub3B0aW9ucy5pbnRlcnZhbCx0aGlzKSxYYn0scmVzZXQ6ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpfSxlbWl0OmZ1bmN0aW9uKCl7dGhpcy5zdGF0ZT09VmImJih0aGlzLl9pbnB1dC50YXBDb3VudD10aGlzLmNvdW50LHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCx0aGlzLl9pbnB1dCkpfX0pLGhjLlZFUlNJT049XCIyLjAuNFwiLGhjLmRlZmF1bHRzPXtkb21FdmVudHM6ITEsdG91Y2hBY3Rpb246SmIsZW5hYmxlOiEwLGlucHV0VGFyZ2V0Om51bGwsaW5wdXRDbGFzczpudWxsLHByZXNldDpbW2VjLHtlbmFibGU6ITF9XSxbY2Mse2VuYWJsZTohMX0sW1wicm90YXRlXCJdXSxbZmMse2RpcmVjdGlvbjpYfV0sW2JjLHtkaXJlY3Rpb246WH0sW1wic3dpcGVcIl1dLFtnY10sW2djLHtldmVudDpcImRvdWJsZXRhcFwiLHRhcHM6Mn0sW1widGFwXCJdXSxbZGNdXSxjc3NQcm9wczp7dXNlclNlbGVjdDpcImRlZmF1bHRcIix0b3VjaFNlbGVjdDpcIm5vbmVcIix0b3VjaENhbGxvdXQ6XCJub25lXCIsY29udGVudFpvb21pbmc6XCJub25lXCIsdXNlckRyYWc6XCJub25lXCIsdGFwSGlnaGxpZ2h0Q29sb3I6XCJyZ2JhKDAsMCwwLDApXCJ9fTt2YXIgaWM9MSxqYz0yO2tjLnByb3RvdHlwZT17c2V0OmZ1bmN0aW9uKGEpe3JldHVybiBuKHRoaXMub3B0aW9ucyxhKSxhLnRvdWNoQWN0aW9uJiZ0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpLGEuaW5wdXRUYXJnZXQmJih0aGlzLmlucHV0LmRlc3Ryb3koKSx0aGlzLmlucHV0LnRhcmdldD1hLmlucHV0VGFyZ2V0LHRoaXMuaW5wdXQuaW5pdCgpKSx0aGlzfSxzdG9wOmZ1bmN0aW9uKGEpe3RoaXMuc2Vzc2lvbi5zdG9wcGVkPWE/amM6aWN9LHJlY29nbml6ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnNlc3Npb247aWYoIWIuc3RvcHBlZCl7dGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoYSk7dmFyIGMsZD10aGlzLnJlY29nbml6ZXJzLGU9Yi5jdXJSZWNvZ25pemVyOyghZXx8ZSYmZS5zdGF0ZSZWYikmJihlPWIuY3VyUmVjb2duaXplcj1udWxsKTtmb3IodmFyIGY9MDtmPGQubGVuZ3RoOyljPWRbZl0sYi5zdG9wcGVkPT09amN8fGUmJmMhPWUmJiFjLmNhblJlY29nbml6ZVdpdGgoZSk/Yy5yZXNldCgpOmMucmVjb2duaXplKGEpLCFlJiZjLnN0YXRlJihTYnxUYnxVYikmJihlPWIuY3VyUmVjb2duaXplcj1jKSxmKyt9fSxnZXQ6ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIFliKXJldHVybiBhO2Zvcih2YXIgYj10aGlzLnJlY29nbml6ZXJzLGM9MDtjPGIubGVuZ3RoO2MrKylpZihiW2NdLm9wdGlvbnMuZXZlbnQ9PWEpcmV0dXJuIGJbY107cmV0dXJuIG51bGx9LGFkZDpmdW5jdGlvbihhKXtpZihsKGEsXCJhZGRcIix0aGlzKSlyZXR1cm4gdGhpczt2YXIgYj10aGlzLmdldChhLm9wdGlvbnMuZXZlbnQpO3JldHVybiBiJiZ0aGlzLnJlbW92ZShiKSx0aGlzLnJlY29nbml6ZXJzLnB1c2goYSksYS5tYW5hZ2VyPXRoaXMsdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKSxhfSxyZW1vdmU6ZnVuY3Rpb24oYSl7aWYobChhLFwicmVtb3ZlXCIsdGhpcykpcmV0dXJuIHRoaXM7dmFyIGI9dGhpcy5yZWNvZ25pemVycztyZXR1cm4gYT10aGlzLmdldChhKSxiLnNwbGljZSh5KGIsYSksMSksdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKSx0aGlzfSxvbjpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuaGFuZGxlcnM7cmV0dXJuIG0oeChhKSxmdW5jdGlvbihhKXtjW2FdPWNbYV18fFtdLGNbYV0ucHVzaChiKX0pLHRoaXN9LG9mZjpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuaGFuZGxlcnM7cmV0dXJuIG0oeChhKSxmdW5jdGlvbihhKXtiP2NbYV0uc3BsaWNlKHkoY1thXSxiKSwxKTpkZWxldGUgY1thXX0pLHRoaXN9LGVtaXQ6ZnVuY3Rpb24oYSxiKXt0aGlzLm9wdGlvbnMuZG9tRXZlbnRzJiZtYyhhLGIpO3ZhciBjPXRoaXMuaGFuZGxlcnNbYV0mJnRoaXMuaGFuZGxlcnNbYV0uc2xpY2UoKTtpZihjJiZjLmxlbmd0aCl7Yi50eXBlPWEsYi5wcmV2ZW50RGVmYXVsdD1mdW5jdGlvbigpe2Iuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKX07Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aDspY1tkXShiKSxkKyt9fSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5lbGVtZW50JiZsYyh0aGlzLCExKSx0aGlzLmhhbmRsZXJzPXt9LHRoaXMuc2Vzc2lvbj17fSx0aGlzLmlucHV0LmRlc3Ryb3koKSx0aGlzLmVsZW1lbnQ9bnVsbH19LG4oaGMse0lOUFVUX1NUQVJUOk8sSU5QVVRfTU9WRTpQLElOUFVUX0VORDpRLElOUFVUX0NBTkNFTDpSLFNUQVRFX1BPU1NJQkxFOlJiLFNUQVRFX0JFR0FOOlNiLFNUQVRFX0NIQU5HRUQ6VGIsU1RBVEVfRU5ERUQ6VWIsU1RBVEVfUkVDT0dOSVpFRDpWYixTVEFURV9DQU5DRUxMRUQ6V2IsU1RBVEVfRkFJTEVEOlhiLERJUkVDVElPTl9OT05FOlMsRElSRUNUSU9OX0xFRlQ6VCxESVJFQ1RJT05fUklHSFQ6VSxESVJFQ1RJT05fVVA6VixESVJFQ1RJT05fRE9XTjpXLERJUkVDVElPTl9IT1JJWk9OVEFMOlgsRElSRUNUSU9OX1ZFUlRJQ0FMOlksRElSRUNUSU9OX0FMTDpaLE1hbmFnZXI6a2MsSW5wdXQ6YWIsVG91Y2hBY3Rpb246UGIsVG91Y2hJbnB1dDpFYixNb3VzZUlucHV0OnJiLFBvaW50ZXJFdmVudElucHV0OndiLFRvdWNoTW91c2VJbnB1dDpHYixTaW5nbGVUb3VjaElucHV0OkFiLFJlY29nbml6ZXI6WWIsQXR0clJlY29nbml6ZXI6YWMsVGFwOmdjLFBhbjpiYyxTd2lwZTpmYyxQaW5jaDpjYyxSb3RhdGU6ZWMsUHJlc3M6ZGMsb246dCxvZmY6dSxlYWNoOm0sbWVyZ2U6byxleHRlbmQ6bixpbmhlcml0OnAsYmluZEZuOnEscHJlZml4ZWQ6Qn0pLHR5cGVvZiBkZWZpbmU9PWcmJmRlZmluZS5hbWQ/ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIGhjfSk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9aGM6YVtjXT1oY30od2luZG93LGRvY3VtZW50LFwiSGFtbWVyXCIpOzsoZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5JywgJ2hhbW1lcmpzJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JyksIHJlcXVpcmUoJ2hhbW1lcmpzJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoalF1ZXJ5LCBIYW1tZXIpO1xuICAgIH1cbn0oZnVuY3Rpb24oJCwgSGFtbWVyKSB7XG4gICAgZnVuY3Rpb24gaGFtbWVyaWZ5KGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciAkZWwgPSAkKGVsKTtcbiAgICAgICAgaWYoISRlbC5kYXRhKFwiaGFtbWVyXCIpKSB7XG4gICAgICAgICAgICAkZWwuZGF0YShcImhhbW1lclwiLCBuZXcgSGFtbWVyKCRlbFswXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJC5mbi5oYW1tZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoYW1tZXJpZnkodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBleHRlbmQgdGhlIGVtaXQgbWV0aG9kIHRvIGFsc28gdHJpZ2dlciBqUXVlcnkgZXZlbnRzXG4gICAgSGFtbWVyLk1hbmFnZXIucHJvdG90eXBlLmVtaXQgPSAoZnVuY3Rpb24ob3JpZ2luYWxFbWl0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICBvcmlnaW5hbEVtaXQuY2FsbCh0aGlzLCB0eXBlLCBkYXRhKTtcbiAgICAgICAgICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGdlc3R1cmU6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0pKEhhbW1lci5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0KTtcbn0pKTtcbjsvLyBSZXF1aXJlZCBmb3IgTWV0ZW9yIHBhY2thZ2UsIHRoZSB1c2Ugb2Ygd2luZG93IHByZXZlbnRzIGV4cG9ydCBieSBNZXRlb3JcbihmdW5jdGlvbih3aW5kb3cpe1xuICBpZih3aW5kb3cuUGFja2FnZSl7XG4gICAgTWF0ZXJpYWxpemUgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuTWF0ZXJpYWxpemUgPSB7fTtcbiAgfVxufSkod2luZG93KTtcblxuXG4vKlxuICogcmFmLmpzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmdyeW1hbi9yYWYuanNcbiAqXG4gKiBvcmlnaW5hbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyXG4gKiBpbnNwaXJlZCBmcm9tIHBhdWxfaXJpc2ggZ2lzdCBhbmQgcG9zdFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMyBuZ3J5bWFuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbih3aW5kb3cpIHtcbiAgdmFyIGxhc3RUaW1lID0gMCxcbiAgICB2ZW5kb3JzID0gWyd3ZWJraXQnLCAnbW96J10sXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSxcbiAgICBpID0gdmVuZG9ycy5sZW5ndGg7XG5cbiAgLy8gdHJ5IHRvIHVuLXByZWZpeCBleGlzdGluZyByYWZcbiAgd2hpbGUgKC0taSA+PSAwICYmICFyZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1tpXSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW2ldICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICB9XG5cbiAgLy8gcG9seWZpbGwgd2l0aCBzZXRUaW1lb3V0IGZhbGxiYWNrXG4gIC8vIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBAZGFyaXVzIGdpc3QgbW9kOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MSNjb21tZW50LTgzNzk0NVxuICBpZiAoIXJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgdmFyIG5vdyA9ICtEYXRlLm5vdygpLFxuICAgICAgICBuZXh0VGltZSA9IE1hdGgubWF4KGxhc3RUaW1lICsgMTYsIG5vdyk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sobGFzdFRpbWUgPSBuZXh0VGltZSk7XG4gICAgICB9LCBuZXh0VGltZSAtIG5vdyk7XG4gICAgfTtcblxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2xlYXJUaW1lb3V0O1xuICB9XG5cbiAgLy8gZXhwb3J0IHRvIHdpbmRvd1xuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYW5jZWxBbmltYXRpb25GcmFtZTtcbn0od2luZG93KSk7XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhcHByb3hpbWF0ZWQgc2VsZWN0b3Igc3RyaW5nIGZvciBhIGpRdWVyeSBvYmplY3RcbiAqIEBwYXJhbSB7alF1ZXJ5fSBvYmogIGpRdWVyeSBvYmplY3QgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5NYXRlcmlhbGl6ZS5vYmplY3RTZWxlY3RvclN0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgdGFnU3RyID0gb2JqLnByb3AoJ3RhZ05hbWUnKSB8fCAnJztcbiAgdmFyIGlkU3RyID0gb2JqLmF0dHIoJ2lkJykgfHwgJyc7XG4gIHZhciBjbGFzc1N0ciA9IG9iai5hdHRyKCdjbGFzcycpIHx8ICcnO1xuICByZXR1cm4gKHRhZ1N0ciArIGlkU3RyICsgY2xhc3NTdHIpLnJlcGxhY2UoL1xccy9nLCcnKTtcbn07XG5cblxuLy8gVW5pcXVlIFJhbmRvbSBJRFxuTWF0ZXJpYWxpemUuZ3VpZCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gczQoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAuc3Vic3RyaW5nKDEpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArXG4gICAgICAgICAgIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIEVzY2FwZXMgaGFzaCBmcm9tIHNwZWNpYWwgY2hhcmFjdGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggIFN0cmluZyByZXR1cm5lZCBmcm9tIHRoaXMuaGFzaFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuTWF0ZXJpYWxpemUuZXNjYXBlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgcmV0dXJuIGhhc2gucmVwbGFjZSggLyg6fFxcLnxcXFt8XFxdfCx8PSkvZywgXCJcXFxcJDFcIiApO1xufTtcblxuTWF0ZXJpYWxpemUuZWxlbWVudE9yUGFyZW50SXNGaXhlZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgIHZhciAkY2hlY2tFbGVtZW50cyA9ICRlbGVtZW50LmFkZCgkZWxlbWVudC5wYXJlbnRzKCkpO1xuICAgIHZhciBpc0ZpeGVkID0gZmFsc2U7XG4gICAgJGNoZWNrRWxlbWVudHMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICBpZiAoJCh0aGlzKS5jc3MoXCJwb3NpdGlvblwiKSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICBpc0ZpeGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0ZpeGVkO1xufTtcblxuXG4vKipcbiAqIEdldCB0aW1lIGluIG1zXG4gKiBAbGljZW5zZSBodHRwczovL3Jhdy5naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL21hc3Rlci9MSUNFTlNFXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbnZhciBnZXRUaW1lID0gKERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufSk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAqIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICogYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICogYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAqIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9tYXN0ZXIvTElDRU5TRVxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtudW1iZXJ9IHdhaXRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5NYXRlcmlhbGl6ZS50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICB2YXIgcHJldmlvdXMgPSAwO1xuICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IGdldFRpbWUoKTtcbiAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm93ID0gZ2V0VGltZSgpO1xuICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLy8gVmVsb2NpdHkgaGFzIGNvbmZsaWN0cyB3aGVuIGxvYWRlZCB3aXRoIGpRdWVyeSwgdGhpcyB3aWxsIGNoZWNrIGZvciBpdFxuLy8gRmlyc3QsIGNoZWNrIGlmIGluIG5vQ29uZmxpY3QgbW9kZVxudmFyIFZlbDtcbmlmIChqUXVlcnkpIHtcbiAgVmVsID0galF1ZXJ5LlZlbG9jaXR5O1xufSBlbHNlIGlmICgkKSB7XG4gIFZlbCA9ICQuVmVsb2NpdHk7XG59IGVsc2Uge1xuICBWZWwgPSBWZWxvY2l0eTtcbn1cbjsoZnVuY3Rpb24gKCQpIHtcbiAgJC5mbi5jb2xsYXBzaWJsZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIG1ldGhvZFBhcmFtKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgYWNjb3JkaW9uOiB1bmRlZmluZWQsXG4gICAgICBvbk9wZW46IHVuZGVmaW5lZCxcbiAgICAgIG9uQ2xvc2U6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICB2YXIgbWV0aG9kTmFtZSA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblxuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcblxuICAgICAgdmFyICRwYW5lbF9oZWFkZXJzID0gJCh0aGlzKS5maW5kKCc+IGxpID4gLmNvbGxhcHNpYmxlLWhlYWRlcicpO1xuXG4gICAgICB2YXIgY29sbGFwc2libGVfdHlwZSA9ICR0aGlzLmRhdGEoXCJjb2xsYXBzaWJsZVwiKTtcblxuICAgICAgLyoqKioqKioqKioqKioqKipcbiAgICAgIEhlbHBlciBGdW5jdGlvbnNcbiAgICAgICoqKioqKioqKioqKioqKiovXG5cbiAgICAgIC8vIEFjY29yZGlvbiBPcGVuXG4gICAgICBmdW5jdGlvbiBhY2NvcmRpb25PcGVuKG9iamVjdCkge1xuICAgICAgICAkcGFuZWxfaGVhZGVycyA9ICR0aGlzLmZpbmQoJz4gbGkgPiAuY29sbGFwc2libGUtaGVhZGVyJyk7XG4gICAgICAgIGlmIChvYmplY3QuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgb2JqZWN0LnBhcmVudCgpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvYmplY3QucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QucGFyZW50KCkuaGFzQ2xhc3MoJ2FjdGl2ZScpKXtcbiAgICAgICAgICBvYmplY3Quc2libGluZ3MoJy5jb2xsYXBzaWJsZS1ib2R5Jykuc3RvcCh0cnVlLGZhbHNlKS5zbGlkZURvd24oeyBkdXJhdGlvbjogMzUwLCBlYXNpbmc6IFwiZWFzZU91dFF1YXJ0XCIsIHF1ZXVlOiBmYWxzZSwgY29tcGxldGU6IGZ1bmN0aW9uKCkgeyQodGhpcykuY3NzKCdoZWlnaHQnLCAnJyk7fX0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgb2JqZWN0LnNpYmxpbmdzKCcuY29sbGFwc2libGUtYm9keScpLnN0b3AodHJ1ZSxmYWxzZSkuc2xpZGVVcCh7IGR1cmF0aW9uOiAzNTAsIGVhc2luZzogXCJlYXNlT3V0UXVhcnRcIiwgcXVldWU6IGZhbHNlLCBjb21wbGV0ZTogZnVuY3Rpb24oKSB7JCh0aGlzKS5jc3MoJ2hlaWdodCcsICcnKTt9fSk7XG4gICAgICAgIH1cblxuICAgICAgICAkcGFuZWxfaGVhZGVycy5ub3Qob2JqZWN0KS5yZW1vdmVDbGFzcygnYWN0aXZlJykucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXG4gICAgICAgIC8vIENsb3NlIHByZXZpb3VzbHkgb3BlbiBhY2NvcmRpb24gZWxlbWVudHMuXG4gICAgICAgICRwYW5lbF9oZWFkZXJzLm5vdChvYmplY3QpLnBhcmVudCgpLmNoaWxkcmVuKCcuY29sbGFwc2libGUtYm9keScpLnN0b3AodHJ1ZSxmYWxzZSkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgJCh0aGlzKS5zbGlkZVVwKHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IDM1MCxcbiAgICAgICAgICAgICAgZWFzaW5nOiBcImVhc2VPdXRRdWFydFwiLFxuICAgICAgICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgICAgICAgIGNvbXBsZXRlOlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ2hlaWdodCcsICcnKTtcbiAgICAgICAgICAgICAgICAgIGV4ZWNDYWxsYmFja3MoJCh0aGlzKS5zaWJsaW5ncygnLmNvbGxhcHNpYmxlLWhlYWRlcicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBFeHBhbmRhYmxlIE9wZW5cbiAgICAgIGZ1bmN0aW9uIGV4cGFuZGFibGVPcGVuKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0Lmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgIG9iamVjdC5wYXJlbnQoKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgb2JqZWN0LnBhcmVudCgpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnBhcmVudCgpLmhhc0NsYXNzKCdhY3RpdmUnKSl7XG4gICAgICAgICAgb2JqZWN0LnNpYmxpbmdzKCcuY29sbGFwc2libGUtYm9keScpLnN0b3AodHJ1ZSxmYWxzZSkuc2xpZGVEb3duKHsgZHVyYXRpb246IDM1MCwgZWFzaW5nOiBcImVhc2VPdXRRdWFydFwiLCBxdWV1ZTogZmFsc2UsIGNvbXBsZXRlOiBmdW5jdGlvbigpIHskKHRoaXMpLmNzcygnaGVpZ2h0JywgJycpO319KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvYmplY3Quc2libGluZ3MoJy5jb2xsYXBzaWJsZS1ib2R5Jykuc3RvcCh0cnVlLGZhbHNlKS5zbGlkZVVwKHsgZHVyYXRpb246IDM1MCwgZWFzaW5nOiBcImVhc2VPdXRRdWFydFwiLCBxdWV1ZTogZmFsc2UsIGNvbXBsZXRlOiBmdW5jdGlvbigpIHskKHRoaXMpLmNzcygnaGVpZ2h0JywgJycpO319KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPcGVuIGNvbGxhcHNpYmxlLiBvYmplY3Q6IC5jb2xsYXBzaWJsZS1oZWFkZXJcbiAgICAgIGZ1bmN0aW9uIGNvbGxhcHNpYmxlT3BlbihvYmplY3QsIG5vVG9nZ2xlKSB7XG4gICAgICAgIGlmICghbm9Ub2dnbGUpIHtcbiAgICAgICAgICBvYmplY3QudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWNjb3JkaW9uIHx8IGNvbGxhcHNpYmxlX3R5cGUgPT09IFwiYWNjb3JkaW9uXCIgfHwgY29sbGFwc2libGVfdHlwZSA9PT0gdW5kZWZpbmVkKSB7IC8vIEhhbmRsZSBBY2NvcmRpb25cbiAgICAgICAgICBhY2NvcmRpb25PcGVuKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIEhhbmRsZSBFeHBhbmRhYmxlc1xuICAgICAgICAgIGV4cGFuZGFibGVPcGVuKG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBleGVjQ2FsbGJhY2tzKG9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBjYWxsYmFja3NcbiAgICAgIGZ1bmN0aW9uIGV4ZWNDYWxsYmFja3Mob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZihvcHRpb25zLm9uT3BlbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3B0aW9ucy5vbk9wZW4uY2FsbCh0aGlzLCBvYmplY3QucGFyZW50KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mKG9wdGlvbnMub25DbG9zZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3B0aW9ucy5vbkNsb3NlLmNhbGwodGhpcywgb2JqZWN0LnBhcmVudCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBpZiBvYmplY3QgaXMgY2hpbGRyZW4gb2YgcGFuZWwgaGVhZGVyXG4gICAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmplY3QgSnF1ZXJ5IG9iamVjdFxuICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBpcyBjaGlsZHJlblxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBpc0NoaWxkcmVuT2ZQYW5lbEhlYWRlcihvYmplY3QpIHtcblxuICAgICAgICB2YXIgcGFuZWxIZWFkZXIgPSBnZXRQYW5lbEhlYWRlcihvYmplY3QpO1xuXG4gICAgICAgIHJldHVybiBwYW5lbEhlYWRlci5sZW5ndGggPiAwO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBwYW5lbCBoZWFkZXIgZnJvbSBhIGNoaWxkcmVuIGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0IEpxdWVyeSBvYmplY3RcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gcGFuZWwgaGVhZGVyIG9iamVjdFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBnZXRQYW5lbEhlYWRlcihvYmplY3QpIHtcblxuICAgICAgICByZXR1cm4gb2JqZWN0LmNsb3Nlc3QoJ2xpID4gLmNvbGxhcHNpYmxlLWhlYWRlcicpO1xuICAgICAgfVxuXG5cbiAgICAgIC8vIFR1cm4gb2ZmIGFueSBleGlzdGluZyBldmVudCBoYW5kbGVyc1xuICAgICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgJHRoaXMub2ZmKCdjbGljay5jb2xsYXBzZScsICc+IGxpID4gLmNvbGxhcHNpYmxlLWhlYWRlcicpO1xuICAgICAgfVxuXG4gICAgICAvKioqKiogIEVuZCBIZWxwZXIgRnVuY3Rpb25zICAqKioqKi9cblxuXG4gICAgICAvLyBNZXRob2RzXG4gICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2Rlc3Ryb3knKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChtZXRob2RQYXJhbSA+PSAwICYmXG4gICAgICAgICAgbWV0aG9kUGFyYW0gPCAkcGFuZWxfaGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgdmFyICRjdXJyX2hlYWRlciA9ICRwYW5lbF9oZWFkZXJzLmVxKG1ldGhvZFBhcmFtKTtcbiAgICAgICAgaWYgKCRjdXJyX2hlYWRlci5sZW5ndGggJiZcbiAgICAgICAgICAgIChtZXRob2ROYW1lID09PSAnb3BlbicgfHxcbiAgICAgICAgICAgIChtZXRob2ROYW1lID09PSAnY2xvc2UnICYmXG4gICAgICAgICAgICAkY3Vycl9oZWFkZXIuaGFzQ2xhc3MoJ2FjdGl2ZScpKSkpIHtcbiAgICAgICAgICBjb2xsYXBzaWJsZU9wZW4oJGN1cnJfaGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cblxuICAgICAgcmVtb3ZlRXZlbnRIYW5kbGVycygpO1xuXG5cbiAgICAgIC8vIEFkZCBjbGljayBoYW5kbGVyIHRvIG9ubHkgZGlyZWN0IGNvbGxhcHNpYmxlIGhlYWRlciBjaGlsZHJlblxuICAgICAgJHRoaXMub24oJ2NsaWNrLmNvbGxhcHNlJywgJz4gbGkgPiAuY29sbGFwc2libGUtaGVhZGVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICQoZS50YXJnZXQpO1xuXG4gICAgICAgIGlmIChpc0NoaWxkcmVuT2ZQYW5lbEhlYWRlcihlbGVtZW50KSkge1xuICAgICAgICAgIGVsZW1lbnQgPSBnZXRQYW5lbEhlYWRlcihlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbGxhcHNpYmxlT3BlbihlbGVtZW50KTtcbiAgICAgIH0pO1xuXG5cbiAgICAgIC8vIE9wZW4gZmlyc3QgYWN0aXZlXG4gICAgICBpZiAob3B0aW9ucy5hY2NvcmRpb24gfHwgY29sbGFwc2libGVfdHlwZSA9PT0gXCJhY2NvcmRpb25cIiB8fCBjb2xsYXBzaWJsZV90eXBlID09PSB1bmRlZmluZWQpIHsgLy8gSGFuZGxlIEFjY29yZGlvblxuICAgICAgICBjb2xsYXBzaWJsZU9wZW4oJHBhbmVsX2hlYWRlcnMuZmlsdGVyKCcuYWN0aXZlJykuZmlyc3QoKSwgdHJ1ZSk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIEhhbmRsZSBFeHBhbmRhYmxlc1xuICAgICAgICAkcGFuZWxfaGVhZGVycy5maWx0ZXIoJy5hY3RpdmUnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbGxhcHNpYmxlT3BlbigkKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfTtcblxuICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuICAgICQoJy5jb2xsYXBzaWJsZScpLmNvbGxhcHNpYmxlKCk7XG4gIH0pO1xufSggalF1ZXJ5ICkpOzsoZnVuY3Rpb24gKCQpIHtcblxuICAvLyBBZGQgcG9zaWJpbGl0eSB0byBzY3JvbGwgdG8gc2VsZWN0ZWQgb3B0aW9uXG4gIC8vIHVzZWZ1bGwgZm9yIHNlbGVjdCBmb3IgZXhhbXBsZVxuICAkLmZuLnNjcm9sbFRvID0gZnVuY3Rpb24oZWxlbSkge1xuICAgICQodGhpcykuc2Nyb2xsVG9wKCQodGhpcykuc2Nyb2xsVG9wKCkgLSAkKHRoaXMpLm9mZnNldCgpLnRvcCArICQoZWxlbSkub2Zmc2V0KCkudG9wKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAkLmZuLmRyb3Bkb3duID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBpbkR1cmF0aW9uOiAzMDAsXG4gICAgICBvdXREdXJhdGlvbjogMjI1LFxuICAgICAgY29uc3RyYWluV2lkdGg6IHRydWUsIC8vIENvbnN0cmFpbnMgd2lkdGggb2YgZHJvcGRvd24gdG8gdGhlIGFjdGl2YXRvclxuICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAgZ3V0dGVyOiAwLCAvLyBTcGFjaW5nIGZyb20gZWRnZVxuICAgICAgYmVsb3dPcmlnaW46IGZhbHNlLFxuICAgICAgYWxpZ25tZW50OiAnbGVmdCcsXG4gICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIE9wZW4gZHJvcGRvd24uXG4gICAgaWYgKG9wdGlvbnMgPT09IFwib3BlblwiKSB7XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICQodGhpcykudHJpZ2dlcignb3BlbicpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2xvc2UgZHJvcGRvd24uXG4gICAgaWYgKG9wdGlvbnMgPT09IFwiY2xvc2VcIikge1xuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAkKHRoaXMpLnRyaWdnZXIoJ2Nsb3NlJyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciBvcmlnaW4gPSAkKHRoaXMpO1xuICAgICAgdmFyIGN1cnJfb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICB2YXIgaXNGb2N1c2VkID0gZmFsc2U7XG5cbiAgICAgIC8vIERyb3Bkb3duIG1lbnVcbiAgICAgIHZhciBhY3RpdmF0ZXMgPSAkKFwiI1wiKyBvcmlnaW4uYXR0cignZGF0YS1hY3RpdmF0ZXMnKSk7XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoKSB7XG4gICAgICAgIGlmIChvcmlnaW4uZGF0YSgnaW5kdXJhdGlvbicpICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgY3Vycl9vcHRpb25zLmluRHVyYXRpb24gPSBvcmlnaW4uZGF0YSgnaW5kdXJhdGlvbicpO1xuICAgICAgICBpZiAob3JpZ2luLmRhdGEoJ291dGR1cmF0aW9uJykgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICBjdXJyX29wdGlvbnMub3V0RHVyYXRpb24gPSBvcmlnaW4uZGF0YSgnb3V0ZHVyYXRpb24nKTtcbiAgICAgICAgaWYgKG9yaWdpbi5kYXRhKCdjb25zdHJhaW53aWR0aCcpICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgY3Vycl9vcHRpb25zLmNvbnN0cmFpbldpZHRoID0gb3JpZ2luLmRhdGEoJ2NvbnN0cmFpbndpZHRoJyk7XG4gICAgICAgIGlmIChvcmlnaW4uZGF0YSgnaG92ZXInKSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGN1cnJfb3B0aW9ucy5ob3ZlciA9IG9yaWdpbi5kYXRhKCdob3ZlcicpO1xuICAgICAgICBpZiAob3JpZ2luLmRhdGEoJ2d1dHRlcicpICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgY3Vycl9vcHRpb25zLmd1dHRlciA9IG9yaWdpbi5kYXRhKCdndXR0ZXInKTtcbiAgICAgICAgaWYgKG9yaWdpbi5kYXRhKCdiZWxvd29yaWdpbicpICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgY3Vycl9vcHRpb25zLmJlbG93T3JpZ2luID0gb3JpZ2luLmRhdGEoJ2JlbG93b3JpZ2luJyk7XG4gICAgICAgIGlmIChvcmlnaW4uZGF0YSgnYWxpZ25tZW50JykgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICBjdXJyX29wdGlvbnMuYWxpZ25tZW50ID0gb3JpZ2luLmRhdGEoJ2FsaWdubWVudCcpO1xuICAgICAgICBpZiAob3JpZ2luLmRhdGEoJ3N0b3Bwcm9wYWdhdGlvbicpICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgY3Vycl9vcHRpb25zLnN0b3BQcm9wYWdhdGlvbiA9IG9yaWdpbi5kYXRhKCdzdG9wcHJvcGFnYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlT3B0aW9ucygpO1xuXG4gICAgICAvLyBBdHRhY2ggZHJvcGRvd24gdG8gaXRzIGFjdGl2YXRvclxuICAgICAgb3JpZ2luLmFmdGVyKGFjdGl2YXRlcyk7XG5cbiAgICAgIC8qXG4gICAgICAgIEhlbHBlciBmdW5jdGlvbiB0byBwb3NpdGlvbiBhbmQgcmVzaXplIGRyb3Bkb3duLlxuICAgICAgICBVc2VkIGluIGhvdmVyIGFuZCBjbGljayBoYW5kbGVyLlxuICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHBsYWNlRHJvcGRvd24oZXZlbnRUeXBlKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBzaW11bHRhbmVvdXMgZm9jdXMgYW5kIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgIGlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBodG1sIGRhdGEgYXR0cmlidXRlc1xuICAgICAgICB1cGRhdGVPcHRpb25zKCk7XG5cbiAgICAgICAgLy8gU2V0IERyb3Bkb3duIHN0YXRlXG4gICAgICAgIGFjdGl2YXRlcy5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIG9yaWdpbi5hZGRDbGFzcygnYWN0aXZlJyk7XG5cbiAgICAgICAgLy8gQ29uc3RyYWluIHdpZHRoXG4gICAgICAgIGlmIChjdXJyX29wdGlvbnMuY29uc3RyYWluV2lkdGggPT09IHRydWUpIHtcbiAgICAgICAgICBhY3RpdmF0ZXMuY3NzKCd3aWR0aCcsIG9yaWdpbi5vdXRlcldpZHRoKCkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aXZhdGVzLmNzcygnd2hpdGUtc3BhY2UnLCAnbm93cmFwJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPZmZzY3JlZW4gZGV0ZWN0aW9uXG4gICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHZhciBvcmlnaW5IZWlnaHQgPSBvcmlnaW4uaW5uZXJIZWlnaHQoKTtcbiAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvcmlnaW4ub2Zmc2V0KCkubGVmdDtcbiAgICAgICAgdmFyIG9mZnNldFRvcCA9IG9yaWdpbi5vZmZzZXQoKS50b3AgLSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgICAgIHZhciBjdXJyQWxpZ25tZW50ID0gY3Vycl9vcHRpb25zLmFsaWdubWVudDtcbiAgICAgICAgdmFyIGd1dHRlclNwYWNpbmcgPSAwO1xuICAgICAgICB2YXIgbGVmdFBvc2l0aW9uID0gMDtcblxuICAgICAgICAvLyBCZWxvdyBPcmlnaW5cbiAgICAgICAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGN1cnJfb3B0aW9ucy5iZWxvd09yaWdpbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gb3JpZ2luSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHNjcm9sbGluZyBwb3NpdGlvbmVkIGNvbnRhaW5lci5cbiAgICAgICAgdmFyIHNjcm9sbFlPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgc2Nyb2xsWE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB3cmFwcGVyID0gb3JpZ2luLnBhcmVudCgpO1xuICAgICAgICBpZiAoIXdyYXBwZXIuaXMoJ2JvZHknKSkge1xuICAgICAgICAgIGlmICh3cmFwcGVyWzBdLnNjcm9sbEhlaWdodCA+IHdyYXBwZXJbMF0uY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICBzY3JvbGxZT2Zmc2V0ID0gd3JhcHBlclswXS5zY3JvbGxUb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3cmFwcGVyWzBdLnNjcm9sbFdpZHRoID4gd3JhcHBlclswXS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgc2Nyb2xsWE9mZnNldCA9IHdyYXBwZXJbMF0uc2Nyb2xsTGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChvZmZzZXRMZWZ0ICsgYWN0aXZhdGVzLmlubmVyV2lkdGgoKSA+ICQod2luZG93KS53aWR0aCgpKSB7XG4gICAgICAgICAgLy8gRHJvcGRvd24gZ29lcyBwYXN0IHNjcmVlbiBvbiByaWdodCwgZm9yY2UgcmlnaHQgYWxpZ25tZW50XG4gICAgICAgICAgY3VyckFsaWdubWVudCA9ICdyaWdodCc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXRMZWZ0IC0gYWN0aXZhdGVzLmlubmVyV2lkdGgoKSArIG9yaWdpbi5pbm5lcldpZHRoKCkgPCAwKSB7XG4gICAgICAgICAgLy8gRHJvcGRvd24gZ29lcyBwYXN0IHNjcmVlbiBvbiBsZWZ0LCBmb3JjZSBsZWZ0IGFsaWdubWVudFxuICAgICAgICAgIGN1cnJBbGlnbm1lbnQgPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVydGljYWwgYm90dG9tIG9mZnNjcmVlbiBkZXRlY3Rpb25cbiAgICAgICAgaWYgKG9mZnNldFRvcCArIGFjdGl2YXRlcy5pbm5lckhlaWdodCgpID4gd2luZG93SGVpZ2h0KSB7XG4gICAgICAgICAgLy8gSWYgZ29pbmcgdXB3YXJkcyBzdGlsbCBnb2VzIG9mZnNjcmVlbiwganVzdCBjcm9wIGhlaWdodCBvZiBkcm9wZG93bi5cbiAgICAgICAgICBpZiAob2Zmc2V0VG9wICsgb3JpZ2luSGVpZ2h0IC0gYWN0aXZhdGVzLmlubmVySGVpZ2h0KCkgPCAwKSB7XG4gICAgICAgICAgICB2YXIgYWRqdXN0ZWRIZWlnaHQgPSB3aW5kb3dIZWlnaHQgLSBvZmZzZXRUb3AgLSB2ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgICAgIGFjdGl2YXRlcy5jc3MoJ21heC1oZWlnaHQnLCBhZGp1c3RlZEhlaWdodCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZsb3cgdXB3YXJkcy5cbiAgICAgICAgICAgIGlmICghdmVydGljYWxPZmZzZXQpIHtcbiAgICAgICAgICAgICAgdmVydGljYWxPZmZzZXQgKz0gb3JpZ2luSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVydGljYWxPZmZzZXQgLT0gYWN0aXZhdGVzLmlubmVySGVpZ2h0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGVkZ2UgYWxpZ25tZW50XG4gICAgICAgIGlmIChjdXJyQWxpZ25tZW50ID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBndXR0ZXJTcGFjaW5nID0gY3Vycl9vcHRpb25zLmd1dHRlcjtcbiAgICAgICAgICBsZWZ0UG9zaXRpb24gPSBvcmlnaW4ucG9zaXRpb24oKS5sZWZ0ICsgZ3V0dGVyU3BhY2luZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyQWxpZ25tZW50ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdmFyIG9mZnNldFJpZ2h0ID0gb3JpZ2luLnBvc2l0aW9uKCkubGVmdCArIG9yaWdpbi5vdXRlcldpZHRoKCkgLSBhY3RpdmF0ZXMub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgIGd1dHRlclNwYWNpbmcgPSAtY3Vycl9vcHRpb25zLmd1dHRlcjtcbiAgICAgICAgICBsZWZ0UG9zaXRpb24gPSAgb2Zmc2V0UmlnaHQgKyBndXR0ZXJTcGFjaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9zaXRpb24gZHJvcGRvd25cbiAgICAgICAgYWN0aXZhdGVzLmNzcyh7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiBvcmlnaW4ucG9zaXRpb24oKS50b3AgKyB2ZXJ0aWNhbE9mZnNldCArIHNjcm9sbFlPZmZzZXQsXG4gICAgICAgICAgbGVmdDogbGVmdFBvc2l0aW9uICsgc2Nyb2xsWE9mZnNldFxuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIFNob3cgZHJvcGRvd25cbiAgICAgICAgYWN0aXZhdGVzLnN0b3AodHJ1ZSwgdHJ1ZSkuY3NzKCdvcGFjaXR5JywgMClcbiAgICAgICAgICAuc2xpZGVEb3duKHtcbiAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBjdXJyX29wdGlvbnMuaW5EdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRDdWJpYycsXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICQodGhpcykuY3NzKCdoZWlnaHQnLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuYW5pbWF0ZSgge29wYWNpdHk6IDF9LCB7cXVldWU6IGZhbHNlLCBkdXJhdGlvbjogY3Vycl9vcHRpb25zLmluRHVyYXRpb24sIGVhc2luZzogJ2Vhc2VPdXRTaW5lJ30pO1xuXG4gICAgICAgIC8vIEFkZCBjbGljayBjbG9zZSBoYW5kbGVyIHRvIGRvY3VtZW50XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJChkb2N1bWVudCkuYmluZCgnY2xpY2suJysgYWN0aXZhdGVzLmF0dHIoJ2lkJyksIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBoaWRlRHJvcGRvd24oKTtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLnVuYmluZCgnY2xpY2suJysgYWN0aXZhdGVzLmF0dHIoJ2lkJykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGlkZURyb3Bkb3duKCkge1xuICAgICAgICAvLyBDaGVjayBmb3Igc2ltdWx0YW5lb3VzIGZvY3VzIGFuZCBjbGljayBldmVudHMuXG4gICAgICAgIGlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICBhY3RpdmF0ZXMuZmFkZU91dChjdXJyX29wdGlvbnMub3V0RHVyYXRpb24pO1xuICAgICAgICBhY3RpdmF0ZXMucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICBvcmlnaW4ucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAkKGRvY3VtZW50KS51bmJpbmQoJ2NsaWNrLicrIGFjdGl2YXRlcy5hdHRyKCdpZCcpKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgYWN0aXZhdGVzLmNzcygnbWF4LWhlaWdodCcsICcnKTsgfSwgY3Vycl9vcHRpb25zLm91dER1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLy8gSG92ZXJcbiAgICAgIGlmIChjdXJyX29wdGlvbnMuaG92ZXIpIHtcbiAgICAgICAgdmFyIG9wZW4gPSBmYWxzZTtcbiAgICAgICAgb3JpZ2luLnVuYmluZCgnY2xpY2suJyArIG9yaWdpbi5hdHRyKCdpZCcpKTtcbiAgICAgICAgLy8gSG92ZXIgaGFuZGxlciB0byBzaG93IGRyb3Bkb3duXG4gICAgICAgIG9yaWdpbi5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKGUpeyAvLyBNb3VzZSBvdmVyXG4gICAgICAgICAgaWYgKG9wZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwbGFjZURyb3Bkb3duKCk7XG4gICAgICAgICAgICBvcGVuID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvcmlnaW4ub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAvLyBJZiBob3ZlciBvbiBvcmlnaW4gdGhlbiB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiBkcm9wZG93biBjb250ZW50LCB0aGVuIGNsb3NlXG4gICAgICAgICAgdmFyIHRvRWwgPSBlLnRvRWxlbWVudCB8fCBlLnJlbGF0ZWRUYXJnZXQ7IC8vIGFkZGVkIGJyb3dzZXIgY29tcGF0aWJpbGl0eSBmb3IgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICBpZighJCh0b0VsKS5jbG9zZXN0KCcuZHJvcGRvd24tY29udGVudCcpLmlzKGFjdGl2YXRlcykpIHtcbiAgICAgICAgICAgIGFjdGl2YXRlcy5zdG9wKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgaGlkZURyb3Bkb3duKCk7XG4gICAgICAgICAgICBvcGVuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhY3RpdmF0ZXMub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbihlKXsgLy8gTW91c2Ugb3V0XG4gICAgICAgICAgdmFyIHRvRWwgPSBlLnRvRWxlbWVudCB8fCBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgICAgaWYoISQodG9FbCkuY2xvc2VzdCgnLmRyb3Bkb3duLWJ1dHRvbicpLmlzKG9yaWdpbikpIHtcbiAgICAgICAgICAgIGFjdGl2YXRlcy5zdG9wKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgaGlkZURyb3Bkb3duKCk7XG4gICAgICAgICAgICBvcGVuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDbGlja1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2xpY2sgaGFuZGxlciB0byBzaG93IGRyb3Bkb3duXG4gICAgICAgIG9yaWdpbi51bmJpbmQoJ2NsaWNrLicgKyBvcmlnaW4uYXR0cignaWQnKSk7XG4gICAgICAgIG9yaWdpbi5iaW5kKCdjbGljay4nK29yaWdpbi5hdHRyKCdpZCcpLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICBpZiAoIWlzRm9jdXNlZCkge1xuICAgICAgICAgICAgaWYgKCBvcmlnaW5bMF0gPT0gZS5jdXJyZW50VGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICFvcmlnaW4uaGFzQ2xhc3MoJ2FjdGl2ZScpICYmXG4gICAgICAgICAgICAgICAgICgkKGUudGFyZ2V0KS5jbG9zZXN0KCcuZHJvcGRvd24tY29udGVudCcpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50cyBidXR0b24gY2xpY2sgZnJvbSBtb3Zpbmcgd2luZG93XG4gICAgICAgICAgICAgIGlmIChjdXJyX29wdGlvbnMuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwbGFjZURyb3Bkb3duKCdjbGljaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgb3JpZ2luIGlzIGNsaWNrZWQgYW5kIG1lbnUgaXMgb3BlbiwgY2xvc2UgbWVudVxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgICBoaWRlRHJvcGRvd24oKTtcbiAgICAgICAgICAgICAgJChkb2N1bWVudCkudW5iaW5kKCdjbGljay4nKyBhY3RpdmF0ZXMuYXR0cignaWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgfSAvLyBFbmQgZWxzZVxuXG4gICAgICAvLyBMaXN0ZW4gdG8gb3BlbiBhbmQgY2xvc2UgZXZlbnQgLSB1c2VmdWwgZm9yIHNlbGVjdCBjb21wb25lbnRcbiAgICAgIG9yaWdpbi5vbignb3BlbicsIGZ1bmN0aW9uKGUsIGV2ZW50VHlwZSkge1xuICAgICAgICBwbGFjZURyb3Bkb3duKGV2ZW50VHlwZSk7XG4gICAgICB9KTtcbiAgICAgIG9yaWdpbi5vbignY2xvc2UnLCBoaWRlRHJvcGRvd24pO1xuXG5cbiAgICB9KTtcbiAgfTsgLy8gRW5kIGRyb3Bkb3duIHBsdWdpblxuXG4gICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG4gICAgJCgnLmRyb3Bkb3duLWJ1dHRvbicpLmRyb3Bkb3duKCk7XG4gIH0pO1xufSggalF1ZXJ5ICkpO1xuOyhmdW5jdGlvbigkKSB7XG4gIHZhciBfc3RhY2sgPSAwLFxuICBfbGFzdElEID0gMCxcbiAgX2dlbmVyYXRlSUQgPSBmdW5jdGlvbigpIHtcbiAgICBfbGFzdElEKys7XG4gICAgcmV0dXJuICdtYXRlcmlhbGl6ZS1tb2RhbC1vdmVybGF5LScgKyBfbGFzdElEO1xuICB9O1xuXG4gIHZhciBtZXRob2RzID0ge1xuICAgIGluaXQgOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgaW5EdXJhdGlvbjogMzUwLFxuICAgICAgICBvdXREdXJhdGlvbjogMjUwLFxuICAgICAgICByZWFkeTogdW5kZWZpbmVkLFxuICAgICAgICBjb21wbGV0ZTogdW5kZWZpbmVkLFxuICAgICAgICBkaXNtaXNzaWJsZTogdHJ1ZSxcbiAgICAgICAgc3RhcnRpbmdUb3A6ICc0JScsXG4gICAgICAgIGVuZGluZ1RvcDogJzEwJSdcbiAgICAgIH07XG5cbiAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHRzXG4gICAgICBvcHRpb25zID0gJC5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgJG1vZGFsID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIG1vZGFsX2lkID0gJCh0aGlzKS5hdHRyKFwiaWRcIikgfHwgJyMnICsgJCh0aGlzKS5kYXRhKCd0YXJnZXQnKTtcblxuICAgICAgICB2YXIgY2xvc2VNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBvdmVybGF5SUQgPSAkbW9kYWwuZGF0YSgnb3ZlcmxheS1pZCcpO1xuICAgICAgICAgIHZhciAkb3ZlcmxheSA9ICQoJyMnICsgb3ZlcmxheUlEKTtcbiAgICAgICAgICAkbW9kYWwucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcblxuICAgICAgICAgIC8vIEVuYWJsZSBzY3JvbGxpbmdcbiAgICAgICAgICAkKCdib2R5JykuY3NzKHtcbiAgICAgICAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgICAgICAgIHdpZHRoOiAnJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgJG1vZGFsLmZpbmQoJy5tb2RhbC1jbG9zZScpLm9mZignY2xpY2suY2xvc2UnKTtcbiAgICAgICAgICAkKGRvY3VtZW50KS5vZmYoJ2tleXVwLm1vZGFsJyArIG92ZXJsYXlJRCk7XG5cbiAgICAgICAgICAkb3ZlcmxheS52ZWxvY2l0eSggeyBvcGFjaXR5OiAwfSwge2R1cmF0aW9uOiBvcHRpb25zLm91dER1cmF0aW9uLCBxdWV1ZTogZmFsc2UsIGVhc2U6IFwiZWFzZU91dFF1YXJ0XCJ9KTtcblxuXG4gICAgICAgICAgLy8gRGVmaW5lIEJvdHRvbSBTaGVldCBhbmltYXRpb25cbiAgICAgICAgICB2YXIgZXhpdFZlbG9jaXR5T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLm91dER1cmF0aW9uLFxuICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgZWFzZTogXCJlYXNlT3V0Q3ViaWNcIixcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtb2RhbCByZWFkeSBjYWxsYmFja1xuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAkKHRoaXMpLmNzcyh7ZGlzcGxheTpcIm5vbmVcIn0pO1xuXG4gICAgICAgICAgICAgIC8vIENhbGwgY29tcGxldGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZihvcHRpb25zLmNvbXBsZXRlKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb21wbGV0ZS5jYWxsKHRoaXMsICRtb2RhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJG92ZXJsYXkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIF9zdGFjay0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKCRtb2RhbC5oYXNDbGFzcygnYm90dG9tLXNoZWV0JykpIHtcbiAgICAgICAgICAgICRtb2RhbC52ZWxvY2l0eSh7Ym90dG9tOiBcIi0xMDAlXCIsIG9wYWNpdHk6IDB9LCBleGl0VmVsb2NpdHlPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkbW9kYWwudmVsb2NpdHkoXG4gICAgICAgICAgICAgIHsgdG9wOiBvcHRpb25zLnN0YXJ0aW5nVG9wLCBvcGFjaXR5OiAwLCBzY2FsZVg6IDAuN30sXG4gICAgICAgICAgICAgIGV4aXRWZWxvY2l0eU9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvcGVuTW9kYWwgPSBmdW5jdGlvbigkdHJpZ2dlcikge1xuICAgICAgICAgIHZhciAkYm9keSA9ICQoJ2JvZHknKTtcbiAgICAgICAgICB2YXIgb2xkV2lkdGggPSAkYm9keS5pbm5lcldpZHRoKCk7XG4gICAgICAgICAgJGJvZHkuY3NzKCdvdmVyZmxvdycsICdoaWRkZW4nKTtcbiAgICAgICAgICAkYm9keS53aWR0aChvbGRXaWR0aCk7XG5cbiAgICAgICAgICBpZiAoJG1vZGFsLmhhc0NsYXNzKCdvcGVuJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3ZlcmxheUlEID0gX2dlbmVyYXRlSUQoKTtcbiAgICAgICAgICB2YXIgJG92ZXJsYXkgPSAkKCc8ZGl2IGNsYXNzPVwibW9kYWwtb3ZlcmxheVwiPjwvZGl2PicpO1xuICAgICAgICAgIGxTdGFjayA9ICgrK19zdGFjayk7XG5cbiAgICAgICAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSBvZiB0aGUgb3ZlcmxheVxuICAgICAgICAgICRvdmVybGF5LmF0dHIoJ2lkJywgb3ZlcmxheUlEKS5jc3MoJ3otaW5kZXgnLCAxMDAwICsgbFN0YWNrICogMik7XG4gICAgICAgICAgJG1vZGFsLmRhdGEoJ292ZXJsYXktaWQnLCBvdmVybGF5SUQpLmNzcygnei1pbmRleCcsIDEwMDAgKyBsU3RhY2sgKiAyICsgMSk7XG4gICAgICAgICAgJG1vZGFsLmFkZENsYXNzKCdvcGVuJyk7XG5cbiAgICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQoJG92ZXJsYXkpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlzbWlzc2libGUpIHtcbiAgICAgICAgICAgICRvdmVybGF5LmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjbG9zZU1vZGFsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFJldHVybiBvbiBFU0NcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdrZXl1cC5tb2RhbCcgKyBvdmVybGF5SUQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHsgICAvLyBFU0Mga2V5XG4gICAgICAgICAgICAgICAgY2xvc2VNb2RhbCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkbW9kYWwuZmluZChcIi5tb2RhbC1jbG9zZVwiKS5vbignY2xpY2suY2xvc2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjbG9zZU1vZGFsKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAkb3ZlcmxheS5jc3MoeyBkaXNwbGF5IDogXCJibG9ja1wiLCBvcGFjaXR5IDogMCB9KTtcblxuICAgICAgICAgICRtb2RhbC5jc3Moe1xuICAgICAgICAgICAgZGlzcGxheSA6IFwiYmxvY2tcIixcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgICRvdmVybGF5LnZlbG9jaXR5KHtvcGFjaXR5OiBvcHRpb25zLm9wYWNpdHl9LCB7ZHVyYXRpb246IG9wdGlvbnMuaW5EdXJhdGlvbiwgcXVldWU6IGZhbHNlLCBlYXNlOiBcImVhc2VPdXRDdWJpY1wifSk7XG4gICAgICAgICAgJG1vZGFsLmRhdGEoJ2Fzc29jaWF0ZWQtb3ZlcmxheScsICRvdmVybGF5WzBdKTtcblxuICAgICAgICAgIC8vIERlZmluZSBCb3R0b20gU2hlZXQgYW5pbWF0aW9uXG4gICAgICAgICAgdmFyIGVudGVyVmVsb2NpdHlPcHRpb25zID0ge1xuICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuaW5EdXJhdGlvbixcbiAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgIGVhc2U6IFwiZWFzZU91dEN1YmljXCIsXG4gICAgICAgICAgICAvLyBIYW5kbGUgbW9kYWwgcmVhZHkgY2FsbGJhY2tcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZihvcHRpb25zLnJlYWR5KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZWFkeS5jYWxsKHRoaXMsICRtb2RhbCwgJHRyaWdnZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoJG1vZGFsLmhhc0NsYXNzKCdib3R0b20tc2hlZXQnKSkge1xuICAgICAgICAgICAgJG1vZGFsLnZlbG9jaXR5KHtib3R0b206IFwiMFwiLCBvcGFjaXR5OiAxfSwgZW50ZXJWZWxvY2l0eU9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQuVmVsb2NpdHkuaG9vaygkbW9kYWwsIFwic2NhbGVYXCIsIDAuNyk7XG4gICAgICAgICAgICAkbW9kYWwuY3NzKHsgdG9wOiBvcHRpb25zLnN0YXJ0aW5nVG9wIH0pO1xuICAgICAgICAgICAgJG1vZGFsLnZlbG9jaXR5KHt0b3A6IG9wdGlvbnMuZW5kaW5nVG9wLCBvcGFjaXR5OiAxLCBzY2FsZVg6ICcxJ30sIGVudGVyVmVsb2NpdHlPcHRpb25zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXNldCBoYW5kbGVyc1xuICAgICAgICAkKGRvY3VtZW50KS5vZmYoJ2NsaWNrLm1vZGFsVHJpZ2dlcicsICdhW2hyZWY9XCIjJyArIG1vZGFsX2lkICsgJ1wiXSwgW2RhdGEtdGFyZ2V0PVwiJyArIG1vZGFsX2lkICsgJ1wiXScpO1xuICAgICAgICAkKHRoaXMpLm9mZignb3Blbk1vZGFsJyk7XG4gICAgICAgICQodGhpcykub2ZmKCdjbG9zZU1vZGFsJyk7XG5cbiAgICAgICAgLy8gQ2xvc2UgSGFuZGxlcnNcbiAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrLm1vZGFsVHJpZ2dlcicsICdhW2hyZWY9XCIjJyArIG1vZGFsX2lkICsgJ1wiXSwgW2RhdGEtdGFyZ2V0PVwiJyArIG1vZGFsX2lkICsgJ1wiXScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXJ0aW5nVG9wID0gKCQodGhpcykub2Zmc2V0KCkudG9wIC0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpKSAvMS4xNTtcbiAgICAgICAgICBvcGVuTW9kYWwoJCh0aGlzKSk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTsgLy8gZG9uZSBzZXQgb24gY2xpY2tcblxuICAgICAgICAkKHRoaXMpLm9uKCdvcGVuTW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbW9kYWxfaWQgPSAkKHRoaXMpLmF0dHIoXCJocmVmXCIpIHx8ICcjJyArICQodGhpcykuZGF0YSgndGFyZ2V0Jyk7XG4gICAgICAgICAgb3Blbk1vZGFsKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQodGhpcykub24oJ2Nsb3NlTW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbG9zZU1vZGFsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIGRvbmUgcmV0dXJuXG4gICAgfSxcbiAgICBvcGVuIDogZnVuY3Rpb24oKSB7XG4gICAgICAkKHRoaXMpLnRyaWdnZXIoJ29wZW5Nb2RhbCcpO1xuICAgIH0sXG4gICAgY2xvc2UgOiBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykudHJpZ2dlcignY2xvc2VNb2RhbCcpO1xuICAgIH1cbiAgfTtcblxuICAkLmZuLm1vZGFsID0gZnVuY3Rpb24obWV0aG9kT3JPcHRpb25zKSB7XG4gICAgaWYgKCBtZXRob2RzW21ldGhvZE9yT3B0aW9uc10gKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1sgbWV0aG9kT3JPcHRpb25zIF0uYXBwbHkoIHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSk7XG4gICAgfSBlbHNlIGlmICggdHlwZW9mIG1ldGhvZE9yT3B0aW9ucyA9PT0gJ29iamVjdCcgfHwgISBtZXRob2RPck9wdGlvbnMgKSB7XG4gICAgICAvLyBEZWZhdWx0IHRvIFwiaW5pdFwiXG4gICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJC5lcnJvciggJ01ldGhvZCAnICsgIG1ldGhvZE9yT3B0aW9ucyArICcgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5Lm1vZGFsJyApO1xuICAgIH1cbiAgfTtcbn0pKGpRdWVyeSk7XG47KGZ1bmN0aW9uICgkKSB7XG5cbiAgJC5mbi5tYXRlcmlhbGJveCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdpbml0aWFsaXplZCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgJCh0aGlzKS5hZGRDbGFzcygnaW5pdGlhbGl6ZWQnKTtcblxuICAgICAgdmFyIG92ZXJsYXlBY3RpdmUgPSBmYWxzZTtcbiAgICAgIHZhciBkb25lQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpbkR1cmF0aW9uID0gMjc1O1xuICAgICAgdmFyIG91dER1cmF0aW9uID0gMjAwO1xuICAgICAgdmFyIG9yaWdpbiA9ICQodGhpcyk7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdtYXRlcmlhbC1wbGFjZWhvbGRlcicpO1xuICAgICAgdmFyIG9yaWdpbmFsV2lkdGggPSAwO1xuICAgICAgdmFyIG9yaWdpbmFsSGVpZ2h0ID0gMDtcbiAgICAgIHZhciBhbmNlc3RvcnNDaGFuZ2VkO1xuICAgICAgdmFyIGFuY2VzdG9yO1xuICAgICAgdmFyIG9yaWdpbklubGluZVN0eWxlcyA9IG9yaWdpbi5hdHRyKCdzdHlsZScpO1xuICAgICAgb3JpZ2luLndyYXAocGxhY2Vob2xkZXIpO1xuXG5cbiAgICAgIG9yaWdpbi5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBvcmlnaW4ucGFyZW50KCcubWF0ZXJpYWwtcGxhY2Vob2xkZXInKTtcbiAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHZhciBvcmlnaW5hbFdpZHRoID0gb3JpZ2luLndpZHRoKCk7XG4gICAgICAgIHZhciBvcmlnaW5hbEhlaWdodCA9IG9yaWdpbi5oZWlnaHQoKTtcblxuXG4gICAgICAgIC8vIElmIGFscmVhZHkgbW9kYWwsIHJldHVybiB0byBvcmlnaW5hbFxuICAgICAgICBpZiAoZG9uZUFuaW1hdGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm5Ub09yaWdpbmFsKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG92ZXJsYXlBY3RpdmUgJiYgZG9uZUFuaW1hdGluZz09PXRydWUpIHtcbiAgICAgICAgICByZXR1cm5Ub09yaWdpbmFsKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBTZXQgc3RhdGVzXG4gICAgICAgIGRvbmVBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgb3JpZ2luLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgb3ZlcmxheUFjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgLy8gU2V0IHBvc2l0aW9uaW5nIGZvciBwbGFjZWhvbGRlclxuICAgICAgICBwbGFjZWhvbGRlci5jc3Moe1xuICAgICAgICAgIHdpZHRoOiBwbGFjZWhvbGRlclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHBsYWNlaG9sZGVyWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaW5kIGFuY2VzdG9yIHdpdGggb3ZlcmZsb3c6IGhpZGRlbjsgYW5kIHJlbW92ZSBpdFxuICAgICAgICBhbmNlc3RvcnNDaGFuZ2VkID0gdW5kZWZpbmVkO1xuICAgICAgICBhbmNlc3RvciA9IHBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIHdoaWxlIChhbmNlc3RvciAhPT0gbnVsbCAmJiAhJChhbmNlc3RvcikuaXMoZG9jdW1lbnQpKSB7XG4gICAgICAgICAgdmFyIGN1cnIgPSAkKGFuY2VzdG9yKTtcbiAgICAgICAgICBpZiAoY3Vyci5jc3MoJ292ZXJmbG93JykgIT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgY3Vyci5jc3MoJ292ZXJmbG93JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnNDaGFuZ2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYW5jZXN0b3JzQ2hhbmdlZCA9IGN1cnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYW5jZXN0b3JzQ2hhbmdlZCA9IGFuY2VzdG9yc0NoYW5nZWQuYWRkKGN1cnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgY3NzIG9uIG9yaWdpblxuICAgICAgICBvcmlnaW4uY3NzKHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAnei1pbmRleCc6IDEwMDAsXG4gICAgICAgICAgJ3dpbGwtY2hhbmdlJzogJ2xlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCdcbiAgICAgICAgfSlcbiAgICAgICAgLmRhdGEoJ3dpZHRoJywgb3JpZ2luYWxXaWR0aClcbiAgICAgICAgLmRhdGEoJ2hlaWdodCcsIG9yaWdpbmFsSGVpZ2h0KTtcblxuICAgICAgICAvLyBBZGQgb3ZlcmxheVxuICAgICAgICB2YXIgb3ZlcmxheSA9ICQoJzxkaXYgaWQ9XCJtYXRlcmlhbGJveC1vdmVybGF5XCI+PC9kaXY+JylcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jbGljayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKGRvbmVBbmltYXRpbmcgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm5Ub09yaWdpbmFsKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHV0IGJlZm9yZSBpbiBvcmlnaW4gaW1hZ2UgdG8gcHJlc2VydmUgei1pbmRleCBsYXllcmluZy5cbiAgICAgICAgb3JpZ2luLmJlZm9yZShvdmVybGF5KTtcblxuICAgICAgICAvLyBTZXQgZGltZW5zaW9ucyBpZiBuZWVkZWRcbiAgICAgICAgdmFyIG92ZXJsYXlPZmZzZXQgPSBvdmVybGF5WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBvdmVybGF5LmNzcyh7XG4gICAgICAgICAgd2lkdGg6IHdpbmRvd1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogd2luZG93SGVpZ2h0LFxuICAgICAgICAgIGxlZnQ6IC0xICogb3ZlcmxheU9mZnNldC5sZWZ0LFxuICAgICAgICAgIHRvcDogLTEgKiBvdmVybGF5T2Zmc2V0LnRvcFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIEFuaW1hdGUgT3ZlcmxheVxuICAgICAgICBvdmVybGF5LnZlbG9jaXR5KHtvcGFjaXR5OiAxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtkdXJhdGlvbjogaW5EdXJhdGlvbiwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCd9ICk7XG5cbiAgICAgICAgLy8gQWRkIGFuZCBhbmltYXRlIGNhcHRpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmIChvcmlnaW4uZGF0YSgnY2FwdGlvbicpICE9PSBcIlwiKSB7XG4gICAgICAgICAgdmFyICRwaG90b19jYXB0aW9uID0gJCgnPGRpdiBjbGFzcz1cIm1hdGVyaWFsYm94LWNhcHRpb25cIj48L2Rpdj4nKTtcbiAgICAgICAgICAkcGhvdG9fY2FwdGlvbi50ZXh0KG9yaWdpbi5kYXRhKCdjYXB0aW9uJykpO1xuICAgICAgICAgICQoJ2JvZHknKS5hcHBlbmQoJHBob3RvX2NhcHRpb24pO1xuICAgICAgICAgICRwaG90b19jYXB0aW9uLmNzcyh7IFwiZGlzcGxheVwiOiBcImlubGluZVwiIH0pO1xuICAgICAgICAgICRwaG90b19jYXB0aW9uLnZlbG9jaXR5KHtvcGFjaXR5OiAxfSwge2R1cmF0aW9uOiBpbkR1cmF0aW9uLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ30pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzaXplIEltYWdlXG4gICAgICAgIHZhciByYXRpbyA9IDA7XG4gICAgICAgIHZhciB3aWR0aFBlcmNlbnQgPSBvcmlnaW5hbFdpZHRoIC8gd2luZG93V2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHRQZXJjZW50ID0gb3JpZ2luYWxIZWlnaHQgLyB3aW5kb3dIZWlnaHQ7XG4gICAgICAgIHZhciBuZXdXaWR0aCA9IDA7XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSAwO1xuXG4gICAgICAgIGlmICh3aWR0aFBlcmNlbnQgPiBoZWlnaHRQZXJjZW50KSB7XG4gICAgICAgICAgcmF0aW8gPSBvcmlnaW5hbEhlaWdodCAvIG9yaWdpbmFsV2lkdGg7XG4gICAgICAgICAgbmV3V2lkdGggPSB3aW5kb3dXaWR0aCAqIDAuOTtcbiAgICAgICAgICBuZXdIZWlnaHQgPSB3aW5kb3dXaWR0aCAqIDAuOSAqIHJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJhdGlvID0gb3JpZ2luYWxXaWR0aCAvIG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgICAgIG5ld1dpZHRoID0gKHdpbmRvd0hlaWdodCAqIDAuOSkgKiByYXRpbztcbiAgICAgICAgICBuZXdIZWlnaHQgPSB3aW5kb3dIZWlnaHQgKiAwLjk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmltYXRlIGltYWdlICsgc2V0IHotaW5kZXhcbiAgICAgICAgaWYob3JpZ2luLmhhc0NsYXNzKCdyZXNwb25zaXZlLWltZycpKSB7XG4gICAgICAgICAgb3JpZ2luLnZlbG9jaXR5KHsnbWF4LXdpZHRoJzogbmV3V2lkdGgsICd3aWR0aCc6IG9yaWdpbmFsV2lkdGh9LCB7ZHVyYXRpb246IDAsIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBvcmlnaW4uY3NzKHtsZWZ0OiAwLCB0b3A6IDB9KVxuICAgICAgICAgICAgICAudmVsb2NpdHkoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQsXG4gICAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGgsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgKyB3aW5kb3dXaWR0aC8yIC0gb3JpZ2luLnBhcmVudCgnLm1hdGVyaWFsLXBsYWNlaG9sZGVyJykub2Zmc2V0KCkubGVmdCAtIG5ld1dpZHRoLzIsXG4gICAgICAgICAgICAgICAgICB0b3A6ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpICsgd2luZG93SGVpZ2h0LzIgLSBvcmlnaW4ucGFyZW50KCcubWF0ZXJpYWwtcGxhY2Vob2xkZXInKS5vZmZzZXQoKS50b3AgLSBuZXdIZWlnaHQvIDJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBpbkR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7ZG9uZUFuaW1hdGluZyA9IHRydWU7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gLy8gRW5kIENvbXBsZXRlXG4gICAgICAgICAgfSk7IC8vIEVuZCBWZWxvY2l0eVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9yaWdpbi5jc3MoJ2xlZnQnLCAwKVxuICAgICAgICAgIC5jc3MoJ3RvcCcsIDApXG4gICAgICAgICAgLnZlbG9jaXR5KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgICAgICAgICAgICBsZWZ0OiAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgKyB3aW5kb3dXaWR0aC8yIC0gb3JpZ2luLnBhcmVudCgnLm1hdGVyaWFsLXBsYWNlaG9sZGVyJykub2Zmc2V0KCkubGVmdCAtIG5ld1dpZHRoLzIsXG4gICAgICAgICAgICAgIHRvcDogJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgKyB3aW5kb3dIZWlnaHQvMiAtIG9yaWdpbi5wYXJlbnQoJy5tYXRlcmlhbC1wbGFjZWhvbGRlcicpLm9mZnNldCgpLnRvcCAtIG5ld0hlaWdodC8gMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IGluRHVyYXRpb24sXG4gICAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKXtkb25lQW5pbWF0aW5nID0gdHJ1ZTt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICApOyAvLyBFbmQgVmVsb2NpdHlcbiAgICAgICAgfVxuXG4gICAgICB9KTsgLy8gRW5kIG9yaWdpbiBvbiBjbGlja1xuXG5cbiAgICAgIC8vIFJldHVybiBvbiBzY3JvbGxcbiAgICAgICQod2luZG93KS5zY3JvbGwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvdmVybGF5QWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuVG9PcmlnaW5hbCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gUmV0dXJuIG9uIEVTQ1xuICAgICAgJChkb2N1bWVudCkua2V5dXAoZnVuY3Rpb24oZSkge1xuXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3ICYmIGRvbmVBbmltYXRpbmcgPT09IHRydWUpIHsgICAvLyBFU0Mga2V5XG4gICAgICAgICAgaWYgKG92ZXJsYXlBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVyblRvT3JpZ2luYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG5cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgbW9kYWxlZCBpbWFnZSB0byB0aGUgb3JpZ2luYWwgc3BvdFxuICAgICAgZnVuY3Rpb24gcmV0dXJuVG9PcmlnaW5hbCgpIHtcblxuICAgICAgICBkb25lQW5pbWF0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gb3JpZ2luLnBhcmVudCgnLm1hdGVyaWFsLXBsYWNlaG9sZGVyJyk7XG4gICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB2YXIgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICB2YXIgb3JpZ2luYWxXaWR0aCA9IG9yaWdpbi5kYXRhKCd3aWR0aCcpO1xuICAgICAgICB2YXIgb3JpZ2luYWxIZWlnaHQgPSBvcmlnaW4uZGF0YSgnaGVpZ2h0Jyk7XG5cbiAgICAgICAgb3JpZ2luLnZlbG9jaXR5KFwic3RvcFwiLCB0cnVlKTtcbiAgICAgICAgJCgnI21hdGVyaWFsYm94LW92ZXJsYXknKS52ZWxvY2l0eShcInN0b3BcIiwgdHJ1ZSk7XG4gICAgICAgICQoJy5tYXRlcmlhbGJveC1jYXB0aW9uJykudmVsb2NpdHkoXCJzdG9wXCIsIHRydWUpO1xuXG5cbiAgICAgICAgJCgnI21hdGVyaWFsYm94LW92ZXJsYXknKS52ZWxvY2l0eSh7b3BhY2l0eTogMH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogb3V0RHVyYXRpb24sIC8vIERlbGF5IHByZXZlbnRzIGFuaW1hdGlvbiBvdmVybGFwcGluZ1xuICAgICAgICAgIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gUmVtb3ZlIE92ZXJsYXlcbiAgICAgICAgICAgIG92ZXJsYXlBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZXNpemUgSW1hZ2VcbiAgICAgICAgb3JpZ2luLnZlbG9jaXR5KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdpZHRoOiBvcmlnaW5hbFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBvcmlnaW5hbEhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBvdXREdXJhdGlvbixcbiAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBwbGFjZWhvbGRlci5jc3Moe1xuICAgICAgICAgICAgICAgIGhlaWdodDogJycsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnJyxcbiAgICAgICAgICAgICAgICB0b3A6ICcnLFxuICAgICAgICAgICAgICAgIGxlZnQ6ICcnXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIG9yaWdpbi5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgICBvcmlnaW4uYXR0cignc3R5bGUnLCBvcmlnaW5JbmxpbmVTdHlsZXMpO1xuXG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBjbGFzc1xuICAgICAgICAgICAgICBvcmlnaW4ucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICBkb25lQW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAvLyBSZW1vdmUgb3ZlcmZsb3cgb3ZlcnJpZGVzIG9uIGFuY2VzdG9yc1xuICAgICAgICAgICAgICBpZiAoYW5jZXN0b3JzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGFuY2VzdG9yc0NoYW5nZWQuY3NzKCdvdmVyZmxvdycsICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBSZW1vdmUgQ2FwdGlvbiArIHJlc2V0IGNzcyBzZXR0aW5ncyBvbiBpbWFnZVxuICAgICAgICAkKCcubWF0ZXJpYWxib3gtY2FwdGlvbicpLnZlbG9jaXR5KHtvcGFjaXR5OiAwfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiBvdXREdXJhdGlvbiwgLy8gRGVsYXkgcHJldmVudHMgYW5pbWF0aW9uIG92ZXJsYXBwaW5nXG4gICAgICAgICAgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCcsXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkKHRoaXMpLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuICAgICQoJy5tYXRlcmlhbGJveGVkJykubWF0ZXJpYWxib3goKTtcbiAgfSk7XG5cbn0oIGpRdWVyeSApKTtcbjsoZnVuY3Rpb24gKCQpIHtcblxuICAkLmZuLnBhcmFsbGF4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB3aW5kb3dfd2lkdGggPSAkKHdpbmRvdykud2lkdGgoKTtcbiAgICAvLyBQYXJhbGxheCBTY3JpcHRzXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgJHRoaXMuYWRkQ2xhc3MoJ3BhcmFsbGF4Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBhcmFsbGF4KGluaXRpYWwpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lcl9oZWlnaHQ7XG4gICAgICAgIGlmICh3aW5kb3dfd2lkdGggPCA2MDEpIHtcbiAgICAgICAgICBjb250YWluZXJfaGVpZ2h0ID0gKCR0aGlzLmhlaWdodCgpID4gMCkgPyAkdGhpcy5oZWlnaHQoKSA6ICR0aGlzLmNoaWxkcmVuKFwiaW1nXCIpLmhlaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lcl9oZWlnaHQgPSAoJHRoaXMuaGVpZ2h0KCkgPiAwKSA/ICR0aGlzLmhlaWdodCgpIDogNTAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciAkaW1nID0gJHRoaXMuY2hpbGRyZW4oXCJpbWdcIikuZmlyc3QoKTtcbiAgICAgICAgdmFyIGltZ19oZWlnaHQgPSAkaW1nLmhlaWdodCgpO1xuICAgICAgICB2YXIgcGFyYWxsYXhfZGlzdCA9IGltZ19oZWlnaHQgLSBjb250YWluZXJfaGVpZ2h0O1xuICAgICAgICB2YXIgYm90dG9tID0gJHRoaXMub2Zmc2V0KCkudG9wICsgY29udGFpbmVyX2hlaWdodDtcbiAgICAgICAgdmFyIHRvcCA9ICR0aGlzLm9mZnNldCgpLnRvcDtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9ICQod2luZG93KS5zY3JvbGxUb3AoKTtcbiAgICAgICAgdmFyIHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgdmFyIHdpbmRvd0JvdHRvbSA9IHNjcm9sbFRvcCArIHdpbmRvd0hlaWdodDtcbiAgICAgICAgdmFyIHBlcmNlbnRTY3JvbGxlZCA9ICh3aW5kb3dCb3R0b20gLSB0b3ApIC8gKGNvbnRhaW5lcl9oZWlnaHQgKyB3aW5kb3dIZWlnaHQpO1xuICAgICAgICB2YXIgcGFyYWxsYXggPSBNYXRoLnJvdW5kKChwYXJhbGxheF9kaXN0ICogcGVyY2VudFNjcm9sbGVkKSk7XG5cbiAgICAgICAgaWYgKGluaXRpYWwpIHtcbiAgICAgICAgICAkaW1nLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoYm90dG9tID4gc2Nyb2xsVG9wKSAmJiAodG9wIDwgKHNjcm9sbFRvcCArIHdpbmRvd0hlaWdodCkpKSB7XG4gICAgICAgICAgJGltZy5jc3MoJ3RyYW5zZm9ybScsIFwidHJhbnNsYXRlM0QoLTUwJSxcIiArIHBhcmFsbGF4ICsgXCJweCwgMClcIik7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBXYWl0IGZvciBpbWFnZSBsb2FkXG4gICAgICAkdGhpcy5jaGlsZHJlbihcImltZ1wiKS5vbmUoXCJsb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB1cGRhdGVQYXJhbGxheCh0cnVlKTtcbiAgICAgIH0pLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRlKSAkKHRoaXMpLnRyaWdnZXIoXCJsb2FkXCIpO1xuICAgICAgfSk7XG5cbiAgICAgICQod2luZG93KS5zY3JvbGwoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvd193aWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xuICAgICAgICB1cGRhdGVQYXJhbGxheChmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgJCh3aW5kb3cpLnJlc2l6ZShmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93X3dpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XG4gICAgICAgIHVwZGF0ZVBhcmFsbGF4KGZhbHNlKTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgfTtcbn0oIGpRdWVyeSApKTtcbjsoZnVuY3Rpb24gKCQpIHtcblxuICB2YXIgbWV0aG9kcyA9IHtcbiAgICBpbml0IDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBvblNob3c6IG51bGwsXG4gICAgICAgIHN3aXBlYWJsZTogZmFsc2UsXG4gICAgICAgIHJlc3BvbnNpdmVUaHJlc2hvbGQ6IEluZmluaXR5LCAvLyBicmVha3BvaW50IGZvciBzd2lwZWFibGVcbiAgICAgIH07XG4gICAgICBvcHRpb25zID0gJC5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IE1hdGVyaWFsaXplLm9iamVjdFNlbGVjdG9yU3RyaW5nKCQodGhpcykpO1xuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblxuICAgICAgdmFyIHVuaXF1ZU5hbWVzcGFjZSA9IG5hbWVzcGFjZStpO1xuXG4gICAgICAvLyBGb3IgZWFjaCBzZXQgb2YgdGFicywgd2Ugd2FudCB0byBrZWVwIHRyYWNrIG9mXG4gICAgICAvLyB3aGljaCB0YWIgaXMgYWN0aXZlIGFuZCBpdHMgYXNzb2NpYXRlZCBjb250ZW50XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgIHdpbmRvd193aWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xuXG4gICAgICB2YXIgJGFjdGl2ZSwgJGNvbnRlbnQsICRsaW5rcyA9ICR0aGlzLmZpbmQoJ2xpLnRhYiBhJyksXG4gICAgICAgICAgJHRhYnNfd2lkdGggPSAkdGhpcy53aWR0aCgpLFxuICAgICAgICAgICR0YWJzX2NvbnRlbnQgPSAkKCksXG4gICAgICAgICAgJHRhYnNfd3JhcHBlcixcbiAgICAgICAgICAkdGFiX3dpZHRoID0gTWF0aC5tYXgoJHRhYnNfd2lkdGgsICR0aGlzWzBdLnNjcm9sbFdpZHRoKSAvICRsaW5rcy5sZW5ndGgsXG4gICAgICAgICAgJGluZGljYXRvcixcbiAgICAgICAgICBpbmRleCA9IHByZXZfaW5kZXggPSAwLFxuICAgICAgICAgIGNsaWNrZWQgPSBmYWxzZSxcbiAgICAgICAgICBjbGlja2VkVGltZW91dCxcbiAgICAgICAgICB0cmFuc2l0aW9uID0gMzAwO1xuXG5cbiAgICAgIC8vIEZpbmRzIHJpZ2h0IGF0dHJpYnV0ZSBmb3IgaW5kaWNhdG9yIGJhc2VkIG9uIGFjdGl2ZSB0YWIuXG4gICAgICAvLyBlbDogalF1ZXJ5IE9iamVjdFxuICAgICAgdmFyIGNhbGNSaWdodFBvcyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoJHRhYnNfd2lkdGggLSBlbC5wb3NpdGlvbigpLmxlZnQgLSBlbC5vdXRlcldpZHRoKCkgLSAkdGhpcy5zY3JvbGxMZWZ0KCkpO1xuICAgICAgfTtcblxuICAgICAgLy8gRmluZHMgbGVmdCBhdHRyaWJ1dGUgZm9yIGluZGljYXRvciBiYXNlZCBvbiBhY3RpdmUgdGFiLlxuICAgICAgLy8gZWw6IGpRdWVyeSBPYmplY3RcbiAgICAgIHZhciBjYWxjTGVmdFBvcyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGVsLnBvc2l0aW9uKCkubGVmdCArICR0aGlzLnNjcm9sbExlZnQoKSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBBbmltYXRlcyBJbmRpY2F0b3IgdG8gYWN0aXZlIHRhYi5cbiAgICAgIC8vIHByZXZfaW5kZXg6IE51bWJlclxuICAgICAgdmFyIGFuaW1hdGVJbmRpY2F0b3IgPSBmdW5jdGlvbihwcmV2X2luZGV4KSB7XG4gICAgICAgIGlmICgoaW5kZXggLSBwcmV2X2luZGV4KSA+PSAwKSB7XG4gICAgICAgICAgJGluZGljYXRvci52ZWxvY2l0eSh7XCJyaWdodFwiOiBjYWxjUmlnaHRQb3MoJGFjdGl2ZSkgfSwgeyBkdXJhdGlvbjogdHJhbnNpdGlvbiwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCd9KTtcbiAgICAgICAgICAkaW5kaWNhdG9yLnZlbG9jaXR5KHtcImxlZnRcIjogY2FsY0xlZnRQb3MoJGFjdGl2ZSkgfSwge2R1cmF0aW9uOiB0cmFuc2l0aW9uLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJywgZGVsYXk6IDkwfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkaW5kaWNhdG9yLnZlbG9jaXR5KHtcImxlZnRcIjogY2FsY0xlZnRQb3MoJGFjdGl2ZSkgfSwgeyBkdXJhdGlvbjogdHJhbnNpdGlvbiwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCd9KTtcbiAgICAgICAgICAkaW5kaWNhdG9yLnZlbG9jaXR5KHtcInJpZ2h0XCI6IGNhbGNSaWdodFBvcygkYWN0aXZlKSB9LCB7ZHVyYXRpb246IHRyYW5zaXRpb24sIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLCBkZWxheTogOTB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gQ2hhbmdlIHN3aXBlYWJsZSBhY2NvcmRpbmcgdG8gcmVzcG9uc2l2ZSB0aHJlc2hvbGRcbiAgICAgIGlmIChvcHRpb25zLnN3aXBlYWJsZSkge1xuICAgICAgICBpZiAod2luZG93X3dpZHRoID4gb3B0aW9ucy5yZXNwb25zaXZlVGhyZXNob2xkKSB7XG4gICAgICAgICAgb3B0aW9ucy5zd2lwZWFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8vIElmIHRoZSBsb2NhdGlvbi5oYXNoIG1hdGNoZXMgb25lIG9mIHRoZSBsaW5rcywgdXNlIHRoYXQgYXMgdGhlIGFjdGl2ZSB0YWIuXG4gICAgICAkYWN0aXZlID0gJCgkbGlua3MuZmlsdGVyKCdbaHJlZj1cIicrbG9jYXRpb24uaGFzaCsnXCJdJykpO1xuXG4gICAgICAvLyBJZiBubyBtYXRjaCBpcyBmb3VuZCwgdXNlIHRoZSBmaXJzdCBsaW5rIG9yIGFueSB3aXRoIGNsYXNzICdhY3RpdmUnIGFzIHRoZSBpbml0aWFsIGFjdGl2ZSB0YWIuXG4gICAgICBpZiAoJGFjdGl2ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgJGFjdGl2ZSA9ICQodGhpcykuZmluZCgnbGkudGFiIGEuYWN0aXZlJykuZmlyc3QoKTtcbiAgICAgIH1cbiAgICAgIGlmICgkYWN0aXZlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAkYWN0aXZlID0gJCh0aGlzKS5maW5kKCdsaS50YWIgYScpLmZpcnN0KCk7XG4gICAgICB9XG5cbiAgICAgICRhY3RpdmUuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgaW5kZXggPSAkbGlua3MuaW5kZXgoJGFjdGl2ZSk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCRhY3RpdmVbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAkY29udGVudCA9ICQoJGFjdGl2ZVswXS5oYXNoKTtcbiAgICAgICAgJGNvbnRlbnQuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBlbmQgaW5kaWNhdG9yIHRoZW4gc2V0IGluZGljYXRvciB3aWR0aCB0byB0YWIgd2lkdGhcbiAgICAgIGlmICghJHRoaXMuZmluZCgnLmluZGljYXRvcicpLmxlbmd0aCkge1xuICAgICAgICAkdGhpcy5hcHBlbmQoJzxkaXYgY2xhc3M9XCJpbmRpY2F0b3JcIj48L2Rpdj4nKTtcbiAgICAgIH1cbiAgICAgICRpbmRpY2F0b3IgPSAkdGhpcy5maW5kKCcuaW5kaWNhdG9yJyk7XG5cbiAgICAgIC8vIHdlIG1ha2Ugc3VyZSB0aGF0IHRoZSBpbmRpY2F0b3IgaXMgYXQgdGhlIGVuZCBvZiB0aGUgdGFic1xuICAgICAgJHRoaXMuYXBwZW5kKCRpbmRpY2F0b3IpO1xuXG4gICAgICBpZiAoJHRoaXMuaXMoXCI6dmlzaWJsZVwiKSkge1xuICAgICAgICAvLyAkaW5kaWNhdG9yLmNzcyh7XCJyaWdodFwiOiAkdGFic193aWR0aCAtICgoaW5kZXggKyAxKSAqICR0YWJfd2lkdGgpfSk7XG4gICAgICAgIC8vICRpbmRpY2F0b3IuY3NzKHtcImxlZnRcIjogaW5kZXggKiAkdGFiX3dpZHRofSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJGluZGljYXRvci5jc3Moe1wicmlnaHRcIjogY2FsY1JpZ2h0UG9zKCRhY3RpdmUpIH0pO1xuICAgICAgICAgICRpbmRpY2F0b3IuY3NzKHtcImxlZnRcIjogY2FsY0xlZnRQb3MoJGFjdGl2ZSkgfSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgICAgJCh3aW5kb3cpLm9mZigncmVzaXplLnRhYnMtJyt1bmlxdWVOYW1lc3BhY2UpLm9uKCdyZXNpemUudGFicy0nK3VuaXF1ZU5hbWVzcGFjZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAkdGFic193aWR0aCA9ICR0aGlzLndpZHRoKCk7XG4gICAgICAgICR0YWJfd2lkdGggPSBNYXRoLm1heCgkdGFic193aWR0aCwgJHRoaXNbMF0uc2Nyb2xsV2lkdGgpIC8gJGxpbmtzLmxlbmd0aDtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHRhYl93aWR0aCAhPT0gMCAmJiAkdGFic193aWR0aCAhPT0gMCkge1xuICAgICAgICAgICRpbmRpY2F0b3IuY3NzKHtcInJpZ2h0XCI6IGNhbGNSaWdodFBvcygkYWN0aXZlKSB9KTtcbiAgICAgICAgICAkaW5kaWNhdG9yLmNzcyh7XCJsZWZ0XCI6IGNhbGNMZWZ0UG9zKCRhY3RpdmUpIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBUYWJzIENvbnRlbnQuXG4gICAgICBpZiAob3B0aW9ucy5zd2lwZWFibGUpIHtcbiAgICAgICAgLy8gVE9ETzogRHVwbGljYXRlIGNhbGxzIHdpdGggc3dpcGVhYmxlPyBoYW5kbGUgbXVsdGlwbGUgZGl2IHdyYXBwaW5nLlxuICAgICAgICAkbGlua3MuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyICRjdXJyX2NvbnRlbnQgPSAkKE1hdGVyaWFsaXplLmVzY2FwZUhhc2godGhpcy5oYXNoKSk7XG4gICAgICAgICAgJGN1cnJfY29udGVudC5hZGRDbGFzcygnY2Fyb3VzZWwtaXRlbScpO1xuICAgICAgICAgICR0YWJzX2NvbnRlbnQgPSAkdGFic19jb250ZW50LmFkZCgkY3Vycl9jb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgICR0YWJzX3dyYXBwZXIgPSAkdGFic19jb250ZW50LndyYXBBbGwoJzxkaXYgY2xhc3M9XCJ0YWJzLWNvbnRlbnQgY2Fyb3VzZWxcIj48L2Rpdj4nKTtcbiAgICAgICAgJHRhYnNfY29udGVudC5jc3MoJ2Rpc3BsYXknLCAnJyk7XG4gICAgICAgICQoJy50YWJzLWNvbnRlbnQuY2Fyb3VzZWwnKS5jYXJvdXNlbCh7XG4gICAgICAgICAgZnVsbFdpZHRoOiB0cnVlLFxuICAgICAgICAgIG5vV3JhcDogdHJ1ZSxcbiAgICAgICAgICBvbkN5Y2xlVG86IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghY2xpY2tlZCkge1xuICAgICAgICAgICAgICB2YXIgcHJldl9pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICBpbmRleCA9ICR0YWJzX3dyYXBwZXIuaW5kZXgoaXRlbSk7XG4gICAgICAgICAgICAgICRhY3RpdmUgPSAkbGlua3MuZXEoaW5kZXgpO1xuICAgICAgICAgICAgICBhbmltYXRlSW5kaWNhdG9yKHByZXZfaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGlkZSB0aGUgcmVtYWluaW5nIGNvbnRlbnRcbiAgICAgICAgJGxpbmtzLm5vdCgkYWN0aXZlKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkKE1hdGVyaWFsaXplLmVzY2FwZUhhc2godGhpcy5oYXNoKSkuaGlkZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuXG4gICAgICAvLyBCaW5kIHRoZSBjbGljayBldmVudCBoYW5kbGVyXG4gICAgICAkdGhpcy5vZmYoJ2NsaWNrLnRhYnMnKS5vbignY2xpY2sudGFicycsICdhJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoJCh0aGlzKS5wYXJlbnQoKS5oYXNDbGFzcygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3QgYXMgcmVndWxhciBsaW5rIGlmIHRhcmdldCBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkLlxuICAgICAgICBpZiAoISEkKHRoaXMpLmF0dHIoXCJ0YXJnZXRcIikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGlja2VkID0gdHJ1ZTtcbiAgICAgICAgJHRhYnNfd2lkdGggPSAkdGhpcy53aWR0aCgpO1xuICAgICAgICAkdGFiX3dpZHRoID0gTWF0aC5tYXgoJHRhYnNfd2lkdGgsICR0aGlzWzBdLnNjcm9sbFdpZHRoKSAvICRsaW5rcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgb2xkIHRhYiBpbmFjdGl2ZS5cbiAgICAgICAgJGFjdGl2ZS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIHZhciAkb2xkQ29udGVudCA9ICRjb250ZW50XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YXJpYWJsZXMgd2l0aCB0aGUgbmV3IGxpbmsgYW5kIGNvbnRlbnRcbiAgICAgICAgJGFjdGl2ZSA9ICQodGhpcyk7XG4gICAgICAgICRjb250ZW50ID0gJChNYXRlcmlhbGl6ZS5lc2NhcGVIYXNoKHRoaXMuaGFzaCkpO1xuICAgICAgICAkbGlua3MgPSAkdGhpcy5maW5kKCdsaS50YWIgYScpO1xuICAgICAgICB2YXIgYWN0aXZlUmVjdCA9ICRhY3RpdmUucG9zaXRpb24oKTtcblxuICAgICAgICAvLyBNYWtlIHRoZSB0YWIgYWN0aXZlLlxuICAgICAgICAkYWN0aXZlLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgcHJldl9pbmRleCA9IGluZGV4O1xuICAgICAgICBpbmRleCA9ICRsaW5rcy5pbmRleCgkKHRoaXMpKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGFuZ2UgdXJsIHRvIGN1cnJlbnQgdGFiXG4gICAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJGFjdGl2ZS5hdHRyKCdocmVmJyk7XG5cbiAgICAgICAgLy8gU3dhcCBjb250ZW50XG4gICAgICAgIGlmIChvcHRpb25zLnN3aXBlYWJsZSkge1xuICAgICAgICAgIGlmICgkdGFic19jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgJHRhYnNfY29udGVudC5jYXJvdXNlbCgnc2V0JywgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoJGNvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJGNvbnRlbnQuc2hvdygpO1xuICAgICAgICAgICAgJGNvbnRlbnQuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihvcHRpb25zLm9uU2hvdykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBvcHRpb25zLm9uU2hvdy5jYWxsKHRoaXMsICRjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJG9sZENvbnRlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAhJG9sZENvbnRlbnQuaXMoJGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAkb2xkQ29udGVudC5oaWRlKCk7XG4gICAgICAgICAgICAkb2xkQ29udGVudC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgY2xpY2tlZCBzdGF0ZVxuICAgICAgICBjbGlja2VkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgY2xpY2tlZCA9IGZhbHNlOyB9LCB0cmFuc2l0aW9uKTtcblxuICAgICAgICAvLyBVcGRhdGUgaW5kaWNhdG9yXG4gICAgICAgIGFuaW1hdGVJbmRpY2F0b3IocHJldl9pbmRleCk7XG5cbiAgICAgICAgLy8gUHJldmVudCB0aGUgYW5jaG9yJ3MgZGVmYXVsdCBjbGljayBhY3Rpb25cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB9LFxuICAgIHNlbGVjdF90YWIgOiBmdW5jdGlvbiggaWQgKSB7XG4gICAgICB0aGlzLmZpbmQoJ2FbaHJlZj1cIiMnICsgaWQgKyAnXCJdJykudHJpZ2dlcignY2xpY2snKTtcbiAgICB9XG4gIH07XG5cbiAgJC5mbi50YWJzID0gZnVuY3Rpb24obWV0aG9kT3JPcHRpb25zKSB7XG4gICAgaWYgKCBtZXRob2RzW21ldGhvZE9yT3B0aW9uc10gKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1sgbWV0aG9kT3JPcHRpb25zIF0uYXBwbHkoIHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSk7XG4gICAgfSBlbHNlIGlmICggdHlwZW9mIG1ldGhvZE9yT3B0aW9ucyA9PT0gJ29iamVjdCcgfHwgISBtZXRob2RPck9wdGlvbnMgKSB7XG4gICAgICAvLyBEZWZhdWx0IHRvIFwiaW5pdFwiXG4gICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJC5lcnJvciggJ01ldGhvZCAnICsgIG1ldGhvZE9yT3B0aW9ucyArICcgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LnRhYnMnICk7XG4gICAgfVxuICB9O1xuXG4gICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG4gICAgJCgndWwudGFicycpLnRhYnMoKTtcbiAgfSk7XG59KCBqUXVlcnkgKSk7XG47KGZ1bmN0aW9uICgkKSB7XG4gICAgJC5mbi50b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciB0aW1lb3V0ID0gbnVsbCxcbiAgICAgIG1hcmdpbiA9IDU7XG5cbiAgICAgIC8vIERlZmF1bHRzXG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIGRlbGF5OiAzNTAsXG4gICAgICAgIHRvb2x0aXA6ICcnLFxuICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgICAgIGh0bWw6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICAvLyBSZW1vdmUgdG9vbHRpcCBmcm9tIHRoZSBhY3RpdmF0b3JcbiAgICAgIGlmIChvcHRpb25zID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAkKCcjJyArICQodGhpcykuYXR0cignZGF0YS10b29sdGlwLWlkJykpLnJlbW92ZSgpO1xuICAgICAgICAgICQodGhpcykub2ZmKCdtb3VzZWVudGVyLnRvb2x0aXAgbW91c2VsZWF2ZS50b29sdGlwJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0b29sdGlwSWQgPSBNYXRlcmlhbGl6ZS5ndWlkKCk7XG4gICAgICAgIHZhciBvcmlnaW4gPSAkKHRoaXMpO1xuXG4gICAgICAgIC8vIERlc3Ryb3kgb2xkIHRvb2x0aXBcbiAgICAgICAgaWYgKG9yaWdpbi5hdHRyKCdkYXRhLXRvb2x0aXAtaWQnKSkge1xuICAgICAgICAgICQoJyMnICsgb3JpZ2luLmF0dHIoJ2RhdGEtdG9vbHRpcC1pZCcpKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9yaWdpbi5hdHRyKCdkYXRhLXRvb2x0aXAtaWQnLCB0b29sdGlwSWQpO1xuXG4gICAgICAgIC8vIEdldCBhdHRyaWJ1dGVzLlxuICAgICAgICB2YXIgYWxsb3dIdG1sLFxuICAgICAgICAgICAgdG9vbHRpcERlbGF5LFxuICAgICAgICAgICAgdG9vbHRpcFBvc2l0aW9uLFxuICAgICAgICAgICAgdG9vbHRpcFRleHQsXG4gICAgICAgICAgICB0b29sdGlwRWwsXG4gICAgICAgICAgICBiYWNrZHJvcDtcbiAgICAgICAgdmFyIHNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBhbGxvd0h0bWwgPSBvcmlnaW4uYXR0cignZGF0YS1odG1sJykgPyBvcmlnaW4uYXR0cignZGF0YS1odG1sJykgPT09ICd0cnVlJyA6IG9wdGlvbnMuaHRtbDtcbiAgICAgICAgICB0b29sdGlwRGVsYXkgPSBvcmlnaW4uYXR0cignZGF0YS1kZWxheScpO1xuICAgICAgICAgIHRvb2x0aXBEZWxheSA9ICh0b29sdGlwRGVsYXkgPT09IHVuZGVmaW5lZCB8fCB0b29sdGlwRGVsYXkgPT09ICcnKSA/XG4gICAgICAgICAgICAgIG9wdGlvbnMuZGVsYXkgOiB0b29sdGlwRGVsYXk7XG4gICAgICAgICAgdG9vbHRpcFBvc2l0aW9uID0gb3JpZ2luLmF0dHIoJ2RhdGEtcG9zaXRpb24nKTtcbiAgICAgICAgICB0b29sdGlwUG9zaXRpb24gPSAodG9vbHRpcFBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgdG9vbHRpcFBvc2l0aW9uID09PSAnJykgP1xuICAgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uIDogdG9vbHRpcFBvc2l0aW9uO1xuICAgICAgICAgIHRvb2x0aXBUZXh0ID0gb3JpZ2luLmF0dHIoJ2RhdGEtdG9vbHRpcCcpO1xuICAgICAgICAgIHRvb2x0aXBUZXh0ID0gKHRvb2x0aXBUZXh0ID09PSB1bmRlZmluZWQgfHwgdG9vbHRpcFRleHQgPT09ICcnKSA/XG4gICAgICAgICAgICAgIG9wdGlvbnMudG9vbHRpcCA6IHRvb2x0aXBUZXh0O1xuICAgICAgICB9O1xuICAgICAgICBzZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgdmFyIHJlbmRlclRvb2x0aXBFbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB0b29sdGlwID0gJCgnPGRpdiBjbGFzcz1cIm1hdGVyaWFsLXRvb2x0aXBcIj48L2Rpdj4nKTtcblxuICAgICAgICAgIC8vIENyZWF0ZSBUZXh0IHNwYW5cbiAgICAgICAgICBpZiAoYWxsb3dIdG1sKSB7XG4gICAgICAgICAgICB0b29sdGlwVGV4dCA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5odG1sKHRvb2x0aXBUZXh0KTtcbiAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICB0b29sdGlwVGV4dCA9ICQoJzxzcGFuPjwvc3Bhbj4nKS50ZXh0KHRvb2x0aXBUZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgdG9vbHRpcFxuICAgICAgICAgIHRvb2x0aXAuYXBwZW5kKHRvb2x0aXBUZXh0KVxuICAgICAgICAgICAgLmFwcGVuZFRvKCQoJ2JvZHknKSlcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIHRvb2x0aXBJZCk7XG5cbiAgICAgICAgICAvLyBDcmVhdGUgYmFja2Ryb3BcbiAgICAgICAgICBiYWNrZHJvcCA9ICQoJzxkaXYgY2xhc3M9XCJiYWNrZHJvcFwiPjwvZGl2PicpO1xuICAgICAgICAgIGJhY2tkcm9wLmFwcGVuZFRvKHRvb2x0aXApO1xuICAgICAgICAgIHJldHVybiB0b29sdGlwO1xuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwRWwgPSByZW5kZXJUb29sdGlwRWwoKTtcblxuICAgICAgICAvLyBEZXN0cm95IHByZXZpb3VzbHkgYmluZGVkIGV2ZW50c1xuICAgICAgICBvcmlnaW4ub2ZmKCdtb3VzZWVudGVyLnRvb2x0aXAgbW91c2VsZWF2ZS50b29sdGlwJyk7XG4gICAgICAgIC8vIE1vdXNlIEluXG4gICAgICAgIHZhciBzdGFydGVkID0gZmFsc2UsIHRpbWVvdXRSZWY7XG4gICAgICAgIG9yaWdpbi5vbih7J21vdXNlZW50ZXIudG9vbHRpcCc6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdG9vbHRpcEVsLnZlbG9jaXR5KCdzdG9wJyk7XG4gICAgICAgICAgICBiYWNrZHJvcC52ZWxvY2l0eSgnc3RvcCcpO1xuICAgICAgICAgICAgdG9vbHRpcEVsLmNzcyh7IHZpc2liaWxpdHk6ICd2aXNpYmxlJywgbGVmdDogJzBweCcsIHRvcDogJzBweCcgfSk7XG5cbiAgICAgICAgICAgIC8vIFRvb2x0aXAgcG9zaXRpb25pbmdcbiAgICAgICAgICAgIHZhciBvcmlnaW5XaWR0aCA9IG9yaWdpbi5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gb3JpZ2luLm91dGVySGVpZ2h0KCk7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcEhlaWdodCA9IHRvb2x0aXBFbC5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgdmFyIHRvb2x0aXBXaWR0aCA9IHRvb2x0aXBFbC5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcFZlcnRpY2FsTW92ZW1lbnQgPSAnMHB4JztcbiAgICAgICAgICAgIHZhciB0b29sdGlwSG9yaXpvbnRhbE1vdmVtZW50ID0gJzBweCc7XG4gICAgICAgICAgICB2YXIgYmFja2Ryb3BPZmZzZXRXaWR0aCA9IGJhY2tkcm9wWzBdLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdmFyIGJhY2tkcm9wT2Zmc2V0SGVpZ2h0ID0gYmFja2Ryb3BbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHNjYWxlWEZhY3RvciA9IDg7XG4gICAgICAgICAgICB2YXIgc2NhbGVZRmFjdG9yID0gODtcbiAgICAgICAgICAgIHZhciBzY2FsZUZhY3RvciA9IDA7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0VG9wLCB0YXJnZXRMZWZ0LCBuZXdDb29yZGluYXRlcztcblxuICAgICAgICAgICAgaWYgKHRvb2x0aXBQb3NpdGlvbiA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgICAvLyBUb3AgUG9zaXRpb25cbiAgICAgICAgICAgICAgdGFyZ2V0VG9wID0gb3JpZ2luLm9mZnNldCgpLnRvcCAtIHRvb2x0aXBIZWlnaHQgLSBtYXJnaW47XG4gICAgICAgICAgICAgIHRhcmdldExlZnQgPSBvcmlnaW4ub2Zmc2V0KCkubGVmdCArIG9yaWdpbldpZHRoLzIgLSB0b29sdGlwV2lkdGgvMjtcbiAgICAgICAgICAgICAgbmV3Q29vcmRpbmF0ZXMgPSByZXBvc2l0aW9uV2l0aGluU2NyZWVuKHRhcmdldExlZnQsIHRhcmdldFRvcCwgdG9vbHRpcFdpZHRoLCB0b29sdGlwSGVpZ2h0KTtcbiAgICAgICAgICAgICAgdG9vbHRpcFZlcnRpY2FsTW92ZW1lbnQgPSAnLTEwcHgnO1xuICAgICAgICAgICAgICBiYWNrZHJvcC5jc3Moe1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzE0cHggMTRweCAwIDAnLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJzUwJSAxMDAlJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IHRvb2x0aXBIZWlnaHQsXG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogKHRvb2x0aXBXaWR0aC8yKSAtIChiYWNrZHJvcE9mZnNldFdpZHRoLzIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGVmdCBQb3NpdGlvblxuICAgICAgICAgICAgZWxzZSBpZiAodG9vbHRpcFBvc2l0aW9uID09PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICB0YXJnZXRUb3AgPSBvcmlnaW4ub2Zmc2V0KCkudG9wICsgb3JpZ2luSGVpZ2h0LzIgLSB0b29sdGlwSGVpZ2h0LzI7XG4gICAgICAgICAgICAgIHRhcmdldExlZnQgPSAgb3JpZ2luLm9mZnNldCgpLmxlZnQgLSB0b29sdGlwV2lkdGggLSBtYXJnaW47XG4gICAgICAgICAgICAgIG5ld0Nvb3JkaW5hdGVzID0gcmVwb3NpdGlvbldpdGhpblNjcmVlbih0YXJnZXRMZWZ0LCB0YXJnZXRUb3AsIHRvb2x0aXBXaWR0aCwgdG9vbHRpcEhlaWdodCk7XG5cbiAgICAgICAgICAgICAgdG9vbHRpcEhvcml6b250YWxNb3ZlbWVudCA9ICctMTBweCc7XG4gICAgICAgICAgICAgIGJhY2tkcm9wLmNzcyh7XG4gICAgICAgICAgICAgICAgdG9wOiAnLTdweCcsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxNHB4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxNHB4JyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxNHB4IDAgMCAxNHB4JyxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICc5NSUgNTAlJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IHRvb2x0aXBIZWlnaHQvMixcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiB0b29sdGlwV2lkdGhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSaWdodCBQb3NpdGlvblxuICAgICAgICAgICAgZWxzZSBpZiAodG9vbHRpcFBvc2l0aW9uID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0VG9wID0gb3JpZ2luLm9mZnNldCgpLnRvcCArIG9yaWdpbkhlaWdodC8yIC0gdG9vbHRpcEhlaWdodC8yO1xuICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gb3JpZ2luLm9mZnNldCgpLmxlZnQgKyBvcmlnaW5XaWR0aCArIG1hcmdpbjtcbiAgICAgICAgICAgICAgbmV3Q29vcmRpbmF0ZXMgPSByZXBvc2l0aW9uV2l0aGluU2NyZWVuKHRhcmdldExlZnQsIHRhcmdldFRvcCwgdG9vbHRpcFdpZHRoLCB0b29sdGlwSGVpZ2h0KTtcblxuICAgICAgICAgICAgICB0b29sdGlwSG9yaXpvbnRhbE1vdmVtZW50ID0gJysxMHB4JztcbiAgICAgICAgICAgICAgYmFja2Ryb3AuY3NzKHtcbiAgICAgICAgICAgICAgICB0b3A6ICctN3B4JyxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTRweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTRweCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMCAxNHB4IDE0cHggMCcsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnNSUgNTAlJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IHRvb2x0aXBIZWlnaHQvMixcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAnMHB4J1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBCb3R0b20gUG9zaXRpb25cbiAgICAgICAgICAgICAgdGFyZ2V0VG9wID0gb3JpZ2luLm9mZnNldCgpLnRvcCArIG9yaWdpbi5vdXRlckhlaWdodCgpICsgbWFyZ2luO1xuICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gb3JpZ2luLm9mZnNldCgpLmxlZnQgKyBvcmlnaW5XaWR0aC8yIC0gdG9vbHRpcFdpZHRoLzI7XG4gICAgICAgICAgICAgIG5ld0Nvb3JkaW5hdGVzID0gcmVwb3NpdGlvbldpdGhpblNjcmVlbih0YXJnZXRMZWZ0LCB0YXJnZXRUb3AsIHRvb2x0aXBXaWR0aCwgdG9vbHRpcEhlaWdodCk7XG4gICAgICAgICAgICAgIHRvb2x0aXBWZXJ0aWNhbE1vdmVtZW50ID0gJysxMHB4JztcbiAgICAgICAgICAgICAgYmFja2Ryb3AuY3NzKHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAodG9vbHRpcFdpZHRoLzIpIC0gKGJhY2tkcm9wT2Zmc2V0V2lkdGgvMilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB0b29wdGlwIGNzcyBwbGFjZW1lbnRcbiAgICAgICAgICAgIHRvb2x0aXBFbC5jc3Moe1xuICAgICAgICAgICAgICB0b3A6IG5ld0Nvb3JkaW5hdGVzLnksXG4gICAgICAgICAgICAgIGxlZnQ6IG5ld0Nvb3JkaW5hdGVzLnhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgU2NhbGUgdG8gZmlsbFxuICAgICAgICAgICAgc2NhbGVYRmFjdG9yID0gTWF0aC5TUVJUMiAqIHRvb2x0aXBXaWR0aCAvIHBhcnNlSW50KGJhY2tkcm9wT2Zmc2V0V2lkdGgpO1xuICAgICAgICAgICAgc2NhbGVZRmFjdG9yID0gTWF0aC5TUVJUMiAqIHRvb2x0aXBIZWlnaHQgLyBwYXJzZUludChiYWNrZHJvcE9mZnNldEhlaWdodCk7XG4gICAgICAgICAgICBzY2FsZUZhY3RvciA9IE1hdGgubWF4KHNjYWxlWEZhY3Rvciwgc2NhbGVZRmFjdG9yKTtcblxuICAgICAgICAgICAgdG9vbHRpcEVsLnZlbG9jaXR5KHsgdHJhbnNsYXRlWTogdG9vbHRpcFZlcnRpY2FsTW92ZW1lbnQsIHRyYW5zbGF0ZVg6IHRvb2x0aXBIb3Jpem9udGFsTW92ZW1lbnR9LCB7IGR1cmF0aW9uOiAzNTAsIHF1ZXVlOiBmYWxzZSB9KVxuICAgICAgICAgICAgICAudmVsb2NpdHkoe29wYWNpdHk6IDF9LCB7ZHVyYXRpb246IDMwMCwgZGVsYXk6IDUwLCBxdWV1ZTogZmFsc2V9KTtcbiAgICAgICAgICAgIGJhY2tkcm9wLmNzcyh7IHZpc2liaWxpdHk6ICd2aXNpYmxlJyB9KVxuICAgICAgICAgICAgICAudmVsb2NpdHkoe29wYWNpdHk6MX0se2R1cmF0aW9uOiA1NSwgZGVsYXk6IDAsIHF1ZXVlOiBmYWxzZX0pXG4gICAgICAgICAgICAgIC52ZWxvY2l0eSh7c2NhbGVYOiBzY2FsZUZhY3Rvciwgc2NhbGVZOiBzY2FsZUZhY3Rvcn0sIHtkdXJhdGlvbjogMzAwLCBkZWxheTogMCwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlSW5PdXRRdWFkJ30pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aW1lb3V0UmVmID0gc2V0VGltZW91dChzaG93VG9vbHRpcCwgdG9vbHRpcERlbGF5KTsgLy8gRW5kIEludGVydmFsXG5cbiAgICAgICAgLy8gTW91c2UgT3V0XG4gICAgICAgIH0sXG4gICAgICAgICdtb3VzZWxlYXZlLnRvb2x0aXAnOiBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIFJlc2V0IFN0YXRlXG4gICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmKTtcblxuICAgICAgICAgIC8vIEFuaW1hdGUgYmFja1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0b29sdGlwRWwudmVsb2NpdHkoe1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsIHRyYW5zbGF0ZVk6IDAsIHRyYW5zbGF0ZVg6IDB9LCB7IGR1cmF0aW9uOiAyMjUsIHF1ZXVlOiBmYWxzZX0pO1xuICAgICAgICAgICAgICBiYWNrZHJvcC52ZWxvY2l0eSh7b3BhY2l0eTogMCwgc2NhbGVYOiAxLCBzY2FsZVk6IDF9LCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246MjI1LFxuICAgICAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgIGJhY2tkcm9wLmNzcyh7IHZpc2liaWxpdHk6ICdoaWRkZW4nIH0pO1xuICAgICAgICAgICAgICAgICAgdG9vbHRpcEVsLmNzcyh7IHZpc2liaWxpdHk6ICdoaWRkZW4nIH0pO1xuICAgICAgICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwyMjUpO1xuICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBvc2l0aW9uV2l0aGluU2NyZWVuID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBuZXdYID0geDtcbiAgICB2YXIgbmV3WSA9IHk7XG5cbiAgICBpZiAobmV3WCA8IDApIHtcbiAgICAgIG5ld1ggPSA0O1xuICAgIH0gZWxzZSBpZiAobmV3WCArIHdpZHRoID4gd2luZG93LmlubmVyV2lkdGgpIHtcbiAgICAgIG5ld1ggLT0gbmV3WCArIHdpZHRoIC0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKG5ld1kgPCAwKSB7XG4gICAgICBuZXdZID0gNDtcbiAgICB9IGVsc2UgaWYgKG5ld1kgKyBoZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQgKyAkKHdpbmRvdykuc2Nyb2xsVG9wKSB7XG4gICAgICBuZXdZIC09IG5ld1kgKyBoZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt4OiBuZXdYLCB5OiBuZXdZfTtcbiAgfTtcblxuICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuICAgICAkKCcudG9vbHRpcHBlZCcpLnRvb2x0aXAoKTtcbiAgIH0pO1xufSggalF1ZXJ5ICkpO1xuOy8qIVxuICogV2F2ZXMgdjAuNi40XG4gKiBodHRwOi8vZmlhbi5teS5pZC9XYXZlc1xuICpcbiAqIENvcHlyaWdodCAyMDE0IEFsZmlhbmEgRS4gU2lidWVhIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZpYW5zL1dhdmVzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG47KGZ1bmN0aW9uKHdpbmRvdykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBXYXZlcyA9IFdhdmVzIHx8IHt9O1xuICAgIHZhciAkJCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwuYmluZChkb2N1bWVudCk7XG5cbiAgICAvLyBGaW5kIGV4YWN0IHBvc2l0aW9uIG9mIGVsZW1lbnRcbiAgICBmdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93KGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGlzV2luZG93KGVsZW0pID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0VmlldztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXQoZWxlbSkge1xuICAgICAgICB2YXIgZG9jRWxlbSwgd2luLFxuICAgICAgICAgICAgYm94ID0ge3RvcDogMCwgbGVmdDogMH0sXG4gICAgICAgICAgICBkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuICAgICAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICBpZiAodHlwZW9mIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSB0eXBlb2YgdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHdpbiA9IGdldFdpbmRvdyhkb2MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBib3gudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG4gICAgICAgICAgICBsZWZ0OiBib3gubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRTdHlsZShvYmopIHtcbiAgICAgICAgdmFyIHN0eWxlID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgYSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoYSkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZSArPSAoYSArICc6JyArIG9ialthXSArICc7Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgdmFyIEVmZmVjdCA9IHtcblxuICAgICAgICAvLyBFZmZlY3QgZGVsYXlcbiAgICAgICAgZHVyYXRpb246IDc1MCxcblxuICAgICAgICBzaG93OiBmdW5jdGlvbihlLCBlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIC8vIERpc2FibGUgcmlnaHQgY2xpY2tcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsID0gZWxlbWVudCB8fCB0aGlzO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgcmlwcGxlXG4gICAgICAgICAgICB2YXIgcmlwcGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICByaXBwbGUuY2xhc3NOYW1lID0gJ3dhdmVzLXJpcHBsZSc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChyaXBwbGUpO1xuXG4gICAgICAgICAgICAvLyBHZXQgY2xpY2sgY29vcmRpbmF0ZSBhbmQgZWxlbWVudCB3aXRkaFxuICAgICAgICAgICAgdmFyIHBvcyAgICAgICAgID0gb2Zmc2V0KGVsKTtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVkgICA9IChlLnBhZ2VZIC0gcG9zLnRvcCk7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVYICAgPSAoZS5wYWdlWCAtIHBvcy5sZWZ0KTtcbiAgICAgICAgICAgIHZhciBzY2FsZSAgICAgICA9ICdzY2FsZSgnKygoZWwuY2xpZW50V2lkdGggLyAxMDApICogMTApKycpJztcblxuICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3IgdG91Y2ggZGV2aWNlc1xuICAgICAgICAgICAgaWYgKCd0b3VjaGVzJyBpbiBlKSB7XG4gICAgICAgICAgICAgIHJlbGF0aXZlWSAgID0gKGUudG91Y2hlc1swXS5wYWdlWSAtIHBvcy50b3ApO1xuICAgICAgICAgICAgICByZWxhdGl2ZVggICA9IChlLnRvdWNoZXNbMF0ucGFnZVggLSBwb3MubGVmdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBkYXRhIHRvIGVsZW1lbnRcbiAgICAgICAgICAgIHJpcHBsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaG9sZCcsIERhdGUubm93KCkpO1xuICAgICAgICAgICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgnZGF0YS1zY2FsZScsIHNjYWxlKTtcbiAgICAgICAgICAgIHJpcHBsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEteCcsIHJlbGF0aXZlWCk7XG4gICAgICAgICAgICByaXBwbGUuc2V0QXR0cmlidXRlKCdkYXRhLXknLCByZWxhdGl2ZVkpO1xuXG4gICAgICAgICAgICAvLyBTZXQgcmlwcGxlIHBvc2l0aW9uXG4gICAgICAgICAgICB2YXIgcmlwcGxlU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgJ3RvcCc6IHJlbGF0aXZlWSsncHgnLFxuICAgICAgICAgICAgICAgICdsZWZ0JzogcmVsYXRpdmVYKydweCdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJpcHBsZS5jbGFzc05hbWUgPSByaXBwbGUuY2xhc3NOYW1lICsgJyB3YXZlcy1ub3RyYW5zaXRpb24nO1xuICAgICAgICAgICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBjb252ZXJ0U3R5bGUocmlwcGxlU3R5bGUpKTtcbiAgICAgICAgICAgIHJpcHBsZS5jbGFzc05hbWUgPSByaXBwbGUuY2xhc3NOYW1lLnJlcGxhY2UoJ3dhdmVzLW5vdHJhbnNpdGlvbicsICcnKTtcblxuICAgICAgICAgICAgLy8gU2NhbGUgdGhlIHJpcHBsZVxuICAgICAgICAgICAgcmlwcGxlU3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBzY2FsZTtcbiAgICAgICAgICAgIHJpcHBsZVN0eWxlWyctbW96LXRyYW5zZm9ybSddID0gc2NhbGU7XG4gICAgICAgICAgICByaXBwbGVTdHlsZVsnLW1zLXRyYW5zZm9ybSddID0gc2NhbGU7XG4gICAgICAgICAgICByaXBwbGVTdHlsZVsnLW8tdHJhbnNmb3JtJ10gPSBzY2FsZTtcbiAgICAgICAgICAgIHJpcHBsZVN0eWxlLnRyYW5zZm9ybSA9IHNjYWxlO1xuICAgICAgICAgICAgcmlwcGxlU3R5bGUub3BhY2l0eSAgID0gJzEnO1xuXG4gICAgICAgICAgICByaXBwbGVTdHlsZVsnLXdlYmtpdC10cmFuc2l0aW9uLWR1cmF0aW9uJ10gPSBFZmZlY3QuZHVyYXRpb24gKyAnbXMnO1xuICAgICAgICAgICAgcmlwcGxlU3R5bGVbJy1tb3otdHJhbnNpdGlvbi1kdXJhdGlvbiddICAgID0gRWZmZWN0LmR1cmF0aW9uICsgJ21zJztcbiAgICAgICAgICAgIHJpcHBsZVN0eWxlWyctby10cmFuc2l0aW9uLWR1cmF0aW9uJ10gICAgICA9IEVmZmVjdC5kdXJhdGlvbiArICdtcyc7XG4gICAgICAgICAgICByaXBwbGVTdHlsZVsndHJhbnNpdGlvbi1kdXJhdGlvbiddICAgICAgICAgPSBFZmZlY3QuZHVyYXRpb24gKyAnbXMnO1xuXG4gICAgICAgICAgICByaXBwbGVTdHlsZVsnLXdlYmtpdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiddID0gJ2N1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCknO1xuICAgICAgICAgICAgcmlwcGxlU3R5bGVbJy1tb3otdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nXSAgICA9ICdjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApJztcbiAgICAgICAgICAgIHJpcHBsZVN0eWxlWyctby10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiddICAgICAgPSAnY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSc7XG4gICAgICAgICAgICByaXBwbGVTdHlsZVsndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nXSAgICAgICAgID0gJ2N1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCknO1xuXG4gICAgICAgICAgICByaXBwbGUuc2V0QXR0cmlidXRlKCdzdHlsZScsIGNvbnZlcnRTdHlsZShyaXBwbGVTdHlsZSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIFRvdWNoSGFuZGxlci50b3VjaHVwKGUpO1xuXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZWwuY2xpZW50V2lkdGggKiAxLjQ7XG5cbiAgICAgICAgICAgIC8vIEdldCBmaXJzdCByaXBwbGVcbiAgICAgICAgICAgIHZhciByaXBwbGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJpcHBsZXMgPSBlbC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd3YXZlcy1yaXBwbGUnKTtcbiAgICAgICAgICAgIGlmIChyaXBwbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByaXBwbGUgPSByaXBwbGVzW3JpcHBsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlWCAgID0gcmlwcGxlLmdldEF0dHJpYnV0ZSgnZGF0YS14Jyk7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVZICAgPSByaXBwbGUuZ2V0QXR0cmlidXRlKCdkYXRhLXknKTtcbiAgICAgICAgICAgIHZhciBzY2FsZSAgICAgICA9IHJpcHBsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2NhbGUnKTtcblxuICAgICAgICAgICAgLy8gR2V0IGRlbGF5IGJlZXR3ZWVuIG1vdXNlZG93biBhbmQgbW91c2UgbGVhdmVcbiAgICAgICAgICAgIHZhciBkaWZmID0gRGF0ZS5ub3coKSAtIE51bWJlcihyaXBwbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhvbGQnKSk7XG4gICAgICAgICAgICB2YXIgZGVsYXkgPSAzNTAgLSBkaWZmO1xuXG4gICAgICAgICAgICBpZiAoZGVsYXkgPCAwKSB7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGYWRlIG91dCByaXBwbGUgYWZ0ZXIgZGVsYXlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICAndG9wJzogcmVsYXRpdmVZKydweCcsXG4gICAgICAgICAgICAgICAgICAgICdsZWZ0JzogcmVsYXRpdmVYKydweCcsXG4gICAgICAgICAgICAgICAgICAgICdvcGFjaXR5JzogJzAnLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIER1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICctd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb24nOiBFZmZlY3QuZHVyYXRpb24gKyAnbXMnLFxuICAgICAgICAgICAgICAgICAgICAnLW1vei10cmFuc2l0aW9uLWR1cmF0aW9uJzogRWZmZWN0LmR1cmF0aW9uICsgJ21zJyxcbiAgICAgICAgICAgICAgICAgICAgJy1vLXRyYW5zaXRpb24tZHVyYXRpb24nOiBFZmZlY3QuZHVyYXRpb24gKyAnbXMnLFxuICAgICAgICAgICAgICAgICAgICAndHJhbnNpdGlvbi1kdXJhdGlvbic6IEVmZmVjdC5kdXJhdGlvbiArICdtcycsXG4gICAgICAgICAgICAgICAgICAgICctd2Via2l0LXRyYW5zZm9ybSc6IHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAnLW1vei10cmFuc2Zvcm0nOiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgJy1tcy10cmFuc2Zvcm0nOiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgJy1vLXRyYW5zZm9ybSc6IHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogc2NhbGUsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJpcHBsZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgY29udmVydFN0eWxlKHN0eWxlKSk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQocmlwcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBFZmZlY3QuZHVyYXRpb24pO1xuICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIExpdHRsZSBoYWNrIHRvIG1ha2UgPGlucHV0PiBjYW4gcGVyZm9ybSB3YXZlcyBlZmZlY3RcbiAgICAgICAgd3JhcElucHV0OiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBlbGVtZW50cy5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRzW2FdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpbnB1dCBhbHJlYWR5IGhhdmUgcGFyZW50IGp1c3QgcGFzcyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaScgJiYgcGFyZW50LmNsYXNzTmFtZS5pbmRleE9mKCd3YXZlcy1lZmZlY3QnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHV0IGVsZW1lbnQgY2xhc3MgYW5kIHN0eWxlIHRvIHRoZSBzcGVjaWZpZWQgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZSArICcgd2F2ZXMtaW5wdXQtd3JhcHBlcic7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRTdHlsZSA9IGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBlbGVtZW50U3R5bGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9ICd3YXZlcy1idXR0b24taW5wdXQnO1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHV0IGVsZW1lbnQgYXMgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh3cmFwcGVyLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgbW91c2Vkb3duIGV2ZW50IGZvciA1MDBtcyBkdXJpbmcgYW5kIGFmdGVyIHRvdWNoXG4gICAgICovXG4gICAgdmFyIFRvdWNoSGFuZGxlciA9IHtcbiAgICAgICAgLyogdXNlcyBhbiBpbnRlZ2VyIHJhdGhlciB0aGFuIGJvb2wgc28gdGhlcmUncyBubyBpc3N1ZXMgd2l0aFxuICAgICAgICAgKiBuZWVkaW5nIHRvIGNsZWFyIHRpbWVvdXRzIGlmIGFub3RoZXIgdG91Y2ggZXZlbnQgb2NjdXJyZWRcbiAgICAgICAgICogd2l0aGluIHRoZSA1MDBtcy4gQ2Fubm90IG1vdXNldXAgYmV0d2VlbiB0b3VjaHN0YXJ0IGFuZFxuICAgICAgICAgKiB0b3VjaGVuZCwgbm9yIGluIHRoZSA1MDBtcyBhZnRlciB0b3VjaGVuZC4gKi9cbiAgICAgICAgdG91Y2hlczogMCxcbiAgICAgICAgYWxsb3dFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGFsbG93ID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgVG91Y2hIYW5kbGVyLnRvdWNoZXMgKz0gMTsgLy9wdXNoXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ3RvdWNoZW5kJyB8fCBlLnR5cGUgPT09ICd0b3VjaGNhbmNlbCcpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVG91Y2hIYW5kbGVyLnRvdWNoZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBUb3VjaEhhbmRsZXIudG91Y2hlcyAtPSAxOyAvL3BvcCBhZnRlciA1MDBtc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJyAmJiBUb3VjaEhhbmRsZXIudG91Y2hlcyA+IDApIHtcbiAgICAgICAgICAgICAgICBhbGxvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWxsb3c7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNodXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIFRvdWNoSGFuZGxlci5hbGxvd0V2ZW50KGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogRGVsZWdhdGVkIGNsaWNrIGhhbmRsZXIgZm9yIC53YXZlcy1lZmZlY3QgZWxlbWVudC5cbiAgICAgKiByZXR1cm5zIG51bGwgd2hlbiAud2F2ZXMtZWZmZWN0IGVsZW1lbnQgbm90IGluIFwiY2xpY2sgdHJlZVwiXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0V2F2ZXNFZmZlY3RFbGVtZW50KGUpIHtcbiAgICAgICAgaWYgKFRvdWNoSGFuZGxlci5hbGxvd0V2ZW50KGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cbiAgICAgICAgd2hpbGUgKHRhcmdldC5wYXJlbnRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ3dhdmVzLWVmZmVjdCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3dhdmVzLWVmZmVjdCcpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnViYmxlIHRoZSBjbGljayBhbmQgc2hvdyBlZmZlY3QgaWYgLndhdmVzLWVmZmVjdCBlbGVtIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3dFZmZlY3QoZSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGdldFdhdmVzRWZmZWN0RWxlbWVudChlKTtcblxuICAgICAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgRWZmZWN0LnNob3coZSwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgRWZmZWN0LmhpZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgRWZmZWN0LmhpZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgRWZmZWN0LmhpZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIEVmZmVjdC5oaWRlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBXYXZlcy5kaXNwbGF5RWZmZWN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAoJ2R1cmF0aW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBFZmZlY3QuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9XcmFwIGlucHV0IGluc2lkZSA8aT4gdGFnXG4gICAgICAgIEVmZmVjdC53cmFwSW5wdXQoJCQoJy53YXZlcy1lZmZlY3QnKSk7XG5cbiAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgc2hvd0VmZmVjdCwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzaG93RWZmZWN0LCBmYWxzZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBXYXZlcyB0byBhbiBpbnB1dCBlbGVtZW50IChvciBhbnkgZWxlbWVudCB3aGljaCBkb2Vzbid0XG4gICAgICogYnViYmxlIG1vdXNldXAvbW91c2Vkb3duIGV2ZW50cykuXG4gICAgICogICBJbnRlbmRlZCB0byBiZSB1c2VkIHdpdGggZHluYW1pY2FsbHkgbG9hZGVkIGZvcm1zL2lucHV0cywgb3JcbiAgICAgKiB3aGVyZSB0aGUgdXNlciBkb2Vzbid0IHdhbnQgYSBkZWxlZ2F0ZWQgY2xpY2sgaGFuZGxlci5cbiAgICAgKi9cbiAgICBXYXZlcy5hdHRhY2ggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIC8vRlVUVVJFOiBhdXRvbWF0aWNhbGx5IGFkZCB3YXZlcyBjbGFzc2VzIGFuZCBhbGxvdyB1c2Vyc1xuICAgICAgICAvLyB0byBzcGVjaWZ5IHRoZW0gd2l0aCBhbiBvcHRpb25zIHBhcmFtPyBFZy4gbGlnaHQvY2xhc3NpYy9idXR0b25cbiAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICBFZmZlY3Qud3JhcElucHV0KFtlbGVtZW50XSk7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgc2hvd0VmZmVjdCwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzaG93RWZmZWN0LCBmYWxzZSk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5XYXZlcyA9IFdhdmVzO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBXYXZlcy5kaXNwbGF5RWZmZWN0KCk7XG4gICAgfSwgZmFsc2UpO1xuXG59KSh3aW5kb3cpO1xuO01hdGVyaWFsaXplLnRvYXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRpc3BsYXlMZW5ndGgsIGNsYXNzTmFtZSwgY29tcGxldGVDYWxsYmFjaykge1xuICBjbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgXCJcIjtcblxuICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvYXN0LWNvbnRhaW5lcicpO1xuXG4gIC8vIENyZWF0ZSB0b2FzdCBjb250YWluZXIgaWYgaXQgZG9lcyBub3QgZXhpc3RcbiAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgIC8vIGNyZWF0ZSBub3RpZmljYXRpb24gY29udGFpbmVyXG4gICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmlkID0gJ3RvYXN0LWNvbnRhaW5lcic7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICB9XG5cbiAgLy8gU2VsZWN0IGFuZCBhcHBlbmQgdG9hc3RcbiAgdmFyIG5ld1RvYXN0ID0gY3JlYXRlVG9hc3QobWVzc2FnZSk7XG5cbiAgLy8gb25seSBhcHBlbmQgdG9hc3QgaWYgbWVzc2FnZSBpcyBub3QgdW5kZWZpbmVkXG4gIGlmKG1lc3NhZ2Upe1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuZXdUb2FzdCk7XG4gIH1cblxuICBuZXdUb2FzdC5zdHlsZS5vcGFjaXR5ID0gMDtcblxuICAvLyBBbmltYXRlIHRvYXN0IGluXG4gIFZlbChuZXdUb2FzdCwge3RyYW5zbGF0ZVk6ICctMzVweCcsICBvcGFjaXR5OiAxIH0sIHtkdXJhdGlvbjogMzAwLFxuICAgIGVhc2luZzogJ2Vhc2VPdXRDdWJpYycsXG4gICAgcXVldWU6IGZhbHNlfSk7XG5cbiAgLy8gQWxsb3dzIHRpbWVyIHRvIGJlIHBhdXNlIHdoaWxlIGJlaW5nIHBhbm5lZFxuICB2YXIgdGltZUxlZnQgPSBkaXNwbGF5TGVuZ3RoO1xuICB2YXIgY291bnRlckludGVydmFsO1xuICBpZiAodGltZUxlZnQgIT0gbnVsbCkgIHtcbiAgICBjb3VudGVySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCAoZnVuY3Rpb24oKXtcbiAgICAgIGlmIChuZXdUb2FzdC5wYXJlbnROb2RlID09PSBudWxsKVxuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChjb3VudGVySW50ZXJ2YWwpO1xuXG4gICAgICAvLyBJZiB0b2FzdCBpcyBub3QgYmVpbmcgZHJhZ2dlZCwgZGVjcmVhc2UgaXRzIHRpbWUgcmVtYWluaW5nXG4gICAgICBpZiAoIW5ld1RvYXN0LmNsYXNzTGlzdC5jb250YWlucygncGFubmluZycpKSB7XG4gICAgICAgIHRpbWVMZWZ0IC09IDIwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgICAvLyBBbmltYXRlIHRvYXN0IG91dFxuICAgICAgICBWZWwobmV3VG9hc3QsIHtcIm9wYWNpdHlcIjogMCwgbWFyZ2luVG9wOiAnLTQwcHgnfSwgeyBkdXJhdGlvbjogMzc1LFxuICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dEV4cG8nLFxuICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIC8vIENhbGwgdGhlIG9wdGlvbmFsIGNhbGxiYWNrXG4gICAgICAgICAgICAgIGlmKHR5cGVvZihjb21wbGV0ZUNhbGxiYWNrKSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRvYXN0IGFmdGVyIGl0IHRpbWVzIG91dFxuICAgICAgICAgICAgICB0aGlzWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGNvdW50ZXJJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfSwgMjApO1xuICB9XG5cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRvYXN0KGh0bWwpIHtcblxuICAgIC8vIENyZWF0ZSB0b2FzdFxuICAgIHZhciB0b2FzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRvYXN0LmNsYXNzTGlzdC5hZGQoJ3RvYXN0Jyk7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgdmFyIGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoJyAnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGNvdW50ID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHRvYXN0LmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAvLyBJZiB0eXBlIG9mIHBhcmFtZXRlciBpcyBIVE1MIEVsZW1lbnRcbiAgICBpZiAoIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIiA/IGh0bWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IGh0bWwgJiYgdHlwZW9mIGh0bWwgPT09IFwib2JqZWN0XCIgJiYgaHRtbCAhPT0gbnVsbCAmJiBodG1sLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBodG1sLm5vZGVOYW1lPT09XCJzdHJpbmdcIlxuKSB7XG4gICAgICB0b2FzdC5hcHBlbmRDaGlsZChodG1sKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaHRtbCBpbnN0YW5jZW9mIGpRdWVyeSkge1xuICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgalF1ZXJ5IG9iamVjdFxuICAgICAgdG9hc3QuYXBwZW5kQ2hpbGQoaHRtbFswXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0IGFzIHRleHQ7XG4gICAgICB0b2FzdC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH1cbiAgICAvLyBCaW5kIGhhbW1lclxuICAgIHZhciBoYW1tZXJIYW5kbGVyID0gbmV3IEhhbW1lcih0b2FzdCwge3ByZXZlbnRfZGVmYXVsdDogZmFsc2V9KTtcbiAgICBoYW1tZXJIYW5kbGVyLm9uKCdwYW4nLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgZGVsdGFYID0gZS5kZWx0YVg7XG4gICAgICB2YXIgYWN0aXZhdGlvbkRpc3RhbmNlID0gODA7XG5cbiAgICAgIC8vIENoYW5nZSB0b2FzdCBzdGF0ZVxuICAgICAgaWYgKCF0b2FzdC5jbGFzc0xpc3QuY29udGFpbnMoJ3Bhbm5pbmcnKSl7XG4gICAgICAgIHRvYXN0LmNsYXNzTGlzdC5hZGQoJ3Bhbm5pbmcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wYWNpdHlQZXJjZW50ID0gMS1NYXRoLmFicyhkZWx0YVggLyBhY3RpdmF0aW9uRGlzdGFuY2UpO1xuICAgICAgaWYgKG9wYWNpdHlQZXJjZW50IDwgMClcbiAgICAgICAgb3BhY2l0eVBlcmNlbnQgPSAwO1xuXG4gICAgICBWZWwodG9hc3QsIHtsZWZ0OiBkZWx0YVgsIG9wYWNpdHk6IG9wYWNpdHlQZXJjZW50IH0sIHtkdXJhdGlvbjogNTAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnfSk7XG5cbiAgICB9KTtcblxuICAgIGhhbW1lckhhbmRsZXIub24oJ3BhbmVuZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBkZWx0YVggPSBlLmRlbHRhWDtcbiAgICAgIHZhciBhY3RpdmF0aW9uRGlzdGFuY2UgPSA4MDtcblxuICAgICAgLy8gSWYgdG9hc3QgZHJhZ2dlZCBwYXN0IGFjdGl2YXRpb24gcG9pbnRcbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YVgpID4gYWN0aXZhdGlvbkRpc3RhbmNlKSB7XG4gICAgICAgIFZlbCh0b2FzdCwge21hcmdpblRvcDogJy00MHB4J30sIHsgZHVyYXRpb246IDM3NSxcbiAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0RXhwbycsXG4gICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYodHlwZW9mKGNvbXBsZXRlQ2FsbGJhY2spID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgY29tcGxldGVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9hc3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b2FzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9hc3QuY2xhc3NMaXN0LnJlbW92ZSgncGFubmluZycpO1xuICAgICAgICAvLyBQdXQgdG9hc3QgYmFjayBpbnRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgIFZlbCh0b2FzdCwgeyBsZWZ0OiAwLCBvcGFjaXR5OiAxIH0sIHsgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0RXhwbycsXG4gICAgICAgICAgcXVldWU6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9hc3Q7XG4gIH1cbn07XG47KGZ1bmN0aW9uICgkKSB7XG5cbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgaW5pdCA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgbWVudVdpZHRoOiAzMDAsXG4gICAgICAgIGVkZ2U6ICdsZWZ0JyxcbiAgICAgICAgY2xvc2VPbkNsaWNrOiBmYWxzZSxcbiAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXG4gICAgICB9O1xuICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgIHZhciBtZW51SWQgPSAkdGhpcy5hdHRyKCdkYXRhLWFjdGl2YXRlcycpO1xuICAgICAgICB2YXIgbWVudSA9ICQoXCIjXCIrIG1lbnVJZCk7XG5cbiAgICAgICAgLy8gU2V0IHRvIHdpZHRoXG4gICAgICAgIGlmIChvcHRpb25zLm1lbnVXaWR0aCAhPSAzMDApIHtcbiAgICAgICAgICBtZW51LmNzcygnd2lkdGgnLCBvcHRpb25zLm1lbnVXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgVG91Y2ggQXJlYVxuICAgICAgICB2YXIgJGRyYWdUYXJnZXQgPSAkKCcuZHJhZy10YXJnZXRbZGF0YS1zaWRlbmF2PVwiJyArIG1lbnVJZCArICdcIl0nKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgLy8gUmVnZW5lcmF0ZSBkcmFnVGFyZ2V0XG4gICAgICAgICAgaWYgKCRkcmFnVGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgJGRyYWdUYXJnZXQucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJGRyYWdUYXJnZXQgPSAkKCc8ZGl2IGNsYXNzPVwiZHJhZy10YXJnZXRcIj48L2Rpdj4nKS5hdHRyKCdkYXRhLXNpZGVuYXYnLCBtZW51SWQpO1xuICAgICAgICAgICQoJ2JvZHknKS5hcHBlbmQoJGRyYWdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRkcmFnVGFyZ2V0ID0gJCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZWRnZSA9PSAnbGVmdCcpIHtcbiAgICAgICAgICBtZW51LmNzcygndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVgoLTEwMCUpJyk7XG4gICAgICAgICAgJGRyYWdUYXJnZXQuY3NzKHsnbGVmdCc6IDB9KTsgLy8gQWRkIFRvdWNoIEFyZWFcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtZW51LmFkZENsYXNzKCdyaWdodC1hbGlnbmVkJykgLy8gQ2hhbmdlIHRleHQtYWxpZ25tZW50IHRvIHJpZ2h0XG4gICAgICAgICAgICAuY3NzKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWCgxMDAlKScpO1xuICAgICAgICAgICRkcmFnVGFyZ2V0LmNzcyh7J3JpZ2h0JzogMH0pOyAvLyBBZGQgVG91Y2ggQXJlYVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgZml4ZWQgc2lkZW5hdiwgYnJpbmcgbWVudSBvdXRcbiAgICAgICAgaWYgKG1lbnUuaGFzQ2xhc3MoJ2ZpeGVkJykpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDk5Mikge1xuICAgICAgICAgICAgICBtZW51LmNzcygndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVgoMCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gV2luZG93IHJlc2l6ZSB0byByZXNldCBvbiBsYXJnZSBzY3JlZW5zIGZpeGVkXG4gICAgICAgIGlmIChtZW51Lmhhc0NsYXNzKCdmaXhlZCcpKSB7XG4gICAgICAgICAgJCh3aW5kb3cpLnJlc2l6ZSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPiA5OTIpIHtcbiAgICAgICAgICAgICAgLy8gQ2xvc2UgbWVudSBpZiB3aW5kb3cgaXMgcmVzaXplZCBiaWdnZXIgdGhhbiA5OTIgYW5kIHVzZXIgaGFzIGZpeGVkIHNpZGVuYXZcbiAgICAgICAgICAgICAgaWYgKCQoJyNzaWRlbmF2LW92ZXJsYXknKS5sZW5ndGggIT09IDAgJiYgbWVudU91dCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU1lbnUodHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbWVudS5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgIG1lbnUuY3NzKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWCgwJSknKTtcbiAgICAgICAgICAgICAgICAvLyBtZW51LmNzcygnd2lkdGgnLCBvcHRpb25zLm1lbnVXaWR0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lbnVPdXQgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZWRnZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgbWVudS5jc3MoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVYKC0xMDAlKScpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lbnUuY3NzKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWCgxMDAlKScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgY2xvc2VPbkNsaWNrLCB0aGVuIGFkZCBjbG9zZSBldmVudCBmb3IgYWxsIGEgdGFncyBpbiBzaWRlIHNpZGVOYXZcbiAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VPbkNsaWNrID09PSB0cnVlKSB7XG4gICAgICAgICAgbWVudS5vbihcImNsaWNrLml0ZW1jbGlja1wiLCBcImE6bm90KC5jb2xsYXBzaWJsZS1oZWFkZXIpXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZW1vdmVNZW51KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVtb3ZlTWVudSA9IGZ1bmN0aW9uKHJlc3RvcmVOYXYpIHtcbiAgICAgICAgICBwYW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgbWVudU91dCA9IGZhbHNlO1xuICAgICAgICAgIC8vIFJlZW5hYmxlIHNjcm9sbGluZ1xuICAgICAgICAgICQoJ2JvZHknKS5jc3Moe1xuICAgICAgICAgICAgb3ZlcmZsb3c6ICcnLFxuICAgICAgICAgICAgd2lkdGg6ICcnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAkKCcjc2lkZW5hdi1vdmVybGF5JykudmVsb2NpdHkoe29wYWNpdHk6IDB9LCB7ZHVyYXRpb246IDIwMCxcbiAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCcsXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IH0pO1xuICAgICAgICAgIGlmIChvcHRpb25zLmVkZ2UgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgLy8gUmVzZXQgcGhhbnRvbSBkaXZcbiAgICAgICAgICAgICRkcmFnVGFyZ2V0LmNzcyh7d2lkdGg6ICcnLCByaWdodDogJycsIGxlZnQ6ICcwJ30pO1xuICAgICAgICAgICAgbWVudS52ZWxvY2l0eShcbiAgICAgICAgICAgICAgeyd0cmFuc2xhdGVYJzogJy0xMDAlJ30sXG4gICAgICAgICAgICAgIHsgZHVyYXRpb246IDIwMCxcbiAgICAgICAgICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dEN1YmljJyxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdG9yZU5hdiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIEZpeGVkIHNpZGVuYXZcbiAgICAgICAgICAgICAgICAgICAgbWVudS5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICBtZW51LmNzcygnd2lkdGgnLCBvcHRpb25zLm1lbnVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXNldCBwaGFudG9tIGRpdlxuICAgICAgICAgICAgJGRyYWdUYXJnZXQuY3NzKHt3aWR0aDogJycsIHJpZ2h0OiAnMCcsIGxlZnQ6ICcnfSk7XG4gICAgICAgICAgICBtZW51LnZlbG9jaXR5KFxuICAgICAgICAgICAgICB7J3RyYW5zbGF0ZVgnOiAnMTAwJSd9LFxuICAgICAgICAgICAgICB7IGR1cmF0aW9uOiAyMDAsXG4gICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRDdWJpYycsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3RvcmVOYXYgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBGaXhlZCBzaWRlbmF2XG4gICAgICAgICAgICAgICAgICAgIG1lbnUucmVtb3ZlQXR0cignc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgbWVudS5jc3MoJ3dpZHRoJywgb3B0aW9ucy5tZW51V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cblxuICAgICAgICAvLyBUb3VjaCBFdmVudFxuICAgICAgICB2YXIgcGFubmluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgbWVudU91dCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmRyYWdnYWJsZSkge1xuICAgICAgICAgICRkcmFnVGFyZ2V0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAobWVudU91dCkge1xuICAgICAgICAgICAgICByZW1vdmVNZW51KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAkZHJhZ1RhcmdldC5oYW1tZXIoe1xuICAgICAgICAgICAgcHJldmVudF9kZWZhdWx0OiBmYWxzZVxuICAgICAgICAgIH0pLmJpbmQoJ3BhbicsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICAgaWYgKGUuZ2VzdHVyZS5wb2ludGVyVHlwZSA9PSBcInRvdWNoXCIpIHtcblxuICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZS5nZXN0dXJlLmRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgdmFyIHggPSBlLmdlc3R1cmUuY2VudGVyLng7XG4gICAgICAgICAgICAgIHZhciB5ID0gZS5nZXN0dXJlLmNlbnRlci55O1xuICAgICAgICAgICAgICB2YXIgdmVsb2NpdHlYID0gZS5nZXN0dXJlLnZlbG9jaXR5WDtcblxuICAgICAgICAgICAgICAvLyBEaXNhYmxlIFNjcm9sbGluZ1xuICAgICAgICAgICAgICB2YXIgJGJvZHkgPSAkKCdib2R5Jyk7XG4gICAgICAgICAgICAgIHZhciAkb3ZlcmxheSA9ICQoJyNzaWRlbmF2LW92ZXJsYXknKTtcbiAgICAgICAgICAgICAgdmFyIG9sZFdpZHRoID0gJGJvZHkuaW5uZXJXaWR0aCgpO1xuICAgICAgICAgICAgICAkYm9keS5jc3MoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAkYm9keS53aWR0aChvbGRXaWR0aCk7XG5cbiAgICAgICAgICAgICAgLy8gSWYgb3ZlcmxheSBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIG9uZSBhbmQgaWYgaXQgaXMgY2xpY2tlZCwgY2xvc2UgbWVudVxuICAgICAgICAgICAgICBpZiAoJG92ZXJsYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgJG92ZXJsYXkgPSAkKCc8ZGl2IGlkPVwic2lkZW5hdi1vdmVybGF5XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgJG92ZXJsYXkuY3NzKCdvcGFjaXR5JywgMCkuY2xpY2soIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICByZW1vdmVNZW51KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJCgnYm9keScpLmFwcGVuZCgkb3ZlcmxheSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBLZWVwIHdpdGhpbiBib3VuZGFyaWVzXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmVkZ2UgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIGlmICh4ID4gb3B0aW9ucy5tZW51V2lkdGgpIHsgeCA9IG9wdGlvbnMubWVudVdpZHRoOyB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeCA8IDApIHsgeCA9IDA7IH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmVkZ2UgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIC8vIExlZnQgRGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHggPCAob3B0aW9ucy5tZW51V2lkdGggLyAyKSkgeyBtZW51T3V0ID0gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICAvLyBSaWdodCBEaXJlY3Rpb25cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4ID49IChvcHRpb25zLm1lbnVXaWR0aCAvIDIpKSB7IG1lbnVPdXQgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgbWVudS5jc3MoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVYKCcgKyAoeCAtIG9wdGlvbnMubWVudVdpZHRoKSArICdweCknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMZWZ0IERpcmVjdGlvblxuICAgICAgICAgICAgICAgIGlmICh4IDwgKHdpbmRvdy5pbm5lcldpZHRoIC0gb3B0aW9ucy5tZW51V2lkdGggLyAyKSkge1xuICAgICAgICAgICAgICAgICAgbWVudU91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0IERpcmVjdGlvblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggPj0gKHdpbmRvdy5pbm5lcldpZHRoIC0gb3B0aW9ucy5tZW51V2lkdGggLyAyKSkge1xuICAgICAgICAgICAgICAgICBtZW51T3V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0UG9zID0gKHggLSBvcHRpb25zLm1lbnVXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodFBvcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgIHJpZ2h0UG9zID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZW51LmNzcygndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVgoJyArIHJpZ2h0UG9zICsgJ3B4KScpO1xuICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAvLyBQZXJjZW50YWdlIG92ZXJsYXlcbiAgICAgICAgICAgICAgdmFyIG92ZXJsYXlQZXJjO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lZGdlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5UGVyYyA9IHggLyBvcHRpb25zLm1lbnVXaWR0aDtcbiAgICAgICAgICAgICAgICAkb3ZlcmxheS52ZWxvY2l0eSh7b3BhY2l0eTogb3ZlcmxheVBlcmMgfSwge2R1cmF0aW9uOiAxMCwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCd9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5UGVyYyA9IE1hdGguYWJzKCh4IC0gd2luZG93LmlubmVyV2lkdGgpIC8gb3B0aW9ucy5tZW51V2lkdGgpO1xuICAgICAgICAgICAgICAgICRvdmVybGF5LnZlbG9jaXR5KHtvcGFjaXR5OiBvdmVybGF5UGVyYyB9LCB7ZHVyYXRpb246IDEwLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ30pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9KS5iaW5kKCdwYW5lbmQnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgICAgIGlmIChlLmdlc3R1cmUucG9pbnRlclR5cGUgPT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgICAgIHZhciAkb3ZlcmxheSA9ICQoJyNzaWRlbmF2LW92ZXJsYXknKTtcbiAgICAgICAgICAgICAgdmFyIHZlbG9jaXR5WCA9IGUuZ2VzdHVyZS52ZWxvY2l0eVg7XG4gICAgICAgICAgICAgIHZhciB4ID0gZS5nZXN0dXJlLmNlbnRlci54O1xuICAgICAgICAgICAgICB2YXIgbGVmdFBvcyA9IHggLSBvcHRpb25zLm1lbnVXaWR0aDtcbiAgICAgICAgICAgICAgdmFyIHJpZ2h0UG9zID0geCAtIG9wdGlvbnMubWVudVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgaWYgKGxlZnRQb3MgPiAwICkge1xuICAgICAgICAgICAgICAgIGxlZnRQb3MgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyaWdodFBvcyA8IDApIHtcbiAgICAgICAgICAgICAgICByaWdodFBvcyA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFubmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmVkZ2UgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIC8vIElmIHZlbG9jaXR5WCA8PSAwLjMgdGhlbiB0aGUgdXNlciBpcyBmbGluZ2luZyB0aGUgbWVudSBjbG9zZWQgc28gaWdub3JlIG1lbnVPdXRcbiAgICAgICAgICAgICAgICBpZiAoKG1lbnVPdXQgJiYgdmVsb2NpdHlYIDw9IDAuMykgfHwgdmVsb2NpdHlYIDwgLTAuNSkge1xuICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIG1lbnUgdG8gb3BlblxuICAgICAgICAgICAgICAgICAgaWYgKGxlZnRQb3MgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVudS52ZWxvY2l0eSh7J3RyYW5zbGF0ZVgnOiBbMCwgbGVmdFBvc119LCB7ZHVyYXRpb246IDMwMCwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCd9KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgJG92ZXJsYXkudmVsb2NpdHkoe29wYWNpdHk6IDEgfSwge2R1cmF0aW9uOiA1MCwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCd9KTtcbiAgICAgICAgICAgICAgICAgICRkcmFnVGFyZ2V0LmNzcyh7d2lkdGg6ICc1MCUnLCByaWdodDogMCwgbGVmdDogJyd9KTtcbiAgICAgICAgICAgICAgICAgIG1lbnVPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbWVudU91dCB8fCB2ZWxvY2l0eVggPiAwLjMpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBTY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAgICQoJ2JvZHknKS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJycsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAvLyBTbGlkZSBtZW51IGNsb3NlZFxuICAgICAgICAgICAgICAgICAgbWVudS52ZWxvY2l0eSh7J3RyYW5zbGF0ZVgnOiBbLTEgKiBvcHRpb25zLm1lbnVXaWR0aCAtIDEwLCBsZWZ0UG9zXX0sIHtkdXJhdGlvbjogMjAwLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ30pO1xuICAgICAgICAgICAgICAgICAgJG92ZXJsYXkudmVsb2NpdHkoe29wYWNpdHk6IDAgfSwge2R1cmF0aW9uOiAyMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH19KTtcbiAgICAgICAgICAgICAgICAgICRkcmFnVGFyZ2V0LmNzcyh7d2lkdGg6ICcxMHB4JywgcmlnaHQ6ICcnLCBsZWZ0OiAwfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgobWVudU91dCAmJiB2ZWxvY2l0eVggPj0gLTAuMykgfHwgdmVsb2NpdHlYID4gMC41KSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gbWVudSB0byBvcGVuXG4gICAgICAgICAgICAgICAgICBpZiAocmlnaHRQb3MgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVudS52ZWxvY2l0eSh7J3RyYW5zbGF0ZVgnOiBbMCwgcmlnaHRQb3NdfSwge2R1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnfSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICRvdmVybGF5LnZlbG9jaXR5KHtvcGFjaXR5OiAxIH0sIHtkdXJhdGlvbjogNTAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnfSk7XG4gICAgICAgICAgICAgICAgICAkZHJhZ1RhcmdldC5jc3Moe3dpZHRoOiAnNTAlJywgcmlnaHQ6ICcnLCBsZWZ0OiAwfSk7XG4gICAgICAgICAgICAgICAgICBtZW51T3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW1lbnVPdXQgfHwgdmVsb2NpdHlYIDwgLTAuMykge1xuICAgICAgICAgICAgICAgICAgLy8gRW5hYmxlIFNjcm9sbGluZ1xuICAgICAgICAgICAgICAgICAgJCgnYm9keScpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcnXG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgLy8gU2xpZGUgbWVudSBjbG9zZWRcbiAgICAgICAgICAgICAgICAgIG1lbnUudmVsb2NpdHkoeyd0cmFuc2xhdGVYJzogW29wdGlvbnMubWVudVdpZHRoICsgMTAsIHJpZ2h0UG9zXX0sIHtkdXJhdGlvbjogMjAwLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ30pO1xuICAgICAgICAgICAgICAgICAgJG92ZXJsYXkudmVsb2NpdHkoe29wYWNpdHk6IDAgfSwge2R1cmF0aW9uOiAyMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH19KTtcbiAgICAgICAgICAgICAgICAgICRkcmFnVGFyZ2V0LmNzcyh7d2lkdGg6ICcxMHB4JywgcmlnaHQ6IDAsIGxlZnQ6ICcnfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICR0aGlzLm9mZignY2xpY2suc2lkZW5hdicpLm9uKCdjbGljay5zaWRlbmF2JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKG1lbnVPdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lbnVPdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlbW92ZU1lbnUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIERpc2FibGUgU2Nyb2xsaW5nXG4gICAgICAgICAgICB2YXIgJGJvZHkgPSAkKCdib2R5Jyk7XG4gICAgICAgICAgICB2YXIgJG92ZXJsYXkgPSAkKCc8ZGl2IGlkPVwic2lkZW5hdi1vdmVybGF5XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICB2YXIgb2xkV2lkdGggPSAkYm9keS5pbm5lcldpZHRoKCk7XG4gICAgICAgICAgICAkYm9keS5jc3MoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xuICAgICAgICAgICAgJGJvZHkud2lkdGgob2xkV2lkdGgpO1xuXG4gICAgICAgICAgICAvLyBQdXNoIGN1cnJlbnQgZHJhZyB0YXJnZXQgb24gdG9wIG9mIERPTSB0cmVlXG4gICAgICAgICAgICAkKCdib2R5JykuYXBwZW5kKCRkcmFnVGFyZ2V0KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZWRnZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICRkcmFnVGFyZ2V0LmNzcyh7d2lkdGg6ICc1MCUnLCByaWdodDogMCwgbGVmdDogJyd9KTtcbiAgICAgICAgICAgICAgbWVudS52ZWxvY2l0eSh7J3RyYW5zbGF0ZVgnOiBbMCwgLTEgKiBvcHRpb25zLm1lbnVXaWR0aF19LCB7ZHVyYXRpb246IDMwMCwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAkZHJhZ1RhcmdldC5jc3Moe3dpZHRoOiAnNTAlJywgcmlnaHQ6ICcnLCBsZWZ0OiAwfSk7XG4gICAgICAgICAgICAgIG1lbnUudmVsb2NpdHkoeyd0cmFuc2xhdGVYJzogWzAsIG9wdGlvbnMubWVudVdpZHRoXX0sIHtkdXJhdGlvbjogMzAwLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkb3ZlcmxheS5jc3MoJ29wYWNpdHknLCAwKVxuICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIG1lbnVPdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcGFubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICByZW1vdmVNZW51KCk7XG4gICAgICAgICAgICAgICRvdmVybGF5LnZlbG9jaXR5KHtvcGFjaXR5OiAwfSwge2R1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSB9KTtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkKCdib2R5JykuYXBwZW5kKCRvdmVybGF5KTtcbiAgICAgICAgICAgICRvdmVybGF5LnZlbG9jaXR5KHtvcGFjaXR5OiAxfSwge2R1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG1lbnVPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG5cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkb3ZlcmxheSA9ICQoJyNzaWRlbmF2LW92ZXJsYXknKTtcbiAgICAgIHZhciAkZHJhZ1RhcmdldCA9ICQoJy5kcmFnLXRhcmdldFtkYXRhLXNpZGVuYXY9XCInICsgJCh0aGlzKS5hdHRyKCdkYXRhLWFjdGl2YXRlcycpICsgJ1wiXScpO1xuICAgICAgJG92ZXJsYXkudHJpZ2dlcignY2xpY2snKTtcbiAgICAgICRkcmFnVGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgJCh0aGlzKS5vZmYoJ2NsaWNrJyk7XG4gICAgICAkb3ZlcmxheS5yZW1vdmUoKTtcbiAgICB9LFxuICAgIHNob3cgOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignY2xpY2snKTtcbiAgICB9LFxuICAgIGhpZGUgOiBmdW5jdGlvbigpIHtcbiAgICAgICQoJyNzaWRlbmF2LW92ZXJsYXknKS50cmlnZ2VyKCdjbGljaycpO1xuICAgIH1cbiAgfTtcblxuXG4gICQuZm4uc2lkZU5hdiA9IGZ1bmN0aW9uKG1ldGhvZE9yT3B0aW9ucykge1xuICAgIGlmICggbWV0aG9kc1ttZXRob2RPck9wdGlvbnNdICkge1xuICAgICAgcmV0dXJuIG1ldGhvZHNbIG1ldGhvZE9yT3B0aW9ucyBdLmFwcGx5KCB0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICkpO1xuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBtZXRob2RPck9wdGlvbnMgPT09ICdvYmplY3QnIHx8ICEgbWV0aG9kT3JPcHRpb25zICkge1xuICAgICAgLy8gRGVmYXVsdCB0byBcImluaXRcIlxuICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQuZXJyb3IoICdNZXRob2QgJyArICBtZXRob2RPck9wdGlvbnMgKyAnIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS5zaWRlTmF2JyApO1xuICAgIH1cbiAgfTsgLy8gUGx1Z2luIGVuZFxufSggalF1ZXJ5ICkpO1xuOy8qKlxuICogRXh0ZW5kIGpxdWVyeSB3aXRoIGEgc2Nyb2xsc3B5IHBsdWdpbi5cbiAqIFRoaXMgd2F0Y2hlcyB0aGUgd2luZG93IHNjcm9sbCBhbmQgZmlyZXMgZXZlbnRzIHdoZW4gZWxlbWVudHMgYXJlIHNjcm9sbGVkIGludG8gdmlld3BvcnQuXG4gKlxuICogdGhyb3R0bGUoKSBhbmQgZ2V0VGltZSgpIHRha2VuIGZyb20gVW5kZXJzY29yZS5qc1xuICogaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlXG4gKlxuICogQGF1dGhvciBDb3B5cmlnaHQgMjAxMyBKb2huIFNtYXJ0XG4gKiBAbGljZW5zZSBodHRwczovL3Jhdy5naXRodWIuY29tL3RoZXNtYXJ0L2pxdWVyeS1zY3JvbGxzcHkvbWFzdGVyL0xJQ0VOU0VcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZXNtYXJ0XG4gKiBAdmVyc2lvbiAwLjEuMlxuICovXG4oZnVuY3Rpb24oJCkge1xuXG5cdHZhciBqV2luZG93ID0gJCh3aW5kb3cpO1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblx0dmFyIGVsZW1lbnRzSW5WaWV3ID0gW107XG5cdHZhciBpc1NweWluZyA9IGZhbHNlO1xuXHR2YXIgdGlja3MgPSAwO1xuXHR2YXIgdW5pcXVlX2lkID0gMTtcblx0dmFyIG9mZnNldCA9IHtcblx0XHR0b3AgOiAwLFxuXHRcdHJpZ2h0IDogMCxcblx0XHRib3R0b20gOiAwLFxuXHRcdGxlZnQgOiAwLFxuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmQgZWxlbWVudHMgdGhhdCBhcmUgd2l0aGluIHRoZSBib3VuZGFyeVxuXHQgKiBAcGFyYW0ge251bWJlcn0gdG9wXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByaWdodFxuXHQgKiBAcGFyYW0ge251bWJlcn0gYm90dG9tXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0XG5cdCAqIEByZXR1cm4ge2pRdWVyeX1cdFx0QSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzXG5cdCAqL1xuXHRmdW5jdGlvbiBmaW5kRWxlbWVudHModG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KSB7XG5cdFx0dmFyIGhpdHMgPSAkKCk7XG5cdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihpLCBlbGVtZW50KSB7XG5cdFx0XHRpZiAoZWxlbWVudC5oZWlnaHQoKSA+IDApIHtcblx0XHRcdFx0dmFyIGVsVG9wID0gZWxlbWVudC5vZmZzZXQoKS50b3AsXG5cdFx0XHRcdFx0ZWxMZWZ0ID0gZWxlbWVudC5vZmZzZXQoKS5sZWZ0LFxuXHRcdFx0XHRcdGVsUmlnaHQgPSBlbExlZnQgKyBlbGVtZW50LndpZHRoKCksXG5cdFx0XHRcdFx0ZWxCb3R0b20gPSBlbFRvcCArIGVsZW1lbnQuaGVpZ2h0KCk7XG5cblx0XHRcdFx0dmFyIGlzSW50ZXJzZWN0ID0gIShlbExlZnQgPiByaWdodCB8fFxuXHRcdFx0XHRcdGVsUmlnaHQgPCBsZWZ0IHx8XG5cdFx0XHRcdFx0ZWxUb3AgPiBib3R0b20gfHxcblx0XHRcdFx0XHRlbEJvdHRvbSA8IHRvcCk7XG5cblx0XHRcdFx0aWYgKGlzSW50ZXJzZWN0KSB7XG5cdFx0XHRcdFx0aGl0cy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gaGl0cztcblx0fVxuXG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSB1c2VyIHNjcm9sbHMgdGhlIHdpbmRvd1xuXHQgKi9cblx0ZnVuY3Rpb24gb25TY3JvbGwoc2Nyb2xsT2Zmc2V0KSB7XG5cdFx0Ly8gdW5pcXVlIHRpY2sgaWRcblx0XHQrK3RpY2tzO1xuXG5cdFx0Ly8gdmlld3BvcnQgcmVjdGFuZ2xlXG5cdFx0dmFyIHRvcCA9IGpXaW5kb3cuc2Nyb2xsVG9wKCksXG5cdFx0XHRsZWZ0ID0galdpbmRvdy5zY3JvbGxMZWZ0KCksXG5cdFx0XHRyaWdodCA9IGxlZnQgKyBqV2luZG93LndpZHRoKCksXG5cdFx0XHRib3R0b20gPSB0b3AgKyBqV2luZG93LmhlaWdodCgpO1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIHdoaWNoIGVsZW1lbnRzIGFyZSBpbiB2aWV3XG5cdFx0dmFyIGludGVyc2VjdGlvbnMgPSBmaW5kRWxlbWVudHModG9wK29mZnNldC50b3AgKyBzY3JvbGxPZmZzZXQgfHwgMjAwLCByaWdodCtvZmZzZXQucmlnaHQsIGJvdHRvbStvZmZzZXQuYm90dG9tLCBsZWZ0K29mZnNldC5sZWZ0KTtcblx0XHQkLmVhY2goaW50ZXJzZWN0aW9ucywgZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXG5cdFx0XHR2YXIgbGFzdFRpY2sgPSBlbGVtZW50LmRhdGEoJ3Njcm9sbFNweTp0aWNrcycpO1xuXHRcdFx0aWYgKHR5cGVvZiBsYXN0VGljayAhPSAnbnVtYmVyJykge1xuXHRcdFx0XHQvLyBlbnRlcmVkIGludG8gdmlld1xuXHRcdFx0XHRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdzY3JvbGxTcHk6ZW50ZXInKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIHRpY2sgaWRcblx0XHRcdGVsZW1lbnQuZGF0YSgnc2Nyb2xsU3B5OnRpY2tzJywgdGlja3MpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIHdoaWNoIGVsZW1lbnRzIGFyZSBubyBsb25nZXIgaW4gdmlld1xuXHRcdCQuZWFjaChlbGVtZW50c0luVmlldywgZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXHRcdFx0dmFyIGxhc3RUaWNrID0gZWxlbWVudC5kYXRhKCdzY3JvbGxTcHk6dGlja3MnKTtcblx0XHRcdGlmICh0eXBlb2YgbGFzdFRpY2sgPT0gJ251bWJlcicgJiYgbGFzdFRpY2sgIT09IHRpY2tzKSB7XG5cdFx0XHRcdC8vIGV4aXRlZCBmcm9tIHZpZXdcblx0XHRcdFx0ZWxlbWVudC50cmlnZ2VySGFuZGxlcignc2Nyb2xsU3B5OmV4aXQnKTtcblx0XHRcdFx0ZWxlbWVudC5kYXRhKCdzY3JvbGxTcHk6dGlja3MnLCBudWxsKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIHJlbWVtYmVyIGVsZW1lbnRzIGluIHZpZXcgZm9yIG5leHQgdGlja1xuXHRcdGVsZW1lbnRzSW5WaWV3ID0gaW50ZXJzZWN0aW9ucztcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiB3aW5kb3cgaXMgcmVzaXplZFxuXHQqL1xuXHRmdW5jdGlvbiBvbldpblNpemUoKSB7XG5cdFx0aldpbmRvdy50cmlnZ2VyKCdzY3JvbGxTcHk6d2luU2l6ZScpO1xuXHR9XG5cblxuXHQvKipcblx0ICogRW5hYmxlcyBTY3JvbGxTcHkgdXNpbmcgYSBzZWxlY3RvclxuXHQgKiBAcGFyYW0ge2pRdWVyeXxzdHJpbmd9IHNlbGVjdG9yICBUaGUgZWxlbWVudHMgY29sbGVjdGlvbiwgb3IgYSBzZWxlY3RvclxuXHQgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcdE9wdGlvbmFsLlxuICAgICAgICB0aHJvdHRsZSA6IG51bWJlciAtPiBzY3JvbGxzcHkgdGhyb3R0bGluZy4gRGVmYXVsdDogMTAwIG1zXG4gICAgICAgIG9mZnNldFRvcCA6IG51bWJlciAtPiBvZmZzZXQgZnJvbSB0b3AuIERlZmF1bHQ6IDBcbiAgICAgICAgb2Zmc2V0UmlnaHQgOiBudW1iZXIgLT4gb2Zmc2V0IGZyb20gcmlnaHQuIERlZmF1bHQ6IDBcbiAgICAgICAgb2Zmc2V0Qm90dG9tIDogbnVtYmVyIC0+IG9mZnNldCBmcm9tIGJvdHRvbS4gRGVmYXVsdDogMFxuICAgICAgICBvZmZzZXRMZWZ0IDogbnVtYmVyIC0+IG9mZnNldCBmcm9tIGxlZnQuIERlZmF1bHQ6IDBcblx0ICogQHJldHVybnMge2pRdWVyeX1cblx0ICovXG5cdCQuc2Nyb2xsU3B5ID0gZnVuY3Rpb24oc2VsZWN0b3IsIG9wdGlvbnMpIHtcblx0ICB2YXIgZGVmYXVsdHMgPSB7XG5cdFx0XHR0aHJvdHRsZTogMTAwLFxuXHRcdFx0c2Nyb2xsT2Zmc2V0OiAyMDAgLy8gb2Zmc2V0IC0gMjAwIGFsbG93cyBlbGVtZW50cyBuZWFyIGJvdHRvbSBvZiBwYWdlIHRvIHNjcm9sbFxuICAgIH07XG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuXHRcdHZhciB2aXNpYmxlID0gW107XG5cdFx0c2VsZWN0b3IgPSAkKHNlbGVjdG9yKTtcblx0XHRzZWxlY3Rvci5lYWNoKGZ1bmN0aW9uKGksIGVsZW1lbnQpIHtcblx0XHRcdGVsZW1lbnRzLnB1c2goJChlbGVtZW50KSk7XG5cdFx0XHQkKGVsZW1lbnQpLmRhdGEoXCJzY3JvbGxTcHk6aWRcIiwgaSk7XG5cdFx0XHQvLyBTbW9vdGggc2Nyb2xsIHRvIHNlY3Rpb25cblx0XHQgICQoJ2FbaHJlZj1cIiMnICsgJChlbGVtZW50KS5hdHRyKCdpZCcpICsgJ1wiXScpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcblx0XHQgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdCAgICB2YXIgb2Zmc2V0ID0gJChNYXRlcmlhbGl6ZS5lc2NhcGVIYXNoKHRoaXMuaGFzaCkpLm9mZnNldCgpLnRvcCArIDE7XG5cdCAgICBcdCQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHsgc2Nyb2xsVG9wOiBvZmZzZXQgLSBvcHRpb25zLnNjcm9sbE9mZnNldCB9LCB7ZHVyYXRpb246IDQwMCwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0Q3ViaWMnfSk7XG5cdFx0ICB9KTtcblx0XHR9KTtcblxuXHRcdG9mZnNldC50b3AgPSBvcHRpb25zLm9mZnNldFRvcCB8fCAwO1xuXHRcdG9mZnNldC5yaWdodCA9IG9wdGlvbnMub2Zmc2V0UmlnaHQgfHwgMDtcblx0XHRvZmZzZXQuYm90dG9tID0gb3B0aW9ucy5vZmZzZXRCb3R0b20gfHwgMDtcblx0XHRvZmZzZXQubGVmdCA9IG9wdGlvbnMub2Zmc2V0TGVmdCB8fCAwO1xuXG5cdFx0dmFyIHRocm90dGxlZFNjcm9sbCA9IE1hdGVyaWFsaXplLnRocm90dGxlKGZ1bmN0aW9uKCkge1xuXHRcdFx0b25TY3JvbGwob3B0aW9ucy5zY3JvbGxPZmZzZXQpO1xuXHRcdH0sIG9wdGlvbnMudGhyb3R0bGUgfHwgMTAwKTtcblx0XHR2YXIgcmVhZHlTY3JvbGwgPSBmdW5jdGlvbigpe1xuXHRcdFx0JChkb2N1bWVudCkucmVhZHkodGhyb3R0bGVkU2Nyb2xsKTtcblx0XHR9O1xuXG5cdFx0aWYgKCFpc1NweWluZykge1xuXHRcdFx0aldpbmRvdy5vbignc2Nyb2xsJywgcmVhZHlTY3JvbGwpO1xuXHRcdFx0aldpbmRvdy5vbigncmVzaXplJywgcmVhZHlTY3JvbGwpO1xuXHRcdFx0aXNTcHlpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIHBlcmZvcm0gYSBzY2FuIG9uY2UsIGFmdGVyIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQsIGFuZCBhZnRlciBkb20gaXMgcmVhZHlcblx0XHRzZXRUaW1lb3V0KHJlYWR5U2Nyb2xsLCAwKTtcblxuXG5cdFx0c2VsZWN0b3Iub24oJ3Njcm9sbFNweTplbnRlcicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmlzaWJsZSA9ICQuZ3JlcCh2aXNpYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdmFsdWUuaGVpZ2h0KCkgIT0gMDtcblx0ICAgIH0pO1xuXG5cdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXG5cdFx0XHRpZiAodmlzaWJsZVswXSkge1xuXHRcdFx0XHQkKCdhW2hyZWY9XCIjJyArIHZpc2libGVbMF0uYXR0cignaWQnKSArICdcIl0nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHRcdGlmICgkdGhpcy5kYXRhKCdzY3JvbGxTcHk6aWQnKSA8IHZpc2libGVbMF0uZGF0YSgnc2Nyb2xsU3B5OmlkJykpIHtcblx0XHRcdFx0XHR2aXNpYmxlLnVuc2hpZnQoJCh0aGlzKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmlzaWJsZS5wdXNoKCQodGhpcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmlzaWJsZS5wdXNoKCQodGhpcykpO1xuXHRcdFx0fVxuXG5cblx0XHRcdCQoJ2FbaHJlZj1cIiMnICsgdmlzaWJsZVswXS5hdHRyKCdpZCcpICsgJ1wiXScpLmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XHR9KTtcblx0XHRzZWxlY3Rvci5vbignc2Nyb2xsU3B5OmV4aXQnLCBmdW5jdGlvbigpIHtcblx0XHRcdHZpc2libGUgPSAkLmdyZXAodmlzaWJsZSwgZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlLmhlaWdodCgpICE9IDA7XG5cdCAgICB9KTtcblxuXHRcdFx0aWYgKHZpc2libGVbMF0pIHtcblx0XHRcdFx0JCgnYVtocmVmPVwiIycgKyB2aXNpYmxlWzBdLmF0dHIoJ2lkJykgKyAnXCJdJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdFx0XHR2aXNpYmxlID0gJC5ncmVwKHZpc2libGUsIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLmF0dHIoJ2lkJykgIT0gJHRoaXMuYXR0cignaWQnKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIGlmICh2aXNpYmxlWzBdKSB7IC8vIENoZWNrIGlmIGVtcHR5XG5cdFx0XHRcdFx0JCgnYVtocmVmPVwiIycgKyB2aXNpYmxlWzBdLmF0dHIoJ2lkJykgKyAnXCJdJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXHQgICAgICB9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gc2VsZWN0b3I7XG5cdH07XG5cblx0LyoqXG5cdCAqIExpc3RlbiBmb3Igd2luZG93IHJlc2l6ZSBldmVudHNcblx0ICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXHRcdFx0XHRcdFx0T3B0aW9uYWwuIFNldCB7IHRocm90dGxlOiBudW1iZXIgfSB0byBjaGFuZ2UgdGhyb3R0bGluZy4gRGVmYXVsdDogMTAwIG1zXG5cdCAqIEByZXR1cm5zIHtqUXVlcnl9XHRcdCQod2luZG93KVxuXHQgKi9cblx0JC53aW5TaXplU3B5ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdCQud2luU2l6ZVNweSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4galdpbmRvdzsgfTsgLy8gbG9jayBmcm9tIG11bHRpcGxlIGNhbGxzXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuXHRcdFx0dGhyb3R0bGU6IDEwMFxuXHRcdH07XG5cdFx0cmV0dXJuIGpXaW5kb3cub24oJ3Jlc2l6ZScsIE1hdGVyaWFsaXplLnRocm90dGxlKG9uV2luU2l6ZSwgb3B0aW9ucy50aHJvdHRsZSB8fCAxMDApKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5hYmxlcyBTY3JvbGxTcHkgb24gYSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzXG5cdCAqIGUuZy4gJCgnLnNjcm9sbFNweScpLnNjcm9sbFNweSgpXG5cdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1x0T3B0aW9uYWwuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3R0bGUgOiBudW1iZXIgLT4gc2Nyb2xsc3B5IHRocm90dGxpbmcuIERlZmF1bHQ6IDEwMCBtc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldFRvcCA6IG51bWJlciAtPiBvZmZzZXQgZnJvbSB0b3AuIERlZmF1bHQ6IDBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXRSaWdodCA6IG51bWJlciAtPiBvZmZzZXQgZnJvbSByaWdodC4gRGVmYXVsdDogMFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldEJvdHRvbSA6IG51bWJlciAtPiBvZmZzZXQgZnJvbSBib3R0b20uIERlZmF1bHQ6IDBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXRMZWZ0IDogbnVtYmVyIC0+IG9mZnNldCBmcm9tIGxlZnQuIERlZmF1bHQ6IDBcblx0ICogQHJldHVybnMge2pRdWVyeX1cblx0ICovXG5cdCQuZm4uc2Nyb2xsU3B5ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiAkLnNjcm9sbFNweSgkKHRoaXMpLCBvcHRpb25zKTtcblx0fTtcblxufSkoalF1ZXJ5KTtcbjsoZnVuY3Rpb24gKCQpIHtcbiAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgbGFiZWxzIG9mIHRleHQgZmllbGRzXG4gICAgTWF0ZXJpYWxpemUudXBkYXRlVGV4dEZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlucHV0X3NlbGVjdG9yID0gJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9cGFzc3dvcmRdLCBpbnB1dFt0eXBlPWVtYWlsXSwgaW5wdXRbdHlwZT11cmxdLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0W3R5cGU9bnVtYmVyXSwgaW5wdXRbdHlwZT1zZWFyY2hdLCB0ZXh0YXJlYSc7XG4gICAgICAkKGlucHV0X3NlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgIGlmICgkKGVsZW1lbnQpLnZhbCgpLmxlbmd0aCA+IDAgfHwgZWxlbWVudC5hdXRvZm9jdXMgfHwgJHRoaXMuYXR0cigncGxhY2Vob2xkZXInKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgJHRoaXMuc2libGluZ3MoJ2xhYmVsJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB9IGVsc2UgaWYgKCQoZWxlbWVudClbMF0udmFsaWRpdHkpIHtcbiAgICAgICAgICAkdGhpcy5zaWJsaW5ncygnbGFiZWwnKS50b2dnbGVDbGFzcygnYWN0aXZlJywgJChlbGVtZW50KVswXS52YWxpZGl0eS5iYWRJbnB1dCA9PT0gdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHRoaXMuc2libGluZ3MoJ2xhYmVsJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gVGV4dCBiYXNlZCBpbnB1dHNcbiAgICB2YXIgaW5wdXRfc2VsZWN0b3IgPSAnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1wYXNzd29yZF0sIGlucHV0W3R5cGU9ZW1haWxdLCBpbnB1dFt0eXBlPXVybF0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXRbdHlwZT1udW1iZXJdLCBpbnB1dFt0eXBlPXNlYXJjaF0sIHRleHRhcmVhJztcblxuICAgIC8vIEFkZCBhY3RpdmUgaWYgZm9ybSBhdXRvIGNvbXBsZXRlXG4gICAgJChkb2N1bWVudCkub24oJ2NoYW5nZScsIGlucHV0X3NlbGVjdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZigkKHRoaXMpLnZhbCgpLmxlbmd0aCAhPT0gMCB8fCAkKHRoaXMpLmF0dHIoJ3BsYWNlaG9sZGVyJykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAkKHRoaXMpLnNpYmxpbmdzKCdsYWJlbCcpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlX2ZpZWxkKCQodGhpcykpO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGFjdGl2ZSBpZiBpbnB1dCBlbGVtZW50IGhhcyBiZWVuIHByZS1wb3B1bGF0ZWQgb24gZG9jdW1lbnQgcmVhZHlcbiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgIE1hdGVyaWFsaXplLnVwZGF0ZVRleHRGaWVsZHMoKTtcbiAgICB9KTtcblxuICAgIC8vIEhUTUwgRE9NIEZPUk0gUkVTRVQgaGFuZGxpbmdcbiAgICAkKGRvY3VtZW50KS5vbigncmVzZXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgZm9ybVJlc2V0ID0gJChlLnRhcmdldCk7XG4gICAgICBpZiAoZm9ybVJlc2V0LmlzKCdmb3JtJykpIHtcbiAgICAgICAgZm9ybVJlc2V0LmZpbmQoaW5wdXRfc2VsZWN0b3IpLnJlbW92ZUNsYXNzKCd2YWxpZCcpLnJlbW92ZUNsYXNzKCdpbnZhbGlkJyk7XG4gICAgICAgIGZvcm1SZXNldC5maW5kKGlucHV0X3NlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoJCh0aGlzKS5hdHRyKCd2YWx1ZScpID09PSAnJykge1xuICAgICAgICAgICAgJCh0aGlzKS5zaWJsaW5ncygnbGFiZWwnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZXNldCBzZWxlY3RcbiAgICAgICAgZm9ybVJlc2V0LmZpbmQoJ3NlbGVjdC5pbml0aWFsaXplZCcpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXNldF90ZXh0ID0gZm9ybVJlc2V0LmZpbmQoJ29wdGlvbltzZWxlY3RlZF0nKS50ZXh0KCk7XG4gICAgICAgICAgZm9ybVJlc2V0LnNpYmxpbmdzKCdpbnB1dC5zZWxlY3QtZHJvcGRvd24nKS52YWwocmVzZXRfdGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQWRkIGFjdGl2ZSB3aGVuIGVsZW1lbnQgaGFzIGZvY3VzXG4gICAgJChkb2N1bWVudCkub24oJ2ZvY3VzJywgaW5wdXRfc2VsZWN0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICQodGhpcykuc2libGluZ3MoJ2xhYmVsLCAucHJlZml4JykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIH0pO1xuXG4gICAgJChkb2N1bWVudCkub24oJ2JsdXInLCBpbnB1dF9zZWxlY3RvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRpbnB1dEVsZW1lbnQgPSAkKHRoaXMpO1xuICAgICAgdmFyIHNlbGVjdG9yID0gXCIucHJlZml4XCI7XG5cbiAgICAgIGlmICgkaW5wdXRFbGVtZW50LnZhbCgpLmxlbmd0aCA9PT0gMCAmJiAkaW5wdXRFbGVtZW50WzBdLnZhbGlkaXR5LmJhZElucHV0ICE9PSB0cnVlICYmICRpbnB1dEVsZW1lbnQuYXR0cigncGxhY2Vob2xkZXInKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGVjdG9yICs9IFwiLCBsYWJlbFwiO1xuICAgICAgfVxuXG4gICAgICAkaW5wdXRFbGVtZW50LnNpYmxpbmdzKHNlbGVjdG9yKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cbiAgICAgIHZhbGlkYXRlX2ZpZWxkKCRpbnB1dEVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgd2luZG93LnZhbGlkYXRlX2ZpZWxkID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgaGFzTGVuZ3RoID0gb2JqZWN0LmF0dHIoJ2RhdGEtbGVuZ3RoJykgIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBsZW5BdHRyID0gcGFyc2VJbnQob2JqZWN0LmF0dHIoJ2RhdGEtbGVuZ3RoJykpO1xuICAgICAgdmFyIGxlbiA9IG9iamVjdC52YWwoKS5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmplY3QudmFsKCkubGVuZ3RoID09PSAwICYmIG9iamVjdFswXS52YWxpZGl0eS5iYWRJbnB1dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG9iamVjdC5oYXNDbGFzcygndmFsaWRhdGUnKSkge1xuICAgICAgICAgIG9iamVjdC5yZW1vdmVDbGFzcygndmFsaWQnKTtcbiAgICAgICAgICBvYmplY3QucmVtb3ZlQ2xhc3MoJ2ludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChvYmplY3QuaGFzQ2xhc3MoJ3ZhbGlkYXRlJykpIHtcbiAgICAgICAgICAvLyBDaGVjayBmb3IgY2hhcmFjdGVyIGNvdW50ZXIgYXR0cmlidXRlc1xuICAgICAgICAgIGlmICgob2JqZWN0LmlzKCc6dmFsaWQnKSAmJiBoYXNMZW5ndGggJiYgKGxlbiA8PSBsZW5BdHRyKSkgfHwgKG9iamVjdC5pcygnOnZhbGlkJykgJiYgIWhhc0xlbmd0aCkpIHtcbiAgICAgICAgICAgIG9iamVjdC5yZW1vdmVDbGFzcygnaW52YWxpZCcpO1xuICAgICAgICAgICAgb2JqZWN0LmFkZENsYXNzKCd2YWxpZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iamVjdC5yZW1vdmVDbGFzcygndmFsaWQnKTtcbiAgICAgICAgICAgIG9iamVjdC5hZGRDbGFzcygnaW52YWxpZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBSYWRpbyBhbmQgQ2hlY2tib3ggZm9jdXMgY2xhc3NcbiAgICB2YXIgcmFkaW9fY2hlY2tib3ggPSAnaW5wdXRbdHlwZT1yYWRpb10sIGlucHV0W3R5cGU9Y2hlY2tib3hdJztcbiAgICAkKGRvY3VtZW50KS5vbigna2V5dXAucmFkaW8nLCByYWRpb19jaGVja2JveCwgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gVEFCLCBjaGVjayBpZiB0YWJiaW5nIHRvIHJhZGlvIG9yIGNoZWNrYm94LlxuICAgICAgaWYgKGUud2hpY2ggPT09IDkpIHtcbiAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygndGFiYmVkJyk7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICR0aGlzLm9uZSgnYmx1cicsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ3RhYmJlZCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVGV4dGFyZWEgQXV0byBSZXNpemVcbiAgICB2YXIgaGlkZGVuRGl2ID0gJCgnLmhpZGRlbmRpdicpLmZpcnN0KCk7XG4gICAgaWYgKCFoaWRkZW5EaXYubGVuZ3RoKSB7XG4gICAgICBoaWRkZW5EaXYgPSAkKCc8ZGl2IGNsYXNzPVwiaGlkZGVuZGl2IGNvbW1vblwiPjwvZGl2PicpO1xuICAgICAgJCgnYm9keScpLmFwcGVuZChoaWRkZW5EaXYpO1xuICAgIH1cbiAgICB2YXIgdGV4dF9hcmVhX3NlbGVjdG9yID0gJy5tYXRlcmlhbGl6ZS10ZXh0YXJlYSc7XG5cbiAgICBmdW5jdGlvbiB0ZXh0YXJlYUF1dG9SZXNpemUoJHRleHRhcmVhKSB7XG4gICAgICAvLyBTZXQgZm9udCBwcm9wZXJ0aWVzIG9mIGhpZGRlbkRpdlxuXG4gICAgICB2YXIgZm9udEZhbWlseSA9ICR0ZXh0YXJlYS5jc3MoJ2ZvbnQtZmFtaWx5Jyk7XG4gICAgICB2YXIgZm9udFNpemUgPSAkdGV4dGFyZWEuY3NzKCdmb250LXNpemUnKTtcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gJHRleHRhcmVhLmNzcygnbGluZS1oZWlnaHQnKTtcblxuICAgICAgaWYgKGZvbnRTaXplKSB7IGhpZGRlbkRpdi5jc3MoJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKTsgfVxuICAgICAgaWYgKGZvbnRGYW1pbHkpIHsgaGlkZGVuRGl2LmNzcygnZm9udC1mYW1pbHknLCBmb250RmFtaWx5KTsgfVxuICAgICAgaWYgKGxpbmVIZWlnaHQpIHsgaGlkZGVuRGl2LmNzcygnbGluZS1oZWlnaHQnLCBsaW5lSGVpZ2h0KTsgfVxuXG4gICAgICBpZiAoJHRleHRhcmVhLmF0dHIoJ3dyYXAnKSA9PT0gXCJvZmZcIikge1xuICAgICAgICBoaWRkZW5EaXYuY3NzKCdvdmVyZmxvdy13cmFwJywgXCJub3JtYWxcIilcbiAgICAgICAgICAgICAgICAgLmNzcygnd2hpdGUtc3BhY2UnLCBcInByZVwiKTtcbiAgICAgIH1cblxuICAgICAgaGlkZGVuRGl2LnRleHQoJHRleHRhcmVhLnZhbCgpICsgJ1xcbicpO1xuICAgICAgdmFyIGNvbnRlbnQgPSBoaWRkZW5EaXYuaHRtbCgpLnJlcGxhY2UoL1xcbi9nLCAnPGJyPicpO1xuICAgICAgaGlkZGVuRGl2Lmh0bWwoY29udGVudCk7XG5cblxuICAgICAgLy8gV2hlbiB0ZXh0YXJlYSBpcyBoaWRkZW4sIHdpZHRoIGdvZXMgY3JhenkuXG4gICAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGhhbGYgb2Ygd2luZG93IHNpemVcblxuICAgICAgaWYgKCR0ZXh0YXJlYS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICBoaWRkZW5EaXYuY3NzKCd3aWR0aCcsICR0ZXh0YXJlYS53aWR0aCgpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBoaWRkZW5EaXYuY3NzKCd3aWR0aCcsICQod2luZG93KS53aWR0aCgpLzIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlc2l6ZSBpZiB0aGUgbmV3IGhlaWdodCBpcyBncmVhdGVyIHRoYW4gdGhlXG4gICAgICAgKiBvcmlnaW5hbCBoZWlnaHQgb2YgdGhlIHRleHRhcmVhXG4gICAgICAgKi9cbiAgICAgIGlmICgkdGV4dGFyZWEuZGF0YShcIm9yaWdpbmFsLWhlaWdodFwiKSA8PSBoaWRkZW5EaXYuaGVpZ2h0KCkpIHtcbiAgICAgICAgJHRleHRhcmVhLmNzcygnaGVpZ2h0JywgaGlkZGVuRGl2LmhlaWdodCgpKTtcbiAgICAgIH0gZWxzZSBpZiAoJHRleHRhcmVhLnZhbCgpLmxlbmd0aCA8ICR0ZXh0YXJlYS5kYXRhKFwicHJldmlvdXMtbGVuZ3RoXCIpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBjYXNlIHRoZSBuZXcgaGVpZ2h0IGlzIGxlc3MgdGhhbiBvcmlnaW5hbCBoZWlnaHQsIGl0XG4gICAgICAgICAqIG1lYW5zIHRoZSB0ZXh0YXJlYSBoYXMgbGVzcyB0ZXh0IHRoYW4gYmVmb3JlXG4gICAgICAgICAqIFNvIHdlIHNldCB0aGUgaGVpZ2h0IHRvIHRoZSBvcmlnaW5hbCBvbmVcbiAgICAgICAgICovXG4gICAgICAgICR0ZXh0YXJlYS5jc3MoJ2hlaWdodCcsICR0ZXh0YXJlYS5kYXRhKFwib3JpZ2luYWwtaGVpZ2h0XCIpKTtcbiAgICAgIH1cbiAgICAgICR0ZXh0YXJlYS5kYXRhKFwicHJldmlvdXMtbGVuZ3RoXCIsICR0ZXh0YXJlYS52YWwoKS5sZW5ndGgpO1xuICAgIH1cblxuICAgICQodGV4dF9hcmVhX3NlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGV4dGFyZWEgPSAkKHRoaXMpO1xuICAgICAgLyoqXG4gICAgICAgKiBJbnN0ZWFkIG9mIHJlc2l6aW5nIHRleHRhcmVhIG9uIGRvY3VtZW50IGxvYWQsXG4gICAgICAgKiBzdG9yZSB0aGUgb3JpZ2luYWwgaGVpZ2h0IGFuZCB0aGUgb3JpZ2luYWwgbGVuZ3RoXG4gICAgICAgKi9cbiAgICAgICR0ZXh0YXJlYS5kYXRhKFwib3JpZ2luYWwtaGVpZ2h0XCIsICR0ZXh0YXJlYS5oZWlnaHQoKSk7XG4gICAgICAkdGV4dGFyZWEuZGF0YShcInByZXZpb3VzLWxlbmd0aFwiLCAkdGV4dGFyZWEudmFsKCkubGVuZ3RoKTtcbiAgICB9KTtcblxuICAgICQoJ2JvZHknKS5vbigna2V5dXAga2V5ZG93biBhdXRvcmVzaXplJywgdGV4dF9hcmVhX3NlbGVjdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0ZXh0YXJlYUF1dG9SZXNpemUoJCh0aGlzKSk7XG4gICAgfSk7XG5cbiAgICAvLyBGaWxlIElucHV0IFBhdGhcbiAgICAkKGRvY3VtZW50KS5vbignY2hhbmdlJywgJy5maWxlLWZpZWxkIGlucHV0W3R5cGU9XCJmaWxlXCJdJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZpbGVfZmllbGQgPSAkKHRoaXMpLmNsb3Nlc3QoJy5maWxlLWZpZWxkJyk7XG4gICAgICB2YXIgcGF0aF9pbnB1dCA9IGZpbGVfZmllbGQuZmluZCgnaW5wdXQuZmlsZS1wYXRoJyk7XG4gICAgICB2YXIgZmlsZXMgICAgICA9ICQodGhpcylbMF0uZmlsZXM7XG4gICAgICB2YXIgZmlsZV9uYW1lcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmaWxlX25hbWVzLnB1c2goZmlsZXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgICBwYXRoX2lucHV0LnZhbChmaWxlX25hbWVzLmpvaW4oXCIsIFwiKSk7XG4gICAgICBwYXRoX2lucHV0LnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pO1xuXG4gICAgLyoqKioqKioqKioqKioqKipcbiAgICAqICBSYW5nZSBJbnB1dCAgKlxuICAgICoqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgcmFuZ2VfdHlwZSA9ICdpbnB1dFt0eXBlPXJhbmdlXSc7XG4gICAgdmFyIHJhbmdlX21vdXNlZG93biA9IGZhbHNlO1xuICAgIHZhciBsZWZ0O1xuXG4gICAgJChyYW5nZV90eXBlKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aHVtYiA9ICQoJzxzcGFuIGNsYXNzPVwidGh1bWJcIj48c3BhbiBjbGFzcz1cInZhbHVlXCI+PC9zcGFuPjwvc3Bhbj4nKTtcbiAgICAgICQodGhpcykuYWZ0ZXIodGh1bWIpO1xuICAgIH0pO1xuXG4gICAgdmFyIHNob3dSYW5nZUJ1YmJsZSA9IGZ1bmN0aW9uKHRodW1iKSB7XG4gICAgICB2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUludCh0aHVtYi5wYXJlbnQoKS5jc3MoJ3BhZGRpbmctbGVmdCcpKTtcbiAgICAgIHZhciBtYXJnaW5MZWZ0ID0gKC03ICsgcGFkZGluZ0xlZnQpICsgJ3B4JztcbiAgICAgIHRodW1iLnZlbG9jaXR5KHsgaGVpZ2h0OiBcIjMwcHhcIiwgd2lkdGg6IFwiMzBweFwiLCB0b3A6IFwiLTMwcHhcIiwgbWFyZ2luTGVmdDogbWFyZ2luTGVmdH0sIHsgZHVyYXRpb246IDMwMCwgZWFzaW5nOiAnZWFzZU91dEV4cG8nIH0pO1xuICAgIH07XG5cbiAgICB2YXIgY2FsY1JhbmdlT2Zmc2V0ID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgIHZhciB3aWR0aCA9IHJhbmdlLndpZHRoKCkgLSAxNTtcbiAgICAgIHZhciBtYXggPSBwYXJzZUZsb2F0KHJhbmdlLmF0dHIoJ21heCcpKTtcbiAgICAgIHZhciBtaW4gPSBwYXJzZUZsb2F0KHJhbmdlLmF0dHIoJ21pbicpKTtcbiAgICAgIHZhciBwZXJjZW50ID0gKHBhcnNlRmxvYXQocmFuZ2UudmFsKCkpIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgICAgcmV0dXJuIHBlcmNlbnQgKiB3aWR0aDtcbiAgICB9XG5cbiAgICB2YXIgcmFuZ2Vfd3JhcHBlciA9ICcucmFuZ2UtZmllbGQnO1xuICAgICQoZG9jdW1lbnQpLm9uKCdjaGFuZ2UnLCByYW5nZV90eXBlLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdGh1bWIgPSAkKHRoaXMpLnNpYmxpbmdzKCcudGh1bWInKTtcbiAgICAgIHRodW1iLmZpbmQoJy52YWx1ZScpLmh0bWwoJCh0aGlzKS52YWwoKSk7XG5cbiAgICAgIGlmICghdGh1bWIuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG4gICAgICAgIHNob3dSYW5nZUJ1YmJsZSh0aHVtYik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXRMZWZ0ID0gY2FsY1JhbmdlT2Zmc2V0KCQodGhpcykpO1xuICAgICAgdGh1bWIuYWRkQ2xhc3MoJ2FjdGl2ZScpLmNzcygnbGVmdCcsIG9mZnNldExlZnQpO1xuICAgIH0pO1xuXG4gICAgJChkb2N1bWVudCkub24oJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgcmFuZ2VfdHlwZSwgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRodW1iID0gJCh0aGlzKS5zaWJsaW5ncygnLnRodW1iJyk7XG5cbiAgICAgIC8vIElmIHRodW1iIGluZGljYXRvciBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdFxuICAgICAgaWYgKHRodW1iLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgIHRodW1iID0gJCgnPHNwYW4gY2xhc3M9XCJ0aHVtYlwiPjxzcGFuIGNsYXNzPVwidmFsdWVcIj48L3NwYW4+PC9zcGFuPicpO1xuICAgICAgICAkKHRoaXMpLmFmdGVyKHRodW1iKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGluZGljYXRvciB2YWx1ZVxuICAgICAgdGh1bWIuZmluZCgnLnZhbHVlJykuaHRtbCgkKHRoaXMpLnZhbCgpKTtcblxuICAgICAgcmFuZ2VfbW91c2Vkb3duID0gdHJ1ZTtcbiAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXG4gICAgICBpZiAoIXRodW1iLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICBzaG93UmFuZ2VCdWJibGUodGh1bWIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50eXBlICE9PSAnaW5wdXQnKSB7XG4gICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gY2FsY1JhbmdlT2Zmc2V0KCQodGhpcykpO1xuICAgICAgICB0aHVtYi5hZGRDbGFzcygnYWN0aXZlJykuY3NzKCdsZWZ0Jywgb2Zmc2V0TGVmdCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAkKGRvY3VtZW50KS5vbignbW91c2V1cCB0b3VjaGVuZCcsIHJhbmdlX3dyYXBwZXIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmFuZ2VfbW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICB9KTtcblxuICAgICQoZG9jdW1lbnQpLm9uKCdpbnB1dCBtb3VzZW1vdmUgdG91Y2htb3ZlJywgcmFuZ2Vfd3JhcHBlciwgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRodW1iID0gJCh0aGlzKS5jaGlsZHJlbignLnRodW1iJyk7XG4gICAgICB2YXIgbGVmdDtcbiAgICAgIHZhciBpbnB1dCA9ICQodGhpcykuZmluZChyYW5nZV90eXBlKTtcblxuICAgICAgaWYgKHJhbmdlX21vdXNlZG93bikge1xuICAgICAgICBpZiAoIXRodW1iLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgIHNob3dSYW5nZUJ1YmJsZSh0aHVtYik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IGNhbGNSYW5nZU9mZnNldChpbnB1dCk7XG4gICAgICAgIHRodW1iLmFkZENsYXNzKCdhY3RpdmUnKS5jc3MoJ2xlZnQnLCBvZmZzZXRMZWZ0KTtcbiAgICAgICAgdGh1bWIuZmluZCgnLnZhbHVlJykuaHRtbCh0aHVtYi5zaWJsaW5ncyhyYW5nZV90eXBlKS52YWwoKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAkKGRvY3VtZW50KS5vbignbW91c2VvdXQgdG91Y2hsZWF2ZScsIHJhbmdlX3dyYXBwZXIsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFyYW5nZV9tb3VzZWRvd24pIHtcblxuICAgICAgICB2YXIgdGh1bWIgPSAkKHRoaXMpLmNoaWxkcmVuKCcudGh1bWInKTtcbiAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQoJCh0aGlzKS5jc3MoJ3BhZGRpbmctbGVmdCcpKTtcbiAgICAgICAgdmFyIG1hcmdpbkxlZnQgPSAoNyArIHBhZGRpbmdMZWZ0KSArICdweCc7XG5cbiAgICAgICAgaWYgKHRodW1iLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgIHRodW1iLnZlbG9jaXR5KHsgaGVpZ2h0OiAnMCcsIHdpZHRoOiAnMCcsIHRvcDogJzEwcHgnLCBtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0fSwgeyBkdXJhdGlvbjogMTAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRodW1iLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIEF1dG8gY29tcGxldGUgcGx1Z2luICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgJC5mbi5hdXRvY29tcGxldGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgLy8gRGVmYXVsdHNcbiAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgZGF0YToge30sXG4gICAgICAgIGxpbWl0OiBJbmZpbml0eSxcbiAgICAgICAgb25BdXRvY29tcGxldGU6IG51bGwsXG4gICAgICAgIG1pbkxlbmd0aDogMVxuICAgICAgfTtcblxuICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICRpbnB1dCA9ICQodGhpcyk7XG4gICAgICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhLFxuICAgICAgICAgICAgY291bnQgPSAwLFxuICAgICAgICAgICAgYWN0aXZlSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG9sZFZhbCxcbiAgICAgICAgICAgICRpbnB1dERpdiA9ICRpbnB1dC5jbG9zZXN0KCcuaW5wdXQtZmllbGQnKTsgLy8gRGl2IHRvIGFwcGVuZCBvblxuXG4gICAgICAgIC8vIENoZWNrIGlmIGRhdGEgaXNuJ3QgZW1wdHlcbiAgICAgICAgaWYgKCEkLmlzRW1wdHlPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICB2YXIgJGF1dG9jb21wbGV0ZSA9ICQoJzx1bCBjbGFzcz1cImF1dG9jb21wbGV0ZS1jb250ZW50IGRyb3Bkb3duLWNvbnRlbnRcIj48L3VsPicpO1xuICAgICAgICAgIHZhciAkb2xkQXV0b2NvbXBsZXRlO1xuXG4gICAgICAgICAgLy8gQXBwZW5kIGF1dG9jb21wbGV0ZSBlbGVtZW50LlxuICAgICAgICAgIC8vIFByZXZlbnQgZG91YmxlIHN0cnVjdHVyZSBpbml0LlxuICAgICAgICAgIGlmICgkaW5wdXREaXYubGVuZ3RoKSB7XG4gICAgICAgICAgICAkb2xkQXV0b2NvbXBsZXRlID0gJGlucHV0RGl2LmNoaWxkcmVuKCcuYXV0b2NvbXBsZXRlLWNvbnRlbnQuZHJvcGRvd24tY29udGVudCcpLmZpcnN0KCk7XG4gICAgICAgICAgICBpZiAoISRvbGRBdXRvY29tcGxldGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICRpbnB1dERpdi5hcHBlbmQoJGF1dG9jb21wbGV0ZSk7IC8vIFNldCB1bCBpbiBib2R5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRvbGRBdXRvY29tcGxldGUgPSAkaW5wdXQubmV4dCgnLmF1dG9jb21wbGV0ZS1jb250ZW50LmRyb3Bkb3duLWNvbnRlbnQnKTtcbiAgICAgICAgICAgIGlmICghJG9sZEF1dG9jb21wbGV0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgJGlucHV0LmFmdGVyKCRhdXRvY29tcGxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJG9sZEF1dG9jb21wbGV0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICRhdXRvY29tcGxldGUgPSAkb2xkQXV0b2NvbXBsZXRlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEhpZ2hsaWdodCBwYXJ0aWFsIG1hdGNoLlxuICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBmdW5jdGlvbihzdHJpbmcsICRlbCkge1xuICAgICAgICAgICAgdmFyIGltZyA9ICRlbC5maW5kKCdpbWcnKTtcbiAgICAgICAgICAgIHZhciBtYXRjaFN0YXJ0ID0gJGVsLnRleHQoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJcIiArIHN0cmluZy50b0xvd2VyQ2FzZSgpICsgXCJcIiksXG4gICAgICAgICAgICAgICAgbWF0Y2hFbmQgPSBtYXRjaFN0YXJ0ICsgc3RyaW5nLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgYmVmb3JlTWF0Y2ggPSAkZWwudGV4dCgpLnNsaWNlKDAsIG1hdGNoU3RhcnQpLFxuICAgICAgICAgICAgICAgIG1hdGNoVGV4dCA9ICRlbC50ZXh0KCkuc2xpY2UobWF0Y2hTdGFydCwgbWF0Y2hFbmQgKyAxKSxcbiAgICAgICAgICAgICAgICBhZnRlck1hdGNoID0gJGVsLnRleHQoKS5zbGljZShtYXRjaEVuZCArIDEpO1xuICAgICAgICAgICAgJGVsLmh0bWwoXCI8c3Bhbj5cIiArIGJlZm9yZU1hdGNoICsgXCI8c3BhbiBjbGFzcz0naGlnaGxpZ2h0Jz5cIiArIG1hdGNoVGV4dCArIFwiPC9zcGFuPlwiICsgYWZ0ZXJNYXRjaCArIFwiPC9zcGFuPlwiKTtcbiAgICAgICAgICAgIGlmIChpbWcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICRlbC5wcmVwZW5kKGltZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIFJlc2V0IGN1cnJlbnQgZWxlbWVudCBwb3NpdGlvblxuICAgICAgICAgIHZhciByZXNldEN1cnJlbnRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhY3RpdmVJbmRleCA9IC0xO1xuICAgICAgICAgICAgJGF1dG9jb21wbGV0ZS5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlbW92ZSBhdXRvY29tcGxldGUgZWxlbWVudHNcbiAgICAgICAgICB2YXIgcmVtb3ZlQXV0b2NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkYXV0b2NvbXBsZXRlLmVtcHR5KCk7XG4gICAgICAgICAgICByZXNldEN1cnJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICBvbGRWYWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgICRpbnB1dC5vZmYoJ2JsdXIuYXV0b2NvbXBsZXRlJykub24oJ2JsdXIuYXV0b2NvbXBsZXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW1vdmVBdXRvY29tcGxldGUoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFBlcmZvcm0gc2VhcmNoXG4gICAgICAgICAgJGlucHV0Lm9mZigna2V5dXAuYXV0b2NvbXBsZXRlIGZvY3VzLmF1dG9jb21wbGV0ZScpLm9uKCdrZXl1cC5hdXRvY29tcGxldGUgZm9jdXMuYXV0b2NvbXBsZXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGNvdW50LlxuICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIHZhbCA9ICRpbnB1dC52YWwoKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBjYXB0dXJlIGVudGVyIG9yIGFycm93IGtleSB1c2FnZS5cbiAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMyB8fFxuICAgICAgICAgICAgICAgIGUud2hpY2ggPT09IDM4IHx8XG4gICAgICAgICAgICAgICAgZS53aGljaCA9PT0gNDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbnB1dCBpc24ndCBlbXB0eVxuICAgICAgICAgICAgaWYgKG9sZFZhbCAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUF1dG9jb21wbGV0ZSgpO1xuXG4gICAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID49IG9wdGlvbnMubWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGtleS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsKSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKSAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJyZWFrIGlmIHBhc3QgbGltaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID49IG9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdXRvY29tcGxldGVPcHRpb24gPSAkKCc8bGk+PC9saT4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhZGF0YVtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlT3B0aW9uLmFwcGVuZCgnPGltZyBzcmM9XCInKyBkYXRhW2tleV0gKydcIiBjbGFzcz1cInJpZ2h0IGNpcmNsZVwiPjxzcGFuPicrIGtleSArJzwvc3Bhbj4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdXRvY29tcGxldGVPcHRpb24uYXBwZW5kKCc8c3Bhbj4nKyBrZXkgKyc8L3NwYW4+Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkYXV0b2NvbXBsZXRlLmFwcGVuZChhdXRvY29tcGxldGVPcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQodmFsLCBhdXRvY29tcGxldGVPcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgb2xkVmFsXG4gICAgICAgICAgICBvbGRWYWwgPSB2YWw7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAkaW5wdXQub2ZmKCdrZXlkb3duLmF1dG9jb21wbGV0ZScpLm9uKCdrZXlkb3duLmF1dG9jb21wbGV0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBBcnJvdyBrZXlzIGFuZCBlbnRlciBrZXkgdXNhZ2VcbiAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZS53aGljaCxcbiAgICAgICAgICAgICAgICBsaUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbnVtSXRlbXMgPSAkYXV0b2NvbXBsZXRlLmNoaWxkcmVuKCdsaScpLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAkYWN0aXZlID0gJGF1dG9jb21wbGV0ZS5jaGlsZHJlbignLmFjdGl2ZScpLmZpcnN0KCk7XG5cbiAgICAgICAgICAgIC8vIHNlbGVjdCBlbGVtZW50IG9uIEVudGVyXG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gMTMgJiYgYWN0aXZlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICBsaUVsZW1lbnQgPSAkYXV0b2NvbXBsZXRlLmNoaWxkcmVuKCdsaScpLmVxKGFjdGl2ZUluZGV4KTtcbiAgICAgICAgICAgICAgaWYgKGxpRWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsaUVsZW1lbnQudHJpZ2dlcignbW91c2Vkb3duLmF1dG9jb21wbGV0ZScpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhcHR1cmUgdXAgYW5kIGRvd24ga2V5XG4gICAgICAgICAgICBpZiAoIGtleUNvZGUgPT09IDM4IHx8IGtleUNvZGUgPT09IDQwICkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IDM4ICYmXG4gICAgICAgICAgICAgICAgICBhY3RpdmVJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmRleC0tO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IDQwICYmXG4gICAgICAgICAgICAgICAgICBhY3RpdmVJbmRleCA8IChudW1JdGVtcyAtIDEpKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlSW5kZXgrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICBpZiAoYWN0aXZlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICRhdXRvY29tcGxldGUuY2hpbGRyZW4oJ2xpJykuZXEoYWN0aXZlSW5kZXgpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU2V0IGlucHV0IHZhbHVlXG4gICAgICAgICAgJGF1dG9jb21wbGV0ZS5vbignbW91c2Vkb3duLmF1dG9jb21wbGV0ZSB0b3VjaHN0YXJ0LmF1dG9jb21wbGV0ZScsICdsaScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gJCh0aGlzKS50ZXh0KCkudHJpbSgpO1xuICAgICAgICAgICAgJGlucHV0LnZhbCh0ZXh0KTtcbiAgICAgICAgICAgICRpbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIHJlbW92ZUF1dG9jb21wbGV0ZSgpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgb25BdXRvY29tcGxldGUgY2FsbGJhY2suXG4gICAgICAgICAgICBpZiAodHlwZW9mKG9wdGlvbnMub25BdXRvY29tcGxldGUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5vbkF1dG9jb21wbGV0ZS5jYWxsKHRoaXMsIHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gIH0pOyAvLyBFbmQgb2YgJChkb2N1bWVudCkucmVhZHlcblxuICAvKioqKioqKioqKioqKioqKioqKlxuICAgKiAgU2VsZWN0IFBsdWdpbiAgKlxuICAgKioqKioqKioqKioqKioqKioqL1xuICAkLmZuLm1hdGVyaWFsX3NlbGVjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICQodGhpcykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyICRzZWxlY3QgPSAkKHRoaXMpO1xuXG4gICAgICBpZiAoJHNlbGVjdC5oYXNDbGFzcygnYnJvd3Nlci1kZWZhdWx0JykpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBDb250aW51ZSB0byBuZXh0IChyZXR1cm4gZmFsc2UgYnJlYWtzIG91dCBvZiBlbnRpcmUgbG9vcClcbiAgICAgIH1cblxuICAgICAgdmFyIG11bHRpcGxlID0gJHNlbGVjdC5hdHRyKCdtdWx0aXBsZScpID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgIGxhc3RJRCA9ICRzZWxlY3QuZGF0YSgnc2VsZWN0LWlkJyk7IC8vIFRlYXIgZG93biBzdHJ1Y3R1cmUgaWYgU2VsZWN0IG5lZWRzIHRvIGJlIHJlYnVpbHRcblxuICAgICAgaWYgKGxhc3RJRCkge1xuICAgICAgICAkc2VsZWN0LnBhcmVudCgpLmZpbmQoJ3NwYW4uY2FyZXQnKS5yZW1vdmUoKTtcbiAgICAgICAgJHNlbGVjdC5wYXJlbnQoKS5maW5kKCdpbnB1dCcpLnJlbW92ZSgpO1xuXG4gICAgICAgICRzZWxlY3QudW53cmFwKCk7XG4gICAgICAgICQoJ3VsI3NlbGVjdC1vcHRpb25zLScrbGFzdElEKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZGVzdHJveWluZyB0aGUgc2VsZWN0LCByZW1vdmUgdGhlIHNlbGVsY3QtaWQgYW5kIHJlc2V0IGl0IHRvIGl0J3MgdW5pbml0aWFsaXplZCBzdGF0ZS5cbiAgICAgIGlmKGNhbGxiYWNrID09PSAnZGVzdHJveScpIHtcbiAgICAgICAgJHNlbGVjdC5kYXRhKCdzZWxlY3QtaWQnLCBudWxsKS5yZW1vdmVDbGFzcygnaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdW5pcXVlSUQgPSBNYXRlcmlhbGl6ZS5ndWlkKCk7XG4gICAgICAkc2VsZWN0LmRhdGEoJ3NlbGVjdC1pZCcsIHVuaXF1ZUlEKTtcbiAgICAgIHZhciB3cmFwcGVyID0gJCgnPGRpdiBjbGFzcz1cInNlbGVjdC13cmFwcGVyXCI+PC9kaXY+Jyk7XG4gICAgICB3cmFwcGVyLmFkZENsYXNzKCRzZWxlY3QuYXR0cignY2xhc3MnKSk7XG4gICAgICB2YXIgb3B0aW9ucyA9ICQoJzx1bCBpZD1cInNlbGVjdC1vcHRpb25zLScgKyB1bmlxdWVJRCArJ1wiIGNsYXNzPVwiZHJvcGRvd24tY29udGVudCBzZWxlY3QtZHJvcGRvd24gJyArIChtdWx0aXBsZSA/ICdtdWx0aXBsZS1zZWxlY3QtZHJvcGRvd24nIDogJycpICsgJ1wiPjwvdWw+JyksXG4gICAgICAgICAgc2VsZWN0Q2hpbGRyZW4gPSAkc2VsZWN0LmNoaWxkcmVuKCdvcHRpb24sIG9wdGdyb3VwJyksXG4gICAgICAgICAgdmFsdWVzU2VsZWN0ZWQgPSBbXSxcbiAgICAgICAgICBvcHRpb25zSG92ZXIgPSBmYWxzZTtcblxuICAgICAgdmFyIGxhYmVsID0gJHNlbGVjdC5maW5kKCdvcHRpb246c2VsZWN0ZWQnKS5odG1sKCkgfHwgJHNlbGVjdC5maW5kKCdvcHRpb246Zmlyc3QnKS5odG1sKCkgfHwgXCJcIjtcblxuICAgICAgLy8gRnVuY3Rpb24gdGhhdCByZW5kZXJzIGFuZCBhcHBlbmRzIHRoZSBvcHRpb24gdGFraW5nIGludG9cbiAgICAgIC8vIGFjY291bnQgdHlwZSBhbmQgcG9zc2libGUgaW1hZ2UgaWNvbi5cbiAgICAgIHZhciBhcHBlbmRPcHRpb25XaXRoSWNvbiA9IGZ1bmN0aW9uKHNlbGVjdCwgb3B0aW9uLCB0eXBlKSB7XG4gICAgICAgIC8vIEFkZCBkaXNhYmxlZCBhdHRyIGlmIGRpc2FibGVkXG4gICAgICAgIHZhciBkaXNhYmxlZENsYXNzID0gKG9wdGlvbi5pcygnOmRpc2FibGVkJykpID8gJ2Rpc2FibGVkICcgOiAnJztcbiAgICAgICAgdmFyIG9wdGdyb3VwQ2xhc3MgPSAodHlwZSA9PT0gJ29wdGdyb3VwLW9wdGlvbicpID8gJ29wdGdyb3VwLW9wdGlvbiAnIDogJyc7XG4gICAgICAgIHZhciBtdWx0aXBsZUNoZWNrYm94ID0gbXVsdGlwbGUgPyAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiJyArIGRpc2FibGVkQ2xhc3MgKyAnLz48bGFiZWw+PC9sYWJlbD4nIDogJyc7XG5cbiAgICAgICAgLy8gYWRkIGljb25zXG4gICAgICAgIHZhciBpY29uX3VybCA9IG9wdGlvbi5kYXRhKCdpY29uJyk7XG4gICAgICAgIHZhciBjbGFzc2VzID0gb3B0aW9uLmF0dHIoJ2NsYXNzJyk7XG4gICAgICAgIGlmICghIWljb25fdXJsKSB7XG4gICAgICAgICAgdmFyIGNsYXNzU3RyaW5nID0gJyc7XG4gICAgICAgICAgaWYgKCEhY2xhc3NlcykgY2xhc3NTdHJpbmcgPSAnIGNsYXNzPVwiJyArIGNsYXNzZXMgKyAnXCInO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIG11bHRpcGxlIHR5cGUuXG4gICAgICAgICAgb3B0aW9ucy5hcHBlbmQoJCgnPGxpIGNsYXNzPVwiJyArIGRpc2FibGVkQ2xhc3MgKyBvcHRncm91cENsYXNzICsgJ1wiPjxpbWcgYWx0PVwiXCIgc3JjPVwiJyArIGljb25fdXJsICsgJ1wiJyArIGNsYXNzU3RyaW5nICsgJz48c3Bhbj4nICsgbXVsdGlwbGVDaGVja2JveCArIG9wdGlvbi5odG1sKCkgKyAnPC9zcGFuPjwvbGk+JykpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG11bHRpcGxlIHR5cGUuXG4gICAgICAgIG9wdGlvbnMuYXBwZW5kKCQoJzxsaSBjbGFzcz1cIicgKyBkaXNhYmxlZENsYXNzICsgb3B0Z3JvdXBDbGFzcyArICdcIj48c3Bhbj4nICsgbXVsdGlwbGVDaGVja2JveCArIG9wdGlvbi5odG1sKCkgKyAnPC9zcGFuPjwvbGk+JykpO1xuICAgICAgfTtcblxuICAgICAgLyogQ3JlYXRlIGRyb3Bkb3duIHN0cnVjdHVyZS4gKi9cbiAgICAgIGlmIChzZWxlY3RDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgc2VsZWN0Q2hpbGRyZW4uZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnb3B0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIERpcmVjdCBkZXNjZW5kYW50IG9wdGlvbi5cbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICBhcHBlbmRPcHRpb25XaXRoSWNvbigkc2VsZWN0LCAkKHRoaXMpLCAnbXVsdGlwbGUnKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uV2l0aEljb24oJHNlbGVjdCwgJCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICgkKHRoaXMpLmlzKCdvcHRncm91cCcpKSB7XG4gICAgICAgICAgICAvLyBPcHRncm91cC5cbiAgICAgICAgICAgIHZhciBzZWxlY3RPcHRpb25zID0gJCh0aGlzKS5jaGlsZHJlbignb3B0aW9uJyk7XG4gICAgICAgICAgICBvcHRpb25zLmFwcGVuZCgkKCc8bGkgY2xhc3M9XCJvcHRncm91cFwiPjxzcGFuPicgKyAkKHRoaXMpLmF0dHIoJ2xhYmVsJykgKyAnPC9zcGFuPjwvbGk+JykpO1xuXG4gICAgICAgICAgICBzZWxlY3RPcHRpb25zLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGFwcGVuZE9wdGlvbldpdGhJY29uKCRzZWxlY3QsICQodGhpcyksICdvcHRncm91cC1vcHRpb24nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuZmluZCgnbGk6bm90KC5vcHRncm91cCknKS5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICQodGhpcykuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBvcHRpb24gZWxlbWVudCBpcyBkaXNhYmxlZFxuICAgICAgICAgIGlmICghJCh0aGlzKS5oYXNDbGFzcygnZGlzYWJsZWQnKSAmJiAhJCh0aGlzKS5oYXNDbGFzcygnb3B0Z3JvdXAnKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICQoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScsIHRoaXMpLnByb3AoJ2NoZWNrZWQnLCBmdW5jdGlvbihpLCB2KSB7IHJldHVybiAhdjsgfSk7XG4gICAgICAgICAgICAgIHNlbGVjdGVkID0gdG9nZ2xlRW50cnlGcm9tQXJyYXkodmFsdWVzU2VsZWN0ZWQsIGksICRzZWxlY3QpO1xuICAgICAgICAgICAgICAkbmV3U2VsZWN0LnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcHRpb25zLmZpbmQoJ2xpJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAkKHRoaXMpLnRvZ2dsZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgJG5ld1NlbGVjdC52YWwoJCh0aGlzKS50ZXh0KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhY3RpdmF0ZU9wdGlvbihvcHRpb25zLCAkKHRoaXMpKTtcbiAgICAgICAgICAgICRzZWxlY3QuZmluZCgnb3B0aW9uJykuZXEoaSkucHJvcCgnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIG9uY2hhbmdlKCkgZXZlbnRcbiAgICAgICAgICAgICRzZWxlY3QudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAndW5kZWZpbmVkJykgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXcmFwIEVsZW1lbnRzXG4gICAgICAkc2VsZWN0LndyYXAod3JhcHBlcik7XG4gICAgICAvLyBBZGQgU2VsZWN0IERpc3BsYXkgRWxlbWVudFxuICAgICAgdmFyIGRyb3Bkb3duSWNvbiA9ICQoJzxzcGFuIGNsYXNzPVwiY2FyZXRcIj4mIzk2NjA7PC9zcGFuPicpO1xuICAgICAgaWYgKCRzZWxlY3QuaXMoJzpkaXNhYmxlZCcpKVxuICAgICAgICBkcm9wZG93bkljb24uYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cbiAgICAgIC8vIGVzY2FwZSBkb3VibGUgcXVvdGVzXG4gICAgICB2YXIgc2FuaXRpemVkTGFiZWxIdG1sID0gbGFiZWwucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuXG4gICAgICB2YXIgJG5ld1NlbGVjdCA9ICQoJzxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwic2VsZWN0LWRyb3Bkb3duXCIgcmVhZG9ubHk9XCJ0cnVlXCIgJyArICgoJHNlbGVjdC5pcygnOmRpc2FibGVkJykpID8gJ2Rpc2FibGVkJyA6ICcnKSArICcgZGF0YS1hY3RpdmF0ZXM9XCJzZWxlY3Qtb3B0aW9ucy0nICsgdW5pcXVlSUQgKydcIiB2YWx1ZT1cIicrIHNhbml0aXplZExhYmVsSHRtbCArJ1wiLz4nKTtcbiAgICAgICRzZWxlY3QuYmVmb3JlKCRuZXdTZWxlY3QpO1xuICAgICAgJG5ld1NlbGVjdC5iZWZvcmUoZHJvcGRvd25JY29uKTtcblxuICAgICAgJG5ld1NlbGVjdC5hZnRlcihvcHRpb25zKTtcbiAgICAgIC8vIENoZWNrIGlmIHNlY3Rpb24gZWxlbWVudCBpcyBkaXNhYmxlZFxuICAgICAgaWYgKCEkc2VsZWN0LmlzKCc6ZGlzYWJsZWQnKSkge1xuICAgICAgICAkbmV3U2VsZWN0LmRyb3Bkb3duKHsnaG92ZXInOiBmYWxzZX0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IHRhYmluZGV4XG4gICAgICBpZiAoJHNlbGVjdC5hdHRyKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICQoJG5ld1NlbGVjdFswXSkuYXR0cigndGFiaW5kZXgnLCAkc2VsZWN0LmF0dHIoJ3RhYmluZGV4JykpO1xuICAgICAgfVxuXG4gICAgICAkc2VsZWN0LmFkZENsYXNzKCdpbml0aWFsaXplZCcpO1xuXG4gICAgICAkbmV3U2VsZWN0Lm9uKHtcbiAgICAgICAgJ2ZvY3VzJzogZnVuY3Rpb24gKCl7XG4gICAgICAgICAgaWYgKCQoJ3VsLnNlbGVjdC1kcm9wZG93bicpLm5vdChvcHRpb25zWzBdKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgJCgnaW5wdXQuc2VsZWN0LWRyb3Bkb3duJykudHJpZ2dlcignY2xvc2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAkKHRoaXMpLnRyaWdnZXIoJ29wZW4nLCBbJ2ZvY3VzJ10pO1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gJCh0aGlzKS52YWwoKTtcbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSAmJiBsYWJlbC5pbmRleE9mKCcsJykgPj0gMCkge1xuICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnNwbGl0KCcsJylbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RlZE9wdGlvbiA9IG9wdGlvbnMuZmluZCgnbGknKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLnRleHQoKS50b0xvd2VyQ2FzZSgpID09PSBsYWJlbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICBhY3RpdmF0ZU9wdGlvbihvcHRpb25zLCBzZWxlY3RlZE9wdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnY2xpY2snOiBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgICRuZXdTZWxlY3Qub24oJ2JsdXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgICAgICQodGhpcykudHJpZ2dlcignY2xvc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmZpbmQoJ2xpLnNlbGVjdGVkJykucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICB9KTtcblxuICAgICAgb3B0aW9ucy5ob3ZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgb3B0aW9uc0hvdmVyID0gdHJ1ZTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3B0aW9uc0hvdmVyID0gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgJCh3aW5kb3cpLm9uKHtcbiAgICAgICAgJ2NsaWNrJzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG11bHRpcGxlICYmIChvcHRpb25zSG92ZXIgfHwgJG5ld1NlbGVjdC50cmlnZ2VyKCdjbG9zZScpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBpbml0aWFsIG11bHRpcGxlIHNlbGVjdGlvbnMuXG4gICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgJHNlbGVjdC5maW5kKFwib3B0aW9uOnNlbGVjdGVkOm5vdCg6ZGlzYWJsZWQpXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbmRleCA9ICQodGhpcykuaW5kZXgoKTtcblxuICAgICAgICAgIHRvZ2dsZUVudHJ5RnJvbUFycmF5KHZhbHVlc1NlbGVjdGVkLCBpbmRleCwgJHNlbGVjdCk7XG4gICAgICAgICAgb3B0aW9ucy5maW5kKFwibGlcIikuZXEoaW5kZXgpLmZpbmQoXCI6Y2hlY2tib3hcIikucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE1ha2Ugb3B0aW9uIGFzIHNlbGVjdGVkIGFuZCBzY3JvbGwgdG8gc2VsZWN0ZWQgcG9zaXRpb25cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBjb2xsZWN0aW9uICBTZWxlY3Qgb3B0aW9ucyBqUXVlcnkgZWxlbWVudFxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBuZXdPcHRpb24gIGVsZW1lbnQgb2YgdGhlIG5ldyBvcHRpb25cbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmlyc3RBY3RpdmF0aW9uICBJZiBvbiBmaXJzdCBhY3RpdmF0aW9uIG9mIHNlbGVjdFxuICAgICAgICovXG4gICAgICB2YXIgYWN0aXZhdGVPcHRpb24gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBuZXdPcHRpb24sIGZpcnN0QWN0aXZhdGlvbikge1xuICAgICAgICBpZiAobmV3T3B0aW9uKSB7XG4gICAgICAgICAgY29sbGVjdGlvbi5maW5kKCdsaS5zZWxlY3RlZCcpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgIHZhciBvcHRpb24gPSAkKG5ld09wdGlvbik7XG4gICAgICAgICAgb3B0aW9uLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgIGlmICghbXVsdGlwbGUgfHwgISFmaXJzdEFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2Nyb2xsVG8ob3B0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEFsbG93IHVzZXIgdG8gc2VhcmNoIGJ5IHR5cGluZ1xuICAgICAgLy8gdGhpcyBhcnJheSBpcyBjbGVhcmVkIGFmdGVyIDEgc2Vjb25kXG4gICAgICB2YXIgZmlsdGVyUXVlcnkgPSBbXSxcbiAgICAgICAgICBvbktleURvd24gPSBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIC8vIFRBQiAtIHN3aXRjaCB0byBhbm90aGVyIGlucHV0XG4gICAgICAgICAgICBpZihlLndoaWNoID09IDkpe1xuICAgICAgICAgICAgICAkbmV3U2VsZWN0LnRyaWdnZXIoJ2Nsb3NlJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQVJST1cgRE9XTiBXSEVOIFNFTEVDVCBJUyBDTE9TRUQgLSBvcGVuIHNlbGVjdCBvcHRpb25zXG4gICAgICAgICAgICBpZihlLndoaWNoID09IDQwICYmICFvcHRpb25zLmlzKCc6dmlzaWJsZScpKXtcbiAgICAgICAgICAgICAgJG5ld1NlbGVjdC50cmlnZ2VyKCdvcGVuJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRU5URVIgV0hFTiBTRUxFQ1QgSVMgQ0xPU0VEIC0gc3VibWl0IGZvcm1cbiAgICAgICAgICAgIGlmKGUud2hpY2ggPT0gMTMgJiYgIW9wdGlvbnMuaXMoJzp2aXNpYmxlJykpe1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgLy8gQ0FTRSBXSEVOIFVTRVIgVFlQRSBMRVRURVJTXG4gICAgICAgICAgICB2YXIgbGV0dGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLndoaWNoKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIG5vbkxldHRlcnMgPSBbOSwxMywyNywzOCw0MF07XG4gICAgICAgICAgICBpZiAobGV0dGVyICYmIChub25MZXR0ZXJzLmluZGV4T2YoZS53aGljaCkgPT09IC0xKSkge1xuICAgICAgICAgICAgICBmaWx0ZXJRdWVyeS5wdXNoKGxldHRlcik7XG5cbiAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IGZpbHRlclF1ZXJ5LmpvaW4oJycpLFxuICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gb3B0aW9ucy5maW5kKCdsaScpLmZpbHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcykudGV4dCgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHJpbmcpID09PSAwO1xuICAgICAgICAgICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICAgICAgaWYgKG5ld09wdGlvbikge1xuICAgICAgICAgICAgICAgIGFjdGl2YXRlT3B0aW9uKG9wdGlvbnMsIG5ld09wdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRU5URVIgLSBzZWxlY3Qgb3B0aW9uIGFuZCBjbG9zZSB3aGVuIHNlbGVjdCBvcHRpb25zIGFyZSBvcGVuZWRcbiAgICAgICAgICAgIGlmIChlLndoaWNoID09IDEzKSB7XG4gICAgICAgICAgICAgIHZhciBhY3RpdmVPcHRpb24gPSBvcHRpb25zLmZpbmQoJ2xpLnNlbGVjdGVkOm5vdCguZGlzYWJsZWQpJylbMF07XG4gICAgICAgICAgICAgIGlmKGFjdGl2ZU9wdGlvbil7XG4gICAgICAgICAgICAgICAgJChhY3RpdmVPcHRpb24pLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgJG5ld1NlbGVjdC50cmlnZ2VyKCdjbG9zZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBUlJPVyBET1dOIC0gbW92ZSB0byBuZXh0IG5vdCBkaXNhYmxlZCBvcHRpb25cbiAgICAgICAgICAgIGlmIChlLndoaWNoID09IDQwKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbmQoJ2xpLnNlbGVjdGVkJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gb3B0aW9ucy5maW5kKCdsaS5zZWxlY3RlZCcpLm5leHQoJ2xpOm5vdCguZGlzYWJsZWQpJylbMF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gb3B0aW9ucy5maW5kKCdsaTpub3QoLmRpc2FibGVkKScpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFjdGl2YXRlT3B0aW9uKG9wdGlvbnMsIG5ld09wdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVTQyAtIGNsb3NlIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChlLndoaWNoID09IDI3KSB7XG4gICAgICAgICAgICAgICRuZXdTZWxlY3QudHJpZ2dlcignY2xvc2UnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQVJST1cgVVAgLSBtb3ZlIHRvIHByZXZpb3VzIG5vdCBkaXNhYmxlZCBvcHRpb25cbiAgICAgICAgICAgIGlmIChlLndoaWNoID09IDM4KSB7XG4gICAgICAgICAgICAgIG5ld09wdGlvbiA9IG9wdGlvbnMuZmluZCgnbGkuc2VsZWN0ZWQnKS5wcmV2KCdsaTpub3QoLmRpc2FibGVkKScpWzBdO1xuICAgICAgICAgICAgICBpZihuZXdPcHRpb24pXG4gICAgICAgICAgICAgICAgYWN0aXZhdGVPcHRpb24ob3B0aW9ucywgbmV3T3B0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXV0b21hdGljYWx5IGNsZWFuIGZpbHRlciBxdWVyeSBzbyB1c2VyIGNhbiBzZWFyY2ggYWdhaW4gYnkgc3RhcnRpbmcgbGV0dGVyc1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyBmaWx0ZXJRdWVyeSA9IFtdOyB9LCAxMDAwKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAkbmV3U2VsZWN0Lm9uKCdrZXlkb3duJywgb25LZXlEb3duKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHRvZ2dsZUVudHJ5RnJvbUFycmF5KGVudHJpZXNBcnJheSwgZW50cnlJbmRleCwgc2VsZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSBlbnRyaWVzQXJyYXkuaW5kZXhPZihlbnRyeUluZGV4KSxcbiAgICAgICAgICBub3RBZGRlZCA9IGluZGV4ID09PSAtMTtcblxuICAgICAgaWYgKG5vdEFkZGVkKSB7XG4gICAgICAgIGVudHJpZXNBcnJheS5wdXNoKGVudHJ5SW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cmllc0FycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdC5zaWJsaW5ncygndWwuZHJvcGRvd24tY29udGVudCcpLmZpbmQoJ2xpOm5vdCgub3B0Z3JvdXApJykuZXEoZW50cnlJbmRleCkudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuXG4gICAgICAvLyB1c2Ugbm90QWRkZWQgaW5zdGVhZCBvZiB0cnVlICh0byBkZXRlY3QgaWYgdGhlIG9wdGlvbiBpcyBzZWxlY3RlZCBvciBub3QpXG4gICAgICBzZWxlY3QuZmluZCgnb3B0aW9uJykuZXEoZW50cnlJbmRleCkucHJvcCgnc2VsZWN0ZWQnLCBub3RBZGRlZCk7XG4gICAgICBzZXRWYWx1ZVRvSW5wdXQoZW50cmllc0FycmF5LCBzZWxlY3QpO1xuXG4gICAgICByZXR1cm4gbm90QWRkZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWVUb0lucHV0KGVudHJpZXNBcnJheSwgc2VsZWN0KSB7XG4gICAgICB2YXIgdmFsdWUgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGNvdW50ID0gZW50cmllc0FycmF5Lmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHRleHQgPSBzZWxlY3QuZmluZCgnb3B0aW9uJykuZXEoZW50cmllc0FycmF5W2ldKS50ZXh0KCk7XG5cbiAgICAgICAgaSA9PT0gMCA/IHZhbHVlICs9IHRleHQgOiB2YWx1ZSArPSAnLCAnICsgdGV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICB2YWx1ZSA9IHNlbGVjdC5maW5kKCdvcHRpb246ZGlzYWJsZWQnKS5lcSgwKS50ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdC5zaWJsaW5ncygnaW5wdXQuc2VsZWN0LWRyb3Bkb3duJykudmFsKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbn0oIGpRdWVyeSApKTtcbjsoZnVuY3Rpb24gKCQpIHtcblxuICB2YXIgbWV0aG9kcyA9IHtcblxuICAgIGluaXQgOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIGluZGljYXRvcnM6IHRydWUsXG4gICAgICAgIGhlaWdodDogNDAwLFxuICAgICAgICB0cmFuc2l0aW9uOiA1MDAsXG4gICAgICAgIGludGVydmFsOiA2MDAwXG4gICAgICB9O1xuICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBGb3IgZWFjaCBzbGlkZXIsIHdlIHdhbnQgdG8ga2VlcCB0cmFjayBvZlxuICAgICAgICAvLyB3aGljaCBzbGlkZSBpcyBhY3RpdmUgYW5kIGl0cyBhc3NvY2lhdGVkIGNvbnRlbnRcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgdmFyICRzbGlkZXIgPSAkdGhpcy5maW5kKCd1bC5zbGlkZXMnKS5maXJzdCgpO1xuICAgICAgICB2YXIgJHNsaWRlcyA9ICRzbGlkZXIuZmluZCgnPiBsaScpO1xuICAgICAgICB2YXIgJGFjdGl2ZV9pbmRleCA9ICRzbGlkZXIuZmluZCgnLmFjdGl2ZScpLmluZGV4KCk7XG4gICAgICAgIHZhciAkYWN0aXZlLCAkaW5kaWNhdG9ycywgJGludGVydmFsO1xuICAgICAgICBpZiAoJGFjdGl2ZV9pbmRleCAhPSAtMSkgeyAkYWN0aXZlID0gJHNsaWRlcy5lcSgkYWN0aXZlX2luZGV4KTsgfVxuXG4gICAgICAgIC8vIFRyYW5zaXRpb25zIHRoZSBjYXB0aW9uIGRlcGVuZGluZyBvbiBhbGlnbm1lbnRcbiAgICAgICAgZnVuY3Rpb24gY2FwdGlvblRyYW5zaXRpb24oY2FwdGlvbiwgZHVyYXRpb24pIHtcbiAgICAgICAgICBpZiAoY2FwdGlvbi5oYXNDbGFzcyhcImNlbnRlci1hbGlnblwiKSkge1xuICAgICAgICAgICAgY2FwdGlvbi52ZWxvY2l0eSh7b3BhY2l0eTogMCwgdHJhbnNsYXRlWTogLTEwMH0sIHtkdXJhdGlvbjogZHVyYXRpb24sIHF1ZXVlOiBmYWxzZX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjYXB0aW9uLmhhc0NsYXNzKFwicmlnaHQtYWxpZ25cIikpIHtcbiAgICAgICAgICAgIGNhcHRpb24udmVsb2NpdHkoe29wYWNpdHk6IDAsIHRyYW5zbGF0ZVg6IDEwMH0sIHtkdXJhdGlvbjogZHVyYXRpb24sIHF1ZXVlOiBmYWxzZX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjYXB0aW9uLmhhc0NsYXNzKFwibGVmdC1hbGlnblwiKSkge1xuICAgICAgICAgICAgY2FwdGlvbi52ZWxvY2l0eSh7b3BhY2l0eTogMCwgdHJhbnNsYXRlWDogLTEwMH0sIHtkdXJhdGlvbjogZHVyYXRpb24sIHF1ZXVlOiBmYWxzZX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCB0cmFuc2l0aW9uIHRoZSBzbGlkZSB0byBhbnkgaW5kZXggb2YgdGhlIG5leHQgc2xpZGVcbiAgICAgICAgZnVuY3Rpb24gbW92ZVRvU2xpZGUoaW5kZXgpIHtcbiAgICAgICAgICAvLyBXcmFwIGFyb3VuZCBpbmRpY2VzLlxuICAgICAgICAgIGlmIChpbmRleCA+PSAkc2xpZGVzLmxlbmd0aCkgaW5kZXggPSAwO1xuICAgICAgICAgIGVsc2UgaWYgKGluZGV4IDwgMCkgaW5kZXggPSAkc2xpZGVzLmxlbmd0aCAtMTtcblxuICAgICAgICAgICRhY3RpdmVfaW5kZXggPSAkc2xpZGVyLmZpbmQoJy5hY3RpdmUnKS5pbmRleCgpO1xuXG4gICAgICAgICAgLy8gT25seSBkbyBpZiBpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgaWYgKCRhY3RpdmVfaW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgICRhY3RpdmUgPSAkc2xpZGVzLmVxKCRhY3RpdmVfaW5kZXgpO1xuICAgICAgICAgICAgJGNhcHRpb24gPSAkYWN0aXZlLmZpbmQoJy5jYXB0aW9uJyk7XG5cbiAgICAgICAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgJGFjdGl2ZS52ZWxvY2l0eSh7b3BhY2l0eTogMH0sIHtkdXJhdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNsaWRlcy5ub3QoJy5hY3RpdmUnKS52ZWxvY2l0eSh7b3BhY2l0eTogMCwgdHJhbnNsYXRlWDogMCwgdHJhbnNsYXRlWTogMH0sIHtkdXJhdGlvbjogMCwgcXVldWU6IGZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgY2FwdGlvblRyYW5zaXRpb24oJGNhcHRpb24sIG9wdGlvbnMudHJhbnNpdGlvbik7XG5cblxuICAgICAgICAgICAgLy8gVXBkYXRlIGluZGljYXRvcnNcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluZGljYXRvcnMpIHtcbiAgICAgICAgICAgICAgJGluZGljYXRvcnMuZXEoJGFjdGl2ZV9pbmRleCkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkc2xpZGVzLmVxKGluZGV4KS52ZWxvY2l0eSh7b3BhY2l0eTogMX0sIHtkdXJhdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ30pO1xuICAgICAgICAgICAgJHNsaWRlcy5lcShpbmRleCkuZmluZCgnLmNhcHRpb24nKS52ZWxvY2l0eSh7b3BhY2l0eTogMSwgdHJhbnNsYXRlWDogMCwgdHJhbnNsYXRlWTogMH0sIHtkdXJhdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLCBkZWxheTogb3B0aW9ucy50cmFuc2l0aW9uLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ30pO1xuICAgICAgICAgICAgJHNsaWRlcy5lcShpbmRleCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3JzXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbmRpY2F0b3JzKSB7XG4gICAgICAgICAgICAgICRpbmRpY2F0b3JzLmVxKGluZGV4KS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGhlaWdodCBvZiBzbGlkZXJcbiAgICAgICAgLy8gSWYgZnVsbHNjcmVlbiwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoISR0aGlzLmhhc0NsYXNzKCdmdWxsc2NyZWVuJykpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5pbmRpY2F0b3JzKSB7XG4gICAgICAgICAgICAvLyBBZGQgaGVpZ2h0IGlmIGluZGljYXRvcnMgYXJlIHByZXNlbnRcbiAgICAgICAgICAgICR0aGlzLmhlaWdodChvcHRpb25zLmhlaWdodCArIDQwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkdGhpcy5oZWlnaHQob3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkc2xpZGVyLmhlaWdodChvcHRpb25zLmhlaWdodCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFNldCBpbml0aWFsIHBvc2l0aW9ucyBvZiBjYXB0aW9uc1xuICAgICAgICAkc2xpZGVzLmZpbmQoJy5jYXB0aW9uJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FwdGlvblRyYW5zaXRpb24oJCh0aGlzKSwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1vdmUgaW1nIHNyYyBpbnRvIGJhY2tncm91bmQtaW1hZ2VcbiAgICAgICAgJHNsaWRlcy5maW5kKCdpbWcnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJCYXNlNjQgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUJBUC8vL3dBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PSc7XG4gICAgICAgICAgaWYgKCQodGhpcykuYXR0cignc3JjJykgIT09IHBsYWNlaG9sZGVyQmFzZTY0KSB7XG4gICAgICAgICAgICAkKHRoaXMpLmNzcygnYmFja2dyb3VuZC1pbWFnZScsICd1cmwoJyArICQodGhpcykuYXR0cignc3JjJykgKyAnKScgKTtcbiAgICAgICAgICAgICQodGhpcykuYXR0cignc3JjJywgcGxhY2Vob2xkZXJCYXNlNjQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZHluYW1pY2FsbHkgYWRkIGluZGljYXRvcnNcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5kaWNhdG9ycykge1xuICAgICAgICAgICRpbmRpY2F0b3JzID0gJCgnPHVsIGNsYXNzPVwiaW5kaWNhdG9yc1wiPjwvdWw+Jyk7XG4gICAgICAgICAgJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCBpbmRleCApIHtcbiAgICAgICAgICAgIHZhciAkaW5kaWNhdG9yID0gJCgnPGxpIGNsYXNzPVwiaW5kaWNhdG9yLWl0ZW1cIj48L2xpPicpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2tzIG9uIGluZGljYXRvcnNcbiAgICAgICAgICAgICRpbmRpY2F0b3IuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgJHBhcmVudCA9ICRzbGlkZXIucGFyZW50KCk7XG4gICAgICAgICAgICAgIHZhciBjdXJyX2luZGV4ID0gJHBhcmVudC5maW5kKCQodGhpcykpLmluZGV4KCk7XG4gICAgICAgICAgICAgIG1vdmVUb1NsaWRlKGN1cnJfaW5kZXgpO1xuXG4gICAgICAgICAgICAgIC8vIHJlc2V0IGludGVydmFsXG4gICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoJGludGVydmFsKTtcbiAgICAgICAgICAgICAgJGludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICRhY3RpdmVfaW5kZXggPSAkc2xpZGVyLmZpbmQoJy5hY3RpdmUnKS5pbmRleCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKCRzbGlkZXMubGVuZ3RoID09ICRhY3RpdmVfaW5kZXggKyAxKSAkYWN0aXZlX2luZGV4ID0gMDsgLy8gbG9vcCB0byBzdGFydFxuICAgICAgICAgICAgICAgICAgZWxzZSAkYWN0aXZlX2luZGV4ICs9IDE7XG5cbiAgICAgICAgICAgICAgICAgIG1vdmVUb1NsaWRlKCRhY3RpdmVfaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy50cmFuc2l0aW9uICsgb3B0aW9ucy5pbnRlcnZhbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkaW5kaWNhdG9ycy5hcHBlbmQoJGluZGljYXRvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgJHRoaXMuYXBwZW5kKCRpbmRpY2F0b3JzKTtcbiAgICAgICAgICAkaW5kaWNhdG9ycyA9ICR0aGlzLmZpbmQoJ3VsLmluZGljYXRvcnMnKS5maW5kKCdsaS5pbmRpY2F0b3ItaXRlbScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRhY3RpdmUpIHtcbiAgICAgICAgICAkYWN0aXZlLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAkc2xpZGVzLmZpcnN0KCkuYWRkQ2xhc3MoJ2FjdGl2ZScpLnZlbG9jaXR5KHtvcGFjaXR5OiAxfSwge2R1cmF0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnfSk7XG5cbiAgICAgICAgICAkYWN0aXZlX2luZGV4ID0gMDtcbiAgICAgICAgICAkYWN0aXZlID0gJHNsaWRlcy5lcSgkYWN0aXZlX2luZGV4KTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBpbmRpY2F0b3JzXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaW5kaWNhdG9ycykge1xuICAgICAgICAgICAgJGluZGljYXRvcnMuZXEoJGFjdGl2ZV9pbmRleCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkanVzdCBoZWlnaHQgdG8gY3VycmVudCBzbGlkZVxuICAgICAgICAkYWN0aXZlLmZpbmQoJ2ltZycpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJGFjdGl2ZS5maW5kKCcuY2FwdGlvbicpLnZlbG9jaXR5KHtvcGFjaXR5OiAxLCB0cmFuc2xhdGVYOiAwLCB0cmFuc2xhdGVZOiAwfSwge2R1cmF0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGF1dG8gc2Nyb2xsXG4gICAgICAgICRpbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkYWN0aXZlX2luZGV4ID0gJHNsaWRlci5maW5kKCcuYWN0aXZlJykuaW5kZXgoKTtcbiAgICAgICAgICAgIG1vdmVUb1NsaWRlKCRhY3RpdmVfaW5kZXggKyAxKTtcblxuICAgICAgICAgIH0sIG9wdGlvbnMudHJhbnNpdGlvbiArIG9wdGlvbnMuaW50ZXJ2YWxcbiAgICAgICAgKTtcblxuXG4gICAgICAgIC8vIEhhbW1lckpTLCBTd2lwZSBuYXZpZ2F0aW9uXG5cbiAgICAgICAgLy8gVG91Y2ggRXZlbnRcbiAgICAgICAgdmFyIHBhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIHN3aXBlTGVmdCA9IGZhbHNlO1xuICAgICAgICB2YXIgc3dpcGVSaWdodCA9IGZhbHNlO1xuXG4gICAgICAgICR0aGlzLmhhbW1lcih7XG4gICAgICAgICAgICBwcmV2ZW50X2RlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0pLmJpbmQoJ3BhbicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoZS5nZXN0dXJlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcblxuICAgICAgICAgICAgLy8gcmVzZXQgaW50ZXJ2YWxcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoJGludGVydmFsKTtcblxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGUuZ2VzdHVyZS5kaXJlY3Rpb247XG4gICAgICAgICAgICB2YXIgeCA9IGUuZ2VzdHVyZS5kZWx0YVg7XG4gICAgICAgICAgICB2YXIgdmVsb2NpdHlYID0gZS5nZXN0dXJlLnZlbG9jaXR5WDtcbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eVkgPSBlLmdlc3R1cmUudmVsb2NpdHlZO1xuXG4gICAgICAgICAgICAkY3Vycl9zbGlkZSA9ICRzbGlkZXIuZmluZCgnLmFjdGl2ZScpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZlbG9jaXR5WCkgPiBNYXRoLmFicyh2ZWxvY2l0eVkpKSB7XG4gICAgICAgICAgICAgICRjdXJyX3NsaWRlLnZlbG9jaXR5KHsgdHJhbnNsYXRlWDogeFxuICAgICAgICAgICAgICAgICAgfSwge2R1cmF0aW9uOiA1MCwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCd9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3dpcGUgTGVmdFxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gNCAmJiAoeCA+ICgkdGhpcy5pbm5lcldpZHRoKCkgLyAyKSB8fCB2ZWxvY2l0eVggPCAtMC42NSkpIHtcbiAgICAgICAgICAgICAgc3dpcGVSaWdodCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTd2lwZSBSaWdodFxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAyICYmICh4IDwgKC0xICogJHRoaXMuaW5uZXJXaWR0aCgpIC8gMikgfHwgdmVsb2NpdHlYID4gMC42NSkpIHtcbiAgICAgICAgICAgICAgc3dpcGVMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBTbGlkZSBCZWhpbmQgYWN0aXZlIHNsaWRlIHZpc2libGVcbiAgICAgICAgICAgIHZhciBuZXh0X3NsaWRlO1xuICAgICAgICAgICAgaWYgKHN3aXBlTGVmdCkge1xuICAgICAgICAgICAgICBuZXh0X3NsaWRlID0gJGN1cnJfc2xpZGUubmV4dCgpO1xuICAgICAgICAgICAgICBpZiAobmV4dF9zbGlkZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXh0X3NsaWRlID0gJHNsaWRlcy5maXJzdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5leHRfc2xpZGUudmVsb2NpdHkoeyBvcGFjaXR5OiAxXG4gICAgICAgICAgICAgICAgICB9LCB7ZHVyYXRpb246IDMwMCwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlT3V0UXVhZCd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzd2lwZVJpZ2h0KSB7XG4gICAgICAgICAgICAgIG5leHRfc2xpZGUgPSAkY3Vycl9zbGlkZS5wcmV2KCk7XG4gICAgICAgICAgICAgIGlmIChuZXh0X3NsaWRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5leHRfc2xpZGUgPSAkc2xpZGVzLmxhc3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXh0X3NsaWRlLnZlbG9jaXR5KHsgb3BhY2l0eTogMVxuICAgICAgICAgICAgICAgICAgfSwge2R1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnfSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgIH1cblxuICAgICAgICB9KS5iaW5kKCdwYW5lbmQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKGUuZ2VzdHVyZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG5cbiAgICAgICAgICAgICRjdXJyX3NsaWRlID0gJHNsaWRlci5maW5kKCcuYWN0aXZlJyk7XG4gICAgICAgICAgICBwYW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjdXJyX2luZGV4ID0gJHNsaWRlci5maW5kKCcuYWN0aXZlJykuaW5kZXgoKTtcblxuICAgICAgICAgICAgaWYgKCFzd2lwZVJpZ2h0ICYmICFzd2lwZUxlZnQgfHwgJHNsaWRlcy5sZW5ndGggPD0xKSB7XG4gICAgICAgICAgICAgIC8vIFJldHVybiB0byBvcmlnaW5hbCBzcG90XG4gICAgICAgICAgICAgICRjdXJyX3NsaWRlLnZlbG9jaXR5KHsgdHJhbnNsYXRlWDogMFxuICAgICAgICAgICAgICAgICAgfSwge2R1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzd2lwZUxlZnQpIHtcbiAgICAgICAgICAgICAgbW92ZVRvU2xpZGUoY3Vycl9pbmRleCArIDEpO1xuICAgICAgICAgICAgICAkY3Vycl9zbGlkZS52ZWxvY2l0eSh7dHJhbnNsYXRlWDogLTEgKiAkdGhpcy5pbm5lcldpZHRoKCkgfSwge2R1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3Vycl9zbGlkZS52ZWxvY2l0eSh7b3BhY2l0eTogMCwgdHJhbnNsYXRlWDogMH0sIHtkdXJhdGlvbjogMCwgcXVldWU6IGZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3dpcGVSaWdodCkge1xuICAgICAgICAgICAgICBtb3ZlVG9TbGlkZShjdXJyX2luZGV4IC0gMSk7XG4gICAgICAgICAgICAgICRjdXJyX3NsaWRlLnZlbG9jaXR5KHt0cmFuc2xhdGVYOiAkdGhpcy5pbm5lcldpZHRoKCkgfSwge2R1cmF0aW9uOiAzMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3Vycl9zbGlkZS52ZWxvY2l0eSh7b3BhY2l0eTogMCwgdHJhbnNsYXRlWDogMH0sIHtkdXJhdGlvbjogMCwgcXVldWU6IGZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpcGVMZWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICBzd2lwZVJpZ2h0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIFJlc3RhcnQgaW50ZXJ2YWxcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoJGludGVydmFsKTtcbiAgICAgICAgICAgICRpbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgICAgICAgICBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICRhY3RpdmVfaW5kZXggPSAkc2xpZGVyLmZpbmQoJy5hY3RpdmUnKS5pbmRleCgpO1xuICAgICAgICAgICAgICAgIGlmICgkc2xpZGVzLmxlbmd0aCA9PSAkYWN0aXZlX2luZGV4ICsgMSkgJGFjdGl2ZV9pbmRleCA9IDA7IC8vIGxvb3AgdG8gc3RhcnRcbiAgICAgICAgICAgICAgICBlbHNlICRhY3RpdmVfaW5kZXggKz0gMTtcblxuICAgICAgICAgICAgICAgIG1vdmVUb1NsaWRlKCRhY3RpdmVfaW5kZXgpO1xuXG4gICAgICAgICAgICAgIH0sIG9wdGlvbnMudHJhbnNpdGlvbiArIG9wdGlvbnMuaW50ZXJ2YWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAkdGhpcy5vbignc2xpZGVyUGF1c2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKCRpbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICR0aGlzLm9uKCdzbGlkZXJTdGFydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoJGludGVydmFsKTtcbiAgICAgICAgICAkaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICRhY3RpdmVfaW5kZXggPSAkc2xpZGVyLmZpbmQoJy5hY3RpdmUnKS5pbmRleCgpO1xuICAgICAgICAgICAgICBpZiAoJHNsaWRlcy5sZW5ndGggPT0gJGFjdGl2ZV9pbmRleCArIDEpICRhY3RpdmVfaW5kZXggPSAwOyAvLyBsb29wIHRvIHN0YXJ0XG4gICAgICAgICAgICAgIGVsc2UgJGFjdGl2ZV9pbmRleCArPSAxO1xuXG4gICAgICAgICAgICAgIG1vdmVUb1NsaWRlKCRhY3RpdmVfaW5kZXgpO1xuXG4gICAgICAgICAgICB9LCBvcHRpb25zLnRyYW5zaXRpb24gKyBvcHRpb25zLmludGVydmFsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHRoaXMub24oJ3NsaWRlck5leHQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkYWN0aXZlX2luZGV4ID0gJHNsaWRlci5maW5kKCcuYWN0aXZlJykuaW5kZXgoKTtcbiAgICAgICAgICBtb3ZlVG9TbGlkZSgkYWN0aXZlX2luZGV4ICsgMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICR0aGlzLm9uKCdzbGlkZXJQcmV2JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJGFjdGl2ZV9pbmRleCA9ICRzbGlkZXIuZmluZCgnLmFjdGl2ZScpLmluZGV4KCk7XG4gICAgICAgICAgbW92ZVRvU2xpZGUoJGFjdGl2ZV9pbmRleCAtIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgfSk7XG5cblxuXG4gICAgfSxcbiAgICBwYXVzZSA6IGZ1bmN0aW9uKCkge1xuICAgICAgJCh0aGlzKS50cmlnZ2VyKCdzbGlkZXJQYXVzZScpO1xuICAgIH0sXG4gICAgc3RhcnQgOiBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykudHJpZ2dlcignc2xpZGVyU3RhcnQnKTtcbiAgICB9LFxuICAgIG5leHQgOiBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykudHJpZ2dlcignc2xpZGVyTmV4dCcpO1xuICAgIH0sXG4gICAgcHJldiA6IGZ1bmN0aW9uKCkge1xuICAgICAgJCh0aGlzKS50cmlnZ2VyKCdzbGlkZXJQcmV2Jyk7XG4gICAgfVxuICB9O1xuXG5cbiAgJC5mbi5zbGlkZXIgPSBmdW5jdGlvbihtZXRob2RPck9wdGlvbnMpIHtcbiAgICBpZiAoIG1ldGhvZHNbbWV0aG9kT3JPcHRpb25zXSApIHtcbiAgICAgIHJldHVybiBtZXRob2RzWyBtZXRob2RPck9wdGlvbnMgXS5hcHBseSggdGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApKTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbWV0aG9kT3JPcHRpb25zID09PSAnb2JqZWN0JyB8fCAhIG1ldGhvZE9yT3B0aW9ucyApIHtcbiAgICAgIC8vIERlZmF1bHQgdG8gXCJpbml0XCJcbiAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgIH0gZWxzZSB7XG4gICAgICAkLmVycm9yKCAnTWV0aG9kICcgKyAgbWV0aG9kT3JPcHRpb25zICsgJyBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkudG9vbHRpcCcgKTtcbiAgICB9XG4gIH07IC8vIFBsdWdpbiBlbmRcbn0oIGpRdWVyeSApKTtcbjsoZnVuY3Rpb24gKCQpIHtcbiAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2suY2FyZCcsICcuY2FyZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoJCh0aGlzKS5maW5kKCc+IC5jYXJkLXJldmVhbCcpLmxlbmd0aCkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXMoJCgnLmNhcmQtcmV2ZWFsIC5jYXJkLXRpdGxlJykpIHx8ICQoZS50YXJnZXQpLmlzKCQoJy5jYXJkLXJldmVhbCAuY2FyZC10aXRsZSBpJykpKSB7XG4gICAgICAgICAgLy8gTWFrZSBSZXZlYWwgYW5pbWF0ZSBkb3duIGFuZCBkaXNwbGF5IG5vbmVcbiAgICAgICAgICAkKHRoaXMpLmZpbmQoJy5jYXJkLXJldmVhbCcpLnZlbG9jaXR5KFxuICAgICAgICAgICAge3RyYW5zbGF0ZVk6IDB9LCB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAyMjUsXG4gICAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZUluT3V0UXVhZCcsXG4gICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHsgJCh0aGlzKS5jc3MoeyBkaXNwbGF5OiAnbm9uZSd9KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJChlLnRhcmdldCkuaXMoJCgnLmNhcmQgLmFjdGl2YXRvcicpKSB8fFxuICAgICAgICAgICAgICAgICAkKGUudGFyZ2V0KS5pcygkKCcuY2FyZCAuYWN0aXZhdG9yIGknKSkgKSB7XG4gICAgICAgICAgJChlLnRhcmdldCkuY2xvc2VzdCgnLmNhcmQnKS5jc3MoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xuICAgICAgICAgICQodGhpcykuZmluZCgnLmNhcmQtcmV2ZWFsJykuY3NzKHsgZGlzcGxheTogJ2Jsb2NrJ30pLnZlbG9jaXR5KFwic3RvcFwiLCBmYWxzZSkudmVsb2NpdHkoe3RyYW5zbGF0ZVk6ICctMTAwJSd9LCB7ZHVyYXRpb246IDMwMCwgcXVldWU6IGZhbHNlLCBlYXNpbmc6ICdlYXNlSW5PdXRRdWFkJ30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSk7XG59KCBqUXVlcnkgKSk7OyhmdW5jdGlvbiAoJCkge1xuICB2YXIgbWF0ZXJpYWxDaGlwc0RlZmF1bHRzID0ge1xuICAgIGRhdGE6IFtdLFxuICAgIHBsYWNlaG9sZGVyOiAnJyxcbiAgICBzZWNvbmRhcnlQbGFjZWhvbGRlcjogJycsXG4gICAgYXV0b2NvbXBsZXRlT3B0aW9uczoge30sXG4gIH07XG5cbiAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgLy8gSGFuZGxlIHJlbW92YWwgb2Ygc3RhdGljIGNoaXBzLlxuICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuY2hpcCAuY2xvc2UnLCBmdW5jdGlvbihlKXtcbiAgICAgIHZhciAkY2hpcHMgPSAkKHRoaXMpLmNsb3Nlc3QoJy5jaGlwcycpO1xuICAgICAgaWYgKCRjaGlwcy5hdHRyKCdkYXRhLWluaXRpYWxpemVkJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgJCh0aGlzKS5jbG9zZXN0KCcuY2hpcCcpLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICAkLmZuLm1hdGVyaWFsX2NoaXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLiRlbCA9ICQodGhpcyk7XG4gICAgdGhpcy4kZG9jdW1lbnQgPSAkKGRvY3VtZW50KTtcbiAgICB0aGlzLlNFTFMgPSB7XG4gICAgICBDSElQUzogJy5jaGlwcycsXG4gICAgICBDSElQOiAnLmNoaXAnLFxuICAgICAgSU5QVVQ6ICdpbnB1dCcsXG4gICAgICBERUxFVEU6ICcubWF0ZXJpYWwtaWNvbnMnLFxuICAgICAgU0VMRUNURURfQ0hJUDogJy5zZWxlY3RlZCcsXG4gICAgfTtcblxuICAgIGlmICgnZGF0YScgPT09IG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLiRlbC5kYXRhKCdjaGlwcycpO1xuICAgIH1cblxuICAgIHZhciBjdXJyX29wdGlvbnMgPSAkLmV4dGVuZCh7fSwgbWF0ZXJpYWxDaGlwc0RlZmF1bHRzLCBvcHRpb25zKTtcbiAgICBzZWxmLmhhc0F1dG9jb21wbGV0ZSA9ICEkLmlzRW1wdHlPYmplY3QoY3Vycl9vcHRpb25zLmF1dG9jb21wbGV0ZU9wdGlvbnMuZGF0YSk7XG5cbiAgICAvLyBJbml0aWFsaXplXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgY2hpcHM7XG4gICAgICBzZWxmLiRlbC5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciAkY2hpcHMgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgY2hpcElkID0gTWF0ZXJpYWxpemUuZ3VpZCgpO1xuICAgICAgICBzZWxmLmNoaXBJZCA9IGNoaXBJZDtcblxuICAgICAgICBpZiAoIWN1cnJfb3B0aW9ucy5kYXRhIHx8ICEoY3Vycl9vcHRpb25zLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICBjdXJyX29wdGlvbnMuZGF0YSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgICRjaGlwcy5kYXRhKCdjaGlwcycsIGN1cnJfb3B0aW9ucy5kYXRhKTtcbiAgICAgICAgJGNoaXBzLmF0dHIoJ2RhdGEtaW5kZXgnLCBpKTtcbiAgICAgICAgJGNoaXBzLmF0dHIoJ2RhdGEtaW5pdGlhbGl6ZWQnLCB0cnVlKTtcblxuICAgICAgICBpZiAoISRjaGlwcy5oYXNDbGFzcyhzZWxmLlNFTFMuQ0hJUFMpKSB7XG4gICAgICAgICAgJGNoaXBzLmFkZENsYXNzKCdjaGlwcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5jaGlwcygkY2hpcHMsIGNoaXBJZCk7XG4gICAgICAgIGkrKztcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIFNFTFMgPSBzZWxmLlNFTFM7XG5cbiAgICAgIHNlbGYuJGRvY3VtZW50Lm9mZignY2xpY2suY2hpcHMtZm9jdXMnLCBTRUxTLkNISVBTKS5vbignY2xpY2suY2hpcHMtZm9jdXMnLCBTRUxTLkNISVBTLCBmdW5jdGlvbihlKXtcbiAgICAgICAgJChlLnRhcmdldCkuZmluZChTRUxTLklOUFVUKS5mb2N1cygpO1xuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuJGRvY3VtZW50Lm9mZignY2xpY2suY2hpcHMtc2VsZWN0JywgU0VMUy5DSElQKS5vbignY2xpY2suY2hpcHMtc2VsZWN0JywgU0VMUy5DSElQLCBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyICRjaGlwID0gJChlLnRhcmdldCk7XG4gICAgICAgIGlmICgkY2hpcC5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgd2FzU2VsZWN0ZWQgPSAkY2hpcC5oYXNDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICB2YXIgJGNoaXBzID0gJGNoaXAuY2xvc2VzdChTRUxTLkNISVBTKTtcbiAgICAgICAgICAkKFNFTFMuQ0hJUCkucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG5cbiAgICAgICAgICBpZiAoIXdhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdENoaXAoJGNoaXAuaW5kZXgoKSwgJGNoaXBzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzZWxmLiRkb2N1bWVudC5vZmYoJ2tleWRvd24uY2hpcHMnKS5vbigna2V5ZG93bi5jaGlwcycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXMoJ2lucHV0LCB0ZXh0YXJlYScpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVsZXRlXG4gICAgICAgIHZhciAkY2hpcCA9IHNlbGYuJGRvY3VtZW50LmZpbmQoU0VMUy5DSElQICsgU0VMUy5TRUxFQ1RFRF9DSElQKTtcbiAgICAgICAgdmFyICRjaGlwcyA9ICRjaGlwLmNsb3Nlc3QoU0VMUy5DSElQUyk7XG4gICAgICAgIHZhciBsZW5ndGggPSAkY2hpcC5zaWJsaW5ncyhTRUxTLkNISVApLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4O1xuXG4gICAgICAgIGlmICghJGNoaXAubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUud2hpY2ggPT09IDggfHwgZS53aGljaCA9PT0gNDYpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpbmRleCA9ICRjaGlwLmluZGV4KCk7XG4gICAgICAgICAgc2VsZi5kZWxldGVDaGlwKGluZGV4LCAkY2hpcHMpO1xuXG4gICAgICAgICAgdmFyIHNlbGVjdEluZGV4ID0gbnVsbDtcbiAgICAgICAgICBpZiAoKGluZGV4ICsgMSkgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGVjdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gbGVuZ3RoIHx8IChpbmRleCArIDEpID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGVjdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZWN0SW5kZXggPCAwKSBzZWxlY3RJbmRleCA9IG51bGw7XG5cbiAgICAgICAgICBpZiAobnVsbCAhPT0gc2VsZWN0SW5kZXgpIHtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0Q2hpcChzZWxlY3RJbmRleCwgJGNoaXBzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFsZW5ndGgpICRjaGlwcy5maW5kKCdpbnB1dCcpLmZvY3VzKCk7XG5cbiAgICAgICAgLy8gbGVmdFxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IDM3KSB7XG4gICAgICAgICAgaW5kZXggPSAkY2hpcC5pbmRleCgpIC0gMTtcbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgICQoU0VMUy5DSElQKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICBzZWxmLnNlbGVjdENoaXAoaW5kZXgsICRjaGlwcyk7XG5cbiAgICAgICAgLy8gcmlnaHRcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09PSAzOSkge1xuICAgICAgICAgIGluZGV4ID0gJGNoaXAuaW5kZXgoKSArIDE7XG4gICAgICAgICAgJChTRUxTLkNISVApLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgJGNoaXBzLmZpbmQoJ2lucHV0JykuZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5zZWxlY3RDaGlwKGluZGV4LCAkY2hpcHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2VsZi4kZG9jdW1lbnQub2ZmKCdmb2N1c2luLmNoaXBzJywgU0VMUy5DSElQUyArICcgJyArIFNFTFMuSU5QVVQpLm9uKCdmb2N1c2luLmNoaXBzJywgU0VMUy5DSElQUyArICcgJyArIFNFTFMuSU5QVVQsIGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgJGN1cnJDaGlwcyA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoU0VMUy5DSElQUyk7XG4gICAgICAgICRjdXJyQ2hpcHMuYWRkQ2xhc3MoJ2ZvY3VzJyk7XG4gICAgICAgICRjdXJyQ2hpcHMuc2libGluZ3MoJ2xhYmVsLCAucHJlZml4JykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAkKFNFTFMuQ0hJUCkucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICB9KTtcblxuICAgICAgc2VsZi4kZG9jdW1lbnQub2ZmKCdmb2N1c291dC5jaGlwcycsIFNFTFMuQ0hJUFMgKyAnICcgKyBTRUxTLklOUFVUKS5vbignZm9jdXNvdXQuY2hpcHMnLCBTRUxTLkNISVBTICsgJyAnICsgU0VMUy5JTlBVVCwgZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciAkY3VyckNoaXBzID0gJChlLnRhcmdldCkuY2xvc2VzdChTRUxTLkNISVBTKTtcbiAgICAgICAgJGN1cnJDaGlwcy5yZW1vdmVDbGFzcygnZm9jdXMnKTtcblxuICAgICAgICAvLyBSZW1vdmUgYWN0aXZlIGlmIGVtcHR5XG4gICAgICAgIGlmICghJGN1cnJDaGlwcy5kYXRhKCdjaGlwcycpLmxlbmd0aCkge1xuICAgICAgICAgICRjdXJyQ2hpcHMuc2libGluZ3MoJ2xhYmVsJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgICRjdXJyQ2hpcHMuc2libGluZ3MoJy5wcmVmaXgnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICB9KTtcblxuICAgICAgc2VsZi4kZG9jdW1lbnQub2ZmKCdrZXlkb3duLmNoaXBzLWFkZCcsIFNFTFMuQ0hJUFMgKyAnICcgKyBTRUxTLklOUFVUKS5vbigna2V5ZG93bi5jaGlwcy1hZGQnLCBTRUxTLkNISVBTICsgJyAnICsgU0VMUy5JTlBVVCwgZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciAkdGFyZ2V0ID0gJChlLnRhcmdldCk7XG4gICAgICAgIHZhciAkY2hpcHMgPSAkdGFyZ2V0LmNsb3Nlc3QoU0VMUy5DSElQUyk7XG4gICAgICAgIHZhciBjaGlwc0xlbmd0aCA9ICRjaGlwcy5jaGlsZHJlbihTRUxTLkNISVApLmxlbmd0aDtcblxuICAgICAgICAvLyBlbnRlclxuICAgICAgICBpZiAoMTMgPT09IGUud2hpY2gpIHtcbiAgICAgICAgICAvLyBPdmVycmlkZSBlbnRlciBpZiBhdXRvY29tcGxldGluZy5cbiAgICAgICAgICBpZiAoc2VsZi5oYXNBdXRvY29tcGxldGUgJiZcbiAgICAgICAgICAgICAgJGNoaXBzLmZpbmQoJy5hdXRvY29tcGxldGUtY29udGVudC5kcm9wZG93bi1jb250ZW50JykubGVuZ3RoICYmXG4gICAgICAgICAgICAgICRjaGlwcy5maW5kKCcuYXV0b2NvbXBsZXRlLWNvbnRlbnQuZHJvcGRvd24tY29udGVudCcpLmNoaWxkcmVuKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHNlbGYuYWRkQ2hpcCh7dGFnOiAkdGFyZ2V0LnZhbCgpfSwgJGNoaXBzKTtcbiAgICAgICAgICAkdGFyZ2V0LnZhbCgnJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVsZXRlIG9yIGxlZnRcbiAgICAgICAgaWYgKCg4ID09PSBlLmtleUNvZGUgfHwgMzcgPT09IGUua2V5Q29kZSkgJiYgJycgPT09ICR0YXJnZXQudmFsKCkgJiYgY2hpcHNMZW5ndGgpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2VsZi5zZWxlY3RDaGlwKGNoaXBzTGVuZ3RoIC0gMSwgJGNoaXBzKTtcbiAgICAgICAgICAkdGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDbGljayBvbiBkZWxldGUgaWNvbiBpbiBjaGlwLlxuICAgICAgc2VsZi4kZG9jdW1lbnQub2ZmKCdjbGljay5jaGlwcy1kZWxldGUnLCBTRUxTLkNISVBTICsgJyAnICsgU0VMUy5ERUxFVEUpLm9uKCdjbGljay5jaGlwcy1kZWxldGUnLCBTRUxTLkNISVBTICsgJyAnICsgU0VMUy5ERUxFVEUsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgdmFyICRjaGlwcyA9ICR0YXJnZXQuY2xvc2VzdChTRUxTLkNISVBTKTtcbiAgICAgICAgdmFyICRjaGlwID0gJHRhcmdldC5jbG9zZXN0KFNFTFMuQ0hJUCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHNlbGYuZGVsZXRlQ2hpcCgkY2hpcC5pbmRleCgpLCAkY2hpcHMpO1xuICAgICAgICAkY2hpcHMuZmluZCgnaW5wdXQnKS5mb2N1cygpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuY2hpcHMgPSBmdW5jdGlvbigkY2hpcHMsIGNoaXBJZCkge1xuICAgICAgJGNoaXBzLmVtcHR5KCk7XG4gICAgICAkY2hpcHMuZGF0YSgnY2hpcHMnKS5mb3JFYWNoKGZ1bmN0aW9uKGVsZW0pe1xuICAgICAgICAkY2hpcHMuYXBwZW5kKHNlbGYucmVuZGVyQ2hpcChlbGVtKSk7XG4gICAgICB9KTtcbiAgICAgICRjaGlwcy5hcHBlbmQoJCgnPGlucHV0IGlkPVwiJyArIGNoaXBJZCArJ1wiIGNsYXNzPVwiaW5wdXRcIiBwbGFjZWhvbGRlcj1cIlwiPicpKTtcbiAgICAgIHNlbGYuc2V0UGxhY2Vob2xkZXIoJGNoaXBzKTtcblxuICAgICAgLy8gU2V0IGZvciBhdHRyaWJ1dGUgZm9yIGxhYmVsXG4gICAgICB2YXIgbGFiZWwgPSAkY2hpcHMubmV4dCgnbGFiZWwnKTtcbiAgICAgIGlmIChsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgbGFiZWwuYXR0cignZm9yJywgY2hpcElkKTtcblxuICAgICAgICBpZiAoJGNoaXBzLmRhdGEoJ2NoaXBzJykubGVuZ3RoKSB7XG4gICAgICAgICAgbGFiZWwuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIGF1dG9jb21wbGV0ZSBpZiBuZWVkZWQuXG4gICAgICB2YXIgaW5wdXQgPSAkKCcjJyArIGNoaXBJZCk7XG4gICAgICBpZiAoc2VsZi5oYXNBdXRvY29tcGxldGUpIHtcbiAgICAgICAgY3Vycl9vcHRpb25zLmF1dG9jb21wbGV0ZU9wdGlvbnMub25BdXRvY29tcGxldGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICBzZWxmLmFkZENoaXAoe3RhZzogdmFsfSwgJGNoaXBzKTtcbiAgICAgICAgICBpbnB1dC52YWwoJycpO1xuICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuYXV0b2NvbXBsZXRlKGN1cnJfb3B0aW9ucy5hdXRvY29tcGxldGVPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGNoaXAgalF1ZXJ5IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1cbiAgICAgKiBAcmV0dXJuIHtqUXVlcnl9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJDaGlwID0gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgaWYgKCFlbGVtLnRhZykgcmV0dXJuO1xuXG4gICAgICB2YXIgJHJlbmRlcmVkQ2hpcCA9ICQoJzxkaXYgY2xhc3M9XCJjaGlwXCI+PC9kaXY+Jyk7XG4gICAgICAkcmVuZGVyZWRDaGlwLnRleHQoZWxlbS50YWcpO1xuICAgICAgJHJlbmRlcmVkQ2hpcC5hcHBlbmQoJCgnPGkgY2xhc3M9XCJtYXRlcmlhbC1pY29ucyBjbG9zZVwiPmNsb3NlPC9pPicpKTtcbiAgICAgIHJldHVybiAkcmVuZGVyZWRDaGlwO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFBsYWNlaG9sZGVyID0gZnVuY3Rpb24oJGNoaXBzKSB7XG4gICAgICBpZiAoJGNoaXBzLmRhdGEoJ2NoaXBzJykubGVuZ3RoICYmIGN1cnJfb3B0aW9ucy5wbGFjZWhvbGRlcikge1xuICAgICAgICAkY2hpcHMuZmluZCgnaW5wdXQnKS5wcm9wKCdwbGFjZWhvbGRlcicsIGN1cnJfb3B0aW9ucy5wbGFjZWhvbGRlcik7XG5cbiAgICAgIH0gZWxzZSBpZiAoISRjaGlwcy5kYXRhKCdjaGlwcycpLmxlbmd0aCAmJiBjdXJyX29wdGlvbnMuc2Vjb25kYXJ5UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgJGNoaXBzLmZpbmQoJ2lucHV0JykucHJvcCgncGxhY2Vob2xkZXInLCBjdXJyX29wdGlvbnMuc2Vjb25kYXJ5UGxhY2Vob2xkZXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmlzVmFsaWQgPSBmdW5jdGlvbigkY2hpcHMsIGVsZW0pIHtcbiAgICAgIHZhciBjaGlwcyA9ICRjaGlwcy5kYXRhKCdjaGlwcycpO1xuICAgICAgdmFyIGV4aXN0cyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaT0wOyBpIDwgY2hpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaXBzW2ldLnRhZyA9PT0gZWxlbS50YWcpIHtcbiAgICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJyAhPT0gZWxlbS50YWcgJiYgIWV4aXN0cztcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRDaGlwID0gZnVuY3Rpb24oZWxlbSwgJGNoaXBzKSB7XG4gICAgICBpZiAoIXNlbGYuaXNWYWxpZCgkY2hpcHMsIGVsZW0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciAkcmVuZGVyZWRDaGlwID0gc2VsZi5yZW5kZXJDaGlwKGVsZW0pO1xuICAgICAgdmFyIG5ld0RhdGEgPSBbXTtcbiAgICAgIHZhciBvbGREYXRhID0gJGNoaXBzLmRhdGEoJ2NoaXBzJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YS5wdXNoKG9sZERhdGFbaV0pO1xuICAgICAgfVxuICAgICAgbmV3RGF0YS5wdXNoKGVsZW0pO1xuXG4gICAgICAkY2hpcHMuZGF0YSgnY2hpcHMnLCBuZXdEYXRhKTtcbiAgICAgICRyZW5kZXJlZENoaXAuaW5zZXJ0QmVmb3JlKCRjaGlwcy5maW5kKCdpbnB1dCcpKTtcbiAgICAgICRjaGlwcy50cmlnZ2VyKCdjaGlwLmFkZCcsIGVsZW0pO1xuICAgICAgc2VsZi5zZXRQbGFjZWhvbGRlcigkY2hpcHMpO1xuICAgIH07XG5cbiAgICB0aGlzLmRlbGV0ZUNoaXAgPSBmdW5jdGlvbihjaGlwSW5kZXgsICRjaGlwcykge1xuICAgICAgdmFyIGNoaXAgPSAkY2hpcHMuZGF0YSgnY2hpcHMnKVtjaGlwSW5kZXhdO1xuICAgICAgJGNoaXBzLmZpbmQoJy5jaGlwJykuZXEoY2hpcEluZGV4KS5yZW1vdmUoKTtcblxuICAgICAgdmFyIG5ld0RhdGEgPSBbXTtcbiAgICAgIHZhciBvbGREYXRhID0gJGNoaXBzLmRhdGEoJ2NoaXBzJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgIT09IGNoaXBJbmRleCkge1xuICAgICAgICAgIG5ld0RhdGEucHVzaChvbGREYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkY2hpcHMuZGF0YSgnY2hpcHMnLCBuZXdEYXRhKTtcbiAgICAgICRjaGlwcy50cmlnZ2VyKCdjaGlwLmRlbGV0ZScsIGNoaXApO1xuICAgICAgc2VsZi5zZXRQbGFjZWhvbGRlcigkY2hpcHMpO1xuICAgIH07XG5cbiAgICB0aGlzLnNlbGVjdENoaXAgPSBmdW5jdGlvbihjaGlwSW5kZXgsICRjaGlwcykge1xuICAgICAgdmFyICRjaGlwID0gJGNoaXBzLmZpbmQoJy5jaGlwJykuZXEoY2hpcEluZGV4KTtcbiAgICAgIGlmICgkY2hpcCAmJiBmYWxzZSA9PT0gJGNoaXAuaGFzQ2xhc3MoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgJGNoaXAuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICRjaGlwcy50cmlnZ2VyKCdjaGlwLnNlbGVjdCcsICRjaGlwcy5kYXRhKCdjaGlwcycpW2NoaXBJbmRleF0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmdldENoaXBzRWxlbWVudCA9IGZ1bmN0aW9uKGluZGV4LCAkY2hpcHMpIHtcbiAgICAgIHJldHVybiAkY2hpcHMuZXEoaW5kZXgpO1xuICAgIH07XG5cbiAgICAvLyBpbml0XG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICB0aGlzLmhhbmRsZUV2ZW50cygpO1xuICB9O1xufSggalF1ZXJ5ICkpO1xuOyhmdW5jdGlvbiAoJCkge1xuICAkLmZuLnB1c2hwaW4gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIERlZmF1bHRzXG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiBJbmZpbml0eSxcbiAgICAgIG9mZnNldDogMFxuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgcHVzaHBpbiBldmVudCBhbmQgY2xhc3Nlc1xuICAgIGlmIChvcHRpb25zID09PSBcInJlbW92ZVwiKSB7XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaWQgPSAkKHRoaXMpLmRhdGEoJ3B1c2hwaW4taWQnKSkge1xuICAgICAgICAgICQod2luZG93KS5vZmYoJ3Njcm9sbC4nICsgaWQpO1xuICAgICAgICAgICQodGhpcykucmVtb3ZlRGF0YSgncHVzaHBpbi1pZCcpLnJlbW92ZUNsYXNzKCdwaW4tdG9wIHBpbm5lZCBwaW4tYm90dG9tJykucmVtb3ZlQXR0cignc3R5bGUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuXG4gICAgJGluZGV4ID0gMDtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyICR1bmlxdWVJZCA9IE1hdGVyaWFsaXplLmd1aWQoKSxcbiAgICAgICAgICAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgJG9yaWdpbmFsX29mZnNldCA9ICQodGhpcykub2Zmc2V0KCkudG9wO1xuXG4gICAgICBmdW5jdGlvbiByZW1vdmVQaW5DbGFzc2VzKG9iamVjdCkge1xuICAgICAgICBvYmplY3QucmVtb3ZlQ2xhc3MoJ3Bpbi10b3AnKTtcbiAgICAgICAgb2JqZWN0LnJlbW92ZUNsYXNzKCdwaW5uZWQnKTtcbiAgICAgICAgb2JqZWN0LnJlbW92ZUNsYXNzKCdwaW4tYm90dG9tJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzKG9iamVjdHMsIHNjcm9sbGVkKSB7XG4gICAgICAgIG9iamVjdHMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gQWRkIHBvc2l0aW9uIGZpeGVkIChiZWNhdXNlIGl0cyBiZXR3ZWVuIHRvcCBhbmQgYm90dG9tKVxuICAgICAgICAgIGlmIChvcHRpb25zLnRvcCA8PSBzY3JvbGxlZCAmJiBvcHRpb25zLmJvdHRvbSA+PSBzY3JvbGxlZCAmJiAhJCh0aGlzKS5oYXNDbGFzcygncGlubmVkJykpIHtcbiAgICAgICAgICAgIHJlbW92ZVBpbkNsYXNzZXMoJCh0aGlzKSk7XG4gICAgICAgICAgICAkKHRoaXMpLmNzcygndG9wJywgb3B0aW9ucy5vZmZzZXQpO1xuICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygncGlubmVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRkIHBpbi10b3AgKHdoZW4gc2Nyb2xsZWQgcG9zaXRpb24gaXMgYWJvdmUgdG9wKVxuICAgICAgICAgIGlmIChzY3JvbGxlZCA8IG9wdGlvbnMudG9wICYmICEkKHRoaXMpLmhhc0NsYXNzKCdwaW4tdG9wJykpIHtcbiAgICAgICAgICAgIHJlbW92ZVBpbkNsYXNzZXMoJCh0aGlzKSk7XG4gICAgICAgICAgICAkKHRoaXMpLmNzcygndG9wJywgMCk7XG4gICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdwaW4tdG9wJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRkIHBpbi1ib3R0b20gKHdoZW4gc2Nyb2xsZWQgcG9zaXRpb24gaXMgYmVsb3cgYm90dG9tKVxuICAgICAgICAgIGlmIChzY3JvbGxlZCA+IG9wdGlvbnMuYm90dG9tICYmICEkKHRoaXMpLmhhc0NsYXNzKCdwaW4tYm90dG9tJykpIHtcbiAgICAgICAgICAgIHJlbW92ZVBpbkNsYXNzZXMoJCh0aGlzKSk7XG4gICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdwaW4tYm90dG9tJyk7XG4gICAgICAgICAgICAkKHRoaXMpLmNzcygndG9wJywgb3B0aW9ucy5ib3R0b20gLSAkb3JpZ2luYWxfb2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAkKHRoaXMpLmRhdGEoJ3B1c2hwaW4taWQnLCAkdW5pcXVlSWQpO1xuICAgICAgdXBkYXRlRWxlbWVudHMoJHRoaXMsICQod2luZG93KS5zY3JvbGxUb3AoKSk7XG4gICAgICAkKHdpbmRvdykub24oJ3Njcm9sbC4nICsgJHVuaXF1ZUlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkc2Nyb2xsZWQgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyBvcHRpb25zLm9mZnNldDtcbiAgICAgICAgdXBkYXRlRWxlbWVudHMoJHRoaXMsICRzY3JvbGxlZCk7XG4gICAgICB9KTtcblxuICAgIH0pO1xuXG4gIH07XG59KCBqUXVlcnkgKSk7OyhmdW5jdGlvbiAoJCkge1xuICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblxuICAgIC8vIGpRdWVyeSByZXZlcnNlXG4gICAgJC5mbi5yZXZlcnNlID0gW10ucmV2ZXJzZTtcblxuICAgIC8vIEhvdmVyIGJlaGF2aW91cjogbWFrZSBzdXJlIHRoaXMgZG9lc24ndCB3b3JrIG9uIC5jbGljay10by10b2dnbGUgRkFCcyFcbiAgICAkKGRvY3VtZW50KS5vbignbW91c2VlbnRlci5maXhlZEFjdGlvbkJ0bicsICcuZml4ZWQtYWN0aW9uLWJ0bjpub3QoLmNsaWNrLXRvLXRvZ2dsZSk6bm90KC50b29sYmFyKScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICBvcGVuRkFCTWVudSgkdGhpcyk7XG4gICAgfSk7XG4gICAgJChkb2N1bWVudCkub24oJ21vdXNlbGVhdmUuZml4ZWRBY3Rpb25CdG4nLCAnLmZpeGVkLWFjdGlvbi1idG46bm90KC5jbGljay10by10b2dnbGUpOm5vdCgudG9vbGJhciknLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgY2xvc2VGQUJNZW51KCR0aGlzKTtcbiAgICB9KTtcblxuICAgIC8vIFRvZ2dsZS1vbi1jbGljayBiZWhhdmlvdXIuXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrLmZhYkNsaWNrVG9nZ2xlJywgJy5maXhlZC1hY3Rpb24tYnRuLmNsaWNrLXRvLXRvZ2dsZSA+IGEnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgdmFyICRtZW51ID0gJHRoaXMucGFyZW50KCk7XG4gICAgICBpZiAoJG1lbnUuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG4gICAgICAgIGNsb3NlRkFCTWVudSgkbWVudSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVuRkFCTWVudSgkbWVudSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUb29sYmFyIHRyYW5zaXRpb24gYmVoYXZpb3VyLlxuICAgICQoZG9jdW1lbnQpLm9uKCdjbGljay5mYWJUb29sYmFyJywgJy5maXhlZC1hY3Rpb24tYnRuLnRvb2xiYXIgPiBhJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgIHZhciAkbWVudSA9ICR0aGlzLnBhcmVudCgpO1xuICAgICAgRkFCdG9Ub29sYmFyKCRtZW51KTtcbiAgICB9KTtcblxuICB9KTtcblxuICAkLmZuLmV4dGVuZCh7XG4gICAgb3BlbkZBQjogZnVuY3Rpb24oKSB7XG4gICAgICBvcGVuRkFCTWVudSgkKHRoaXMpKTtcbiAgICB9LFxuICAgIGNsb3NlRkFCOiBmdW5jdGlvbigpIHtcbiAgICAgIGNsb3NlRkFCTWVudSgkKHRoaXMpKTtcbiAgICB9LFxuICAgIG9wZW5Ub29sYmFyOiBmdW5jdGlvbigpIHtcbiAgICAgIEZBQnRvVG9vbGJhcigkKHRoaXMpKTtcbiAgICB9LFxuICAgIGNsb3NlVG9vbGJhcjogZnVuY3Rpb24oKSB7XG4gICAgICB0b29sYmFyVG9GQUIoJCh0aGlzKSk7XG4gICAgfVxuICB9KTtcblxuXG4gIHZhciBvcGVuRkFCTWVudSA9IGZ1bmN0aW9uIChidG4pIHtcbiAgICB2YXIgJHRoaXMgPSBidG47XG4gICAgaWYgKCR0aGlzLmhhc0NsYXNzKCdhY3RpdmUnKSA9PT0gZmFsc2UpIHtcblxuICAgICAgLy8gR2V0IGRpcmVjdGlvbiBvcHRpb25cbiAgICAgIHZhciBob3Jpem9udGFsID0gJHRoaXMuaGFzQ2xhc3MoJ2hvcml6b250YWwnKTtcbiAgICAgIHZhciBvZmZzZXRZLCBvZmZzZXRYO1xuXG4gICAgICBpZiAoaG9yaXpvbnRhbCA9PT0gdHJ1ZSkge1xuICAgICAgICBvZmZzZXRYID0gNDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXRZID0gNDA7XG4gICAgICB9XG5cbiAgICAgICR0aGlzLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICR0aGlzLmZpbmQoJ3VsIC5idG4tZmxvYXRpbmcnKS52ZWxvY2l0eShcbiAgICAgICAgeyBzY2FsZVk6IFwiLjRcIiwgc2NhbGVYOiBcIi40XCIsIHRyYW5zbGF0ZVk6IG9mZnNldFkgKyAncHgnLCB0cmFuc2xhdGVYOiBvZmZzZXRYICsgJ3B4J30sXG4gICAgICAgIHsgZHVyYXRpb246IDAgfSk7XG5cbiAgICAgIHZhciB0aW1lID0gMDtcbiAgICAgICR0aGlzLmZpbmQoJ3VsIC5idG4tZmxvYXRpbmcnKS5yZXZlcnNlKCkuZWFjaCggZnVuY3Rpb24gKCkge1xuICAgICAgICAkKHRoaXMpLnZlbG9jaXR5KFxuICAgICAgICAgIHsgb3BhY2l0eTogXCIxXCIsIHNjYWxlWDogXCIxXCIsIHNjYWxlWTogXCIxXCIsIHRyYW5zbGF0ZVk6IFwiMFwiLCB0cmFuc2xhdGVYOiAnMCd9LFxuICAgICAgICAgIHsgZHVyYXRpb246IDgwLCBkZWxheTogdGltZSB9KTtcbiAgICAgICAgdGltZSArPSA0MDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2xvc2VGQUJNZW51ID0gZnVuY3Rpb24gKGJ0bikge1xuICAgIHZhciAkdGhpcyA9IGJ0bjtcbiAgICAvLyBHZXQgZGlyZWN0aW9uIG9wdGlvblxuICAgIHZhciBob3Jpem9udGFsID0gJHRoaXMuaGFzQ2xhc3MoJ2hvcml6b250YWwnKTtcbiAgICB2YXIgb2Zmc2V0WSwgb2Zmc2V0WDtcblxuICAgIGlmIChob3Jpem9udGFsID09PSB0cnVlKSB7XG4gICAgICBvZmZzZXRYID0gNDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldFkgPSA0MDtcbiAgICB9XG5cbiAgICAkdGhpcy5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgdmFyIHRpbWUgPSAwO1xuICAgICR0aGlzLmZpbmQoJ3VsIC5idG4tZmxvYXRpbmcnKS52ZWxvY2l0eShcInN0b3BcIiwgdHJ1ZSk7XG4gICAgJHRoaXMuZmluZCgndWwgLmJ0bi1mbG9hdGluZycpLnZlbG9jaXR5KFxuICAgICAgeyBvcGFjaXR5OiBcIjBcIiwgc2NhbGVYOiBcIi40XCIsIHNjYWxlWTogXCIuNFwiLCB0cmFuc2xhdGVZOiBvZmZzZXRZICsgJ3B4JywgdHJhbnNsYXRlWDogb2Zmc2V0WCArICdweCd9LFxuICAgICAgeyBkdXJhdGlvbjogODAgfVxuICAgICk7XG4gIH07XG5cblxuICAvKipcbiAgICogVHJhbnNmb3JtIEZBQiBpbnRvIHRvb2xiYXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb2JqZWN0IGpRdWVyeSBvYmplY3RcbiAgICovXG4gIHZhciBGQUJ0b1Rvb2xiYXIgPSBmdW5jdGlvbihidG4pIHtcbiAgICBpZiAoYnRuLmF0dHIoJ2RhdGEtb3BlbicpID09PSBcInRydWVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRYLCBvZmZzZXRZLCBzY2FsZUZhY3RvcjtcbiAgICB2YXIgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB2YXIgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHZhciBidG5SZWN0ID0gYnRuWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBhbmNob3IgPSBidG4uZmluZCgnPiBhJykuZmlyc3QoKTtcbiAgICB2YXIgbWVudSA9IGJ0bi5maW5kKCc+IHVsJykuZmlyc3QoKTtcbiAgICB2YXIgYmFja2Ryb3AgPSAkKCc8ZGl2IGNsYXNzPVwiZmFiLWJhY2tkcm9wXCI+PC9kaXY+Jyk7XG4gICAgdmFyIGZhYkNvbG9yID0gYW5jaG9yLmNzcygnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgIGFuY2hvci5hcHBlbmQoYmFja2Ryb3ApO1xuXG4gICAgb2Zmc2V0WCA9IGJ0blJlY3QubGVmdCAtICh3aW5kb3dXaWR0aCAvIDIpICsgKGJ0blJlY3Qud2lkdGggLyAyKTtcbiAgICBvZmZzZXRZID0gd2luZG93SGVpZ2h0IC0gYnRuUmVjdC5ib3R0b207XG4gICAgc2NhbGVGYWN0b3IgPSB3aW5kb3dXaWR0aCAvIGJhY2tkcm9wLndpZHRoKCk7XG4gICAgYnRuLmF0dHIoJ2RhdGEtb3JpZ2luLWJvdHRvbScsIGJ0blJlY3QuYm90dG9tKTtcbiAgICBidG4uYXR0cignZGF0YS1vcmlnaW4tbGVmdCcsIGJ0blJlY3QubGVmdCk7XG4gICAgYnRuLmF0dHIoJ2RhdGEtb3JpZ2luLXdpZHRoJywgYnRuUmVjdC53aWR0aCk7XG5cbiAgICAvLyBTZXQgaW5pdGlhbCBzdGF0ZVxuICAgIGJ0bi5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgYnRuLmF0dHIoJ2RhdGEtb3BlbicsIHRydWUpO1xuICAgIGJ0bi5jc3Moe1xuICAgICAgJ3RleHQtYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgnICsgb2Zmc2V0WCArICdweCknLFxuICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgfSk7XG4gICAgYW5jaG9yLmNzcyh7XG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKCcgKyAtb2Zmc2V0WSArICdweCknLFxuICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgfSk7XG4gICAgYmFja2Ryb3AuY3NzKHtcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogZmFiQ29sb3JcbiAgICB9KTtcblxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGJ0bi5jc3Moe1xuICAgICAgICB0cmFuc2Zvcm06ICcnLFxuICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIC4ycyBjdWJpYy1iZXppZXIoMC41NTAsIDAuMDg1LCAwLjY4MCwgMC41MzApLCBiYWNrZ3JvdW5kLWNvbG9yIDBzIGxpbmVhciAuMnMnXG4gICAgICB9KTtcbiAgICAgIGFuY2hvci5jc3Moe1xuICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnLFxuICAgICAgICB0cmFuc2Zvcm06ICcnLFxuICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIC4ycydcbiAgICAgIH0pO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBidG4uY3NzKHtcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBmYWJDb2xvclxuICAgICAgICB9KTtcbiAgICAgICAgYmFja2Ryb3AuY3NzKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgnICsgc2NhbGVGYWN0b3IgKyAnKScsXG4gICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAuMnMgY3ViaWMtYmV6aWVyKDAuNTUwLCAwLjA1NSwgMC42NzUsIDAuMTkwKSdcbiAgICAgICAgfSk7XG4gICAgICAgIG1lbnUuZmluZCgnPiBsaSA+IGEnKS5jc3Moe1xuICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2Nyb2xsIHRvIGNsb3NlLlxuICAgICAgICAkKHdpbmRvdykub24oJ3Njcm9sbC5mYWJUb29sYmFyQ2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0b29sYmFyVG9GQUIoYnRuKTtcbiAgICAgICAgICAkKHdpbmRvdykub2ZmKCdzY3JvbGwuZmFiVG9vbGJhckNsb3NlJyk7XG4gICAgICAgICAgJChkb2N1bWVudCkub2ZmKCdjbGljay5mYWJUb29sYmFyQ2xvc2UnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrLmZhYlRvb2xiYXJDbG9zZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoISQoZS50YXJnZXQpLmNsb3Nlc3QobWVudSkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b29sYmFyVG9GQUIoYnRuKTtcbiAgICAgICAgICAgICQod2luZG93KS5vZmYoJ3Njcm9sbC5mYWJUb29sYmFyQ2xvc2UnKTtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZignY2xpY2suZmFiVG9vbGJhckNsb3NlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0b29sYmFyIGJhY2sgaW50byBGQUJcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb2JqZWN0IGpRdWVyeSBvYmplY3RcbiAgICovXG4gIHZhciB0b29sYmFyVG9GQUIgPSBmdW5jdGlvbihidG4pIHtcbiAgICBpZiAoYnRuLmF0dHIoJ2RhdGEtb3BlbicpICE9PSBcInRydWVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRYLCBvZmZzZXRZLCBzY2FsZUZhY3RvcjtcbiAgICB2YXIgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB2YXIgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHZhciBidG5XaWR0aCA9IGJ0bi5hdHRyKCdkYXRhLW9yaWdpbi13aWR0aCcpO1xuICAgIHZhciBidG5Cb3R0b20gPSBidG4uYXR0cignZGF0YS1vcmlnaW4tYm90dG9tJyk7XG4gICAgdmFyIGJ0bkxlZnQgPSBidG4uYXR0cignZGF0YS1vcmlnaW4tbGVmdCcpO1xuICAgIHZhciBhbmNob3IgPSBidG4uZmluZCgnPiAuYnRuLWZsb2F0aW5nJykuZmlyc3QoKTtcbiAgICB2YXIgbWVudSA9IGJ0bi5maW5kKCc+IHVsJykuZmlyc3QoKTtcbiAgICB2YXIgYmFja2Ryb3AgPSBidG4uZmluZCgnLmZhYi1iYWNrZHJvcCcpO1xuICAgIHZhciBmYWJDb2xvciA9IGFuY2hvci5jc3MoJ2JhY2tncm91bmQtY29sb3InKTtcblxuICAgIG9mZnNldFggPSBidG5MZWZ0IC0gKHdpbmRvd1dpZHRoIC8gMikgKyAoYnRuV2lkdGggLyAyKTtcbiAgICBvZmZzZXRZID0gd2luZG93SGVpZ2h0IC0gYnRuQm90dG9tO1xuICAgIHNjYWxlRmFjdG9yID0gd2luZG93V2lkdGggLyBiYWNrZHJvcC53aWR0aCgpO1xuXG5cbiAgICAvLyBIaWRlIGJhY2tkcm9wXG4gICAgYnRuLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICBidG4uYXR0cignZGF0YS1vcGVuJywgZmFsc2UpO1xuICAgIGJ0bi5jc3Moe1xuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAndHJhbnNwYXJlbnQnLFxuICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgfSk7XG4gICAgYW5jaG9yLmNzcyh7XG4gICAgICB0cmFuc2l0aW9uOiAnbm9uZSdcbiAgICB9KTtcbiAgICBiYWNrZHJvcC5jc3Moe1xuICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknLFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBmYWJDb2xvclxuICAgIH0pO1xuICAgIG1lbnUuZmluZCgnPiBsaSA+IGEnKS5jc3Moe1xuICAgICAgb3BhY2l0eTogJydcbiAgICB9KTtcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBiYWNrZHJvcC5yZW1vdmUoKTtcblxuICAgICAgLy8gU2V0IGluaXRpYWwgc3RhdGUuXG4gICAgICBidG4uY3NzKHtcbiAgICAgICAgJ3RleHQtYWxpZ24nOiAnJyxcbiAgICAgICAgd2lkdGg6ICcnLFxuICAgICAgICBib3R0b206ICcnLFxuICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgb3ZlcmZsb3c6ICcnLFxuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcnLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgLW9mZnNldFggKyAncHgsMCwwKSdcbiAgICAgIH0pO1xuICAgICAgYW5jaG9yLmNzcyh7XG4gICAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwnICsgb2Zmc2V0WSArICdweCwwKSdcbiAgICAgIH0pO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBidG4uY3NzKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLDAsMCknLFxuICAgICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gLjJzJ1xuICAgICAgICB9KTtcbiAgICAgICAgYW5jaG9yLmNzcyh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwwLDApJyxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIC4ycyBjdWJpYy1iZXppZXIoMC41NTAsIDAuMDU1LCAwLjY3NSwgMC4xOTApJ1xuICAgICAgICB9KTtcbiAgICAgIH0sIDIwKTtcbiAgICB9LCAyMDApO1xuICB9O1xuXG5cbn0oIGpRdWVyeSApKTtcbjsoZnVuY3Rpb24gKCQpIHtcbiAgLy8gSW1hZ2UgdHJhbnNpdGlvbiBmdW5jdGlvblxuICBNYXRlcmlhbGl6ZS5mYWRlSW5JbWFnZSA9IGZ1bmN0aW9uKHNlbGVjdG9yT3JFbCkge1xuICAgIHZhciBlbGVtZW50O1xuICAgIGlmICh0eXBlb2Yoc2VsZWN0b3JPckVsKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsZW1lbnQgPSAkKHNlbGVjdG9yT3JFbCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yoc2VsZWN0b3JPckVsKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGVsZW1lbnQgPSBzZWxlY3Rvck9yRWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudC5jc3Moe29wYWNpdHk6IDB9KTtcbiAgICAkKGVsZW1lbnQpLnZlbG9jaXR5KHtvcGFjaXR5OiAxfSwge1xuICAgICAgZHVyYXRpb246IDY1MCxcbiAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRTaW5lJ1xuICAgIH0pO1xuICAgICQoZWxlbWVudCkudmVsb2NpdHkoe29wYWNpdHk6IDF9LCB7XG4gICAgICBkdXJhdGlvbjogMTMwMCxcbiAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgIGVhc2luZzogJ3N3aW5nJyxcbiAgICAgIHN0ZXA6IGZ1bmN0aW9uKG5vdywgZngpIHtcbiAgICAgICAgZnguc3RhcnQgPSAxMDA7XG4gICAgICAgIHZhciBncmF5c2NhbGVfc2V0dGluZyA9IG5vdy8xMDA7XG4gICAgICAgIHZhciBicmlnaHRuZXNzX3NldHRpbmcgPSAxNTAgLSAoMTAwIC0gbm93KS8xLjc1O1xuXG4gICAgICAgIGlmIChicmlnaHRuZXNzX3NldHRpbmcgPCAxMDApIHtcbiAgICAgICAgICBicmlnaHRuZXNzX3NldHRpbmcgPSAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdyA+PSAwKSB7XG4gICAgICAgICAgJCh0aGlzKS5jc3Moe1xuICAgICAgICAgICAgICBcIi13ZWJraXQtZmlsdGVyXCI6IFwiZ3JheXNjYWxlKFwiK2dyYXlzY2FsZV9zZXR0aW5nK1wiKVwiICsgXCJicmlnaHRuZXNzKFwiK2JyaWdodG5lc3Nfc2V0dGluZytcIiUpXCIsXG4gICAgICAgICAgICAgIFwiZmlsdGVyXCI6IFwiZ3JheXNjYWxlKFwiK2dyYXlzY2FsZV9zZXR0aW5nK1wiKVwiICsgXCJicmlnaHRuZXNzKFwiK2JyaWdodG5lc3Nfc2V0dGluZytcIiUpXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIEhvcml6b250YWwgc3RhZ2dlcmVkIGxpc3RcbiAgTWF0ZXJpYWxpemUuc2hvd1N0YWdnZXJlZExpc3QgPSBmdW5jdGlvbihzZWxlY3Rvck9yRWwpIHtcbiAgICB2YXIgZWxlbWVudDtcbiAgICBpZiAodHlwZW9mKHNlbGVjdG9yT3JFbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbGVtZW50ID0gJChzZWxlY3Rvck9yRWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mKHNlbGVjdG9yT3JFbCkgPT09ICdvYmplY3QnKSB7XG4gICAgICBlbGVtZW50ID0gc2VsZWN0b3JPckVsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lID0gMDtcbiAgICBlbGVtZW50LmZpbmQoJ2xpJykudmVsb2NpdHkoXG4gICAgICAgIHsgdHJhbnNsYXRlWDogXCItMTAwcHhcIn0sXG4gICAgICAgIHsgZHVyYXRpb246IDAgfSk7XG5cbiAgICBlbGVtZW50LmZpbmQoJ2xpJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykudmVsb2NpdHkoXG4gICAgICAgIHsgb3BhY2l0eTogXCIxXCIsIHRyYW5zbGF0ZVg6IFwiMFwifSxcbiAgICAgICAgeyBkdXJhdGlvbjogODAwLCBkZWxheTogdGltZSwgZWFzaW5nOiBbNjAsIDEwXSB9KTtcbiAgICAgIHRpbWUgKz0gMTIwO1xuICAgIH0pO1xuICB9O1xuXG5cbiAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgLy8gSGFyZGNvZGVkIC5zdGFnZ2VyZWQtbGlzdCBzY3JvbGxGaXJlXG4gICAgLy8gdmFyIHN0YWdnZXJlZExpc3RPcHRpb25zID0gW107XG4gICAgLy8gJCgndWwuc3RhZ2dlcmVkLWxpc3QnKS5lYWNoKGZ1bmN0aW9uIChpKSB7XG5cbiAgICAvLyAgIHZhciBsYWJlbCA9ICdzY3JvbGxGaXJlLScgKyBpO1xuICAgIC8vICAgJCh0aGlzKS5hZGRDbGFzcyhsYWJlbCk7XG4gICAgLy8gICBzdGFnZ2VyZWRMaXN0T3B0aW9ucy5wdXNoKFxuICAgIC8vICAgICB7c2VsZWN0b3I6ICd1bC5zdGFnZ2VyZWQtbGlzdC4nICsgbGFiZWwsXG4gICAgLy8gICAgICBvZmZzZXQ6IDIwMCxcbiAgICAvLyAgICAgIGNhbGxiYWNrOiAnc2hvd1N0YWdnZXJlZExpc3QoXCJ1bC5zdGFnZ2VyZWQtbGlzdC4nICsgbGFiZWwgKyAnXCIpJ30pO1xuICAgIC8vIH0pO1xuICAgIC8vIHNjcm9sbEZpcmUoc3RhZ2dlcmVkTGlzdE9wdGlvbnMpO1xuXG4gICAgLy8gSGFtbWVySlMsIFN3aXBlIG5hdmlnYXRpb25cblxuICAgIC8vIFRvdWNoIEV2ZW50XG4gICAgdmFyIHN3aXBlTGVmdCA9IGZhbHNlO1xuICAgIHZhciBzd2lwZVJpZ2h0ID0gZmFsc2U7XG5cblxuICAgIC8vIERpc21pc3NpYmxlIENvbGxlY3Rpb25zXG4gICAgJCgnLmRpc21pc3NhYmxlJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykuaGFtbWVyKHtcbiAgICAgICAgcHJldmVudF9kZWZhdWx0OiBmYWxzZVxuICAgICAgfSkuYmluZCgncGFuJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5nZXN0dXJlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBlLmdlc3R1cmUuZGlyZWN0aW9uO1xuICAgICAgICAgIHZhciB4ID0gZS5nZXN0dXJlLmRlbHRhWDtcbiAgICAgICAgICB2YXIgdmVsb2NpdHlYID0gZS5nZXN0dXJlLnZlbG9jaXR5WDtcblxuICAgICAgICAgICR0aGlzLnZlbG9jaXR5KHsgdHJhbnNsYXRlWDogeFxuICAgICAgICAgICAgICB9LCB7ZHVyYXRpb246IDUwLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJ30pO1xuXG4gICAgICAgICAgLy8gU3dpcGUgTGVmdFxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDQgJiYgKHggPiAoJHRoaXMuaW5uZXJXaWR0aCgpIC8gMikgfHwgdmVsb2NpdHlYIDwgLTAuNzUpKSB7XG4gICAgICAgICAgICBzd2lwZUxlZnQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN3aXBlIFJpZ2h0XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMiAmJiAoeCA8ICgtMSAqICR0aGlzLmlubmVyV2lkdGgoKSAvIDIpIHx8IHZlbG9jaXR5WCA+IDAuNzUpKSB7XG4gICAgICAgICAgICBzd2lwZVJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLmJpbmQoJ3BhbmVuZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gUmVzZXQgaWYgY29sbGVjdGlvbiBpcyBtb3ZlZCBiYWNrIGludG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgaWYgKE1hdGguYWJzKGUuZ2VzdHVyZS5kZWx0YVgpIDwgKCQodGhpcykuaW5uZXJXaWR0aCgpIC8gMikpIHtcbiAgICAgICAgICBzd2lwZVJpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgc3dpcGVMZWZ0ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5nZXN0dXJlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAgIGlmIChzd2lwZUxlZnQgfHwgc3dpcGVSaWdodCkge1xuICAgICAgICAgICAgdmFyIGZ1bGxXaWR0aDtcbiAgICAgICAgICAgIGlmIChzd2lwZUxlZnQpIHsgZnVsbFdpZHRoID0gJHRoaXMuaW5uZXJXaWR0aCgpOyB9XG4gICAgICAgICAgICBlbHNlIHsgZnVsbFdpZHRoID0gLTEgKiAkdGhpcy5pbm5lcldpZHRoKCk7IH1cblxuICAgICAgICAgICAgJHRoaXMudmVsb2NpdHkoeyB0cmFuc2xhdGVYOiBmdWxsV2lkdGgsXG4gICAgICAgICAgICAgIH0sIHtkdXJhdGlvbjogMTAwLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJywgY29tcGxldGU6XG4gICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICR0aGlzLmNzcygnYm9yZGVyJywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAkdGhpcy52ZWxvY2l0eSh7IGhlaWdodDogMCwgcGFkZGluZzogMCxcbiAgICAgICAgICAgICAgICAgIH0sIHtkdXJhdGlvbjogMjAwLCBxdWV1ZTogZmFsc2UsIGVhc2luZzogJ2Vhc2VPdXRRdWFkJywgY29tcGxldGU6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyAkdGhpcy5yZW1vdmUoKTsgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICR0aGlzLnZlbG9jaXR5KHsgdHJhbnNsYXRlWDogMCxcbiAgICAgICAgICAgICAgfSwge2R1cmF0aW9uOiAxMDAsIHF1ZXVlOiBmYWxzZSwgZWFzaW5nOiAnZWFzZU91dFF1YWQnfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXBlTGVmdCA9IGZhbHNlO1xuICAgICAgICAgIHN3aXBlUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9KTtcblxuXG4gICAgLy8gdGltZSA9IDBcbiAgICAvLyAvLyBWZXJ0aWNhbCBTdGFnZ2VyZWQgbGlzdFxuICAgIC8vICQoJ3VsLnN0YWdnZXJlZC1saXN0LnZlcnRpY2FsIGxpJykudmVsb2NpdHkoXG4gICAgLy8gICAgIHsgdHJhbnNsYXRlWTogXCIxMDBweFwifSxcbiAgICAvLyAgICAgeyBkdXJhdGlvbjogMCB9KTtcblxuICAgIC8vICQoJ3VsLnN0YWdnZXJlZC1saXN0LnZlcnRpY2FsIGxpJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAvLyAgICQodGhpcykudmVsb2NpdHkoXG4gICAgLy8gICAgIHsgb3BhY2l0eTogXCIxXCIsIHRyYW5zbGF0ZVk6IFwiMFwifSxcbiAgICAvLyAgICAgeyBkdXJhdGlvbjogODAwLCBkZWxheTogdGltZSwgZWFzaW5nOiBbNjAsIDI1XSB9KTtcbiAgICAvLyAgIHRpbWUgKz0gMTIwO1xuICAgIC8vIH0pO1xuXG4gICAgLy8gLy8gRmFkZSBpbiBhbmQgU2NhbGVcbiAgICAvLyAkKCcuZmFkZS1pbi5zY2FsZScpLnZlbG9jaXR5KFxuICAgIC8vICAgICB7IHNjYWxlWDogLjQsIHNjYWxlWTogLjQsIHRyYW5zbGF0ZVg6IC02MDB9LFxuICAgIC8vICAgICB7IGR1cmF0aW9uOiAwfSk7XG4gICAgLy8gJCgnLmZhZGUtaW4nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIC8vICAgJCh0aGlzKS52ZWxvY2l0eShcbiAgICAvLyAgICAgeyBvcGFjaXR5OiBcIjFcIiwgc2NhbGVYOiAxLCBzY2FsZVk6IDEsIHRyYW5zbGF0ZVg6IDB9LFxuICAgIC8vICAgICB7IGR1cmF0aW9uOiA4MDAsIGVhc2luZzogWzYwLCAxMF0gfSk7XG4gICAgLy8gfSk7XG4gIH0pO1xufSggalF1ZXJ5ICkpO1xuOyhmdW5jdGlvbigkKSB7XG5cbiAgdmFyIHNjcm9sbEZpcmVFdmVudHNIYW5kbGVkID0gZmFsc2U7XG5cbiAgLy8gSW5wdXQ6IEFycmF5IG9mIEpTT04gb2JqZWN0cyB7c2VsZWN0b3IsIG9mZnNldCwgY2FsbGJhY2t9XG4gIE1hdGVyaWFsaXplLnNjcm9sbEZpcmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgd2luZG93U2Nyb2xsID0gd2luZG93LnBhZ2VZT2Zmc2V0ICsgd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEdldCBvcHRpb25zIGZyb20gZWFjaCBsaW5lXG4gICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbaV07XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHZhbHVlLnNlbGVjdG9yLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWUub2Zmc2V0LFxuICAgICAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZS5jYWxsYmFjaztcblxuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCBjdXJyZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBlbGVtZW50T2Zmc2V0ID0gY3VycmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0O1xuXG4gICAgICAgICAgaWYgKHdpbmRvd1Njcm9sbCA+IChlbGVtZW50T2Zmc2V0ICsgb2Zmc2V0KSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmRvbmUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZihjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGN1cnJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoY2FsbGJhY2spID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja0Z1bmMgPSBuZXcgRnVuY3Rpb24oY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrRnVuYyhjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgdmFyIHRocm90dGxlZFNjcm9sbCA9IE1hdGVyaWFsaXplLnRocm90dGxlKGZ1bmN0aW9uKCkge1xuICAgICAgb25TY3JvbGwoKTtcbiAgICB9LCBvcHRpb25zLnRocm90dGxlIHx8IDEwMCk7XG5cbiAgICBpZiAoIXNjcm9sbEZpcmVFdmVudHNIYW5kbGVkKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aHJvdHRsZWRTY3JvbGwpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhyb3R0bGVkU2Nyb2xsKTtcbiAgICAgIHNjcm9sbEZpcmVFdmVudHNIYW5kbGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIGEgc2NhbiBvbmNlLCBhZnRlciBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LCBhbmQgYWZ0ZXIgZG9tIGlzIHJlYWR5XG4gICAgc2V0VGltZW91dCh0aHJvdHRsZWRTY3JvbGwsIDApO1xuICB9O1xuXG59KShqUXVlcnkpO1xuOy8qIVxuICogcGlja2FkYXRlLmpzIHYzLjUuMCwgMjAxNC8wNC8xM1xuICogQnkgQW1zdWwsIGh0dHA6Ly9hbXN1bC5jYVxuICogSG9zdGVkIG9uIGh0dHA6Ly9hbXN1bC5naXRodWIuaW8vcGlja2FkYXRlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqL1xuXG4oZnVuY3Rpb24gKCBmYWN0b3J5ICkge1xuXG4gICAgLy8gQU1ELlxuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKVxuICAgICAgICBkZWZpbmUoICdwaWNrZXInLCBbJ2pxdWVyeSddLCBmYWN0b3J5IClcblxuICAgIC8vIE5vZGUuanMvYnJvd3NlcmlmeS5cbiAgICBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgKVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoJ2pxdWVyeScpIClcblxuICAgIC8vIEJyb3dzZXIgZ2xvYmFscy5cbiAgICBlbHNlIHRoaXMuUGlja2VyID0gZmFjdG9yeSggalF1ZXJ5IClcblxufShmdW5jdGlvbiggJCApIHtcblxudmFyICR3aW5kb3cgPSAkKCB3aW5kb3cgKVxudmFyICRkb2N1bWVudCA9ICQoIGRvY3VtZW50IClcbnZhciAkaHRtbCA9ICQoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApXG5cblxuLyoqXG4gKiBUaGUgcGlja2VyIGNvbnN0cnVjdG9yIHRoYXQgY3JlYXRlcyBhIGJsYW5rIHBpY2tlci5cbiAqL1xuZnVuY3Rpb24gUGlja2VyQ29uc3RydWN0b3IoIEVMRU1FTlQsIE5BTUUsIENPTVBPTkVOVCwgT1BUSU9OUyApIHtcblxuICAgIC8vIElmIHRoZXJl4oCZcyBubyBlbGVtZW50LCByZXR1cm4gdGhlIHBpY2tlciBjb25zdHJ1Y3Rvci5cbiAgICBpZiAoICFFTEVNRU5UICkgcmV0dXJuIFBpY2tlckNvbnN0cnVjdG9yXG5cblxuICAgIHZhclxuICAgICAgICBJU19ERUZBVUxUX1RIRU1FID0gZmFsc2UsXG5cblxuICAgICAgICAvLyBUaGUgc3RhdGUgb2YgdGhlIHBpY2tlci5cbiAgICAgICAgU1RBVEUgPSB7XG4gICAgICAgICAgICBpZDogRUxFTUVOVC5pZCB8fCAnUCcgKyBNYXRoLmFicyggfn4oTWF0aC5yYW5kb20oKSAqIG5ldyBEYXRlKCkpIClcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8vIE1lcmdlIHRoZSBkZWZhdWx0cyBhbmQgb3B0aW9ucyBwYXNzZWQuXG4gICAgICAgIFNFVFRJTkdTID0gQ09NUE9ORU5UID8gJC5leHRlbmQoIHRydWUsIHt9LCBDT01QT05FTlQuZGVmYXVsdHMsIE9QVElPTlMgKSA6IE9QVElPTlMgfHwge30sXG5cblxuICAgICAgICAvLyBNZXJnZSB0aGUgZGVmYXVsdCBjbGFzc2VzIHdpdGggdGhlIHNldHRpbmdzIGNsYXNzZXMuXG4gICAgICAgIENMQVNTRVMgPSAkLmV4dGVuZCgge30sIFBpY2tlckNvbnN0cnVjdG9yLmtsYXNzZXMoKSwgU0VUVElOR1Mua2xhc3MgKSxcblxuXG4gICAgICAgIC8vIFRoZSBlbGVtZW50IG5vZGUgd3JhcHBlciBpbnRvIGEgalF1ZXJ5IG9iamVjdC5cbiAgICAgICAgJEVMRU1FTlQgPSAkKCBFTEVNRU5UICksXG5cblxuICAgICAgICAvLyBQc2V1ZG8gcGlja2VyIGNvbnN0cnVjdG9yLlxuICAgICAgICBQaWNrZXJJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoKVxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLy8gVGhlIHBpY2tlciBwcm90b3R5cGUuXG4gICAgICAgIFAgPSBQaWNrZXJJbnN0YW5jZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBQaWNrZXJJbnN0YW5jZSxcblxuICAgICAgICAgICAgJG5vZGU6ICRFTEVNRU5ULFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZSBldmVyeXRoaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIElmIGl04oCZcyBhbHJlYWR5IHN0YXJ0ZWQsIGRvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCBTVEFURSAmJiBTVEFURS5zdGFydCApIHJldHVybiBQXG5cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcGlja2VyIHN0YXRlcy5cbiAgICAgICAgICAgICAgICBTVEFURS5tZXRob2RzID0ge31cbiAgICAgICAgICAgICAgICBTVEFURS5zdGFydCA9IHRydWVcbiAgICAgICAgICAgICAgICBTVEFURS5vcGVuID0gZmFsc2VcbiAgICAgICAgICAgICAgICBTVEFURS50eXBlID0gRUxFTUVOVC50eXBlXG5cblxuICAgICAgICAgICAgICAgIC8vIENvbmZpcm0gZm9jdXMgc3RhdGUsIGNvbnZlcnQgaW50byB0ZXh0IGlucHV0IHRvIHJlbW92ZSBVQSBzdHlsaW5ncyxcbiAgICAgICAgICAgICAgICAvLyBhbmQgc2V0IGFzIHJlYWRvbmx5IHRvIHByZXZlbnQga2V5Ym9hcmQgcG9wdXAuXG4gICAgICAgICAgICAgICAgRUxFTUVOVC5hdXRvZm9jdXMgPSBFTEVNRU5UID09IGdldEFjdGl2ZUVsZW1lbnQoKVxuICAgICAgICAgICAgICAgIEVMRU1FTlQucmVhZE9ubHkgPSAhU0VUVElOR1MuZWRpdGFibGVcbiAgICAgICAgICAgICAgICBFTEVNRU5ULmlkID0gRUxFTUVOVC5pZCB8fCBTVEFURS5pZFxuICAgICAgICAgICAgICAgIGlmICggRUxFTUVOVC50eXBlICE9ICd0ZXh0JyApIHtcbiAgICAgICAgICAgICAgICAgICAgRUxFTUVOVC50eXBlID0gJ3RleHQnXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGlja2VyIGNvbXBvbmVudCB3aXRoIHRoZSBzZXR0aW5ncy5cbiAgICAgICAgICAgICAgICBQLmNvbXBvbmVudCA9IG5ldyBDT01QT05FTlQoUCwgU0VUVElOR1MpXG5cblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcGlja2VyIHJvb3Qgd2l0aCBhIGhvbGRlciBhbmQgdGhlbiBwcmVwYXJlIGl0LlxuICAgICAgICAgICAgICAgIFAuJHJvb3QgPSAkKCBQaWNrZXJDb25zdHJ1Y3Rvci5fLm5vZGUoJ2RpdicsIGNyZWF0ZVdyYXBwZWRDb21wb25lbnQoKSwgQ0xBU1NFUy5waWNrZXIsICdpZD1cIicgKyBFTEVNRU5ULmlkICsgJ19yb290XCIgdGFiaW5kZXg9XCIwXCInKSApXG4gICAgICAgICAgICAgICAgcHJlcGFyZUVsZW1lbnRSb290KClcblxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmXigJlzIGEgZm9ybWF0IGZvciB0aGUgaGlkZGVuIGlucHV0IGVsZW1lbnQsIGNyZWF0ZSB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBpZiAoIFNFVFRJTkdTLmZvcm1hdFN1Ym1pdCApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUVsZW1lbnRIaWRkZW4oKVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBwcmVwYXJlRWxlbWVudCgpXG5cblxuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgcm9vdCBhcyBzcGVjaWZpZWQgaW4gdGhlIHNldHRpbmdzLlxuICAgICAgICAgICAgICAgIGlmICggU0VUVElOR1MuY29udGFpbmVyICkgJCggU0VUVElOR1MuY29udGFpbmVyICkuYXBwZW5kKCBQLiRyb290IClcbiAgICAgICAgICAgICAgICBlbHNlICRFTEVNRU5ULmFmdGVyKCBQLiRyb290IClcblxuXG4gICAgICAgICAgICAgICAgLy8gQmluZCB0aGUgZGVmYXVsdCBjb21wb25lbnQgYW5kIHNldHRpbmdzIGV2ZW50cy5cbiAgICAgICAgICAgICAgICBQLm9uKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFAuY29tcG9uZW50Lm9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogUC5jb21wb25lbnQub25SZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0b3A6IFAuY29tcG9uZW50Lm9uU3RvcCxcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogUC5jb21wb25lbnQub25PcGVuLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZTogUC5jb21wb25lbnQub25DbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBQLmNvbXBvbmVudC5vblNldFxuICAgICAgICAgICAgICAgIH0pLm9uKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFNFVFRJTkdTLm9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogU0VUVElOR1Mub25SZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0b3A6IFNFVFRJTkdTLm9uU3RvcCxcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogU0VUVElOR1Mub25PcGVuLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZTogU0VUVElOR1Mub25DbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBTRVRUSU5HUy5vblNldFxuICAgICAgICAgICAgICAgIH0pXG5cblxuICAgICAgICAgICAgICAgIC8vIE9uY2Ugd2XigJlyZSBhbGwgc2V0LCBjaGVjayB0aGUgdGhlbWUgaW4gdXNlLlxuICAgICAgICAgICAgICAgIElTX0RFRkFVTFRfVEhFTUUgPSBpc1VzaW5nRGVmYXVsdFRoZW1lKCBQLiRyb290LmNoaWxkcmVuKClbIDAgXSApXG5cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhdXRvZm9jdXMsIG9wZW4gdGhlIHBpY2tlci5cbiAgICAgICAgICAgICAgICBpZiAoIEVMRU1FTlQuYXV0b2ZvY3VzICkge1xuICAgICAgICAgICAgICAgICAgICBQLm9wZW4oKVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBxdWV1ZWQgdGhlIOKAnHN0YXJ04oCdIGFuZCDigJxyZW5kZXLigJ0gZXZlbnRzLlxuICAgICAgICAgICAgICAgIHJldHVybiBQLnRyaWdnZXIoICdzdGFydCcgKS50cmlnZ2VyKCAncmVuZGVyJyApXG4gICAgICAgICAgICB9LCAvL3N0YXJ0XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW5kZXIgYSBuZXcgcGlja2VyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oIGVudGlyZUNvbXBvbmVudCApIHtcblxuICAgICAgICAgICAgICAgIC8vIEluc2VydCBhIG5ldyBjb21wb25lbnQgaG9sZGVyIGluIHRoZSByb290IG9yIGJveC5cbiAgICAgICAgICAgICAgICBpZiAoIGVudGlyZUNvbXBvbmVudCApIFAuJHJvb3QuaHRtbCggY3JlYXRlV3JhcHBlZENvbXBvbmVudCgpIClcbiAgICAgICAgICAgICAgICBlbHNlIFAuJHJvb3QuZmluZCggJy4nICsgQ0xBU1NFUy5ib3ggKS5odG1sKCBQLmNvbXBvbmVudC5ub2RlcyggU1RBVEUub3BlbiApIClcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIHF1ZXVlZCDigJxyZW5kZXLigJ0gZXZlbnRzLlxuICAgICAgICAgICAgICAgIHJldHVybiBQLnRyaWdnZXIoICdyZW5kZXInIClcbiAgICAgICAgICAgIH0sIC8vcmVuZGVyXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZXN0cm95IGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdOKAmXMgYWxyZWFkeSBzdG9wcGVkLCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgICAgIGlmICggIVNUQVRFLnN0YXJ0ICkgcmV0dXJuIFBcblxuICAgICAgICAgICAgICAgIC8vIFRoZW4gY2xvc2UgdGhlIHBpY2tlci5cbiAgICAgICAgICAgICAgICBQLmNsb3NlKClcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaGlkZGVuIGZpZWxkLlxuICAgICAgICAgICAgICAgIGlmICggUC5faGlkZGVuICkge1xuICAgICAgICAgICAgICAgICAgICBQLl9oaWRkZW4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggUC5faGlkZGVuIClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHJvb3QuXG4gICAgICAgICAgICAgICAgUC4kcm9vdC5yZW1vdmUoKVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBpbnB1dCBjbGFzcywgcmVtb3ZlIHRoZSBzdG9yZWQgZGF0YSwgYW5kIHVuYmluZFxuICAgICAgICAgICAgICAgIC8vIHRoZSBldmVudHMgKGFmdGVyIGEgdGljayBmb3IgSUUgLSBzZWUgYFAuY2xvc2VgKS5cbiAgICAgICAgICAgICAgICAkRUxFTUVOVC5yZW1vdmVDbGFzcyggQ0xBU1NFUy5pbnB1dCApLnJlbW92ZURhdGEoIE5BTUUgKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkRUxFTUVOVC5vZmYoICcuJyArIFNUQVRFLmlkIClcbiAgICAgICAgICAgICAgICB9LCAwKVxuXG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgZWxlbWVudCBzdGF0ZVxuICAgICAgICAgICAgICAgIEVMRU1FTlQudHlwZSA9IFNUQVRFLnR5cGVcbiAgICAgICAgICAgICAgICBFTEVNRU5ULnJlYWRPbmx5ID0gZmFsc2VcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIHF1ZXVlZCDigJxzdG9w4oCdIGV2ZW50cy5cbiAgICAgICAgICAgICAgICBQLnRyaWdnZXIoICdzdG9wJyApXG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgcGlja2VyIHN0YXRlcy5cbiAgICAgICAgICAgICAgICBTVEFURS5tZXRob2RzID0ge31cbiAgICAgICAgICAgICAgICBTVEFURS5zdGFydCA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUFxuICAgICAgICAgICAgfSwgLy9zdG9wXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcGVuIHVwIHRoZSBwaWNrZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24oIGRvbnRHaXZlRm9jdXMgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdOKAmXMgYWxyZWFkeSBvcGVuLCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgICAgIGlmICggU1RBVEUub3BlbiApIHJldHVybiBQXG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIOKAnGFjdGl2ZeKAnSBjbGFzcy5cbiAgICAgICAgICAgICAgICAkRUxFTUVOVC5hZGRDbGFzcyggQ0xBU1NFUy5hY3RpdmUgKVxuICAgICAgICAgICAgICAgIGFyaWEoIEVMRU1FTlQsICdleHBhbmRlZCcsIHRydWUgKVxuXG4gICAgICAgICAgICAgICAgLy8gKiBBIEZpcmVmb3ggYnVnLCB3aGVuIGBodG1sYCBoYXMgYG92ZXJmbG93OmhpZGRlbmAsIHJlc3VsdHMgaW5cbiAgICAgICAgICAgICAgICAvLyAgIGtpbGxpbmcgdHJhbnNpdGlvbnMgOiguIFNvIGFkZCB0aGUg4oCcb3BlbmVk4oCdIHN0YXRlIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgICAgICAgICAgICAgLy8gICBCdWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTYyNTI4OVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUg4oCcb3BlbmVk4oCdIGNsYXNzIHRvIHRoZSBwaWNrZXIgcm9vdC5cbiAgICAgICAgICAgICAgICAgICAgUC4kcm9vdC5hZGRDbGFzcyggQ0xBU1NFUy5vcGVuZWQgKVxuICAgICAgICAgICAgICAgICAgICBhcmlhKCBQLiRyb290WzBdLCAnaGlkZGVuJywgZmFsc2UgKVxuXG4gICAgICAgICAgICAgICAgfSwgMCApXG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHRvIGdpdmUgZm9jdXMsIGJpbmQgdGhlIGVsZW1lbnQgYW5kIGRvYyBldmVudHMuXG4gICAgICAgICAgICAgICAgaWYgKCBkb250R2l2ZUZvY3VzICE9PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaXQgYXMgb3Blbi5cbiAgICAgICAgICAgICAgICAgICAgU1RBVEUub3BlbiA9IHRydWVcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIElTX0RFRkFVTFRfVEhFTUUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaHRtbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3MoICdvdmVyZmxvdycsICdoaWRkZW4nICkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzKCAncGFkZGluZy1yaWdodCcsICcrPScgKyBnZXRTY3JvbGxiYXJXaWR0aCgpIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgZm9jdXMgdG8gdGhlIHJvb3QgZWxlbWVudOKAmXMgalF1ZXJ5IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gKiBXb3JrYXJvdW5kIGZvciBpT1M4IHRvIGJyaW5nIHRoZSBwaWNrZXLigJlzIHJvb3QgaW50byB2aWV3LlxuICAgICAgICAgICAgICAgICAgICBQLiRyb290LmVxKDApLmZvY3VzKClcblxuICAgICAgICAgICAgICAgICAgICAvLyBCaW5kIHRoZSBkb2N1bWVudCBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgICRkb2N1bWVudC5vbiggJ2NsaWNrLicgKyBTVEFURS5pZCArICcgZm9jdXNpbi4nICsgU1RBVEUuaWQsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudCBpcyBub3QgdGhlIGVsZW1lbnQsIGNsb3NlIHRoZSBwaWNrZXIgcGlja2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKiBEb27igJl0IHdvcnJ5IGFib3V0IGNsaWNrcyBvciBmb2N1c2lucyBvbiB0aGUgcm9vdCBiZWNhdXNlIHRob3NlIGRvbuKAmXQgYnViYmxlIHVwLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBBbHNvLCBmb3IgRmlyZWZveCwgYSBjbGljayBvbiBhbiBgb3B0aW9uYCBlbGVtZW50IGJ1YmJsZXMgdXAgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgdG8gdGhlIGRvYy4gU28gbWFrZSBzdXJlIHRoZSB0YXJnZXQgd2Fzbid0IHRoZSBkb2MuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAqIEluIEZpcmVmb3ggc3RvcFByb3BhZ2F0aW9uKCkgZG9lc27igJl0IHByZXZlbnQgcmlnaHQtY2xpY2sgZXZlbnRzIGZyb20gYnViYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdoaWNoIGNhdXNlcyB0aGUgcGlja2VyIHRvIHVuZXhwZWN0ZWRseSBjbG9zZSB3aGVuIHJpZ2h0LWNsaWNraW5nIGl0LiBTbyBtYWtlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHN1cmUgdGhlIGV2ZW50IHdhc27igJl0IGEgcmlnaHQtY2xpY2suXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRhcmdldCAhPSBFTEVNRU5UICYmIHRhcmdldCAhPSBkb2N1bWVudCAmJiBldmVudC53aGljaCAhPSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCB3YXMgdGhlIGhvbGRlciB0aGF0IGNvdmVycyB0aGUgc2NyZWVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlIGVsZW1lbnQgZm9jdXNlZCB0byBtYWludGFpbiB0YWJpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLmNsb3NlKCB0YXJnZXQgPT09IFAuJHJvb3QuY2hpbGRyZW4oKVswXSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSkub24oICdrZXlkb3duLicgKyBTVEFURS5pZCwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGtleWNvZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5Y29kZSA9IGV2ZW50LmtleUNvZGUsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2xhdGUgdGhhdCB0byBhIHNlbGVjdGlvbiBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5Y29kZVRvTW92ZSA9IFAuY29tcG9uZW50LmtleVsga2V5Y29kZSBdLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR3JhYiB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGV2ZW50LnRhcmdldFxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9uIGVzY2FwZSwgY2xvc2UgdGhlIHBpY2tlciBhbmQgZ2l2ZSBmb2N1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgga2V5Y29kZSA9PSAyNyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLmNsb3NlKCB0cnVlIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIGtleSBtb3ZlbWVudCBvciDigJxlbnRlcuKAnSBrZXlwcmVzcyBvbiB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCB0YXJnZXQgPT0gUC4kcm9vdFswXSAmJiAoIGtleWNvZGVUb01vdmUgfHwga2V5Y29kZSA9PSAxMyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24gdG8gc3RvcCBwYWdlIG1vdmVtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGtleSBtb3ZlbWVudCBhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBrZXljb2RlVG9Nb3ZlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQaWNrZXJDb25zdHJ1Y3Rvci5fLnRyaWdnZXIoIFAuY29tcG9uZW50LmtleS5nbywgUCwgWyBQaWNrZXJDb25zdHJ1Y3Rvci5fLnRyaWdnZXIoIGtleWNvZGVUb01vdmUgKSBdIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiDigJxlbnRlcuKAnSwgaWYgdGhlIGhpZ2hsaWdodGVkIGl0ZW0gaXNu4oCZdCBkaXNhYmxlZCwgc2V0IHRoZSB2YWx1ZSBhbmQgY2xvc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoICFQLiRyb290LmZpbmQoICcuJyArIENMQVNTRVMuaGlnaGxpZ2h0ZWQgKS5oYXNDbGFzcyggQ0xBU1NFUy5kaXNhYmxlZCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLnNldCggJ3NlbGVjdCcsIFAuY29tcG9uZW50Lml0ZW0uaGlnaGxpZ2h0ICkuY2xvc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIHdpdGhpbiB0aGUgcm9vdCBhbmQg4oCcZW50ZXLigJ0gaXMgcHJlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uIGFuZCB0cmlnZ2VyIGEgY2xpY2sgb24gdGhlIHRhcmdldCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoICQuY29udGFpbnMoIFAuJHJvb3RbMF0sIHRhcmdldCApICYmIGtleWNvZGUgPT0gMTMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5jbGljaygpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgcXVldWVkIOKAnG9wZW7igJ0gZXZlbnRzLlxuICAgICAgICAgICAgICAgIHJldHVybiBQLnRyaWdnZXIoICdvcGVuJyApXG4gICAgICAgICAgICB9LCAvL29wZW5cblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENsb3NlIHRoZSBwaWNrZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCBnaXZlRm9jdXMgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBuZWVkIHRvIGdpdmUgZm9jdXMsIGRvIGl0IGJlZm9yZSBjaGFuZ2luZyBzdGF0ZXMuXG4gICAgICAgICAgICAgICAgaWYgKCBnaXZlRm9jdXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLi5haCB5ZXMhIEl0IHdvdWxk4oCZdmUgYmVlbiBpbmNvbXBsZXRlIHdpdGhvdXQgYSBjcmF6eSB3b3JrYXJvdW5kIGZvciBJRSA6fFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9jdXMgaXMgdHJpZ2dlcmVkICphZnRlciogdGhlIGNsb3NlIGhhcyBjb21wbGV0ZWQgLSBjYXVzaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIG9wZW4gYWdhaW4uIFNvIHVuYmluZCBhbmQgcmViaW5kIHRoZSBldmVudCBhdCB0aGUgbmV4dCB0aWNrLlxuICAgICAgICAgICAgICAgICAgICBQLiRyb290Lm9mZiggJ2ZvY3VzLnRvT3BlbicgKS5lcSgwKS5mb2N1cygpXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUC4kcm9vdC5vbiggJ2ZvY3VzLnRvT3BlbicsIGhhbmRsZUZvY3VzVG9PcGVuRXZlbnQgKVxuICAgICAgICAgICAgICAgICAgICB9LCAwIClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIOKAnGFjdGl2ZeKAnSBjbGFzcy5cbiAgICAgICAgICAgICAgICAkRUxFTUVOVC5yZW1vdmVDbGFzcyggQ0xBU1NFUy5hY3RpdmUgKVxuICAgICAgICAgICAgICAgIGFyaWEoIEVMRU1FTlQsICdleHBhbmRlZCcsIGZhbHNlIClcblxuICAgICAgICAgICAgICAgIC8vICogQSBGaXJlZm94IGJ1Zywgd2hlbiBgaHRtbGAgaGFzIGBvdmVyZmxvdzpoaWRkZW5gLCByZXN1bHRzIGluXG4gICAgICAgICAgICAgICAgLy8gICBraWxsaW5nIHRyYW5zaXRpb25zIDooLiBTbyByZW1vdmUgdGhlIOKAnG9wZW5lZOKAnSBzdGF0ZSBvbiB0aGUgbmV4dCB0aWNrLlxuICAgICAgICAgICAgICAgIC8vICAgQnVnOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MjUyODlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIOKAnG9wZW5lZOKAnSBhbmQg4oCcZm9jdXNlZOKAnSBjbGFzcyBmcm9tIHRoZSBwaWNrZXIgcm9vdC5cbiAgICAgICAgICAgICAgICAgICAgUC4kcm9vdC5yZW1vdmVDbGFzcyggQ0xBU1NFUy5vcGVuZWQgKyAnICcgKyBDTEFTU0VTLmZvY3VzZWQgKVxuICAgICAgICAgICAgICAgICAgICBhcmlhKCBQLiRyb290WzBdLCAnaGlkZGVuJywgdHJ1ZSApXG5cbiAgICAgICAgICAgICAgICB9LCAwIClcblxuICAgICAgICAgICAgICAgIC8vIElmIGl04oCZcyBhbHJlYWR5IGNsb3NlZCwgZG8gbm90aGluZyBtb3JlLlxuICAgICAgICAgICAgICAgIGlmICggIVNUQVRFLm9wZW4gKSByZXR1cm4gUFxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IGl0IGFzIGNsb3NlZC5cbiAgICAgICAgICAgICAgICBTVEFURS5vcGVuID0gZmFsc2VcblxuICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBwYWdlIHRvIHNjcm9sbC5cbiAgICAgICAgICAgICAgICBpZiAoIElTX0RFRkFVTFRfVEhFTUUgKSB7XG4gICAgICAgICAgICAgICAgICAgICRodG1sLlxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzKCAnb3ZlcmZsb3cnLCAnJyApLlxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzKCAncGFkZGluZy1yaWdodCcsICctPScgKyBnZXRTY3JvbGxiYXJXaWR0aCgpIClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVbmJpbmQgdGhlIGRvY3VtZW50IGV2ZW50cy5cbiAgICAgICAgICAgICAgICAkZG9jdW1lbnQub2ZmKCAnLicgKyBTVEFURS5pZCApXG5cbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBxdWV1ZWQg4oCcY2xvc2XigJ0gZXZlbnRzLlxuICAgICAgICAgICAgICAgIHJldHVybiBQLnRyaWdnZXIoICdjbG9zZScgKVxuICAgICAgICAgICAgfSwgLy9jbG9zZVxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2xlYXIgdGhlIHZhbHVlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFAuc2V0KCAnY2xlYXInLCBudWxsLCBvcHRpb25zIClcbiAgICAgICAgICAgIH0sIC8vY2xlYXJcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCBzb21ldGhpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggdGhpbmcsIHZhbHVlLCBvcHRpb25zICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRoaW5nSXRlbSwgdGhpbmdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpbmdJc09iamVjdCA9ICQuaXNQbGFpbk9iamVjdCggdGhpbmcgKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpbmdPYmplY3QgPSB0aGluZ0lzT2JqZWN0ID8gdGhpbmcgOiB7fVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgdXNhYmxlIG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHRoaW5nSXNPYmplY3QgJiYgJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApID8gdmFsdWUgOiBvcHRpb25zIHx8IHt9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRoaW5nICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0aGluZyBpc27igJl0IGFuIG9iamVjdCwgbWFrZSBpdCBvbmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXRoaW5nSXNPYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGluZ09iamVjdFsgdGhpbmcgXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSB0aGluZ3Mgb2YgaXRlbXMgdG8gc2V0LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB0aGluZ0l0ZW0gaW4gdGhpbmdPYmplY3QgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdyYWIgdGhlIHZhbHVlIG9mIHRoZSB0aGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaW5nVmFsdWUgPSB0aGluZ09iamVjdFsgdGhpbmdJdGVtIF1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QsIGlmIHRoZSBpdGVtIGV4aXN0cyBhbmQgdGhlcmXigJlzIGEgdmFsdWUsIHNldCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpbmdJdGVtIGluIFAuY29tcG9uZW50Lml0ZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGluZ1ZhbHVlID09PSB1bmRlZmluZWQgKSB0aGluZ1ZhbHVlID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuY29tcG9uZW50LnNldCggdGhpbmdJdGVtLCB0aGluZ1ZhbHVlLCBvcHRpb25zIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgY2hlY2sgdG8gdXBkYXRlIHRoZSBlbGVtZW50IHZhbHVlIGFuZCBicm9hZGNhc3QgYSBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaW5nSXRlbSA9PSAnc2VsZWN0JyB8fCB0aGluZ0l0ZW0gPT0gJ2NsZWFyJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkRUxFTUVOVC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsKCB0aGluZ0l0ZW0gPT0gJ2NsZWFyJyA/ICcnIDogUC5nZXQoIHRoaW5nSXRlbSwgU0VUVElOR1MuZm9ybWF0ICkgKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlciggJ2NoYW5nZScgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVuZGVyIGEgbmV3IHBpY2tlci5cbiAgICAgICAgICAgICAgICAgICAgUC5yZW5kZXIoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIG1ldGhvZCBpc27igJl0IG11dGVkLCB0cmlnZ2VyIHF1ZXVlZCDigJxzZXTigJ0gZXZlbnRzIGFuZCBwYXNzIHRoZSBgdGhpbmdPYmplY3RgLlxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm11dGVkID8gUCA6IFAudHJpZ2dlciggJ3NldCcsIHRoaW5nT2JqZWN0IClcbiAgICAgICAgICAgIH0sIC8vc2V0XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgc29tZXRoaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIHRoaW5nLCBmb3JtYXQgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmXigJlzIHNvbWV0aGluZyB0byBnZXQuXG4gICAgICAgICAgICAgICAgdGhpbmcgPSB0aGluZyB8fCAndmFsdWUnXG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIHBpY2tlciBzdGF0ZSBleGlzdHMsIHJldHVybiB0aGF0LlxuICAgICAgICAgICAgICAgIGlmICggU1RBVEVbIHRoaW5nIF0gIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFWyB0aGluZyBdXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBzdWJtaXNzaW9uIHZhbHVlLCBpZiB0aGF0LlxuICAgICAgICAgICAgICAgIGlmICggdGhpbmcgPT0gJ3ZhbHVlU3VibWl0JyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBQLl9oaWRkZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC5faGlkZGVuLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpbmcgPSAndmFsdWUnXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSB2YWx1ZSwgaWYgdGhhdC5cbiAgICAgICAgICAgICAgICBpZiAoIHRoaW5nID09ICd2YWx1ZScgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFTEVNRU5ULnZhbHVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBjb21wb25lbnQgaXRlbSBleGlzdHMsIHJldHVybiB0aGF0LlxuICAgICAgICAgICAgICAgIGlmICggdGhpbmcgaW4gUC5jb21wb25lbnQuaXRlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgZm9ybWF0ID09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoaW5nVmFsdWUgPSBQLmNvbXBvbmVudC5nZXQoIHRoaW5nIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGluZ1ZhbHVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQaWNrZXJDb25zdHJ1Y3Rvci5fLnRyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuY29tcG9uZW50LmZvcm1hdHMudG9TdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIGZvcm1hdCwgdGhpbmdWYWx1ZSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSA6ICcnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFAuY29tcG9uZW50LmdldCggdGhpbmcgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIC8vZ2V0XG5cblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJpbmQgZXZlbnRzIG9uIHRoZSB0aGluZ3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uOiBmdW5jdGlvbiggdGhpbmcsIG1ldGhvZCwgaW50ZXJuYWwgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGhpbmdOYW1lLCB0aGluZ01ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdGhpbmdJc09iamVjdCA9ICQuaXNQbGFpbk9iamVjdCggdGhpbmcgKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpbmdPYmplY3QgPSB0aGluZ0lzT2JqZWN0ID8gdGhpbmcgOiB7fVxuXG4gICAgICAgICAgICAgICAgaWYgKCB0aGluZyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGhpbmcgaXNu4oCZdCBhbiBvYmplY3QsIG1ha2UgaXQgb25lLlxuICAgICAgICAgICAgICAgICAgICBpZiAoICF0aGluZ0lzT2JqZWN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpbmdPYmplY3RbIHRoaW5nIF0gPSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIHRoaW5ncyB0byBiaW5kIHRvLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB0aGluZ05hbWUgaW4gdGhpbmdPYmplY3QgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdyYWIgdGhlIG1ldGhvZCBvZiB0aGUgdGhpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGluZ01ldGhvZCA9IHRoaW5nT2JqZWN0WyB0aGluZ05hbWUgXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCB3YXMgYW4gaW50ZXJuYWwgYmluZGluZywgcHJlZml4IGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcm5hbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGluZ05hbWUgPSAnXycgKyB0aGluZ05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0aGluZyBtZXRob2RzIGNvbGxlY3Rpb24gZXhpc3RzLlxuICAgICAgICAgICAgICAgICAgICAgICAgU1RBVEUubWV0aG9kc1sgdGhpbmdOYW1lIF0gPSBTVEFURS5tZXRob2RzWyB0aGluZ05hbWUgXSB8fCBbXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG1ldGhvZCB0byB0aGUgcmVsYXRpdmUgbWV0aG9kIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBTVEFURS5tZXRob2RzWyB0aGluZ05hbWUgXS5wdXNoKCB0aGluZ01ldGhvZCApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUFxuICAgICAgICAgICAgfSwgLy9vblxuXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVbmJpbmQgZXZlbnRzIG9uIHRoZSB0aGluZ3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9mZjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIHRoaW5nTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIG5hbWVzQ291bnQgPSBuYW1lcy5sZW5ndGg7IGkgPCBuYW1lc0NvdW50OyBpICs9IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaW5nTmFtZSA9IG5hbWVzW2ldXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpbmdOYW1lIGluIFNUQVRFLm1ldGhvZHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgU1RBVEUubWV0aG9kc1t0aGluZ05hbWVdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBcbiAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGaXJlIG9mZiBtZXRob2QgZXZlbnRzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiggbmFtZSwgZGF0YSApIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RyaWdnZXIgPSBmdW5jdGlvbiggbmFtZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZExpc3QgPSBTVEFURS5tZXRob2RzWyBuYW1lIF1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtZXRob2RMaXN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kTGlzdC5tYXAoIGZ1bmN0aW9uKCBtZXRob2QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUGlja2VyQ29uc3RydWN0b3IuXy50cmlnZ2VyKCBtZXRob2QsIFAsIFsgZGF0YSBdIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RyaWdnZXIoICdfJyArIG5hbWUgKVxuICAgICAgICAgICAgICAgIF90cmlnZ2VyKCBuYW1lIClcbiAgICAgICAgICAgICAgICByZXR1cm4gUFxuICAgICAgICAgICAgfSAvL3RyaWdnZXJcbiAgICAgICAgfSAvL1BpY2tlckluc3RhbmNlLnByb3RvdHlwZVxuXG5cbiAgICAvKipcbiAgICAgKiBXcmFwIHRoZSBwaWNrZXIgaG9sZGVyIGNvbXBvbmVudHMgdG9nZXRoZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlZENvbXBvbmVudCgpIHtcblxuICAgICAgICAvLyBDcmVhdGUgYSBwaWNrZXIgd3JhcHBlciBob2xkZXJcbiAgICAgICAgcmV0dXJuIFBpY2tlckNvbnN0cnVjdG9yLl8ubm9kZSggJ2RpdicsXG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHBpY2tlciB3cmFwcGVyIG5vZGVcbiAgICAgICAgICAgIFBpY2tlckNvbnN0cnVjdG9yLl8ubm9kZSggJ2RpdicsXG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwaWNrZXIgZnJhbWVcbiAgICAgICAgICAgICAgICBQaWNrZXJDb25zdHJ1Y3Rvci5fLm5vZGUoICdkaXYnLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHBpY2tlciBib3ggbm9kZVxuICAgICAgICAgICAgICAgICAgICBQaWNrZXJDb25zdHJ1Y3Rvci5fLm5vZGUoICdkaXYnLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNvbXBvbmVudHMgbm9kZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBQLmNvbXBvbmVudC5ub2RlcyggU1RBVEUub3BlbiApLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcGlja2VyIGJveCBjbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgQ0xBU1NFUy5ib3hcbiAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBQaWNrZXIgd3JhcCBjbGFzc1xuICAgICAgICAgICAgICAgICAgICBDTEFTU0VTLndyYXBcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgLy8gUGlja2VyIGZyYW1lIGNsYXNzXG4gICAgICAgICAgICAgICAgQ0xBU1NFUy5mcmFtZVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgLy8gUGlja2VyIGhvbGRlciBjbGFzc1xuICAgICAgICAgICAgQ0xBU1NFUy5ob2xkZXJcbiAgICAgICAgKSAvL2VuZHJldHVyblxuICAgIH0gLy9jcmVhdGVXcmFwcGVkQ29tcG9uZW50XG5cblxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgaW5wdXQgZWxlbWVudCB3aXRoIGFsbCBiaW5kaW5ncy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVwYXJlRWxlbWVudCgpIHtcblxuICAgICAgICAkRUxFTUVOVC5cblxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHBpY2tlciBkYXRhIGJ5IGNvbXBvbmVudCBuYW1lLlxuICAgICAgICAgICAgZGF0YShOQU1FLCBQKS5cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSDigJxpbnB1dOKAnSBjbGFzcyBuYW1lLlxuICAgICAgICAgICAgYWRkQ2xhc3MoQ0xBU1NFUy5pbnB1dCkuXG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdGFiaW5kZXguXG4gICAgICAgICAgICBhdHRyKCd0YWJpbmRleCcsIC0xKS5cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmXigJlzIGEgYGRhdGEtdmFsdWVgLCB1cGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgdmFsKCAkRUxFTUVOVC5kYXRhKCd2YWx1ZScpID9cbiAgICAgICAgICAgICAgICBQLmdldCgnc2VsZWN0JywgU0VUVElOR1MuZm9ybWF0KSA6XG4gICAgICAgICAgICAgICAgRUxFTUVOVC52YWx1ZVxuICAgICAgICAgICAgKVxuXG5cbiAgICAgICAgLy8gT25seSBiaW5kIGtleWRvd24gZXZlbnRzIGlmIHRoZSBlbGVtZW50IGlzbuKAmXQgZWRpdGFibGUuXG4gICAgICAgIGlmICggIVNFVFRJTkdTLmVkaXRhYmxlICkge1xuXG4gICAgICAgICAgICAkRUxFTUVOVC5cblxuICAgICAgICAgICAgICAgIC8vIE9uIGZvY3VzL2NsaWNrLCBmb2N1cyBvbnRvIHRoZSByb290IHRvIG9wZW4gaXQgdXAuXG4gICAgICAgICAgICAgICAgb24oICdmb2N1cy4nICsgU1RBVEUuaWQgKyAnIGNsaWNrLicgKyBTVEFURS5pZCwgZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgIFAuJHJvb3QuZXEoMCkuZm9jdXMoKVxuICAgICAgICAgICAgICAgIH0pLlxuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGtleWJvYXJkIGV2ZW50IGJhc2VkIG9uIHRoZSBwaWNrZXIgYmVpbmcgb3BlbmVkIG9yIG5vdC5cbiAgICAgICAgICAgICAgICBvbiggJ2tleWRvd24uJyArIFNUQVRFLmlkLCBoYW5kbGVLZXlkb3duRXZlbnQgKVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGFyaWEgYXR0cmlidXRlcy5cbiAgICAgICAgYXJpYShFTEVNRU5ULCB7XG4gICAgICAgICAgICBoYXNwb3B1cDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlYWRvbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIG93bnM6IEVMRU1FTlQuaWQgKyAnX3Jvb3QnXG4gICAgICAgIH0pXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSByb290IHBpY2tlciBlbGVtZW50IHdpdGggYWxsIGJpbmRpbmdzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXBhcmVFbGVtZW50Um9vdCgpIHtcblxuICAgICAgICBQLiRyb290LlxuXG4gICAgICAgICAgICBvbih7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgaU9TOC5cbiAgICAgICAgICAgICAgICBrZXlkb3duOiBoYW5kbGVLZXlkb3duRXZlbnQsXG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHNvbWV0aGluZyB3aXRoaW4gdGhlIHJvb3QgaXMgZm9jdXNlZCwgc3RvcCBmcm9tIGJ1YmJsaW5nXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIGRvYyBhbmQgcmVtb3ZlIHRoZSDigJxmb2N1c2Vk4oCdIHN0YXRlIGZyb20gdGhlIHJvb3QuXG4gICAgICAgICAgICAgICAgZm9jdXNpbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBQLiRyb290LnJlbW92ZUNsYXNzKCBDTEFTU0VTLmZvY3VzZWQgKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHNvbWV0aGluZyB3aXRoaW4gdGhlIHJvb3QgaG9sZGVyIGlzIGNsaWNrZWQsIHN0b3AgaXRcbiAgICAgICAgICAgICAgICAvLyBmcm9tIGJ1YmJsaW5nIHRvIHRoZSBkb2MuXG4gICAgICAgICAgICAgICAgJ21vdXNlZG93biBjbGljayc6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0YXJnZXQgaXNu4oCZdCB0aGUgcm9vdCBob2xkZXIgc28gaXQgY2FuIGJ1YmJsZSB1cC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0YXJnZXQgIT0gUC4kcm9vdC5jaGlsZHJlbigpWyAwIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICogRm9yIG1vdXNlZG93biBldmVudHMsIGNhbmNlbCB0aGUgZGVmYXVsdCBhY3Rpb24gaW4gb3JkZXIgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcHJldmVudCBjYXNlcyB3aGVyZSBmb2N1cyBpcyBzaGlmdGVkIG9udG8gZXh0ZXJuYWwgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgd2hlbiB1c2luZyB0aGluZ3MgbGlrZSBqUXVlcnkgbW9iaWxlIG9yIE1hZ25pZmljUG9wdXAgKHJlZjogIzI0OSAmICMxMjApLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBBbHNvLCBmb3IgRmlyZWZveCwgZG9u4oCZdCBwcmV2ZW50IGFjdGlvbiBvbiB0aGUgYG9wdGlvbmAgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXZlbnQudHlwZSA9PSAnbW91c2Vkb3duJyAmJiAhJCggdGFyZ2V0ICkuaXMoICdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgYnV0dG9uLCBvcHRpb24nICkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLWZvY3VzIG9udG8gdGhlIHJvb3Qgc28gdGhhdCB1c2VycyBjYW4gY2xpY2sgYXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb20gZWxlbWVudHMgZm9jdXNlZCB3aXRoaW4gdGhlIHBpY2tlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLiRyb290LmVxKDApLmZvY3VzKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLlxuXG4gICAgICAgICAgICAvLyBBZGQvcmVtb3ZlIHRoZSDigJx0YXJnZXTigJ0gY2xhc3Mgb24gZm9jdXMgYW5kIGJsdXIuXG4gICAgICAgICAgICBvbih7XG4gICAgICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkRUxFTUVOVC5hZGRDbGFzcyggQ0xBU1NFUy50YXJnZXQgKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmx1cjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRFTEVNRU5ULnJlbW92ZUNsYXNzKCBDTEFTU0VTLnRhcmdldCApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuXG5cbiAgICAgICAgICAgIC8vIE9wZW4gdGhlIHBpY2tlciBhbmQgYWRqdXN0IHRoZSByb290IOKAnGZvY3VzZWTigJ0gc3RhdGVcbiAgICAgICAgICAgIG9uKCAnZm9jdXMudG9PcGVuJywgaGFuZGxlRm9jdXNUb09wZW5FdmVudCApLlxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZeKAmXMgYSBjbGljayBvbiBhbiBhY3Rpb25hYmxlIGVsZW1lbnQsIGNhcnJ5IG91dCB0aGUgYWN0aW9ucy5cbiAgICAgICAgICAgIG9uKCAnY2xpY2snLCAnW2RhdGEtcGlja10sIFtkYXRhLW5hdl0sIFtkYXRhLWNsZWFyXSwgW2RhdGEtY2xvc2VdJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgJHRhcmdldCA9ICQoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGF0YSA9ICR0YXJnZXQuZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXREaXNhYmxlZCA9ICR0YXJnZXQuaGFzQ2xhc3MoIENMQVNTRVMubmF2RGlzYWJsZWQgKSB8fCAkdGFyZ2V0Lmhhc0NsYXNzKCBDTEFTU0VTLmRpc2FibGVkICksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gKiBGb3IgSUUsIG5vbi1mb2N1c2FibGUgZWxlbWVudHMgY2FuIGJlIGFjdGl2ZSBlbGVtZW50cyBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2ODQ1NjEpLlxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCgpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50ICYmICggYWN0aXZlRWxlbWVudC50eXBlIHx8IGFjdGl2ZUVsZW1lbnQuaHJlZiApXG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdOKAmXMgZGlzYWJsZWQgb3Igbm90aGluZyBpbnNpZGUgaXMgYWN0aXZlbHkgZm9jdXNlZCwgcmUtZm9jdXMgdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKCB0YXJnZXREaXNhYmxlZCB8fCBhY3RpdmVFbGVtZW50ICYmICEkLmNvbnRhaW5zKCBQLiRyb290WzBdLCBhY3RpdmVFbGVtZW50ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIFAuJHJvb3QuZXEoMCkuZm9jdXMoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyBzdXBlcmZpY2lhbGx5IGNoYW5nZWQsIHVwZGF0ZSB0aGUgYGhpZ2hsaWdodGAgYmFzZWQgb24gdGhlIGBuYXZgLlxuICAgICAgICAgICAgICAgIGlmICggIXRhcmdldERpc2FibGVkICYmIHRhcmdldERhdGEubmF2ICkge1xuICAgICAgICAgICAgICAgICAgICBQLnNldCggJ2hpZ2hsaWdodCcsIFAuY29tcG9uZW50Lml0ZW0uaGlnaGxpZ2h0LCB7IG5hdjogdGFyZ2V0RGF0YS5uYXYgfSApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIGlzIHBpY2tlZCwgc2V0IGBzZWxlY3RgIHRoZW4gY2xvc2Ugd2l0aCBmb2N1cy5cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggIXRhcmdldERpc2FibGVkICYmICdwaWNrJyBpbiB0YXJnZXREYXRhICkge1xuICAgICAgICAgICAgICAgICAgICBQLnNldCggJ3NlbGVjdCcsIHRhcmdldERhdGEucGljayApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYSDigJxjbGVhcuKAnSBidXR0b24gaXMgcHJlc3NlZCwgZW1wdHkgdGhlIHZhbHVlcyBhbmQgY2xvc2Ugd2l0aCBmb2N1cy5cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggdGFyZ2V0RGF0YS5jbGVhciApIHtcbiAgICAgICAgICAgICAgICAgICAgUC5jbGVhcigpLmNsb3NlKCB0cnVlIClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggdGFyZ2V0RGF0YS5jbG9zZSApIHtcbiAgICAgICAgICAgICAgICAgICAgUC5jbG9zZSggdHJ1ZSApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KSAvL1AuJHJvb3RcblxuICAgICAgICBhcmlhKCBQLiRyb290WzBdLCAnaGlkZGVuJywgdHJ1ZSApXG4gICAgfVxuXG5cbiAgICAgLyoqXG4gICAgICAqIFByZXBhcmUgdGhlIGhpZGRlbiBpbnB1dCBlbGVtZW50IGFsb25nIHdpdGggYWxsIGJpbmRpbmdzLlxuICAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVwYXJlRWxlbWVudEhpZGRlbigpIHtcblxuICAgICAgICB2YXIgbmFtZVxuXG4gICAgICAgIGlmICggU0VUVElOR1MuaGlkZGVuTmFtZSA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgIG5hbWUgPSBFTEVNRU5ULm5hbWVcbiAgICAgICAgICAgIEVMRU1FTlQubmFtZSA9ICcnXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gW1xuICAgICAgICAgICAgICAgIHR5cGVvZiBTRVRUSU5HUy5oaWRkZW5QcmVmaXggPT0gJ3N0cmluZycgPyBTRVRUSU5HUy5oaWRkZW5QcmVmaXggOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlb2YgU0VUVElOR1MuaGlkZGVuU3VmZml4ID09ICdzdHJpbmcnID8gU0VUVElOR1MuaGlkZGVuU3VmZml4IDogJ19zdWJtaXQnXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICBuYW1lID0gbmFtZVswXSArIEVMRU1FTlQubmFtZSArIG5hbWVbMV1cbiAgICAgICAgfVxuXG4gICAgICAgIFAuX2hpZGRlbiA9ICQoXG4gICAgICAgICAgICAnPGlucHV0ICcgK1xuICAgICAgICAgICAgJ3R5cGU9aGlkZGVuICcgK1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5hbWUgdXNpbmcgdGhlIG9yaWdpbmFsIGlucHV04oCZcyB3aXRoIGEgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgICAgICAnbmFtZT1cIicgKyBuYW1lICsgJ1wiJyArXG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIHZhbHVlLCBzZXQgdGhlIGhpZGRlbiB2YWx1ZSBhcyB3ZWxsLlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICRFTEVNRU5ULmRhdGEoJ3ZhbHVlJykgfHwgRUxFTUVOVC52YWx1ZSA/XG4gICAgICAgICAgICAgICAgICAgICcgdmFsdWU9XCInICsgUC5nZXQoJ3NlbGVjdCcsIFNFVFRJTkdTLmZvcm1hdFN1Ym1pdCkgKyAnXCInIDpcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgJz4nXG4gICAgICAgIClbMF1cblxuICAgICAgICAkRUxFTUVOVC5cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGNoYW5nZXMsIHVwZGF0ZSB0aGUgaGlkZGVuIGlucHV0IHdpdGggdGhlIGNvcnJlY3QgZm9ybWF0LlxuICAgICAgICAgICAgb24oJ2NoYW5nZS4nICsgU1RBVEUuaWQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIFAuX2hpZGRlbi52YWx1ZSA9IEVMRU1FTlQudmFsdWUgP1xuICAgICAgICAgICAgICAgICAgICBQLmdldCgnc2VsZWN0JywgU0VUVElOR1MuZm9ybWF0U3VibWl0KSA6XG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICB9KVxuXG5cbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBoaWRkZW4gaW5wdXQgYXMgc3BlY2lmaWVkIGluIHRoZSBzZXR0aW5ncy5cbiAgICAgICAgaWYgKCBTRVRUSU5HUy5jb250YWluZXIgKSAkKCBTRVRUSU5HUy5jb250YWluZXIgKS5hcHBlbmQoIFAuX2hpZGRlbiApXG4gICAgICAgIGVsc2UgJEVMRU1FTlQuYWZ0ZXIoIFAuX2hpZGRlbiApXG4gICAgfVxuXG5cbiAgICAvLyBGb3IgaU9TOC5cbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlkb3duRXZlbnQoIGV2ZW50ICkge1xuXG4gICAgICAgIHZhciBrZXljb2RlID0gZXZlbnQua2V5Q29kZSxcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb25lIG9mIHRoZSBkZWxldGUga2V5cyB3YXMgcHJlc3NlZC5cbiAgICAgICAgICAgIGlzS2V5Y29kZURlbGV0ZSA9IC9eKDh8NDYpJC8udGVzdChrZXljb2RlKVxuXG4gICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBJRSBjbGVhcnMgdGhlIGlucHV0IHZhbHVlIG9uIOKAnGVzY2FwZeKAnS5cbiAgICAgICAgaWYgKCBrZXljb2RlID09IDI3ICkge1xuICAgICAgICAgICAgUC5jbG9zZSgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGBzcGFjZWAgb3IgYGRlbGV0ZWAgd2FzIHByZXNzZWQgb3IgdGhlIHBpY2tlciBpcyBjbG9zZWQgd2l0aCBhIGtleSBtb3ZlbWVudC5cbiAgICAgICAgaWYgKCBrZXljb2RlID09IDMyIHx8IGlzS2V5Y29kZURlbGV0ZSB8fCAhU1RBVEUub3BlbiAmJiBQLmNvbXBvbmVudC5rZXlba2V5Y29kZV0gKSB7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgaXQgZnJvbSBtb3ZpbmcgdGhlIHBhZ2UgYW5kIGJ1YmJsaW5nIHRvIGRvYy5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICAgICAgICAgIC8vIElmIGBkZWxldGVgIHdhcyBwcmVzc2VkLCBjbGVhciB0aGUgdmFsdWVzIGFuZCBjbG9zZSB0aGUgcGlja2VyLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIG9wZW4gdGhlIHBpY2tlci5cbiAgICAgICAgICAgIGlmICggaXNLZXljb2RlRGVsZXRlICkgeyBQLmNsZWFyKCkuY2xvc2UoKSB9XG4gICAgICAgICAgICBlbHNlIHsgUC5vcGVuKCkgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBTZXBhcmF0ZWQgZm9yIElFXG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNUb09wZW5FdmVudCggZXZlbnQgKSB7XG5cbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgZnJvbSBwcm9wYWdhdGluZyB0byB0aGUgZG9jLlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgICAgIC8vIElmIGl04oCZcyBhIGZvY3VzIGV2ZW50LCBhZGQgdGhlIOKAnGZvY3VzZWTigJ0gY2xhc3MgdG8gdGhlIHJvb3QuXG4gICAgICAgIGlmICggZXZlbnQudHlwZSA9PSAnZm9jdXMnICkge1xuICAgICAgICAgICAgUC4kcm9vdC5hZGRDbGFzcyggQ0xBU1NFUy5mb2N1c2VkIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuZCB0aGVuIGZpbmFsbHkgb3BlbiB0aGUgcGlja2VyLlxuICAgICAgICBQLm9wZW4oKVxuICAgIH1cblxuXG4gICAgLy8gUmV0dXJuIGEgbmV3IHBpY2tlciBpbnN0YW5jZS5cbiAgICByZXR1cm4gbmV3IFBpY2tlckluc3RhbmNlKClcbn0gLy9QaWNrZXJDb25zdHJ1Y3RvclxuXG5cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBjbGFzc2VzIGFuZCBwcmVmaXggdG8gdXNlIGZvciB0aGUgSFRNTCBjbGFzc2VzLlxuICovXG5QaWNrZXJDb25zdHJ1Y3Rvci5rbGFzc2VzID0gZnVuY3Rpb24oIHByZWZpeCApIHtcbiAgICBwcmVmaXggPSBwcmVmaXggfHwgJ3BpY2tlcidcbiAgICByZXR1cm4ge1xuXG4gICAgICAgIHBpY2tlcjogcHJlZml4LFxuICAgICAgICBvcGVuZWQ6IHByZWZpeCArICctLW9wZW5lZCcsXG4gICAgICAgIGZvY3VzZWQ6IHByZWZpeCArICctLWZvY3VzZWQnLFxuXG4gICAgICAgIGlucHV0OiBwcmVmaXggKyAnX19pbnB1dCcsXG4gICAgICAgIGFjdGl2ZTogcHJlZml4ICsgJ19faW5wdXQtLWFjdGl2ZScsXG4gICAgICAgIHRhcmdldDogcHJlZml4ICsgJ19faW5wdXQtLXRhcmdldCcsXG5cbiAgICAgICAgaG9sZGVyOiBwcmVmaXggKyAnX19ob2xkZXInLFxuXG4gICAgICAgIGZyYW1lOiBwcmVmaXggKyAnX19mcmFtZScsXG4gICAgICAgIHdyYXA6IHByZWZpeCArICdfX3dyYXAnLFxuXG4gICAgICAgIGJveDogcHJlZml4ICsgJ19fYm94J1xuICAgIH1cbn0gLy9QaWNrZXJDb25zdHJ1Y3Rvci5rbGFzc2VzXG5cblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkZWZhdWx0IHRoZW1lIGlzIGJlaW5nIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzVXNpbmdEZWZhdWx0VGhlbWUoIGVsZW1lbnQgKSB7XG5cbiAgICB2YXIgdGhlbWUsXG4gICAgICAgIHByb3AgPSAncG9zaXRpb24nXG5cbiAgICAvLyBGb3IgSUUuXG4gICAgaWYgKCBlbGVtZW50LmN1cnJlbnRTdHlsZSApIHtcbiAgICAgICAgdGhlbWUgPSBlbGVtZW50LmN1cnJlbnRTdHlsZVtwcm9wXVxuICAgIH1cblxuICAgIC8vIEZvciBub3JtYWwgYnJvd3NlcnMuXG4gICAgZWxzZSBpZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICkge1xuICAgICAgICB0aGVtZSA9IGdldENvbXB1dGVkU3R5bGUoIGVsZW1lbnQgKVtwcm9wXVxuICAgIH1cblxuICAgIHJldHVybiB0aGVtZSA9PSAnZml4ZWQnXG59XG5cblxuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggb2YgdGhlIGJyb3dzZXLigJlzIHNjcm9sbGJhci5cbiAqIFRha2VuIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9Wb2RrYUJlYXJzL1JlbW9kYWwvYmxvYi9tYXN0ZXIvc3JjL2pxdWVyeS5yZW1vZGFsLmpzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRoKCkge1xuXG4gICAgaWYgKCAkaHRtbC5oZWlnaHQoKSA8PSAkd2luZG93LmhlaWdodCgpICkge1xuICAgICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHZhciAkb3V0ZXIgPSAkKCAnPGRpdiBzdHlsZT1cInZpc2liaWxpdHk6aGlkZGVuO3dpZHRoOjEwMHB4XCIgLz4nICkuXG4gICAgICAgIGFwcGVuZFRvKCAnYm9keScgKVxuXG4gICAgLy8gR2V0IHRoZSB3aWR0aCB3aXRob3V0IHNjcm9sbGJhcnMuXG4gICAgdmFyIHdpZHRoV2l0aG91dFNjcm9sbCA9ICRvdXRlclswXS5vZmZzZXRXaWR0aFxuXG4gICAgLy8gRm9yY2UgYWRkaW5nIHNjcm9sbGJhcnMuXG4gICAgJG91dGVyLmNzcyggJ292ZXJmbG93JywgJ3Njcm9sbCcgKVxuXG4gICAgLy8gQWRkIHRoZSBpbm5lciBkaXYuXG4gICAgdmFyICRpbm5lciA9ICQoICc8ZGl2IHN0eWxlPVwid2lkdGg6MTAwJVwiIC8+JyApLmFwcGVuZFRvKCAkb3V0ZXIgKVxuXG4gICAgLy8gR2V0IHRoZSB3aWR0aCB3aXRoIHNjcm9sbGJhcnMuXG4gICAgdmFyIHdpZHRoV2l0aFNjcm9sbCA9ICRpbm5lclswXS5vZmZzZXRXaWR0aFxuXG4gICAgLy8gUmVtb3ZlIHRoZSBkaXZzLlxuICAgICRvdXRlci5yZW1vdmUoKVxuXG4gICAgLy8gUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHdpZHRocy5cbiAgICByZXR1cm4gd2lkdGhXaXRob3V0U2Nyb2xsIC0gd2lkdGhXaXRoU2Nyb2xsXG59XG5cblxuXG4vKipcbiAqIFBpY2tlckNvbnN0cnVjdG9yIGhlbHBlciBtZXRob2RzLlxuICovXG5QaWNrZXJDb25zdHJ1Y3Rvci5fID0ge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZ3JvdXAgb2Ygbm9kZXMuIEV4cGVjdHM6XG4gICAgICogYFxuICAgICAgICB7XG4gICAgICAgICAgICBtaW46ICAgIHtJbnRlZ2VyfSxcbiAgICAgICAgICAgIG1heDogICAge0ludGVnZXJ9LFxuICAgICAgICAgICAgaTogICAgICB7SW50ZWdlcn0sXG4gICAgICAgICAgICBub2RlOiAgIHtTdHJpbmd9LFxuICAgICAgICAgICAgaXRlbTogICB7RnVuY3Rpb259XG4gICAgICAgIH1cbiAgICAgKiBgXG4gICAgICovXG4gICAgZ3JvdXA6IGZ1bmN0aW9uKCBncm91cE9iamVjdCApIHtcblxuICAgICAgICB2YXJcbiAgICAgICAgICAgIC8vIFNjb3BlIGZvciB0aGUgbG9vcGVkIG9iamVjdFxuICAgICAgICAgICAgbG9vcE9iamVjdFNjb3BlLFxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5vZGVzIGxpc3RcbiAgICAgICAgICAgIG5vZGVzTGlzdCA9ICcnLFxuXG4gICAgICAgICAgICAvLyBUaGUgY291bnRlciBzdGFydHMgZnJvbSB0aGUgYG1pbmBcbiAgICAgICAgICAgIGNvdW50ZXIgPSBQaWNrZXJDb25zdHJ1Y3Rvci5fLnRyaWdnZXIoIGdyb3VwT2JqZWN0Lm1pbiwgZ3JvdXBPYmplY3QgKVxuXG5cbiAgICAgICAgLy8gTG9vcCBmcm9tIHRoZSBgbWluYCB0byBgbWF4YCwgaW5jcmVtZW50aW5nIGJ5IGBpYFxuICAgICAgICBmb3IgKCA7IGNvdW50ZXIgPD0gUGlja2VyQ29uc3RydWN0b3IuXy50cmlnZ2VyKCBncm91cE9iamVjdC5tYXgsIGdyb3VwT2JqZWN0LCBbIGNvdW50ZXIgXSApOyBjb3VudGVyICs9IGdyb3VwT2JqZWN0LmkgKSB7XG5cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGBpdGVtYCBmdW5jdGlvbiB3aXRoaW4gc2NvcGUgb2YgdGhlIG9iamVjdFxuICAgICAgICAgICAgbG9vcE9iamVjdFNjb3BlID0gUGlja2VyQ29uc3RydWN0b3IuXy50cmlnZ2VyKCBncm91cE9iamVjdC5pdGVtLCBncm91cE9iamVjdCwgWyBjb3VudGVyIF0gKVxuXG4gICAgICAgICAgICAvLyBTcGxpY2UgdGhlIHN1Ymdyb3VwIGFuZCBjcmVhdGUgbm9kZXMgb3V0IG9mIHRoZSBzdWIgbm9kZXNcbiAgICAgICAgICAgIG5vZGVzTGlzdCArPSBQaWNrZXJDb25zdHJ1Y3Rvci5fLm5vZGUoXG4gICAgICAgICAgICAgICAgZ3JvdXBPYmplY3Qubm9kZSxcbiAgICAgICAgICAgICAgICBsb29wT2JqZWN0U2NvcGVbIDAgXSwgICAvLyB0aGUgbm9kZVxuICAgICAgICAgICAgICAgIGxvb3BPYmplY3RTY29wZVsgMSBdLCAgIC8vIHRoZSBjbGFzc2VzXG4gICAgICAgICAgICAgICAgbG9vcE9iamVjdFNjb3BlWyAyIF0gICAgLy8gdGhlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgbGlzdCBvZiBub2Rlc1xuICAgICAgICByZXR1cm4gbm9kZXNMaXN0XG4gICAgfSwgLy9ncm91cFxuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkb20gbm9kZSBzdHJpbmdcbiAgICAgKi9cbiAgICBub2RlOiBmdW5jdGlvbiggd3JhcHBlciwgaXRlbSwga2xhc3MsIGF0dHJpYnV0ZSApIHtcblxuICAgICAgICAvLyBJZiB0aGUgaXRlbSBpcyBmYWxzZS15LCBqdXN0IHJldHVybiBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYgKCAhaXRlbSApIHJldHVybiAnJ1xuXG4gICAgICAgIC8vIElmIHRoZSBpdGVtIGlzIGFuIGFycmF5LCBkbyBhIGpvaW5cbiAgICAgICAgaXRlbSA9ICQuaXNBcnJheSggaXRlbSApID8gaXRlbS5qb2luKCAnJyApIDogaXRlbVxuXG4gICAgICAgIC8vIENoZWNrIGZvciB0aGUgY2xhc3NcbiAgICAgICAga2xhc3MgPSBrbGFzcyA/ICcgY2xhc3M9XCInICsga2xhc3MgKyAnXCInIDogJydcblxuICAgICAgICAvLyBDaGVjayBmb3IgYW55IGF0dHJpYnV0ZXNcbiAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlID8gJyAnICsgYXR0cmlidXRlIDogJydcblxuICAgICAgICAvLyBSZXR1cm4gdGhlIHdyYXBwZWQgaXRlbVxuICAgICAgICByZXR1cm4gJzwnICsgd3JhcHBlciArIGtsYXNzICsgYXR0cmlidXRlICsgJz4nICsgaXRlbSArICc8LycgKyB3cmFwcGVyICsgJz4nXG4gICAgfSwgLy9ub2RlXG5cblxuICAgIC8qKlxuICAgICAqIExlYWQgbnVtYmVycyBiZWxvdyAxMCB3aXRoIGEgemVyby5cbiAgICAgKi9cbiAgICBsZWFkOiBmdW5jdGlvbiggbnVtYmVyICkge1xuICAgICAgICByZXR1cm4gKCBudW1iZXIgPCAxMCA/ICcwJzogJycgKSArIG51bWJlclxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYSBmdW5jdGlvbiBvdGhlcndpc2UgcmV0dXJuIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHNjb3BlLCBhcmdzICkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgPyBjYWxsYmFjay5hcHBseSggc2NvcGUsIGFyZ3MgfHwgW10gKSA6IGNhbGxiYWNrXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHNlY29uZCBjaGFyYWN0ZXIgaXMgYSBkaWdpdCwgbGVuZ3RoIGlzIDIgb3RoZXJ3aXNlIDEuXG4gICAgICovXG4gICAgZGlnaXRzOiBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgICAgICByZXR1cm4gKCAvXFxkLyApLnRlc3QoIHN0cmluZ1sgMSBdICkgPyAyIDogMVxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRlbGwgaWYgc29tZXRoaW5nIGlzIGEgZGF0ZSBvYmplY3QuXG4gICAgICovXG4gICAgaXNEYXRlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKCB2YWx1ZSApLmluZGV4T2YoICdEYXRlJyApID4gLTEgJiYgdGhpcy5pc0ludGVnZXIoIHZhbHVlLmdldERhdGUoKSApXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGVsbCBpZiBzb21ldGhpbmcgaXMgYW4gaW50ZWdlci5cbiAgICAgKi9cbiAgICBpc0ludGVnZXI6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoIHZhbHVlICkuaW5kZXhPZiggJ051bWJlcicgKSA+IC0xICYmIHZhbHVlICUgMSA9PT0gMFxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBBUklBIGF0dHJpYnV0ZSBzdHJpbmdzLlxuICAgICAqL1xuICAgIGFyaWFBdHRyOiBhcmlhQXR0clxufSAvL1BpY2tlckNvbnN0cnVjdG9yLl9cblxuXG5cbi8qKlxuICogRXh0ZW5kIHRoZSBwaWNrZXIgd2l0aCBhIGNvbXBvbmVudCBhbmQgZGVmYXVsdHMuXG4gKi9cblBpY2tlckNvbnN0cnVjdG9yLmV4dGVuZCA9IGZ1bmN0aW9uKCBuYW1lLCBDb21wb25lbnQgKSB7XG5cbiAgICAvLyBFeHRlbmQgalF1ZXJ5LlxuICAgICQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBhY3Rpb24gKSB7XG5cbiAgICAgICAgLy8gR3JhYiB0aGUgY29tcG9uZW50IGRhdGEuXG4gICAgICAgIHZhciBjb21wb25lbnREYXRhID0gdGhpcy5kYXRhKCBuYW1lIClcblxuICAgICAgICAvLyBJZiB0aGUgcGlja2VyIGlzIHJlcXVlc3RlZCwgcmV0dXJuIHRoZSBkYXRhIG9iamVjdC5cbiAgICAgICAgaWYgKCBvcHRpb25zID09ICdwaWNrZXInICkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudERhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgZGF0YSBleGlzdHMgYW5kIGBvcHRpb25zYCBpcyBhIHN0cmluZywgY2Fycnkgb3V0IHRoZSBhY3Rpb24uXG4gICAgICAgIGlmICggY29tcG9uZW50RGF0YSAmJiB0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgIHJldHVybiBQaWNrZXJDb25zdHJ1Y3Rvci5fLnRyaWdnZXIoIGNvbXBvbmVudERhdGFbIG9wdGlvbnMgXSwgY29tcG9uZW50RGF0YSwgWyBhY3Rpb24gXSApXG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UgZ28gdGhyb3VnaCBlYWNoIG1hdGNoZWQgZWxlbWVudCBhbmQgaWYgdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBkb2VzbuKAmXQgZXhpc3QsIGNyZWF0ZSBhIG5ldyBwaWNrZXIgdXNpbmcgYHRoaXNgIGVsZW1lbnRcbiAgICAgICAgLy8gYW5kIG1lcmdpbmcgdGhlIGRlZmF1bHRzIGFuZCBvcHRpb25zIHdpdGggYSBkZWVwIGNvcHkuXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCggdGhpcyApXG4gICAgICAgICAgICBpZiAoICEkdGhpcy5kYXRhKCBuYW1lICkgKSB7XG4gICAgICAgICAgICAgICAgbmV3IFBpY2tlckNvbnN0cnVjdG9yKCB0aGlzLCBuYW1lLCBDb21wb25lbnQsIG9wdGlvbnMgKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMuXG4gICAgJC5mblsgbmFtZSBdLmRlZmF1bHRzID0gQ29tcG9uZW50LmRlZmF1bHRzXG59IC8vUGlja2VyQ29uc3RydWN0b3IuZXh0ZW5kXG5cblxuXG5mdW5jdGlvbiBhcmlhKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAoICQuaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpICkge1xuICAgICAgICBmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZSApIHtcbiAgICAgICAgICAgIGFyaWFTZXQoZWxlbWVudCwga2V5LCBhdHRyaWJ1dGVba2V5XSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXJpYVNldChlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFyaWFTZXQoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFxuICAgICAgICAoYXR0cmlidXRlID09ICdyb2xlJyA/ICcnIDogJ2FyaWEtJykgKyBhdHRyaWJ1dGUsXG4gICAgICAgIHZhbHVlXG4gICAgKVxufVxuZnVuY3Rpb24gYXJpYUF0dHIoYXR0cmlidXRlLCBkYXRhKSB7XG4gICAgaWYgKCAhJC5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkgKSB7XG4gICAgICAgIGF0dHJpYnV0ZSA9IHsgYXR0cmlidXRlOiBkYXRhIH1cbiAgICB9XG4gICAgZGF0YSA9ICcnXG4gICAgZm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGUgKSB7XG4gICAgICAgIHZhciBhdHRyID0gKGtleSA9PSAncm9sZScgPyAnJyA6ICdhcmlhLScpICsga2V5LFxuICAgICAgICAgICAgYXR0clZhbCA9IGF0dHJpYnV0ZVtrZXldXG4gICAgICAgIGRhdGEgKz0gYXR0clZhbCA9PSBudWxsID8gJycgOiBhdHRyICsgJz1cIicgKyBhdHRyaWJ1dGVba2V5XSArICdcIidcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbn1cblxuLy8gSUU4IGJ1ZyB0aHJvd3MgYW4gZXJyb3IgZm9yIGFjdGl2ZUVsZW1lbnRzIHdpdGhpbiBpZnJhbWVzLlxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgIH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuXG5cbi8vIEV4cG9zZSB0aGUgcGlja2VyIGNvbnN0cnVjdG9yLlxucmV0dXJuIFBpY2tlckNvbnN0cnVjdG9yXG5cblxufSkpO1xuXG5cbjsvKiFcbiAqIERhdGUgcGlja2VyIGZvciBwaWNrYWRhdGUuanMgdjMuNS4wXG4gKiBodHRwOi8vYW1zdWwuZ2l0aHViLmlvL3BpY2thZGF0ZS5qcy9kYXRlLmh0bVxuICovXG5cbihmdW5jdGlvbiAoIGZhY3RvcnkgKSB7XG5cbiAgICAvLyBBTUQuXG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApXG4gICAgICAgIGRlZmluZSggWydwaWNrZXInLCAnanF1ZXJ5J10sIGZhY3RvcnkgKVxuXG4gICAgLy8gTm9kZS5qcy9icm93c2VyaWZ5LlxuICAgIGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyApXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSgnLi9waWNrZXIuanMnKSwgcmVxdWlyZSgnanF1ZXJ5JykgKVxuXG4gICAgLy8gQnJvd3NlciBnbG9iYWxzLlxuICAgIGVsc2UgZmFjdG9yeSggUGlja2VyLCBqUXVlcnkgKVxuXG59KGZ1bmN0aW9uKCBQaWNrZXIsICQgKSB7XG5cblxuLyoqXG4gKiBHbG9iYWxzIGFuZCBjb25zdGFudHNcbiAqL1xudmFyIERBWVNfSU5fV0VFSyA9IDcsXG4gICAgV0VFS1NfSU5fQ0FMRU5EQVIgPSA2LFxuICAgIF8gPSBQaWNrZXIuX1xuXG5cblxuLyoqXG4gKiBUaGUgZGF0ZSBwaWNrZXIgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRGF0ZVBpY2tlciggcGlja2VyLCBzZXR0aW5ncyApIHtcblxuICAgIHZhciBjYWxlbmRhciA9IHRoaXMsXG4gICAgICAgIGVsZW1lbnQgPSBwaWNrZXIuJG5vZGVbIDAgXSxcbiAgICAgICAgZWxlbWVudFZhbHVlID0gZWxlbWVudC52YWx1ZSxcbiAgICAgICAgZWxlbWVudERhdGFWYWx1ZSA9IHBpY2tlci4kbm9kZS5kYXRhKCAndmFsdWUnICksXG4gICAgICAgIHZhbHVlU3RyaW5nID0gZWxlbWVudERhdGFWYWx1ZSB8fCBlbGVtZW50VmFsdWUsXG4gICAgICAgIGZvcm1hdFN0cmluZyA9IGVsZW1lbnREYXRhVmFsdWUgPyBzZXR0aW5ncy5mb3JtYXRTdWJtaXQgOiBzZXR0aW5ncy5mb3JtYXQsXG4gICAgICAgIGlzUlRMID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmN1cnJlbnRTdHlsZSA/XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgSUUuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jdXJyZW50U3R5bGUuZGlyZWN0aW9uID09ICdydGwnIDpcblxuICAgICAgICAgICAgICAgIC8vIEZvciBub3JtYWwgYnJvd3NlcnMuXG4gICAgICAgICAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSggcGlja2VyLiRyb290WzBdICkuZGlyZWN0aW9uID09ICdydGwnXG4gICAgICAgIH1cblxuICAgIGNhbGVuZGFyLnNldHRpbmdzID0gc2V0dGluZ3NcbiAgICBjYWxlbmRhci4kbm9kZSA9IHBpY2tlci4kbm9kZVxuXG4gICAgLy8gVGhlIHF1ZXVlIG9mIG1ldGhvZHMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYnVpbGQgaXRlbSBvYmplY3RzLlxuICAgIGNhbGVuZGFyLnF1ZXVlID0ge1xuICAgICAgICBtaW46ICdtZWFzdXJlIGNyZWF0ZScsXG4gICAgICAgIG1heDogJ21lYXN1cmUgY3JlYXRlJyxcbiAgICAgICAgbm93OiAnbm93IGNyZWF0ZScsXG4gICAgICAgIHNlbGVjdDogJ3BhcnNlIGNyZWF0ZSB2YWxpZGF0ZScsXG4gICAgICAgIGhpZ2hsaWdodDogJ3BhcnNlIG5hdmlnYXRlIGNyZWF0ZSB2YWxpZGF0ZScsXG4gICAgICAgIHZpZXc6ICdwYXJzZSBjcmVhdGUgdmFsaWRhdGUgdmlld3NldCcsXG4gICAgICAgIGRpc2FibGU6ICdkZWFjdGl2YXRlJyxcbiAgICAgICAgZW5hYmxlOiAnYWN0aXZhdGUnXG4gICAgfVxuXG4gICAgLy8gVGhlIGNvbXBvbmVudCdzIGl0ZW0gb2JqZWN0LlxuICAgIGNhbGVuZGFyLml0ZW0gPSB7fVxuXG4gICAgY2FsZW5kYXIuaXRlbS5jbGVhciA9IG51bGxcbiAgICBjYWxlbmRhci5pdGVtLmRpc2FibGUgPSAoIHNldHRpbmdzLmRpc2FibGUgfHwgW10gKS5zbGljZSggMCApXG4gICAgY2FsZW5kYXIuaXRlbS5lbmFibGUgPSAtKGZ1bmN0aW9uKCBjb2xsZWN0aW9uRGlzYWJsZWQgKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uRGlzYWJsZWRbIDAgXSA9PT0gdHJ1ZSA/IGNvbGxlY3Rpb25EaXNhYmxlZC5zaGlmdCgpIDogLTFcbiAgICB9KSggY2FsZW5kYXIuaXRlbS5kaXNhYmxlIClcblxuICAgIGNhbGVuZGFyLlxuICAgICAgICBzZXQoICdtaW4nLCBzZXR0aW5ncy5taW4gKS5cbiAgICAgICAgc2V0KCAnbWF4Jywgc2V0dGluZ3MubWF4ICkuXG4gICAgICAgIHNldCggJ25vdycgKVxuXG4gICAgLy8gV2hlbiB0aGVyZeKAmXMgYSB2YWx1ZSwgc2V0IHRoZSBgc2VsZWN0YCwgd2hpY2ggaW4gdHVyblxuICAgIC8vIGFsc28gc2V0cyB0aGUgYGhpZ2hsaWdodGAgYW5kIGB2aWV3YC5cbiAgICBpZiAoIHZhbHVlU3RyaW5nICkge1xuICAgICAgICBjYWxlbmRhci5zZXQoICdzZWxlY3QnLCB2YWx1ZVN0cmluZywgeyBmb3JtYXQ6IGZvcm1hdFN0cmluZyB9KVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJl4oCZcyBubyB2YWx1ZSwgZGVmYXVsdCB0byBoaWdobGlnaHRpbmcg4oCcdG9kYXnigJ0uXG4gICAgZWxzZSB7XG4gICAgICAgIGNhbGVuZGFyLlxuICAgICAgICAgICAgc2V0KCAnc2VsZWN0JywgbnVsbCApLlxuICAgICAgICAgICAgc2V0KCAnaGlnaGxpZ2h0JywgY2FsZW5kYXIuaXRlbS5ub3cgKVxuICAgIH1cblxuXG4gICAgLy8gVGhlIGtleWNvZGUgdG8gbW92ZW1lbnQgbWFwcGluZy5cbiAgICBjYWxlbmRhci5rZXkgPSB7XG4gICAgICAgIDQwOiA3LCAvLyBEb3duXG4gICAgICAgIDM4OiAtNywgLy8gVXBcbiAgICAgICAgMzk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNSVEwoKSA/IC0xIDogMSB9LCAvLyBSaWdodFxuICAgICAgICAzNzogZnVuY3Rpb24oKSB7IHJldHVybiBpc1JUTCgpID8gMSA6IC0xIH0sIC8vIExlZnRcbiAgICAgICAgZ286IGZ1bmN0aW9uKCB0aW1lQ2hhbmdlICkge1xuICAgICAgICAgICAgdmFyIGhpZ2hsaWdodGVkT2JqZWN0ID0gY2FsZW5kYXIuaXRlbS5oaWdobGlnaHQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0RGF0ZSA9IG5ldyBEYXRlKCBoaWdobGlnaHRlZE9iamVjdC55ZWFyLCBoaWdobGlnaHRlZE9iamVjdC5tb250aCwgaGlnaGxpZ2h0ZWRPYmplY3QuZGF0ZSArIHRpbWVDaGFuZ2UgKVxuICAgICAgICAgICAgY2FsZW5kYXIuc2V0KFxuICAgICAgICAgICAgICAgICdoaWdobGlnaHQnLFxuICAgICAgICAgICAgICAgIHRhcmdldERhdGUsXG4gICAgICAgICAgICAgICAgeyBpbnRlcnZhbDogdGltZUNoYW5nZSB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIEJpbmQgc29tZSBwaWNrZXIgZXZlbnRzLlxuICAgIHBpY2tlci5cbiAgICAgICAgb24oICdyZW5kZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHBpY2tlci4kcm9vdC5maW5kKCAnLicgKyBzZXR0aW5ncy5rbGFzcy5zZWxlY3RNb250aCApLm9uKCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZVxuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlci5zZXQoICdoaWdobGlnaHQnLCBbIHBpY2tlci5nZXQoICd2aWV3JyApLnllYXIsIHZhbHVlLCBwaWNrZXIuZ2V0KCAnaGlnaGxpZ2h0JyApLmRhdGUgXSApXG4gICAgICAgICAgICAgICAgICAgIHBpY2tlci4kcm9vdC5maW5kKCAnLicgKyBzZXR0aW5ncy5rbGFzcy5zZWxlY3RNb250aCApLnRyaWdnZXIoICdmb2N1cycgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwaWNrZXIuJHJvb3QuZmluZCggJy4nICsgc2V0dGluZ3Mua2xhc3Muc2VsZWN0WWVhciApLm9uKCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZVxuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlci5zZXQoICdoaWdobGlnaHQnLCBbIHZhbHVlLCBwaWNrZXIuZ2V0KCAndmlldycgKS5tb250aCwgcGlja2VyLmdldCggJ2hpZ2hsaWdodCcgKS5kYXRlIF0gKVxuICAgICAgICAgICAgICAgICAgICBwaWNrZXIuJHJvb3QuZmluZCggJy4nICsgc2V0dGluZ3Mua2xhc3Muc2VsZWN0WWVhciApLnRyaWdnZXIoICdmb2N1cycgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIDEgKS5cbiAgICAgICAgb24oICdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5jbHVkZVRvZGF5ID0gJydcbiAgICAgICAgICAgIGlmICggY2FsZW5kYXIuZGlzYWJsZWQoIGNhbGVuZGFyLmdldCgnbm93JykgKSApIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlVG9kYXkgPSAnOm5vdCguJyArIHNldHRpbmdzLmtsYXNzLmJ1dHRvblRvZGF5ICsgJyknXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaWNrZXIuJHJvb3QuZmluZCggJ2J1dHRvbicgKyBpbmNsdWRlVG9kYXkgKyAnLCBzZWxlY3QnICkuYXR0ciggJ2Rpc2FibGVkJywgZmFsc2UgKVxuICAgICAgICB9LCAxICkuXG4gICAgICAgIG9uKCAnY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHBpY2tlci4kcm9vdC5maW5kKCAnYnV0dG9uLCBzZWxlY3QnICkuYXR0ciggJ2Rpc2FibGVkJywgdHJ1ZSApXG4gICAgICAgIH0sIDEgKVxuXG59IC8vRGF0ZVBpY2tlclxuXG5cbi8qKlxuICogU2V0IGEgZGF0ZXBpY2tlciBpdGVtIG9iamVjdC5cbiAqL1xuRGF0ZVBpY2tlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oIHR5cGUsIHZhbHVlLCBvcHRpb25zICkge1xuXG4gICAgdmFyIGNhbGVuZGFyID0gdGhpcyxcbiAgICAgICAgY2FsZW5kYXJJdGVtID0gY2FsZW5kYXIuaXRlbVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIGlzIGBudWxsYCBqdXN0IHNldCBpdCBpbW1lZGlhdGVseS5cbiAgICBpZiAoIHZhbHVlID09PSBudWxsICkge1xuICAgICAgICBpZiAoIHR5cGUgPT0gJ2NsZWFyJyApIHR5cGUgPSAnc2VsZWN0J1xuICAgICAgICBjYWxlbmRhckl0ZW1bIHR5cGUgXSA9IHZhbHVlXG4gICAgICAgIHJldHVybiBjYWxlbmRhclxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBnbyB0aHJvdWdoIHRoZSBxdWV1ZSBvZiBtZXRob2RzLCBhbmQgaW52b2tlIHRoZSBmdW5jdGlvbnMuXG4gICAgLy8gVXBkYXRlIHRoaXMgYXMgdGhlIHRpbWUgdW5pdCwgYW5kIHNldCB0aGUgZmluYWwgdmFsdWUgYXMgdGhpcyBpdGVtLlxuICAgIC8vICogSW4gdGhlIGNhc2Ugb2YgYGVuYWJsZWAsIGtlZXAgdGhlIHF1ZXVlIGJ1dCBzZXQgYGRpc2FibGVgIGluc3RlYWQuXG4gICAgLy8gICBBbmQgaW4gdGhlIGNhc2Ugb2YgYGZsaXBgLCBrZWVwIHRoZSBxdWV1ZSBidXQgc2V0IGBlbmFibGVgIGluc3RlYWQuXG4gICAgY2FsZW5kYXJJdGVtWyAoIHR5cGUgPT0gJ2VuYWJsZScgPyAnZGlzYWJsZScgOiB0eXBlID09ICdmbGlwJyA/ICdlbmFibGUnIDogdHlwZSApIF0gPSBjYWxlbmRhci5xdWV1ZVsgdHlwZSBdLnNwbGl0KCAnICcgKS5tYXAoIGZ1bmN0aW9uKCBtZXRob2QgKSB7XG4gICAgICAgIHZhbHVlID0gY2FsZW5kYXJbIG1ldGhvZCBdKCB0eXBlLCB2YWx1ZSwgb3B0aW9ucyApXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0pLnBvcCgpXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGNhc2NhZGUgdGhyb3VnaCBtb3JlIHVwZGF0ZXMuXG4gICAgaWYgKCB0eXBlID09ICdzZWxlY3QnICkge1xuICAgICAgICBjYWxlbmRhci5zZXQoICdoaWdobGlnaHQnLCBjYWxlbmRhckl0ZW0uc2VsZWN0LCBvcHRpb25zIClcbiAgICB9XG4gICAgZWxzZSBpZiAoIHR5cGUgPT0gJ2hpZ2hsaWdodCcgKSB7XG4gICAgICAgIGNhbGVuZGFyLnNldCggJ3ZpZXcnLCBjYWxlbmRhckl0ZW0uaGlnaGxpZ2h0LCBvcHRpb25zIClcbiAgICB9XG4gICAgZWxzZSBpZiAoIHR5cGUubWF0Y2goIC9eKGZsaXB8bWlufG1heHxkaXNhYmxlfGVuYWJsZSkkLyApICkge1xuICAgICAgICBpZiAoIGNhbGVuZGFySXRlbS5zZWxlY3QgJiYgY2FsZW5kYXIuZGlzYWJsZWQoIGNhbGVuZGFySXRlbS5zZWxlY3QgKSApIHtcbiAgICAgICAgICAgIGNhbGVuZGFyLnNldCggJ3NlbGVjdCcsIGNhbGVuZGFySXRlbS5zZWxlY3QsIG9wdGlvbnMgKVxuICAgICAgICB9XG4gICAgICAgIGlmICggY2FsZW5kYXJJdGVtLmhpZ2hsaWdodCAmJiBjYWxlbmRhci5kaXNhYmxlZCggY2FsZW5kYXJJdGVtLmhpZ2hsaWdodCApICkge1xuICAgICAgICAgICAgY2FsZW5kYXIuc2V0KCAnaGlnaGxpZ2h0JywgY2FsZW5kYXJJdGVtLmhpZ2hsaWdodCwgb3B0aW9ucyApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2FsZW5kYXJcbn0gLy9EYXRlUGlja2VyLnByb3RvdHlwZS5zZXRcblxuXG4vKipcbiAqIEdldCBhIGRhdGVwaWNrZXIgaXRlbSBvYmplY3QuXG4gKi9cbkRhdGVQaWNrZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgIHJldHVybiB0aGlzLml0ZW1bIHR5cGUgXVxufSAvL0RhdGVQaWNrZXIucHJvdG90eXBlLmdldFxuXG5cbi8qKlxuICogQ3JlYXRlIGEgcGlja2VyIGRhdGUgb2JqZWN0LlxuICovXG5EYXRlUGlja2VyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiggdHlwZSwgdmFsdWUsIG9wdGlvbnMgKSB7XG5cbiAgICB2YXIgaXNJbmZpbml0ZVZhbHVlLFxuICAgICAgICBjYWxlbmRhciA9IHRoaXNcblxuICAgIC8vIElmIHRoZXJl4oCZcyBubyB2YWx1ZSwgdXNlIHRoZSB0eXBlIGFzIHRoZSB2YWx1ZS5cbiAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyB0eXBlIDogdmFsdWVcblxuXG4gICAgLy8gSWYgaXTigJlzIGluZmluaXR5LCB1cGRhdGUgdGhlIHZhbHVlLlxuICAgIGlmICggdmFsdWUgPT0gLUluZmluaXR5IHx8IHZhbHVlID09IEluZmluaXR5ICkge1xuICAgICAgICBpc0luZmluaXRlVmFsdWUgPSB2YWx1ZVxuICAgIH1cblxuICAgIC8vIElmIGl04oCZcyBhbiBvYmplY3QsIHVzZSB0aGUgbmF0aXZlIGRhdGUgb2JqZWN0LlxuICAgIGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIHZhbHVlICkgJiYgXy5pc0ludGVnZXIoIHZhbHVlLnBpY2sgKSApIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5vYmpcbiAgICB9XG5cbiAgICAvLyBJZiBpdOKAmXMgYW4gYXJyYXksIGNvbnZlcnQgaXQgaW50byBhIGRhdGUgYW5kIG1ha2Ugc3VyZVxuICAgIC8vIHRoYXQgaXTigJlzIGEgdmFsaWQgZGF0ZSDigJMgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gdG9kYXkuXG4gICAgZWxzZSBpZiAoICQuaXNBcnJheSggdmFsdWUgKSApIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSggdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSApXG4gICAgICAgIHZhbHVlID0gXy5pc0RhdGUoIHZhbHVlICkgPyB2YWx1ZSA6IGNhbGVuZGFyLmNyZWF0ZSgpLm9ialxuICAgIH1cblxuICAgIC8vIElmIGl04oCZcyBhIG51bWJlciBvciBkYXRlIG9iamVjdCwgbWFrZSBhIG5vcm1hbGl6ZWQgZGF0ZS5cbiAgICBlbHNlIGlmICggXy5pc0ludGVnZXIoIHZhbHVlICkgfHwgXy5pc0RhdGUoIHZhbHVlICkgKSB7XG4gICAgICAgIHZhbHVlID0gY2FsZW5kYXIubm9ybWFsaXplKCBuZXcgRGF0ZSggdmFsdWUgKSwgb3B0aW9ucyApXG4gICAgfVxuXG4gICAgLy8gSWYgaXTigJlzIGEgbGl0ZXJhbCB0cnVlIG9yIGFueSBvdGhlciBjYXNlLCBzZXQgaXQgdG8gbm93LlxuICAgIGVsc2UgLyppZiAoIHZhbHVlID09PSB0cnVlICkqLyB7XG4gICAgICAgIHZhbHVlID0gY2FsZW5kYXIubm93KCB0eXBlLCB2YWx1ZSwgb3B0aW9ucyApXG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBjb21waWxlZCBvYmplY3QuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogaXNJbmZpbml0ZVZhbHVlIHx8IHZhbHVlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgIG1vbnRoOiBpc0luZmluaXRlVmFsdWUgfHwgdmFsdWUuZ2V0TW9udGgoKSxcbiAgICAgICAgZGF0ZTogaXNJbmZpbml0ZVZhbHVlIHx8IHZhbHVlLmdldERhdGUoKSxcbiAgICAgICAgZGF5OiBpc0luZmluaXRlVmFsdWUgfHwgdmFsdWUuZ2V0RGF5KCksXG4gICAgICAgIG9iajogaXNJbmZpbml0ZVZhbHVlIHx8IHZhbHVlLFxuICAgICAgICBwaWNrOiBpc0luZmluaXRlVmFsdWUgfHwgdmFsdWUuZ2V0VGltZSgpXG4gICAgfVxufSAvL0RhdGVQaWNrZXIucHJvdG90eXBlLmNyZWF0ZVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgcmFuZ2UgbGltaXQgb2JqZWN0IHVzaW5nIGFuIGFycmF5LCBkYXRlIG9iamVjdCxcbiAqIGxpdGVyYWwg4oCcdHJ1ZeKAnSwgb3IgaW50ZWdlciByZWxhdGl2ZSB0byBhbm90aGVyIHRpbWUuXG4gKi9cbkRhdGVQaWNrZXIucHJvdG90eXBlLmNyZWF0ZVJhbmdlID0gZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXG4gICAgdmFyIGNhbGVuZGFyID0gdGhpcyxcbiAgICAgICAgY3JlYXRlRGF0ZSA9IGZ1bmN0aW9uKCBkYXRlICkge1xuICAgICAgICAgICAgaWYgKCBkYXRlID09PSB0cnVlIHx8ICQuaXNBcnJheSggZGF0ZSApIHx8IF8uaXNEYXRlKCBkYXRlICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyLmNyZWF0ZSggZGF0ZSApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVxuICAgICAgICB9XG5cbiAgICAvLyBDcmVhdGUgb2JqZWN0cyBpZiBwb3NzaWJsZS5cbiAgICBpZiAoICFfLmlzSW50ZWdlciggZnJvbSApICkge1xuICAgICAgICBmcm9tID0gY3JlYXRlRGF0ZSggZnJvbSApXG4gICAgfVxuICAgIGlmICggIV8uaXNJbnRlZ2VyKCB0byApICkge1xuICAgICAgICB0byA9IGNyZWF0ZURhdGUoIHRvIClcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgcmVsYXRpdmUgZGF0ZXMuXG4gICAgaWYgKCBfLmlzSW50ZWdlciggZnJvbSApICYmICQuaXNQbGFpbk9iamVjdCggdG8gKSApIHtcbiAgICAgICAgZnJvbSA9IFsgdG8ueWVhciwgdG8ubW9udGgsIHRvLmRhdGUgKyBmcm9tIF07XG4gICAgfVxuICAgIGVsc2UgaWYgKCBfLmlzSW50ZWdlciggdG8gKSAmJiAkLmlzUGxhaW5PYmplY3QoIGZyb20gKSApIHtcbiAgICAgICAgdG8gPSBbIGZyb20ueWVhciwgZnJvbS5tb250aCwgZnJvbS5kYXRlICsgdG8gXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBjcmVhdGVEYXRlKCBmcm9tICksXG4gICAgICAgIHRvOiBjcmVhdGVEYXRlKCB0byApXG4gICAgfVxufSAvL0RhdGVQaWNrZXIucHJvdG90eXBlLmNyZWF0ZVJhbmdlXG5cblxuLyoqXG4gKiBDaGVjayBpZiBhIGRhdGUgdW5pdCBmYWxscyB3aXRoaW4gYSBkYXRlIHJhbmdlIG9iamVjdC5cbiAqL1xuRGF0ZVBpY2tlci5wcm90b3R5cGUud2l0aGluUmFuZ2UgPSBmdW5jdGlvbiggcmFuZ2UsIGRhdGVVbml0ICkge1xuICAgIHJhbmdlID0gdGhpcy5jcmVhdGVSYW5nZShyYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICByZXR1cm4gZGF0ZVVuaXQucGljayA+PSByYW5nZS5mcm9tLnBpY2sgJiYgZGF0ZVVuaXQucGljayA8PSByYW5nZS50by5waWNrXG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gZGF0ZSByYW5nZSBvYmplY3RzIG92ZXJsYXAuXG4gKi9cbkRhdGVQaWNrZXIucHJvdG90eXBlLm92ZXJsYXBSYW5nZXMgPSBmdW5jdGlvbiggb25lLCB0d28gKSB7XG5cbiAgICB2YXIgY2FsZW5kYXIgPSB0aGlzXG5cbiAgICAvLyBDb252ZXJ0IHRoZSByYW5nZXMgaW50byBjb21wYXJhYmxlIGRhdGVzLlxuICAgIG9uZSA9IGNhbGVuZGFyLmNyZWF0ZVJhbmdlKCBvbmUuZnJvbSwgb25lLnRvIClcbiAgICB0d28gPSBjYWxlbmRhci5jcmVhdGVSYW5nZSggdHdvLmZyb20sIHR3by50byApXG5cbiAgICByZXR1cm4gY2FsZW5kYXIud2l0aGluUmFuZ2UoIG9uZSwgdHdvLmZyb20gKSB8fCBjYWxlbmRhci53aXRoaW5SYW5nZSggb25lLCB0d28udG8gKSB8fFxuICAgICAgICBjYWxlbmRhci53aXRoaW5SYW5nZSggdHdvLCBvbmUuZnJvbSApIHx8IGNhbGVuZGFyLndpdGhpblJhbmdlKCB0d28sIG9uZS50byApXG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRhdGUgdG9kYXkuXG4gKi9cbkRhdGVQaWNrZXIucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uKCB0eXBlLCB2YWx1ZSwgb3B0aW9ucyApIHtcbiAgICB2YWx1ZSA9IG5ldyBEYXRlKClcbiAgICBpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5yZWwgKSB7XG4gICAgICAgIHZhbHVlLnNldERhdGUoIHZhbHVlLmdldERhdGUoKSArIG9wdGlvbnMucmVsIClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCB2YWx1ZSwgb3B0aW9ucyApXG59XG5cblxuLyoqXG4gKiBOYXZpZ2F0ZSB0byBuZXh0L3ByZXYgbW9udGguXG4gKi9cbkRhdGVQaWNrZXIucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24oIHR5cGUsIHZhbHVlLCBvcHRpb25zICkge1xuXG4gICAgdmFyIHRhcmdldERhdGVPYmplY3QsXG4gICAgICAgIHRhcmdldFllYXIsXG4gICAgICAgIHRhcmdldE1vbnRoLFxuICAgICAgICB0YXJnZXREYXRlLFxuICAgICAgICBpc1RhcmdldEFycmF5ID0gJC5pc0FycmF5KCB2YWx1ZSApLFxuICAgICAgICBpc1RhcmdldE9iamVjdCA9ICQuaXNQbGFpbk9iamVjdCggdmFsdWUgKSxcbiAgICAgICAgdmlld3NldE9iamVjdCA9IHRoaXMuaXRlbS52aWV3LyosXG4gICAgICAgIHNhZmV0eSA9IDEwMCovXG5cblxuICAgIGlmICggaXNUYXJnZXRBcnJheSB8fCBpc1RhcmdldE9iamVjdCApIHtcblxuICAgICAgICBpZiAoIGlzVGFyZ2V0T2JqZWN0ICkge1xuICAgICAgICAgICAgdGFyZ2V0WWVhciA9IHZhbHVlLnllYXJcbiAgICAgICAgICAgIHRhcmdldE1vbnRoID0gdmFsdWUubW9udGhcbiAgICAgICAgICAgIHRhcmdldERhdGUgPSB2YWx1ZS5kYXRlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRZZWFyID0gK3ZhbHVlWzBdXG4gICAgICAgICAgICB0YXJnZXRNb250aCA9ICt2YWx1ZVsxXVxuICAgICAgICAgICAgdGFyZ2V0RGF0ZSA9ICt2YWx1ZVsyXVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2XigJlyZSBuYXZpZ2F0aW5nIG1vbnRocyBidXQgdGhlIHZpZXcgaXMgaW4gYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gbW9udGgsIG5hdmlnYXRlIHRvIHRoZSB2aWV34oCZcyB5ZWFyIGFuZCBtb250aC5cbiAgICAgICAgaWYgKCBvcHRpb25zICYmIG9wdGlvbnMubmF2ICYmIHZpZXdzZXRPYmplY3QgJiYgdmlld3NldE9iamVjdC5tb250aCAhPT0gdGFyZ2V0TW9udGggKSB7XG4gICAgICAgICAgICB0YXJnZXRZZWFyID0gdmlld3NldE9iamVjdC55ZWFyXG4gICAgICAgICAgICB0YXJnZXRNb250aCA9IHZpZXdzZXRPYmplY3QubW9udGhcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGV4cGVjdGVkIHRhcmdldCB5ZWFyIGFuZCBtb250aC5cbiAgICAgICAgdGFyZ2V0RGF0ZU9iamVjdCA9IG5ldyBEYXRlKCB0YXJnZXRZZWFyLCB0YXJnZXRNb250aCArICggb3B0aW9ucyAmJiBvcHRpb25zLm5hdiA/IG9wdGlvbnMubmF2IDogMCApLCAxIClcbiAgICAgICAgdGFyZ2V0WWVhciA9IHRhcmdldERhdGVPYmplY3QuZ2V0RnVsbFllYXIoKVxuICAgICAgICB0YXJnZXRNb250aCA9IHRhcmdldERhdGVPYmplY3QuZ2V0TW9udGgoKVxuXG4gICAgICAgIC8vIElmIHRoZSBtb250aCB3ZeKAmXJlIGdvaW5nIHRvIGRvZXNu4oCZdCBoYXZlIGVub3VnaCBkYXlzLFxuICAgICAgICAvLyBrZWVwIGRlY3JlYXNpbmcgdGhlIGRhdGUgdW50aWwgd2UgcmVhY2ggdGhlIG1vbnRo4oCZcyBsYXN0IGRhdGUuXG4gICAgICAgIHdoaWxlICggLypzYWZldHkgJiYqLyBuZXcgRGF0ZSggdGFyZ2V0WWVhciwgdGFyZ2V0TW9udGgsIHRhcmdldERhdGUgKS5nZXRNb250aCgpICE9PSB0YXJnZXRNb250aCApIHtcbiAgICAgICAgICAgIHRhcmdldERhdGUgLT0gMVxuICAgICAgICAgICAgLypzYWZldHkgLT0gMVxuICAgICAgICAgICAgaWYgKCAhc2FmZXR5ICkge1xuICAgICAgICAgICAgICAgIHRocm93ICdGZWxsIGludG8gYW4gaW5maW5pdGUgbG9vcCB3aGlsZSBuYXZpZ2F0aW5nIHRvICcgKyBuZXcgRGF0ZSggdGFyZ2V0WWVhciwgdGFyZ2V0TW9udGgsIHRhcmdldERhdGUgKSArICcuJ1xuICAgICAgICAgICAgfSovXG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IFsgdGFyZ2V0WWVhciwgdGFyZ2V0TW9udGgsIHRhcmdldERhdGUgXVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVxufSAvL0RhdGVQaWNrZXIucHJvdG90eXBlLm5hdmlnYXRlXG5cblxuLyoqXG4gKiBOb3JtYWxpemUgYSBkYXRlIGJ5IHNldHRpbmcgdGhlIGhvdXJzIHRvIG1pZG5pZ2h0LlxuICovXG5EYXRlUGlja2VyLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiggdmFsdWUvKiwgb3B0aW9ucyovICkge1xuICAgIHZhbHVlLnNldEhvdXJzKCAwLCAwLCAwLCAwIClcbiAgICByZXR1cm4gdmFsdWVcbn1cblxuXG4vKipcbiAqIE1lYXN1cmUgdGhlIHJhbmdlIG9mIGRhdGVzLlxuICovXG5EYXRlUGlja2VyLnByb3RvdHlwZS5tZWFzdXJlID0gZnVuY3Rpb24oIHR5cGUsIHZhbHVlLyosIG9wdGlvbnMqLyApIHtcblxuICAgIHZhciBjYWxlbmRhciA9IHRoaXNcblxuICAgIC8vIElmIGl04oCZcyBhbnl0aGluZyBmYWxzZS15LCByZW1vdmUgdGhlIGxpbWl0cy5cbiAgICBpZiAoICF2YWx1ZSApIHtcbiAgICAgICAgdmFsdWUgPSB0eXBlID09ICdtaW4nID8gLUluZmluaXR5IDogSW5maW5pdHlcbiAgICB9XG5cbiAgICAvLyBJZiBpdOKAmXMgYSBzdHJpbmcsIHBhcnNlIGl0LlxuICAgIGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHZhbHVlID0gY2FsZW5kYXIucGFyc2UoIHR5cGUsIHZhbHVlIClcbiAgICB9XG5cbiAgICAvLyBJZiBpdCdzIGFuIGludGVnZXIsIGdldCBhIGRhdGUgcmVsYXRpdmUgdG8gdG9kYXkuXG4gICAgZWxzZSBpZiAoIF8uaXNJbnRlZ2VyKCB2YWx1ZSApICkge1xuICAgICAgICB2YWx1ZSA9IGNhbGVuZGFyLm5vdyggdHlwZSwgdmFsdWUsIHsgcmVsOiB2YWx1ZSB9IClcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVcbn0gLy8vRGF0ZVBpY2tlci5wcm90b3R5cGUubWVhc3VyZVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgdmlld3NldCBvYmplY3QgYmFzZWQgb24gbmF2aWdhdGlvbi5cbiAqL1xuRGF0ZVBpY2tlci5wcm90b3R5cGUudmlld3NldCA9IGZ1bmN0aW9uKCB0eXBlLCBkYXRlT2JqZWN0LyosIG9wdGlvbnMqLyApIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGUoWyBkYXRlT2JqZWN0LnllYXIsIGRhdGVPYmplY3QubW9udGgsIDEgXSlcbn1cblxuXG4vKipcbiAqIFZhbGlkYXRlIGEgZGF0ZSBhcyBlbmFibGVkIGFuZCBzaGlmdCBpZiBuZWVkZWQuXG4gKi9cbkRhdGVQaWNrZXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oIHR5cGUsIGRhdGVPYmplY3QsIG9wdGlvbnMgKSB7XG5cbiAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLFxuXG4gICAgICAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGRhdGUuXG4gICAgICAgIG9yaWdpbmFsRGF0ZU9iamVjdCA9IGRhdGVPYmplY3QsXG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYW4gaW50ZXJ2YWwuXG4gICAgICAgIGludGVydmFsID0gb3B0aW9ucyAmJiBvcHRpb25zLmludGVydmFsID8gb3B0aW9ucy5pbnRlcnZhbCA6IDEsXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNhbGVuZGFyIGVuYWJsZWQgZGF0ZXMgYXJlIGludmVydGVkLlxuICAgICAgICBpc0ZsaXBwZWRCYXNlID0gY2FsZW5kYXIuaXRlbS5lbmFibGUgPT09IC0xLFxuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYW55IGVuYWJsZWQgZGF0ZXMgYWZ0ZXIvYmVmb3JlIG5vdy5cbiAgICAgICAgaGFzRW5hYmxlZEJlZm9yZVRhcmdldCwgaGFzRW5hYmxlZEFmdGVyVGFyZ2V0LFxuXG4gICAgICAgIC8vIFRoZSBtaW4gJiBtYXggbGltaXRzLlxuICAgICAgICBtaW5MaW1pdE9iamVjdCA9IGNhbGVuZGFyLml0ZW0ubWluLFxuICAgICAgICBtYXhMaW1pdE9iamVjdCA9IGNhbGVuZGFyLml0ZW0ubWF4LFxuXG4gICAgICAgIC8vIENoZWNrIGlmIHdl4oCZdmUgcmVhY2hlZCB0aGUgbGltaXQgZHVyaW5nIHNoaWZ0aW5nLlxuICAgICAgICByZWFjaGVkTWluLCByZWFjaGVkTWF4LFxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjYWxlbmRhciBpcyBpbnZlcnRlZCBhbmQgYXQgbGVhc3Qgb25lIHdlZWtkYXkgaXMgZW5hYmxlZC5cbiAgICAgICAgaGFzRW5hYmxlZFdlZWtkYXlzID0gaXNGbGlwcGVkQmFzZSAmJiBjYWxlbmRhci5pdGVtLmRpc2FibGUuZmlsdGVyKCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJl4oCZcyBhIGRhdGUsIGNoZWNrIHdoZXJlIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICBpZiAoICQuaXNBcnJheSggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZVRpbWUgPSBjYWxlbmRhci5jcmVhdGUoIHZhbHVlICkucGlja1xuICAgICAgICAgICAgICAgIGlmICggZGF0ZVRpbWUgPCBkYXRlT2JqZWN0LnBpY2sgKSBoYXNFbmFibGVkQmVmb3JlVGFyZ2V0ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBkYXRlVGltZSA+IGRhdGVPYmplY3QucGljayApIGhhc0VuYWJsZWRBZnRlclRhcmdldCA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIG9ubHkgaW50ZWdlcnMgZm9yIGVuYWJsZWQgd2Vla2RheXMuXG4gICAgICAgICAgICByZXR1cm4gXy5pc0ludGVnZXIoIHZhbHVlIClcbiAgICAgICAgfSkubGVuZ3RoLyosXG5cbiAgICAgICAgc2FmZXR5ID0gMTAwKi9cblxuXG5cbiAgICAvLyBDYXNlcyB0byB2YWxpZGF0ZSBmb3I6XG4gICAgLy8gWzFdIE5vdCBpbnZlcnRlZCBhbmQgZGF0ZSBkaXNhYmxlZC5cbiAgICAvLyBbMl0gSW52ZXJ0ZWQgYW5kIHNvbWUgZGF0ZXMgZW5hYmxlZC5cbiAgICAvLyBbM10gTm90IGludmVydGVkIGFuZCBvdXQgb2YgcmFuZ2UuXG4gICAgLy9cbiAgICAvLyBDYXNlcyB0byAqKm5vdCoqIHZhbGlkYXRlIGZvcjpcbiAgICAvLyDigKIgTmF2aWdhdGluZyBtb250aHMuXG4gICAgLy8g4oCiIE5vdCBpbnZlcnRlZCBhbmQgZGF0ZSBlbmFibGVkLlxuICAgIC8vIOKAoiBJbnZlcnRlZCBhbmQgYWxsIGRhdGVzIGRpc2FibGVkLlxuICAgIC8vIOKAoiAuLmFuZCBhbnl0aGluZyBlbHNlLlxuICAgIGlmICggIW9wdGlvbnMgfHwgIW9wdGlvbnMubmF2ICkgaWYgKFxuICAgICAgICAvKiAxICovICggIWlzRmxpcHBlZEJhc2UgJiYgY2FsZW5kYXIuZGlzYWJsZWQoIGRhdGVPYmplY3QgKSApIHx8XG4gICAgICAgIC8qIDIgKi8gKCBpc0ZsaXBwZWRCYXNlICYmIGNhbGVuZGFyLmRpc2FibGVkKCBkYXRlT2JqZWN0ICkgJiYgKCBoYXNFbmFibGVkV2Vla2RheXMgfHwgaGFzRW5hYmxlZEJlZm9yZVRhcmdldCB8fCBoYXNFbmFibGVkQWZ0ZXJUYXJnZXQgKSApIHx8XG4gICAgICAgIC8qIDMgKi8gKCAhaXNGbGlwcGVkQmFzZSAmJiAoZGF0ZU9iamVjdC5waWNrIDw9IG1pbkxpbWl0T2JqZWN0LnBpY2sgfHwgZGF0ZU9iamVjdC5waWNrID49IG1heExpbWl0T2JqZWN0LnBpY2spIClcbiAgICApIHtcblxuXG4gICAgICAgIC8vIFdoZW4gaW52ZXJ0ZWQsIGZsaXAgdGhlIGRpcmVjdGlvbiBpZiB0aGVyZSBhcmVu4oCZdCBhbnkgZW5hYmxlZCB3ZWVrZGF5c1xuICAgICAgICAvLyBhbmQgdGhlcmUgYXJlIG5vIGVuYWJsZWQgZGF0ZXMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgaW50ZXJ2YWwuXG4gICAgICAgIGlmICggaXNGbGlwcGVkQmFzZSAmJiAhaGFzRW5hYmxlZFdlZWtkYXlzICYmICggKCAhaGFzRW5hYmxlZEFmdGVyVGFyZ2V0ICYmIGludGVydmFsID4gMCApIHx8ICggIWhhc0VuYWJsZWRCZWZvcmVUYXJnZXQgJiYgaW50ZXJ2YWwgPCAwICkgKSApIHtcbiAgICAgICAgICAgIGludGVydmFsICo9IC0xXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEtlZXAgbG9vcGluZyB1bnRpbCB3ZSByZWFjaCBhbiBlbmFibGVkIGRhdGUuXG4gICAgICAgIHdoaWxlICggLypzYWZldHkgJiYqLyBjYWxlbmRhci5kaXNhYmxlZCggZGF0ZU9iamVjdCApICkge1xuXG4gICAgICAgICAgICAvKnNhZmV0eSAtPSAxXG4gICAgICAgICAgICBpZiAoICFzYWZldHkgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0ZlbGwgaW50byBhbiBpbmZpbml0ZSBsb29wIHdoaWxlIHZhbGlkYXRpbmcgJyArIGRhdGVPYmplY3Qub2JqICsgJy4nXG4gICAgICAgICAgICB9Ki9cblxuXG4gICAgICAgICAgICAvLyBJZiB3ZeKAmXZlIGxvb3BlZCBpbnRvIHRoZSBuZXh0L3ByZXYgbW9udGggd2l0aCBhIGxhcmdlIGludGVydmFsLCByZXR1cm4gdG8gdGhlIG9yaWdpbmFsIGRhdGUgYW5kIGZsYXR0ZW4gdGhlIGludGVydmFsLlxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggaW50ZXJ2YWwgKSA+IDEgJiYgKCBkYXRlT2JqZWN0Lm1vbnRoIDwgb3JpZ2luYWxEYXRlT2JqZWN0Lm1vbnRoIHx8IGRhdGVPYmplY3QubW9udGggPiBvcmlnaW5hbERhdGVPYmplY3QubW9udGggKSApIHtcbiAgICAgICAgICAgICAgICBkYXRlT2JqZWN0ID0gb3JpZ2luYWxEYXRlT2JqZWN0XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBpbnRlcnZhbCA+IDAgPyAxIDogLTFcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBJZiB3ZeKAmXZlIHJlYWNoZWQgdGhlIG1pbi9tYXggbGltaXQsIHJldmVyc2UgdGhlIGRpcmVjdGlvbiwgZmxhdHRlbiB0aGUgaW50ZXJ2YWwgYW5kIHNldCBpdCB0byB0aGUgbGltaXQuXG4gICAgICAgICAgICBpZiAoIGRhdGVPYmplY3QucGljayA8PSBtaW5MaW1pdE9iamVjdC5waWNrICkge1xuICAgICAgICAgICAgICAgIHJlYWNoZWRNaW4gPSB0cnVlXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSAxXG4gICAgICAgICAgICAgICAgZGF0ZU9iamVjdCA9IGNhbGVuZGFyLmNyZWF0ZShbXG4gICAgICAgICAgICAgICAgICAgIG1pbkxpbWl0T2JqZWN0LnllYXIsXG4gICAgICAgICAgICAgICAgICAgIG1pbkxpbWl0T2JqZWN0Lm1vbnRoLFxuICAgICAgICAgICAgICAgICAgICBtaW5MaW1pdE9iamVjdC5kYXRlICsgKGRhdGVPYmplY3QucGljayA9PT0gbWluTGltaXRPYmplY3QucGljayA/IDAgOiAtMSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIGRhdGVPYmplY3QucGljayA+PSBtYXhMaW1pdE9iamVjdC5waWNrICkge1xuICAgICAgICAgICAgICAgIHJlYWNoZWRNYXggPSB0cnVlXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSAtMVxuICAgICAgICAgICAgICAgIGRhdGVPYmplY3QgPSBjYWxlbmRhci5jcmVhdGUoW1xuICAgICAgICAgICAgICAgICAgICBtYXhMaW1pdE9iamVjdC55ZWFyLFxuICAgICAgICAgICAgICAgICAgICBtYXhMaW1pdE9iamVjdC5tb250aCxcbiAgICAgICAgICAgICAgICAgICAgbWF4TGltaXRPYmplY3QuZGF0ZSArIChkYXRlT2JqZWN0LnBpY2sgPT09IG1heExpbWl0T2JqZWN0LnBpY2sgPyAwIDogMSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIElmIHdl4oCZdmUgcmVhY2hlZCBib3RoIGxpbWl0cywganVzdCBicmVhayBvdXQgb2YgdGhlIGxvb3AuXG4gICAgICAgICAgICBpZiAoIHJlYWNoZWRNaW4gJiYgcmVhY2hlZE1heCApIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIGNyZWF0ZSB0aGUgc2hpZnRlZCBkYXRlIHVzaW5nIHRoZSBpbnRlcnZhbCBhbmQga2VlcCBsb29waW5nLlxuICAgICAgICAgICAgZGF0ZU9iamVjdCA9IGNhbGVuZGFyLmNyZWF0ZShbIGRhdGVPYmplY3QueWVhciwgZGF0ZU9iamVjdC5tb250aCwgZGF0ZU9iamVjdC5kYXRlICsgaW50ZXJ2YWwgXSlcbiAgICAgICAgfVxuXG4gICAgfSAvL2VuZGlmXG5cblxuICAgIC8vIFJldHVybiB0aGUgZGF0ZSBvYmplY3Qgc2V0dGxlZCBvbi5cbiAgICByZXR1cm4gZGF0ZU9iamVjdFxufSAvL0RhdGVQaWNrZXIucHJvdG90eXBlLnZhbGlkYXRlXG5cblxuLyoqXG4gKiBDaGVjayBpZiBhIGRhdGUgaXMgZGlzYWJsZWQuXG4gKi9cbkRhdGVQaWNrZXIucHJvdG90eXBlLmRpc2FibGVkID0gZnVuY3Rpb24oIGRhdGVUb1ZlcmlmeSApIHtcblxuICAgIHZhclxuICAgICAgICBjYWxlbmRhciA9IHRoaXMsXG5cbiAgICAgICAgLy8gRmlsdGVyIHRocm91Z2ggdGhlIGRpc2FibGVkIGRhdGVzIHRvIGNoZWNrIGlmIHRoaXMgaXMgb25lLlxuICAgICAgICBpc0Rpc2FibGVkTWF0Y2ggPSBjYWxlbmRhci5pdGVtLmRpc2FibGUuZmlsdGVyKCBmdW5jdGlvbiggZGF0ZVRvRGlzYWJsZSApIHtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRhdGUgaXMgYSBudW1iZXIsIG1hdGNoIHRoZSB3ZWVrZGF5IHdpdGggMGluZGV4IGFuZCBgZmlyc3REYXlgIGNoZWNrLlxuICAgICAgICAgICAgaWYgKCBfLmlzSW50ZWdlciggZGF0ZVRvRGlzYWJsZSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlVG9WZXJpZnkuZGF5ID09PSAoIGNhbGVuZGFyLnNldHRpbmdzLmZpcnN0RGF5ID8gZGF0ZVRvRGlzYWJsZSA6IGRhdGVUb0Rpc2FibGUgLSAxICkgJSA3XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGl04oCZcyBhbiBhcnJheSBvciBhIG5hdGl2ZSBKUyBkYXRlLCBjcmVhdGUgYW5kIG1hdGNoIHRoZSBleGFjdCBkYXRlLlxuICAgICAgICAgICAgaWYgKCAkLmlzQXJyYXkoIGRhdGVUb0Rpc2FibGUgKSB8fCBfLmlzRGF0ZSggZGF0ZVRvRGlzYWJsZSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlVG9WZXJpZnkucGljayA9PT0gY2FsZW5kYXIuY3JlYXRlKCBkYXRlVG9EaXNhYmxlICkucGlja1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBpdOKAmXMgYW4gb2JqZWN0LCBtYXRjaCBhIGRhdGUgd2l0aGluIHRoZSDigJxmcm9t4oCdIGFuZCDigJx0b+KAnSByYW5nZS5cbiAgICAgICAgICAgIGlmICggJC5pc1BsYWluT2JqZWN0KCBkYXRlVG9EaXNhYmxlICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyLndpdGhpblJhbmdlKCBkYXRlVG9EaXNhYmxlLCBkYXRlVG9WZXJpZnkgKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgLy8gSWYgdGhpcyBkYXRlIG1hdGNoZXMgYSBkaXNhYmxlZCBkYXRlLCBjb25maXJtIGl04oCZcyBub3QgaW52ZXJ0ZWQuXG4gICAgaXNEaXNhYmxlZE1hdGNoID0gaXNEaXNhYmxlZE1hdGNoLmxlbmd0aCAmJiAhaXNEaXNhYmxlZE1hdGNoLmZpbHRlcihmdW5jdGlvbiggZGF0ZVRvRGlzYWJsZSApIHtcbiAgICAgICAgcmV0dXJuICQuaXNBcnJheSggZGF0ZVRvRGlzYWJsZSApICYmIGRhdGVUb0Rpc2FibGVbM10gPT0gJ2ludmVydGVkJyB8fFxuICAgICAgICAgICAgJC5pc1BsYWluT2JqZWN0KCBkYXRlVG9EaXNhYmxlICkgJiYgZGF0ZVRvRGlzYWJsZS5pbnZlcnRlZFxuICAgIH0pLmxlbmd0aFxuXG4gICAgLy8gQ2hlY2sgdGhlIGNhbGVuZGFyIOKAnGVuYWJsZWTigJ0gZmxhZyBhbmQgcmVzcGVjdGl2ZWx5IGZsaXAgdGhlXG4gICAgLy8gZGlzYWJsZWQgc3RhdGUuIFRoZW4gYWxzbyBjaGVjayBpZiBpdOKAmXMgYmV5b25kIHRoZSBtaW4vbWF4IGxpbWl0cy5cbiAgICByZXR1cm4gY2FsZW5kYXIuaXRlbS5lbmFibGUgPT09IC0xID8gIWlzRGlzYWJsZWRNYXRjaCA6IGlzRGlzYWJsZWRNYXRjaCB8fFxuICAgICAgICBkYXRlVG9WZXJpZnkucGljayA8IGNhbGVuZGFyLml0ZW0ubWluLnBpY2sgfHxcbiAgICAgICAgZGF0ZVRvVmVyaWZ5LnBpY2sgPiBjYWxlbmRhci5pdGVtLm1heC5waWNrXG5cbn0gLy9EYXRlUGlja2VyLnByb3RvdHlwZS5kaXNhYmxlZFxuXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgaW50byBhIHVzYWJsZSB0eXBlLlxuICovXG5EYXRlUGlja2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCB0eXBlLCB2YWx1ZSwgb3B0aW9ucyApIHtcblxuICAgIHZhciBjYWxlbmRhciA9IHRoaXMsXG4gICAgICAgIHBhcnNpbmdPYmplY3QgPSB7fVxuXG4gICAgLy8gSWYgaXTigJlzIGFscmVhZHkgcGFyc2VkLCB3ZeKAmXJlIGdvb2QuXG4gICAgaWYgKCAhdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnICkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvLyBXZSBuZWVkIGEgYC5mb3JtYXRgIHRvIHBhcnNlIHRoZSB2YWx1ZSB3aXRoLlxuICAgIGlmICggISggb3B0aW9ucyAmJiBvcHRpb25zLmZvcm1hdCApICkge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgICAgICBvcHRpb25zLmZvcm1hdCA9IGNhbGVuZGFyLnNldHRpbmdzLmZvcm1hdFxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgdGhlIGZvcm1hdCBpbnRvIGFuIGFycmF5IGFuZCB0aGVuIG1hcCB0aHJvdWdoIGl0LlxuICAgIGNhbGVuZGFyLmZvcm1hdHMudG9BcnJheSggb3B0aW9ucy5mb3JtYXQgKS5tYXAoIGZ1bmN0aW9uKCBsYWJlbCApIHtcblxuICAgICAgICB2YXJcbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIGZvcm1hdHRpbmcgbGFiZWwuXG4gICAgICAgICAgICBmb3JtYXR0aW5nTGFiZWwgPSBjYWxlbmRhci5mb3JtYXRzWyBsYWJlbCBdLFxuXG4gICAgICAgICAgICAvLyBUaGUgZm9ybWF0IGxlbmd0aCBpcyBmcm9tIHRoZSBmb3JtYXR0aW5nIGxhYmVsIGZ1bmN0aW9uIG9yIHRoZVxuICAgICAgICAgICAgLy8gbGFiZWwgbGVuZ3RoIHdpdGhvdXQgdGhlIGVzY2FwaW5nIGV4Y2xhbWF0aW9uICghKSBtYXJrLlxuICAgICAgICAgICAgZm9ybWF0TGVuZ3RoID0gZm9ybWF0dGluZ0xhYmVsID8gXy50cmlnZ2VyKCBmb3JtYXR0aW5nTGFiZWwsIGNhbGVuZGFyLCBbIHZhbHVlLCBwYXJzaW5nT2JqZWN0IF0gKSA6IGxhYmVsLnJlcGxhY2UoIC9eIS8sICcnICkubGVuZ3RoXG5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIGZvcm1hdCBsYWJlbCwgc3BsaXQgdGhlIHZhbHVlIHVwIHRvIHRoZSBmb3JtYXQgbGVuZ3RoLlxuICAgICAgICAvLyBUaGVuIGFkZCBpdCB0byB0aGUgcGFyc2luZyBvYmplY3Qgd2l0aCBhcHByb3ByaWF0ZSBsYWJlbC5cbiAgICAgICAgaWYgKCBmb3JtYXR0aW5nTGFiZWwgKSB7XG4gICAgICAgICAgICBwYXJzaW5nT2JqZWN0WyBsYWJlbCBdID0gdmFsdWUuc3Vic3RyKCAwLCBmb3JtYXRMZW5ndGggKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YWx1ZSBhcyB0aGUgc3Vic3RyaW5nIGZyb20gZm9ybWF0IGxlbmd0aCB0byBlbmQuXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKCBmb3JtYXRMZW5ndGggKVxuICAgIH0pXG5cbiAgICAvLyBDb21wZW5zYXRlIGZvciBtb250aCAwaW5kZXguXG4gICAgcmV0dXJuIFtcbiAgICAgICAgcGFyc2luZ09iamVjdC55eXl5IHx8IHBhcnNpbmdPYmplY3QueXksXG4gICAgICAgICsoIHBhcnNpbmdPYmplY3QubW0gfHwgcGFyc2luZ09iamVjdC5tICkgLSAxLFxuICAgICAgICBwYXJzaW5nT2JqZWN0LmRkIHx8IHBhcnNpbmdPYmplY3QuZFxuICAgIF1cbn0gLy9EYXRlUGlja2VyLnByb3RvdHlwZS5wYXJzZVxuXG5cbi8qKlxuICogVmFyaW91cyBmb3JtYXRzIHRvIGRpc3BsYXkgdGhlIG9iamVjdCBpbi5cbiAqL1xuRGF0ZVBpY2tlci5wcm90b3R5cGUuZm9ybWF0cyA9IChmdW5jdGlvbigpIHtcblxuICAgIC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCB3b3JkIGluIGEgY29sbGVjdGlvbi5cbiAgICBmdW5jdGlvbiBnZXRXb3JkTGVuZ3RoRnJvbUNvbGxlY3Rpb24oIHN0cmluZywgY29sbGVjdGlvbiwgZGF0ZU9iamVjdCApIHtcblxuICAgICAgICAvLyBHcmFiIHRoZSBmaXJzdCB3b3JkIGZyb20gdGhlIHN0cmluZy5cbiAgICAgICAgdmFyIHdvcmQgPSBzdHJpbmcubWF0Y2goIC9cXHcrLyApWyAwIF1cblxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG1vbnRoIGluZGV4LCBhZGQgaXQgdG8gdGhlIGRhdGUgb2JqZWN0XG4gICAgICAgIGlmICggIWRhdGVPYmplY3QubW0gJiYgIWRhdGVPYmplY3QubSApIHtcbiAgICAgICAgICAgIGRhdGVPYmplY3QubSA9IGNvbGxlY3Rpb24uaW5kZXhPZiggd29yZCApICsgMVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIHdvcmQuXG4gICAgICAgIHJldHVybiB3b3JkLmxlbmd0aFxuICAgIH1cblxuICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCB3b3JkIGluIGEgc3RyaW5nLlxuICAgIGZ1bmN0aW9uIGdldEZpcnN0V29yZExlbmd0aCggc3RyaW5nICkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKCAvXFx3Ky8gKVsgMCBdLmxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgZDogZnVuY3Rpb24oIHN0cmluZywgZGF0ZU9iamVjdCApIHtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBzdHJpbmcsIHRoZW4gZ2V0IHRoZSBkaWdpdHMgbGVuZ3RoLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybiB0aGUgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcgPyBfLmRpZ2l0cyggc3RyaW5nICkgOiBkYXRlT2JqZWN0LmRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgZGQ6IGZ1bmN0aW9uKCBzdHJpbmcsIGRhdGVPYmplY3QgKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBzdHJpbmcsIHRoZW4gdGhlIGxlbmd0aCBpcyBhbHdheXMgMi5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIHNlbGVjdGVkIGRhdGUgd2l0aCBhIGxlYWRpbmcgemVyby5cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcgPyAyIDogXy5sZWFkKCBkYXRlT2JqZWN0LmRhdGUgKVxuICAgICAgICB9LFxuICAgICAgICBkZGQ6IGZ1bmN0aW9uKCBzdHJpbmcsIGRhdGVPYmplY3QgKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBzdHJpbmcsIHRoZW4gZ2V0IHRoZSBsZW5ndGggb2YgdGhlIGZpcnN0IHdvcmQuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoZSBzaG9ydCBzZWxlY3RlZCB3ZWVrZGF5LlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZyA/IGdldEZpcnN0V29yZExlbmd0aCggc3RyaW5nICkgOiB0aGlzLnNldHRpbmdzLndlZWtkYXlzU2hvcnRbIGRhdGVPYmplY3QuZGF5IF1cbiAgICAgICAgfSxcbiAgICAgICAgZGRkZDogZnVuY3Rpb24oIHN0cmluZywgZGF0ZU9iamVjdCApIHtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHN0cmluZywgdGhlbiBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgZmlyc3Qgd29yZC5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIGZ1bGwgc2VsZWN0ZWQgd2Vla2RheS5cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcgPyBnZXRGaXJzdFdvcmRMZW5ndGgoIHN0cmluZyApIDogdGhpcy5zZXR0aW5ncy53ZWVrZGF5c0Z1bGxbIGRhdGVPYmplY3QuZGF5IF1cbiAgICAgICAgfSxcbiAgICAgICAgbTogZnVuY3Rpb24oIHN0cmluZywgZGF0ZU9iamVjdCApIHtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHN0cmluZywgdGhlbiBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgZGlnaXRzXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoZSBzZWxlY3RlZCBtb250aCB3aXRoIDBpbmRleCBjb21wZW5zYXRpb24uXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nID8gXy5kaWdpdHMoIHN0cmluZyApIDogZGF0ZU9iamVjdC5tb250aCArIDFcbiAgICAgICAgfSxcbiAgICAgICAgbW06IGZ1bmN0aW9uKCBzdHJpbmcsIGRhdGVPYmplY3QgKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBzdHJpbmcsIHRoZW4gdGhlIGxlbmd0aCBpcyBhbHdheXMgMi5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIHNlbGVjdGVkIG1vbnRoIHdpdGggMGluZGV4IGFuZCBsZWFkaW5nIHplcm8uXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nID8gMiA6IF8ubGVhZCggZGF0ZU9iamVjdC5tb250aCArIDEgKVxuICAgICAgICB9LFxuICAgICAgICBtbW06IGZ1bmN0aW9uKCBzdHJpbmcsIGRhdGVPYmplY3QgKSB7XG5cbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5zZXR0aW5ncy5tb250aHNTaG9ydFxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgc3RyaW5nLCBnZXQgbGVuZ3RoIG9mIHRoZSByZWxldmFudCBtb250aCBmcm9tIHRoZSBzaG9ydFxuICAgICAgICAgICAgLy8gbW9udGhzIGNvbGxlY3Rpb24uIE90aGVyd2lzZSByZXR1cm4gdGhlIHNlbGVjdGVkIG1vbnRoIGZyb20gdGhhdCBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZyA/IGdldFdvcmRMZW5ndGhGcm9tQ29sbGVjdGlvbiggc3RyaW5nLCBjb2xsZWN0aW9uLCBkYXRlT2JqZWN0ICkgOiBjb2xsZWN0aW9uWyBkYXRlT2JqZWN0Lm1vbnRoIF1cbiAgICAgICAgfSxcbiAgICAgICAgbW1tbTogZnVuY3Rpb24oIHN0cmluZywgZGF0ZU9iamVjdCApIHtcblxuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLnNldHRpbmdzLm1vbnRoc0Z1bGxcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHN0cmluZywgZ2V0IGxlbmd0aCBvZiB0aGUgcmVsZXZhbnQgbW9udGggZnJvbSB0aGUgZnVsbFxuICAgICAgICAgICAgLy8gbW9udGhzIGNvbGxlY3Rpb24uIE90aGVyd2lzZSByZXR1cm4gdGhlIHNlbGVjdGVkIG1vbnRoIGZyb20gdGhhdCBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZyA/IGdldFdvcmRMZW5ndGhGcm9tQ29sbGVjdGlvbiggc3RyaW5nLCBjb2xsZWN0aW9uLCBkYXRlT2JqZWN0ICkgOiBjb2xsZWN0aW9uWyBkYXRlT2JqZWN0Lm1vbnRoIF1cbiAgICAgICAgfSxcbiAgICAgICAgeXk6IGZ1bmN0aW9uKCBzdHJpbmcsIGRhdGVPYmplY3QgKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBzdHJpbmcsIHRoZW4gdGhlIGxlbmd0aCBpcyBhbHdheXMgMi5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIHNlbGVjdGVkIHllYXIgYnkgc2xpY2luZyBvdXQgdGhlIGZpcnN0IDIgZGlnaXRzLlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZyA/IDIgOiAoICcnICsgZGF0ZU9iamVjdC55ZWFyICkuc2xpY2UoIDIgKVxuICAgICAgICB9LFxuICAgICAgICB5eXl5OiBmdW5jdGlvbiggc3RyaW5nLCBkYXRlT2JqZWN0ICkge1xuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgc3RyaW5nLCB0aGVuIHRoZSBsZW5ndGggaXMgYWx3YXlzIDQuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoZSBzZWxlY3RlZCB5ZWFyLlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZyA/IDQgOiBkYXRlT2JqZWN0LnllYXJcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDcmVhdGUgYW4gYXJyYXkgYnkgc3BsaXR0aW5nIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBwYXNzZWQuXG4gICAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCBmb3JtYXRTdHJpbmcgKSB7IHJldHVybiBmb3JtYXRTdHJpbmcuc3BsaXQoIC8oZHsxLDR9fG17MSw0fXx5ezR9fHl5fCEuKS9nICkgfSxcblxuICAgICAgICAvLyBGb3JtYXQgYW4gb2JqZWN0IGludG8gYSBzdHJpbmcgdXNpbmcgdGhlIGZvcm1hdHRpbmcgb3B0aW9ucy5cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICggZm9ybWF0U3RyaW5nLCBpdGVtT2JqZWN0ICkge1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpc1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyLmZvcm1hdHMudG9BcnJheSggZm9ybWF0U3RyaW5nICkubWFwKCBmdW5jdGlvbiggbGFiZWwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8udHJpZ2dlciggY2FsZW5kYXIuZm9ybWF0c1sgbGFiZWwgXSwgY2FsZW5kYXIsIFsgMCwgaXRlbU9iamVjdCBdICkgfHwgbGFiZWwucmVwbGFjZSggL14hLywgJycgKVxuICAgICAgICAgICAgfSkuam9pbiggJycgKVxuICAgICAgICB9XG4gICAgfVxufSkoKSAvL0RhdGVQaWNrZXIucHJvdG90eXBlLmZvcm1hdHNcblxuXG5cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gZGF0ZSB1bml0cyBhcmUgdGhlIGV4YWN0LlxuICovXG5EYXRlUGlja2VyLnByb3RvdHlwZS5pc0RhdGVFeGFjdCA9IGZ1bmN0aW9uKCBvbmUsIHR3byApIHtcblxuICAgIHZhciBjYWxlbmRhciA9IHRoaXNcblxuICAgIC8vIFdoZW4gd2XigJlyZSB3b3JraW5nIHdpdGggd2Vla2RheXMsIGRvIGEgZGlyZWN0IGNvbXBhcmlzb24uXG4gICAgaWYgKFxuICAgICAgICAoIF8uaXNJbnRlZ2VyKCBvbmUgKSAmJiBfLmlzSW50ZWdlciggdHdvICkgKSB8fFxuICAgICAgICAoIHR5cGVvZiBvbmUgPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiB0d28gPT0gJ2Jvb2xlYW4nIClcbiAgICAgKSB7XG4gICAgICAgIHJldHVybiBvbmUgPT09IHR3b1xuICAgIH1cblxuICAgIC8vIFdoZW4gd2XigJlyZSB3b3JraW5nIHdpdGggZGF0ZSByZXByZXNlbnRhdGlvbnMsIGNvbXBhcmUgdGhlIOKAnHBpY2vigJ0gdmFsdWUuXG4gICAgaWYgKFxuICAgICAgICAoIF8uaXNEYXRlKCBvbmUgKSB8fCAkLmlzQXJyYXkoIG9uZSApICkgJiZcbiAgICAgICAgKCBfLmlzRGF0ZSggdHdvICkgfHwgJC5pc0FycmF5KCB0d28gKSApXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBjYWxlbmRhci5jcmVhdGUoIG9uZSApLnBpY2sgPT09IGNhbGVuZGFyLmNyZWF0ZSggdHdvICkucGlja1xuICAgIH1cblxuICAgIC8vIFdoZW4gd2XigJlyZSB3b3JraW5nIHdpdGggcmFuZ2Ugb2JqZWN0cywgY29tcGFyZSB0aGUg4oCcZnJvbeKAnSBhbmQg4oCcdG/igJ0uXG4gICAgaWYgKCAkLmlzUGxhaW5PYmplY3QoIG9uZSApICYmICQuaXNQbGFpbk9iamVjdCggdHdvICkgKSB7XG4gICAgICAgIHJldHVybiBjYWxlbmRhci5pc0RhdGVFeGFjdCggb25lLmZyb20sIHR3by5mcm9tICkgJiYgY2FsZW5kYXIuaXNEYXRlRXhhY3QoIG9uZS50bywgdHdvLnRvIClcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2Vcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIHR3byBkYXRlIHVuaXRzIG92ZXJsYXAuXG4gKi9cbkRhdGVQaWNrZXIucHJvdG90eXBlLmlzRGF0ZU92ZXJsYXAgPSBmdW5jdGlvbiggb25lLCB0d28gKSB7XG5cbiAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLFxuICAgICAgICBmaXJzdERheSA9IGNhbGVuZGFyLnNldHRpbmdzLmZpcnN0RGF5ID8gMSA6IDBcblxuICAgIC8vIFdoZW4gd2XigJlyZSB3b3JraW5nIHdpdGggYSB3ZWVrZGF5IGluZGV4LCBjb21wYXJlIHRoZSBkYXlzLlxuICAgIGlmICggXy5pc0ludGVnZXIoIG9uZSApICYmICggXy5pc0RhdGUoIHR3byApIHx8ICQuaXNBcnJheSggdHdvICkgKSApIHtcbiAgICAgICAgb25lID0gb25lICUgNyArIGZpcnN0RGF5XG4gICAgICAgIHJldHVybiBvbmUgPT09IGNhbGVuZGFyLmNyZWF0ZSggdHdvICkuZGF5ICsgMVxuICAgIH1cbiAgICBpZiAoIF8uaXNJbnRlZ2VyKCB0d28gKSAmJiAoIF8uaXNEYXRlKCBvbmUgKSB8fCAkLmlzQXJyYXkoIG9uZSApICkgKSB7XG4gICAgICAgIHR3byA9IHR3byAlIDcgKyBmaXJzdERheVxuICAgICAgICByZXR1cm4gdHdvID09PSBjYWxlbmRhci5jcmVhdGUoIG9uZSApLmRheSArIDFcbiAgICB9XG5cbiAgICAvLyBXaGVuIHdl4oCZcmUgd29ya2luZyB3aXRoIHJhbmdlIG9iamVjdHMsIGNoZWNrIGlmIHRoZSByYW5nZXMgb3ZlcmxhcC5cbiAgICBpZiAoICQuaXNQbGFpbk9iamVjdCggb25lICkgJiYgJC5pc1BsYWluT2JqZWN0KCB0d28gKSApIHtcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyLm92ZXJsYXBSYW5nZXMoIG9uZSwgdHdvIClcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2Vcbn1cblxuXG4vKipcbiAqIEZsaXAgdGhlIOKAnGVuYWJsZWTigJ0gc3RhdGUuXG4gKi9cbkRhdGVQaWNrZXIucHJvdG90eXBlLmZsaXBFbmFibGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgaXRlbU9iamVjdCA9IHRoaXMuaXRlbVxuICAgIGl0ZW1PYmplY3QuZW5hYmxlID0gdmFsIHx8IChpdGVtT2JqZWN0LmVuYWJsZSA9PSAtMSA/IDEgOiAtMSlcbn1cblxuXG4vKipcbiAqIE1hcmsgYSBjb2xsZWN0aW9uIG9mIGRhdGVzIGFzIOKAnGRpc2FibGVk4oCdLlxuICovXG5EYXRlUGlja2VyLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24oIHR5cGUsIGRhdGVzVG9EaXNhYmxlICkge1xuXG4gICAgdmFyIGNhbGVuZGFyID0gdGhpcyxcbiAgICAgICAgZGlzYWJsZWRJdGVtcyA9IGNhbGVuZGFyLml0ZW0uZGlzYWJsZS5zbGljZSgwKVxuXG5cbiAgICAvLyBJZiB3ZeKAmXJlIGZsaXBwaW5nLCB0aGF04oCZcyBhbGwgd2UgbmVlZCB0byBkby5cbiAgICBpZiAoIGRhdGVzVG9EaXNhYmxlID09ICdmbGlwJyApIHtcbiAgICAgICAgY2FsZW5kYXIuZmxpcEVuYWJsZSgpXG4gICAgfVxuXG4gICAgZWxzZSBpZiAoIGRhdGVzVG9EaXNhYmxlID09PSBmYWxzZSApIHtcbiAgICAgICAgY2FsZW5kYXIuZmxpcEVuYWJsZSgxKVxuICAgICAgICBkaXNhYmxlZEl0ZW1zID0gW11cbiAgICB9XG5cbiAgICBlbHNlIGlmICggZGF0ZXNUb0Rpc2FibGUgPT09IHRydWUgKSB7XG4gICAgICAgIGNhbGVuZGFyLmZsaXBFbmFibGUoLTEpXG4gICAgICAgIGRpc2FibGVkSXRlbXMgPSBbXVxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBnbyB0aHJvdWdoIHRoZSBkYXRlcyB0byBkaXNhYmxlLlxuICAgIGVsc2Uge1xuXG4gICAgICAgIGRhdGVzVG9EaXNhYmxlLm1hcChmdW5jdGlvbiggdW5pdFRvRGlzYWJsZSApIHtcblxuICAgICAgICAgICAgdmFyIG1hdGNoRm91bmRcblxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIGRpc2FibGVkIGl0ZW1zLCBjaGVjayBmb3IgbWF0Y2hlcy5cbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyBtYXRjaGVkLCBpbW1lZGlhdGVseSBicmVhayBvdXQuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaW5kZXggPSAwOyBpbmRleCA8IGRpc2FibGVkSXRlbXMubGVuZ3RoOyBpbmRleCArPSAxICkge1xuICAgICAgICAgICAgICAgIGlmICggY2FsZW5kYXIuaXNEYXRlRXhhY3QoIHVuaXRUb0Rpc2FibGUsIGRpc2FibGVkSXRlbXNbaW5kZXhdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRm91bmQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCwgYWRkIHRoZSB2YWxpZGF0ZWQgdW5pdCB0byB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgICAgIGlmICggIW1hdGNoRm91bmQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBfLmlzSW50ZWdlciggdW5pdFRvRGlzYWJsZSApIHx8XG4gICAgICAgICAgICAgICAgICAgIF8uaXNEYXRlKCB1bml0VG9EaXNhYmxlICkgfHxcbiAgICAgICAgICAgICAgICAgICAgJC5pc0FycmF5KCB1bml0VG9EaXNhYmxlICkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCAkLmlzUGxhaW5PYmplY3QoIHVuaXRUb0Rpc2FibGUgKSAmJiB1bml0VG9EaXNhYmxlLmZyb20gJiYgdW5pdFRvRGlzYWJsZS50byApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkSXRlbXMucHVzaCggdW5pdFRvRGlzYWJsZSApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgdXBkYXRlZCBjb2xsZWN0aW9uLlxuICAgIHJldHVybiBkaXNhYmxlZEl0ZW1zXG59IC8vRGF0ZVBpY2tlci5wcm90b3R5cGUuZGVhY3RpdmF0ZVxuXG5cbi8qKlxuICogTWFyayBhIGNvbGxlY3Rpb24gb2YgZGF0ZXMgYXMg4oCcZW5hYmxlZOKAnS5cbiAqL1xuRGF0ZVBpY2tlci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiggdHlwZSwgZGF0ZXNUb0VuYWJsZSApIHtcblxuICAgIHZhciBjYWxlbmRhciA9IHRoaXMsXG4gICAgICAgIGRpc2FibGVkSXRlbXMgPSBjYWxlbmRhci5pdGVtLmRpc2FibGUsXG4gICAgICAgIGRpc2FibGVkSXRlbXNDb3VudCA9IGRpc2FibGVkSXRlbXMubGVuZ3RoXG5cbiAgICAvLyBJZiB3ZeKAmXJlIGZsaXBwaW5nLCB0aGF04oCZcyBhbGwgd2UgbmVlZCB0byBkby5cbiAgICBpZiAoIGRhdGVzVG9FbmFibGUgPT0gJ2ZsaXAnICkge1xuICAgICAgICBjYWxlbmRhci5mbGlwRW5hYmxlKClcbiAgICB9XG5cbiAgICBlbHNlIGlmICggZGF0ZXNUb0VuYWJsZSA9PT0gdHJ1ZSApIHtcbiAgICAgICAgY2FsZW5kYXIuZmxpcEVuYWJsZSgxKVxuICAgICAgICBkaXNhYmxlZEl0ZW1zID0gW11cbiAgICB9XG5cbiAgICBlbHNlIGlmICggZGF0ZXNUb0VuYWJsZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgIGNhbGVuZGFyLmZsaXBFbmFibGUoLTEpXG4gICAgICAgIGRpc2FibGVkSXRlbXMgPSBbXVxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBnbyB0aHJvdWdoIHRoZSBkaXNhYmxlZCBkYXRlcy5cbiAgICBlbHNlIHtcblxuICAgICAgICBkYXRlc1RvRW5hYmxlLm1hcChmdW5jdGlvbiggdW5pdFRvRW5hYmxlICkge1xuXG4gICAgICAgICAgICB2YXIgbWF0Y2hGb3VuZCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZFVuaXQsXG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgaXNFeGFjdFJhbmdlXG5cbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGRpc2FibGVkIGl0ZW1zIGFuZCB0cnkgdG8gZmluZCBhIG1hdGNoLlxuICAgICAgICAgICAgZm9yICggaW5kZXggPSAwOyBpbmRleCA8IGRpc2FibGVkSXRlbXNDb3VudDsgaW5kZXggKz0gMSApIHtcblxuICAgICAgICAgICAgICAgIGRpc2FibGVkVW5pdCA9IGRpc2FibGVkSXRlbXNbaW5kZXhdXG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIGFuIGV4YWN0IG1hdGNoIGlzIGZvdW5kLCByZW1vdmUgaXQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoIGNhbGVuZGFyLmlzRGF0ZUV4YWN0KCBkaXNhYmxlZFVuaXQsIHVuaXRUb0VuYWJsZSApICkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZvdW5kID0gZGlzYWJsZWRJdGVtc1tpbmRleF0gPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIGlzRXhhY3RSYW5nZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIGFuIG92ZXJsYXBwZWQgbWF0Y2ggaXMgZm91bmQsIGFkZCB0aGUg4oCcaW52ZXJ0ZWTigJ0gc3RhdGUgdG8gaXQuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIGNhbGVuZGFyLmlzRGF0ZU92ZXJsYXAoIGRpc2FibGVkVW5pdCwgdW5pdFRvRW5hYmxlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggJC5pc1BsYWluT2JqZWN0KCB1bml0VG9FbmFibGUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRUb0VuYWJsZS5pbnZlcnRlZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRm91bmQgPSB1bml0VG9FbmFibGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggJC5pc0FycmF5KCB1bml0VG9FbmFibGUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRm91bmQgPSB1bml0VG9FbmFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW1hdGNoRm91bmRbM10gKSBtYXRjaEZvdW5kLnB1c2goICdpbnZlcnRlZCcgKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBfLmlzRGF0ZSggdW5pdFRvRW5hYmxlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZvdW5kID0gWyB1bml0VG9FbmFibGUuZ2V0RnVsbFllYXIoKSwgdW5pdFRvRW5hYmxlLmdldE1vbnRoKCksIHVuaXRUb0VuYWJsZS5nZXREYXRlKCksICdpbnZlcnRlZCcgXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIG1hdGNoIHdhcyBmb3VuZCwgcmVtb3ZlIGEgcHJldmlvdXMgZHVwbGljYXRlIGVudHJ5LlxuICAgICAgICAgICAgaWYgKCBtYXRjaEZvdW5kICkgZm9yICggaW5kZXggPSAwOyBpbmRleCA8IGRpc2FibGVkSXRlbXNDb3VudDsgaW5kZXggKz0gMSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGNhbGVuZGFyLmlzRGF0ZUV4YWN0KCBkaXNhYmxlZEl0ZW1zW2luZGV4XSwgdW5pdFRvRW5hYmxlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkSXRlbXNbaW5kZXhdID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW4gdGhlIGV2ZW50IHRoYXQgd2XigJlyZSBkZWFsaW5nIHdpdGggYW4gZXhhY3QgcmFuZ2Ugb2YgZGF0ZXMsXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlcmUgYXJlIG5vIOKAnGludmVydGVk4oCdIGRhdGVzIGJlY2F1c2Ugb2YgaXQuXG4gICAgICAgICAgICBpZiAoIGlzRXhhY3RSYW5nZSApIGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBkaXNhYmxlZEl0ZW1zQ291bnQ7IGluZGV4ICs9IDEgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjYWxlbmRhci5pc0RhdGVPdmVybGFwKCBkaXNhYmxlZEl0ZW1zW2luZGV4XSwgdW5pdFRvRW5hYmxlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkSXRlbXNbaW5kZXhdID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIGlzIHN0aWxsIG1hdGNoZWQsIGFkZCBpdCBpbnRvIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKCBtYXRjaEZvdW5kICkge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkSXRlbXMucHVzaCggbWF0Y2hGb3VuZCApXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSB1cGRhdGVkIGNvbGxlY3Rpb24uXG4gICAgcmV0dXJuIGRpc2FibGVkSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKCB2YWwgKSB7IHJldHVybiB2YWwgIT0gbnVsbCB9KVxufSAvL0RhdGVQaWNrZXIucHJvdG90eXBlLmFjdGl2YXRlXG5cblxuLyoqXG4gKiBDcmVhdGUgYSBzdHJpbmcgZm9yIHRoZSBub2RlcyBpbiB0aGUgcGlja2VyLlxuICovXG5EYXRlUGlja2VyLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uKCBpc09wZW4gKSB7XG5cbiAgICB2YXJcbiAgICAgICAgY2FsZW5kYXIgPSB0aGlzLFxuICAgICAgICBzZXR0aW5ncyA9IGNhbGVuZGFyLnNldHRpbmdzLFxuICAgICAgICBjYWxlbmRhckl0ZW0gPSBjYWxlbmRhci5pdGVtLFxuICAgICAgICBub3dPYmplY3QgPSBjYWxlbmRhckl0ZW0ubm93LFxuICAgICAgICBzZWxlY3RlZE9iamVjdCA9IGNhbGVuZGFySXRlbS5zZWxlY3QsXG4gICAgICAgIGhpZ2hsaWdodGVkT2JqZWN0ID0gY2FsZW5kYXJJdGVtLmhpZ2hsaWdodCxcbiAgICAgICAgdmlld3NldE9iamVjdCA9IGNhbGVuZGFySXRlbS52aWV3LFxuICAgICAgICBkaXNhYmxlZENvbGxlY3Rpb24gPSBjYWxlbmRhckl0ZW0uZGlzYWJsZSxcbiAgICAgICAgbWluTGltaXRPYmplY3QgPSBjYWxlbmRhckl0ZW0ubWluLFxuICAgICAgICBtYXhMaW1pdE9iamVjdCA9IGNhbGVuZGFySXRlbS5tYXgsXG5cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGNhbGVuZGFyIHRhYmxlIGhlYWQgdXNpbmcgYSBjb3B5IG9mIHdlZWtkYXkgbGFiZWxzIGNvbGxlY3Rpb24uXG4gICAgICAgIC8vICogV2UgZG8gYSBjb3B5IHNvIHdlIGRvbid0IG11dGF0ZSB0aGUgb3JpZ2luYWwgYXJyYXkuXG4gICAgICAgIHRhYmxlSGVhZCA9IChmdW5jdGlvbiggY29sbGVjdGlvbiwgZnVsbENvbGxlY3Rpb24gKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBkYXkgc2hvdWxkIGJlIE1vbmRheSwgbW92ZSBTdW5kYXkgdG8gdGhlIGVuZC5cbiAgICAgICAgICAgIGlmICggc2V0dGluZ3MuZmlyc3REYXkgKSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKCBjb2xsZWN0aW9uLnNoaWZ0KCkgKVxuICAgICAgICAgICAgICAgIGZ1bGxDb2xsZWN0aW9uLnB1c2goIGZ1bGxDb2xsZWN0aW9uLnNoaWZ0KCkgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiB0aGUgdGFibGUgaGVhZCBncm91cC5cbiAgICAgICAgICAgIHJldHVybiBfLm5vZGUoXG4gICAgICAgICAgICAgICAgJ3RoZWFkJyxcbiAgICAgICAgICAgICAgICBfLm5vZGUoXG4gICAgICAgICAgICAgICAgICAgICd0cicsXG4gICAgICAgICAgICAgICAgICAgIF8uZ3JvdXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBEQVlTX0lOX1dFRUsgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6ICd0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBmdW5jdGlvbiggY291bnRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uWyBjb3VudGVyIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmtsYXNzLndlZWtkYXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2NvcGU9Y29sIHRpdGxlPVwiJyArIGZ1bGxDb2xsZWN0aW9uWyBjb3VudGVyIF0gKyAnXCInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkgLy9lbmRyZXR1cm5cblxuICAgICAgICAvLyBNYXRlcmlhbGl6ZSBtb2RpZmllZFxuICAgICAgICB9KSggKCBzZXR0aW5ncy5zaG93V2Vla2RheXNGdWxsID8gc2V0dGluZ3Mud2Vla2RheXNGdWxsIDogc2V0dGluZ3Mud2Vla2RheXNMZXR0ZXIgKS5zbGljZSggMCApLCBzZXR0aW5ncy53ZWVrZGF5c0Z1bGwuc2xpY2UoIDAgKSApLCAvL3RhYmxlSGVhZFxuXG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBuYXYgZm9yIG5leHQvcHJldiBtb250aC5cbiAgICAgICAgY3JlYXRlTW9udGhOYXYgPSBmdW5jdGlvbiggbmV4dCApIHtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIGNyZWF0ZWQgbW9udGggdGFnLlxuICAgICAgICAgICAgcmV0dXJuIF8ubm9kZShcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAnICcsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mua2xhc3NbICduYXYnICsgKCBuZXh0ID8gJ05leHQnIDogJ1ByZXYnICkgXSArIChcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZm9jdXNlZCBtb250aCBpcyBvdXRzaWRlIHRoZSByYW5nZSwgZGlzYWJsZWQgdGhlIGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgICAgKCBuZXh0ICYmIHZpZXdzZXRPYmplY3QueWVhciA+PSBtYXhMaW1pdE9iamVjdC55ZWFyICYmIHZpZXdzZXRPYmplY3QubW9udGggPj0gbWF4TGltaXRPYmplY3QubW9udGggKSB8fFxuICAgICAgICAgICAgICAgICAgICAoICFuZXh0ICYmIHZpZXdzZXRPYmplY3QueWVhciA8PSBtaW5MaW1pdE9iamVjdC55ZWFyICYmIHZpZXdzZXRPYmplY3QubW9udGggPD0gbWluTGltaXRPYmplY3QubW9udGggKSA/XG4gICAgICAgICAgICAgICAgICAgICcgJyArIHNldHRpbmdzLmtsYXNzLm5hdkRpc2FibGVkIDogJydcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICdkYXRhLW5hdj0nICsgKCBuZXh0IHx8IC0xICkgKyAnICcgK1xuICAgICAgICAgICAgICAgIF8uYXJpYUF0dHIoe1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHM6IGNhbGVuZGFyLiRub2RlWzBdLmlkICsgJ190YWJsZSdcbiAgICAgICAgICAgICAgICB9KSArICcgJyArXG4gICAgICAgICAgICAgICAgJ3RpdGxlPVwiJyArIChuZXh0ID8gc2V0dGluZ3MubGFiZWxNb250aE5leHQgOiBzZXR0aW5ncy5sYWJlbE1vbnRoUHJldiApICsgJ1wiJ1xuICAgICAgICAgICAgKSAvL2VuZHJldHVyblxuICAgICAgICB9LCAvL2NyZWF0ZU1vbnRoTmF2XG5cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIG1vbnRoIGxhYmVsLlxuICAgICAgICAvL01hdGVyaWFsaXplIG1vZGlmaWVkXG4gICAgICAgIGNyZWF0ZU1vbnRoTGFiZWwgPSBmdW5jdGlvbihvdmVycmlkZSkge1xuXG4gICAgICAgICAgICB2YXIgbW9udGhzQ29sbGVjdGlvbiA9IHNldHRpbmdzLnNob3dNb250aHNTaG9ydCA/IHNldHRpbmdzLm1vbnRoc1Nob3J0IDogc2V0dGluZ3MubW9udGhzRnVsbFxuXG4gICAgICAgICAgICAgLy8gTWF0ZXJpYWxpemUgbW9kaWZpZWRcbiAgICAgICAgICAgIGlmIChvdmVycmlkZSA9PSBcInNob3J0X21vbnRoc1wiKSB7XG4gICAgICAgICAgICAgIG1vbnRoc0NvbGxlY3Rpb24gPSBzZXR0aW5ncy5tb250aHNTaG9ydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vbnRocyB0byBzZWxlY3QsIGFkZCBhIGRyb3Bkb3duIG1lbnUuXG4gICAgICAgICAgICBpZiAoIHNldHRpbmdzLnNlbGVjdE1vbnRocyAgJiYgb3ZlcnJpZGUgPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gXy5ub2RlKCAnc2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgXy5ncm91cCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg6IDExLFxuICAgICAgICAgICAgICAgICAgICAgICAgaTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogZnVuY3Rpb24oIGxvb3BlZE1vbnRoICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbG9vcGVkIG1vbnRoIGFuZCBubyBjbGFzc2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aHNDb2xsZWN0aW9uWyBsb29wZWRNb250aCBdLCAwLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgdmFsdWUgYW5kIHNlbGVjdGVkIGluZGV4LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWU9JyArIGxvb3BlZE1vbnRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB2aWV3c2V0T2JqZWN0Lm1vbnRoID09IGxvb3BlZE1vbnRoID8gJyBzZWxlY3RlZCcgOiAnJyApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggdmlld3NldE9iamVjdC55ZWFyID09IG1pbkxpbWl0T2JqZWN0LnllYXIgJiYgbG9vcGVkTW9udGggPCBtaW5MaW1pdE9iamVjdC5tb250aCApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB2aWV3c2V0T2JqZWN0LnllYXIgPT0gbWF4TGltaXRPYmplY3QueWVhciAmJiBsb29wZWRNb250aCA+IG1heExpbWl0T2JqZWN0Lm1vbnRoIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBkaXNhYmxlZCcgOiAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mua2xhc3Muc2VsZWN0TW9udGggKyAnIGJyb3dzZXItZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgICggaXNPcGVuID8gJycgOiAnZGlzYWJsZWQnICkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICBfLmFyaWFBdHRyKHsgY29udHJvbHM6IGNhbGVuZGFyLiRub2RlWzBdLmlkICsgJ190YWJsZScgfSkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAndGl0bGU9XCInICsgc2V0dGluZ3MubGFiZWxNb250aFNlbGVjdCArICdcIidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hdGVyaWFsaXplIG1vZGlmaWVkXG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUgPT0gXCJzaG9ydF9tb250aHNcIilcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRPYmplY3QgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5ub2RlKCAnZGl2JywgbW9udGhzQ29sbGVjdGlvblsgc2VsZWN0ZWRPYmplY3QubW9udGggXSApO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIF8ubm9kZSggJ2RpdicsIG1vbnRoc0NvbGxlY3Rpb25bIHZpZXdzZXRPYmplY3QubW9udGggXSApO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgbmVlZCBmb3IgYSBtb250aCBzZWxlY3RvclxuICAgICAgICAgICAgcmV0dXJuIF8ubm9kZSggJ2RpdicsIG1vbnRoc0NvbGxlY3Rpb25bIHZpZXdzZXRPYmplY3QubW9udGggXSwgc2V0dGluZ3Mua2xhc3MubW9udGggKVxuICAgICAgICB9LCAvL2NyZWF0ZU1vbnRoTGFiZWxcblxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgeWVhciBsYWJlbC5cbiAgICAgICAgLy8gTWF0ZXJpYWxpemUgbW9kaWZpZWRcbiAgICAgICAgY3JlYXRlWWVhckxhYmVsID0gZnVuY3Rpb24ob3ZlcnJpZGUpIHtcblxuICAgICAgICAgICAgdmFyIGZvY3VzZWRZZWFyID0gdmlld3NldE9iamVjdC55ZWFyLFxuXG4gICAgICAgICAgICAvLyBJZiB5ZWFycyBzZWxlY3RvciBpcyBzZXQgdG8gYSBsaXRlcmFsIFwidHJ1ZVwiLCBzZXQgaXQgdG8gNS4gT3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBkaXZpZGUgaW4gaGFsZiB0byBnZXQgaGFsZiBiZWZvcmUgYW5kIGhhbGYgYWZ0ZXIgZm9jdXNlZCB5ZWFyLlxuICAgICAgICAgICAgbnVtYmVyWWVhcnMgPSBzZXR0aW5ncy5zZWxlY3RZZWFycyA9PT0gdHJ1ZSA/IDUgOiB+figgc2V0dGluZ3Muc2VsZWN0WWVhcnMgLyAyIClcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHllYXJzIHRvIHNlbGVjdCwgYWRkIGEgZHJvcGRvd24gbWVudS5cbiAgICAgICAgICAgIGlmICggbnVtYmVyWWVhcnMgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbWluWWVhciA9IG1pbkxpbWl0T2JqZWN0LnllYXIsXG4gICAgICAgICAgICAgICAgICAgIG1heFllYXIgPSBtYXhMaW1pdE9iamVjdC55ZWFyLFxuICAgICAgICAgICAgICAgICAgICBsb3dlc3RZZWFyID0gZm9jdXNlZFllYXIgLSBudW1iZXJZZWFycyxcbiAgICAgICAgICAgICAgICAgICAgaGlnaGVzdFllYXIgPSBmb2N1c2VkWWVhciArIG51bWJlclllYXJzXG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbWluIHllYXIgaXMgZ3JlYXRlciB0aGFuIHRoZSBsb3dlc3QgeWVhciwgaW5jcmVhc2UgdGhlIGhpZ2hlc3QgeWVhclxuICAgICAgICAgICAgICAgIC8vIGJ5IHRoZSBkaWZmZXJlbmNlIGFuZCBzZXQgdGhlIGxvd2VzdCB5ZWFyIHRvIHRoZSBtaW4geWVhci5cbiAgICAgICAgICAgICAgICBpZiAoIG1pblllYXIgPiBsb3dlc3RZZWFyICkge1xuICAgICAgICAgICAgICAgICAgICBoaWdoZXN0WWVhciArPSBtaW5ZZWFyIC0gbG93ZXN0WWVhclxuICAgICAgICAgICAgICAgICAgICBsb3dlc3RZZWFyID0gbWluWWVhclxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBtYXggeWVhciBpcyBsZXNzIHRoYW4gdGhlIGhpZ2hlc3QgeWVhciwgZGVjcmVhc2UgdGhlIGxvd2VzdCB5ZWFyXG4gICAgICAgICAgICAgICAgLy8gYnkgdGhlIGxvd2VyIG9mIHRoZSB0d286IGF2YWlsYWJsZSBhbmQgbmVlZGVkIHllYXJzLiBUaGVuIHNldCB0aGVcbiAgICAgICAgICAgICAgICAvLyBoaWdoZXN0IHllYXIgdG8gdGhlIG1heCB5ZWFyLlxuICAgICAgICAgICAgICAgIGlmICggbWF4WWVhciA8IGhpZ2hlc3RZZWFyICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGVZZWFycyA9IGxvd2VzdFllYXIgLSBtaW5ZZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZGVkWWVhcnMgPSBoaWdoZXN0WWVhciAtIG1heFllYXJcblxuICAgICAgICAgICAgICAgICAgICBsb3dlc3RZZWFyIC09IGF2YWlsYWJsZVllYXJzID4gbmVlZGVkWWVhcnMgPyBuZWVkZWRZZWFycyA6IGF2YWlsYWJsZVllYXJzXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RZZWFyID0gbWF4WWVhclxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggc2V0dGluZ3Muc2VsZWN0WWVhcnMgICYmIG92ZXJyaWRlID09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubm9kZSggJ3NlbGVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmdyb3VwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IGxvd2VzdFllYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBoaWdoZXN0WWVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGZ1bmN0aW9uKCBsb29wZWRZZWFyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbG9vcGVkIHllYXIgYW5kIG5vIGNsYXNzZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wZWRZZWFyLCAwLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlIGFuZCBzZWxlY3RlZCBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZT0nICsgbG9vcGVkWWVhciArICggZm9jdXNlZFllYXIgPT0gbG9vcGVkWWVhciA/ICcgc2VsZWN0ZWQnIDogJycgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5rbGFzcy5zZWxlY3RZZWFyICsgJyBicm93c2VyLWRlZmF1bHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgKCBpc09wZW4gPyAnJyA6ICdkaXNhYmxlZCcgKSArICcgJyArIF8uYXJpYUF0dHIoeyBjb250cm9sczogY2FsZW5kYXIuJG5vZGVbMF0uaWQgKyAnX3RhYmxlJyB9KSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAndGl0bGU9XCInICsgc2V0dGluZ3MubGFiZWxZZWFyU2VsZWN0ICsgJ1wiJ1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYXRlcmlhbGl6ZSBtb2RpZmllZFxuICAgICAgICAgICAgaWYgKG92ZXJyaWRlID09IFwicmF3XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubm9kZSggJ2RpdicsIGZvY3VzZWRZZWFyIClcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSB5ZWFyIGZvY3VzZWRcbiAgICAgICAgICAgIHJldHVybiBfLm5vZGUoICdkaXYnLCBmb2N1c2VkWWVhciwgc2V0dGluZ3Mua2xhc3MueWVhciApXG4gICAgICAgIH0gLy9jcmVhdGVZZWFyTGFiZWxcblxuXG4gICAgICAgIC8vIE1hdGVyaWFsaXplIG1vZGlmaWVkXG4gICAgICAgIGNyZWF0ZURheUxhYmVsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkT2JqZWN0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm5vZGUoICdkaXYnLCBzZWxlY3RlZE9iamVjdC5kYXRlKVxuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIF8ubm9kZSggJ2RpdicsIG5vd09iamVjdC5kYXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICBjcmVhdGVXZWVrZGF5TGFiZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5X2RheTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkT2JqZWN0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZGlzcGxheV9kYXkgPSBzZWxlY3RlZE9iamVjdC5kYXk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGlzcGxheV9kYXkgPSBub3dPYmplY3QuZGF5O1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBzZXR0aW5ncy53ZWVrZGF5c0Z1bGxbIGRpc3BsYXlfZGF5IF1cbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5XG4gICAgICAgIH1cblxuXG4gICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gdGhlIGVudGlyZSBjYWxlbmRhci5cbnJldHVybiBfLm5vZGUoXG4gICAgICAgIC8vIERhdGUgcHJlc2VudGF0aW9uIFZpZXdcbiAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICBfLm5vZGUoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgY3JlYXRlV2Vla2RheUxhYmVsKCksXG4gICAgICAgICAgICAgICAgXCJwaWNrZXJfX3dlZWtkYXktZGlzcGxheVwiXG4gICAgICAgICAgICApK1xuICAgICAgICAgICAgXy5ub2RlKFxuICAgICAgICAgICAgICAgIC8vIERpdiBmb3Igc2hvcnQgTW9udGhcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICBjcmVhdGVNb250aExhYmVsKFwic2hvcnRfbW9udGhzXCIpLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmtsYXNzLm1vbnRoX2Rpc3BsYXlcbiAgICAgICAgICAgICkrXG4gICAgICAgICAgICBfLm5vZGUoXG4gICAgICAgICAgICAgICAgLy8gRGl2IGZvciBEYXlcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICBjcmVhdGVEYXlMYWJlbCgpICxcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5rbGFzcy5kYXlfZGlzcGxheVxuICAgICAgICAgICAgKStcbiAgICAgICAgICAgIF8ubm9kZShcbiAgICAgICAgICAgICAgICAvLyBEaXYgZm9yIFllYXJcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICBjcmVhdGVZZWFyTGFiZWwoXCJyYXdcIikgLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmtsYXNzLnllYXJfZGlzcGxheVxuICAgICAgICAgICAgKSxcbiAgICAgICAgc2V0dGluZ3Mua2xhc3MuZGF0ZV9kaXNwbGF5XG4gICAgKStcbiAgICAvLyBDYWxlbmRhciBjb250YWluZXJcbiAgICBfLm5vZGUoJ2RpdicsXG4gICAgICAgIF8ubm9kZSgnZGl2JyxcbiAgICAgICAgKCBzZXR0aW5ncy5zZWxlY3RZZWFycyA/ICBjcmVhdGVNb250aExhYmVsKCkgKyBjcmVhdGVZZWFyTGFiZWwoKSA6IGNyZWF0ZU1vbnRoTGFiZWwoKSArIGNyZWF0ZVllYXJMYWJlbCgpICkgK1xuICAgICAgICBjcmVhdGVNb250aE5hdigpICsgY3JlYXRlTW9udGhOYXYoIDEgKSxcbiAgICAgICAgc2V0dGluZ3Mua2xhc3MuaGVhZGVyXG4gICAgKSArIF8ubm9kZShcbiAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgdGFibGVIZWFkICtcbiAgICAgICAgXy5ub2RlKFxuICAgICAgICAgICAgJ3Rib2R5JyxcbiAgICAgICAgICAgIF8uZ3JvdXAoe1xuICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICBtYXg6IFdFRUtTX0lOX0NBTEVOREFSIC0gMSxcbiAgICAgICAgICAgICAgICBpOiAxLFxuICAgICAgICAgICAgICAgIG5vZGU6ICd0cicsXG4gICAgICAgICAgICAgICAgaXRlbTogZnVuY3Rpb24oIHJvd0NvdW50ZXIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgYW5kIHRoZSBtb250aCBzdGFydHMgb24gU3VuZGF5LCBzaGlmdCB0aGUgZGF0ZSBiYWNrIGEgd2Vlay5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNoaWZ0RGF0ZUJ5ID0gc2V0dGluZ3MuZmlyc3REYXkgJiYgY2FsZW5kYXIuY3JlYXRlKFsgdmlld3NldE9iamVjdC55ZWFyLCB2aWV3c2V0T2JqZWN0Lm1vbnRoLCAxIF0pLmRheSA9PT0gMCA/IC03IDogMFxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmdyb3VwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IERBWVNfSU5fV0VFSyAqIHJvd0NvdW50ZXIgLSB2aWV3c2V0T2JqZWN0LmRheSArIHNoaWZ0RGF0ZUJ5ICsgMSwgLy8gQWRkIDEgZm9yIHdlZWtkYXkgMGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluICsgREFZU19JTl9XRUVLIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiAndGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGZ1bmN0aW9uKCB0YXJnZXREYXRlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHRpbWUgZGF0ZSBmcm9tIGEgcmVsYXRpdmUgZGF0ZSB0byBhIHRhcmdldCBkYXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXREYXRlID0gY2FsZW5kYXIuY3JlYXRlKFsgdmlld3NldE9iamVjdC55ZWFyLCB2aWV3c2V0T2JqZWN0Lm1vbnRoLCB0YXJnZXREYXRlICsgKCBzZXR0aW5ncy5maXJzdERheSA/IDEgOiAwICkgXSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IHNlbGVjdGVkT2JqZWN0ICYmIHNlbGVjdGVkT2JqZWN0LnBpY2sgPT0gdGFyZ2V0RGF0ZS5waWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNIaWdobGlnaHRlZCA9IGhpZ2hsaWdodGVkT2JqZWN0ICYmIGhpZ2hsaWdodGVkT2JqZWN0LnBpY2sgPT0gdGFyZ2V0RGF0ZS5waWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEaXNhYmxlZCA9IGRpc2FibGVkQ29sbGVjdGlvbiAmJiBjYWxlbmRhci5kaXNhYmxlZCggdGFyZ2V0RGF0ZSApIHx8IHRhcmdldERhdGUucGljayA8IG1pbkxpbWl0T2JqZWN0LnBpY2sgfHwgdGFyZ2V0RGF0ZS5waWNrID4gbWF4TGltaXRPYmplY3QucGljayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZERhdGUgPSBfLnRyaWdnZXIoIGNhbGVuZGFyLmZvcm1hdHMudG9TdHJpbmcsIGNhbGVuZGFyLCBbIHNldHRpbmdzLmZvcm1hdCwgdGFyZ2V0RGF0ZSBdIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5ub2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGUuZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oIGtsYXNzZXMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBgaW5mb2N1c2Agb3IgYG91dGZvY3VzYCBjbGFzc2VzIGJhc2VkIG9uIG1vbnRoIGluIHZpZXcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtsYXNzZXMucHVzaCggdmlld3NldE9iamVjdC5tb250aCA9PSB0YXJnZXREYXRlLm1vbnRoID8gc2V0dGluZ3Mua2xhc3MuaW5mb2N1cyA6IHNldHRpbmdzLmtsYXNzLm91dGZvY3VzIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGB0b2RheWAgY2xhc3MgaWYgbmVlZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vd09iamVjdC5waWNrID09IHRhcmdldERhdGUucGljayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtsYXNzZXMucHVzaCggc2V0dGluZ3Mua2xhc3Mubm93IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgYHNlbGVjdGVkYCBjbGFzcyBpZiBzb21ldGhpbmcncyBzZWxlY3RlZCBhbmQgdGhlIHRpbWUgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1NlbGVjdGVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2xhc3Nlcy5wdXNoKCBzZXR0aW5ncy5rbGFzcy5zZWxlY3RlZCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGBoaWdobGlnaHRlZGAgY2xhc3MgaWYgc29tZXRoaW5nJ3MgaGlnaGxpZ2h0ZWQgYW5kIHRoZSB0aW1lIG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNIaWdobGlnaHRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtsYXNzZXMucHVzaCggc2V0dGluZ3Mua2xhc3MuaGlnaGxpZ2h0ZWQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBgZGlzYWJsZWRgIGNsYXNzIGlmIHNvbWV0aGluZydzIGRpc2FibGVkIGFuZCB0aGUgb2JqZWN0IG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNEaXNhYmxlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtsYXNzZXMucHVzaCggc2V0dGluZ3Mua2xhc3MuZGlzYWJsZWQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtsYXNzZXMuam9pbiggJyAnIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KShbIHNldHRpbmdzLmtsYXNzLmRheSBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1waWNrPScgKyB0YXJnZXREYXRlLnBpY2sgKyAnICcgKyBfLmFyaWFBdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2dyaWRjZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZvcm1hdHRlZERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBpc1NlbGVjdGVkICYmIGNhbGVuZGFyLiRub2RlLnZhbCgpID09PSBmb3JtYXR0ZWREYXRlID8gdHJ1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZWRlc2NlbmRhbnQ6IGlzSGlnaGxpZ2h0ZWQgPyB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGlzRGlzYWJsZWQgPyB0cnVlIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmFyaWFBdHRyKHsgcm9sZTogJ3ByZXNlbnRhdGlvbicgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSAvL2VuZHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIF0gLy9lbmRyZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICBzZXR0aW5ncy5rbGFzcy50YWJsZSxcbiAgICAgICAgJ2lkPVwiJyArIGNhbGVuZGFyLiRub2RlWzBdLmlkICsgJ190YWJsZScgKyAnXCIgJyArIF8uYXJpYUF0dHIoe1xuICAgICAgICAgICAgcm9sZTogJ2dyaWQnLFxuICAgICAgICAgICAgY29udHJvbHM6IGNhbGVuZGFyLiRub2RlWzBdLmlkLFxuICAgICAgICAgICAgcmVhZG9ubHk6IHRydWVcbiAgICAgICAgfSlcbiAgICApXG4gICAgLCBzZXR0aW5ncy5rbGFzcy5jYWxlbmRhcl9jb250YWluZXIpIC8vIGVuZCBjYWxlbmRhclxuXG4gICAgICtcblxuICAgIC8vICogRm9yIEZpcmVmb3ggZm9ybXMgdG8gc3VibWl0LCBtYWtlIHN1cmUgdG8gc2V0IHRoZSBidXR0b25z4oCZIGB0eXBlYCBhdHRyaWJ1dGVzIGFzIOKAnGJ1dHRvbuKAnS5cbiAgICBfLm5vZGUoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBfLm5vZGUoICdidXR0b24nLCBzZXR0aW5ncy50b2RheSwgXCJidG4tZmxhdCBwaWNrZXJfX3RvZGF5XCIsXG4gICAgICAgICAgICAndHlwZT1idXR0b24gZGF0YS1waWNrPScgKyBub3dPYmplY3QucGljayArXG4gICAgICAgICAgICAoIGlzT3BlbiAmJiAhY2FsZW5kYXIuZGlzYWJsZWQobm93T2JqZWN0KSA/ICcnIDogJyBkaXNhYmxlZCcgKSArICcgJyArXG4gICAgICAgICAgICBfLmFyaWFBdHRyKHsgY29udHJvbHM6IGNhbGVuZGFyLiRub2RlWzBdLmlkIH0pICkgK1xuICAgICAgICBfLm5vZGUoICdidXR0b24nLCBzZXR0aW5ncy5jbGVhciwgXCJidG4tZmxhdCBwaWNrZXJfX2NsZWFyXCIsXG4gICAgICAgICAgICAndHlwZT1idXR0b24gZGF0YS1jbGVhcj0xJyArXG4gICAgICAgICAgICAoIGlzT3BlbiA/ICcnIDogJyBkaXNhYmxlZCcgKSArICcgJyArXG4gICAgICAgICAgICBfLmFyaWFBdHRyKHsgY29udHJvbHM6IGNhbGVuZGFyLiRub2RlWzBdLmlkIH0pICkgK1xuICAgICAgICBfLm5vZGUoJ2J1dHRvbicsIHNldHRpbmdzLmNsb3NlLCBcImJ0bi1mbGF0IHBpY2tlcl9fY2xvc2VcIixcbiAgICAgICAgICAgICd0eXBlPWJ1dHRvbiBkYXRhLWNsb3NlPXRydWUgJyArXG4gICAgICAgICAgICAoIGlzT3BlbiA/ICcnIDogJyBkaXNhYmxlZCcgKSArICcgJyArXG4gICAgICAgICAgICBfLmFyaWFBdHRyKHsgY29udHJvbHM6IGNhbGVuZGFyLiRub2RlWzBdLmlkIH0pICksXG4gICAgICAgIHNldHRpbmdzLmtsYXNzLmZvb3RlclxuICAgICkgLy9lbmRyZXR1cm5cbn0gLy9EYXRlUGlja2VyLnByb3RvdHlwZS5ub2Rlc1xuXG5cblxuXG4vKipcbiAqIFRoZSBkYXRlIHBpY2tlciBkZWZhdWx0cy5cbiAqL1xuRGF0ZVBpY2tlci5kZWZhdWx0cyA9IChmdW5jdGlvbiggcHJlZml4ICkge1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgICAvLyBUaGUgdGl0bGUgbGFiZWwgdG8gdXNlIGZvciB0aGUgbW9udGggbmF2IGJ1dHRvbnNcbiAgICAgICAgbGFiZWxNb250aE5leHQ6ICdOZXh0IG1vbnRoJyxcbiAgICAgICAgbGFiZWxNb250aFByZXY6ICdQcmV2aW91cyBtb250aCcsXG5cbiAgICAgICAgLy8gVGhlIHRpdGxlIGxhYmVsIHRvIHVzZSBmb3IgdGhlIGRyb3Bkb3duIHNlbGVjdG9yc1xuICAgICAgICBsYWJlbE1vbnRoU2VsZWN0OiAnU2VsZWN0IGEgbW9udGgnLFxuICAgICAgICBsYWJlbFllYXJTZWxlY3Q6ICdTZWxlY3QgYSB5ZWFyJyxcblxuICAgICAgICAvLyBNb250aHMgYW5kIHdlZWtkYXlzXG4gICAgICAgIG1vbnRoc0Z1bGw6IFsgJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInIF0sXG4gICAgICAgIG1vbnRoc1Nob3J0OiBbICdKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYycgXSxcbiAgICAgICAgd2Vla2RheXNGdWxsOiBbICdTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheScgXSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogWyAnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0JyBdLFxuXG4gICAgICAgIC8vIE1hdGVyaWFsaXplIG1vZGlmaWVkXG4gICAgICAgIHdlZWtkYXlzTGV0dGVyOiBbICdTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJyBdLFxuXG4gICAgICAgIC8vIFRvZGF5IGFuZCBjbGVhclxuICAgICAgICB0b2RheTogJ1RvZGF5JyxcbiAgICAgICAgY2xlYXI6ICdDbGVhcicsXG4gICAgICAgIGNsb3NlOiAnQ2xvc2UnLFxuXG4gICAgICAgIC8vIFRoZSBmb3JtYXQgdG8gc2hvdyBvbiB0aGUgYGlucHV0YCBlbGVtZW50XG4gICAgICAgIGZvcm1hdDogJ2QgbW1tbSwgeXl5eScsXG5cbiAgICAgICAgLy8gQ2xhc3Nlc1xuICAgICAgICBrbGFzczoge1xuXG4gICAgICAgICAgICB0YWJsZTogcHJlZml4ICsgJ3RhYmxlJyxcblxuICAgICAgICAgICAgaGVhZGVyOiBwcmVmaXggKyAnaGVhZGVyJyxcblxuXG4gICAgICAgICAgICAvLyBNYXRlcmlhbGl6ZSBBZGRlZCBrbGFzc2VzXG4gICAgICAgICAgICBkYXRlX2Rpc3BsYXk6IHByZWZpeCArICdkYXRlLWRpc3BsYXknLFxuICAgICAgICAgICAgZGF5X2Rpc3BsYXk6IHByZWZpeCArICdkYXktZGlzcGxheScsXG4gICAgICAgICAgICBtb250aF9kaXNwbGF5OiBwcmVmaXggKyAnbW9udGgtZGlzcGxheScsXG4gICAgICAgICAgICB5ZWFyX2Rpc3BsYXk6IHByZWZpeCArICd5ZWFyLWRpc3BsYXknLFxuICAgICAgICAgICAgY2FsZW5kYXJfY29udGFpbmVyOiBwcmVmaXggKyAnY2FsZW5kYXItY29udGFpbmVyJyxcbiAgICAgICAgICAgIC8vIGVuZFxuXG5cblxuICAgICAgICAgICAgbmF2UHJldjogcHJlZml4ICsgJ25hdi0tcHJldicsXG4gICAgICAgICAgICBuYXZOZXh0OiBwcmVmaXggKyAnbmF2LS1uZXh0JyxcbiAgICAgICAgICAgIG5hdkRpc2FibGVkOiBwcmVmaXggKyAnbmF2LS1kaXNhYmxlZCcsXG5cbiAgICAgICAgICAgIG1vbnRoOiBwcmVmaXggKyAnbW9udGgnLFxuICAgICAgICAgICAgeWVhcjogcHJlZml4ICsgJ3llYXInLFxuXG4gICAgICAgICAgICBzZWxlY3RNb250aDogcHJlZml4ICsgJ3NlbGVjdC0tbW9udGgnLFxuICAgICAgICAgICAgc2VsZWN0WWVhcjogcHJlZml4ICsgJ3NlbGVjdC0teWVhcicsXG5cbiAgICAgICAgICAgIHdlZWtkYXlzOiBwcmVmaXggKyAnd2Vla2RheScsXG5cbiAgICAgICAgICAgIGRheTogcHJlZml4ICsgJ2RheScsXG4gICAgICAgICAgICBkaXNhYmxlZDogcHJlZml4ICsgJ2RheS0tZGlzYWJsZWQnLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHByZWZpeCArICdkYXktLXNlbGVjdGVkJyxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkOiBwcmVmaXggKyAnZGF5LS1oaWdobGlnaHRlZCcsXG4gICAgICAgICAgICBub3c6IHByZWZpeCArICdkYXktLXRvZGF5JyxcbiAgICAgICAgICAgIGluZm9jdXM6IHByZWZpeCArICdkYXktLWluZm9jdXMnLFxuICAgICAgICAgICAgb3V0Zm9jdXM6IHByZWZpeCArICdkYXktLW91dGZvY3VzJyxcblxuICAgICAgICAgICAgZm9vdGVyOiBwcmVmaXggKyAnZm9vdGVyJyxcblxuICAgICAgICAgICAgYnV0dG9uQ2xlYXI6IHByZWZpeCArICdidXR0b24tLWNsZWFyJyxcbiAgICAgICAgICAgIGJ1dHRvblRvZGF5OiBwcmVmaXggKyAnYnV0dG9uLS10b2RheScsXG4gICAgICAgICAgICBidXR0b25DbG9zZTogcHJlZml4ICsgJ2J1dHRvbi0tY2xvc2UnXG4gICAgICAgIH1cbiAgICB9XG59KSggUGlja2VyLmtsYXNzZXMoKS5waWNrZXIgKyAnX18nIClcblxuXG5cblxuXG4vKipcbiAqIEV4dGVuZCB0aGUgcGlja2VyIHRvIGFkZCB0aGUgZGF0ZSBwaWNrZXIuXG4gKi9cblBpY2tlci5leHRlbmQoICdwaWNrYWRhdGUnLCBEYXRlUGlja2VyIClcblxuXG59KSk7XG5cblxuOyhmdW5jdGlvbiAoJCkge1xuXG4gICQuZm4uY2hhcmFjdGVyQ291bnRlciA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyICRpbnB1dCA9ICQodGhpcyk7XG4gICAgICB2YXIgJGNvdW50ZXJFbGVtZW50ID0gJGlucHV0LnBhcmVudCgpLmZpbmQoJ3NwYW5bY2xhc3M9XCJjaGFyYWN0ZXItY291bnRlclwiXScpO1xuXG4gICAgICAvLyBjaGFyYWN0ZXIgY291bnRlciBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIGFwcGVuZGVkIHRvIHRoZSBwYXJlbnQgY29udGFpbmVyXG4gICAgICBpZiAoJGNvdW50ZXJFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdEhhc0xlbmd0aEF0dHJpYnV0ZSA9ICRpbnB1dC5hdHRyKCdkYXRhLWxlbmd0aCcpICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmKGl0SGFzTGVuZ3RoQXR0cmlidXRlKXtcbiAgICAgICAgJGlucHV0Lm9uKCdpbnB1dCcsIHVwZGF0ZUNvdW50ZXIpO1xuICAgICAgICAkaW5wdXQub24oJ2ZvY3VzJywgdXBkYXRlQ291bnRlcik7XG4gICAgICAgICRpbnB1dC5vbignYmx1cicsIHJlbW92ZUNvdW50ZXJFbGVtZW50KTtcblxuICAgICAgICBhZGRDb3VudGVyRWxlbWVudCgkaW5wdXQpO1xuICAgICAgfVxuXG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ291bnRlcigpe1xuICAgIHZhciBtYXhMZW5ndGggICAgID0gKyQodGhpcykuYXR0cignZGF0YS1sZW5ndGgnKSxcbiAgICBhY3R1YWxMZW5ndGggICAgICA9ICskKHRoaXMpLnZhbCgpLmxlbmd0aCxcbiAgICBpc1ZhbGlkTGVuZ3RoICAgICA9IGFjdHVhbExlbmd0aCA8PSBtYXhMZW5ndGg7XG5cbiAgICAkKHRoaXMpLnBhcmVudCgpLmZpbmQoJ3NwYW5bY2xhc3M9XCJjaGFyYWN0ZXItY291bnRlclwiXScpXG4gICAgICAgICAgICAgICAgICAgIC5odG1sKCBhY3R1YWxMZW5ndGggKyAnLycgKyBtYXhMZW5ndGgpO1xuXG4gICAgYWRkSW5wdXRTdHlsZShpc1ZhbGlkTGVuZ3RoLCAkKHRoaXMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENvdW50ZXJFbGVtZW50KCRpbnB1dCkge1xuICAgIHZhciAkY291bnRlckVsZW1lbnQgPSAkaW5wdXQucGFyZW50KCkuZmluZCgnc3BhbltjbGFzcz1cImNoYXJhY3Rlci1jb3VudGVyXCJdJyk7XG5cbiAgICBpZiAoJGNvdW50ZXJFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICRjb3VudGVyRWxlbWVudCA9ICQoJzxzcGFuLz4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdjaGFyYWN0ZXItY291bnRlcicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3NzKCdmbG9hdCcsJ3JpZ2h0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ2ZvbnQtc2l6ZScsJzEycHgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygnaGVpZ2h0JywgMSk7XG5cbiAgICAkaW5wdXQucGFyZW50KCkuYXBwZW5kKCRjb3VudGVyRWxlbWVudCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDb3VudGVyRWxlbWVudCgpe1xuICAgICQodGhpcykucGFyZW50KCkuZmluZCgnc3BhbltjbGFzcz1cImNoYXJhY3Rlci1jb3VudGVyXCJdJykuaHRtbCgnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRJbnB1dFN0eWxlKGlzVmFsaWRMZW5ndGgsICRpbnB1dCl7XG4gICAgdmFyIGlucHV0SGFzSW52YWxpZENsYXNzID0gJGlucHV0Lmhhc0NsYXNzKCdpbnZhbGlkJyk7XG4gICAgaWYgKGlzVmFsaWRMZW5ndGggJiYgaW5wdXRIYXNJbnZhbGlkQ2xhc3MpIHtcbiAgICAgICRpbnB1dC5yZW1vdmVDbGFzcygnaW52YWxpZCcpO1xuICAgIH1cbiAgICBlbHNlIGlmKCFpc1ZhbGlkTGVuZ3RoICYmICFpbnB1dEhhc0ludmFsaWRDbGFzcyl7XG4gICAgICAkaW5wdXQucmVtb3ZlQ2xhc3MoJ3ZhbGlkJyk7XG4gICAgICAkaW5wdXQuYWRkQ2xhc3MoJ2ludmFsaWQnKTtcbiAgICB9XG4gIH1cblxuICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuICAgICQoJ2lucHV0LCB0ZXh0YXJlYScpLmNoYXJhY3RlckNvdW50ZXIoKTtcbiAgfSk7XG5cbn0oIGpRdWVyeSApKTtcbjsoZnVuY3Rpb24gKCQpIHtcblxuICB2YXIgbWV0aG9kcyA9IHtcblxuICAgIGluaXQgOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIGR1cmF0aW9uOiAyMDAsIC8vIG1zXG4gICAgICAgIGRpc3Q6IC0xMDAsIC8vIHpvb20gc2NhbGUgVE9ETzogbWFrZSB0aGlzIG1vcmUgaW50dWl0aXZlIGFzIGFuIG9wdGlvblxuICAgICAgICBzaGlmdDogMCwgLy8gc3BhY2luZyBmb3IgY2VudGVyIGltYWdlXG4gICAgICAgIHBhZGRpbmc6IDAsIC8vIFBhZGRpbmcgYmV0d2VlbiBub24gY2VudGVyIGl0ZW1zXG4gICAgICAgIGZ1bGxXaWR0aDogZmFsc2UsIC8vIENoYW5nZSB0byBmdWxsIHdpZHRoIHN0eWxlc1xuICAgICAgICBpbmRpY2F0b3JzOiBmYWxzZSwgLy8gVG9nZ2xlIGluZGljYXRvcnNcbiAgICAgICAgbm9XcmFwOiBmYWxzZSwgLy8gRG9uJ3Qgd3JhcCBhcm91bmQgYW5kIGN5Y2xlIHRocm91Z2ggaXRlbXMuXG4gICAgICAgIG9uQ3ljbGVUbzogbnVsbCAvLyBDYWxsYmFjayBmb3Igd2hlbiBhIG5ldyBzbGlkZSBpcyBjeWNsZWQgdG8uXG4gICAgICB9O1xuICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgIHZhciBuYW1lc3BhY2UgPSBNYXRlcmlhbGl6ZS5vYmplY3RTZWxlY3RvclN0cmluZygkKHRoaXMpKTtcblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cbiAgICAgICAgdmFyIHVuaXF1ZU5hbWVzcGFjZSA9IG5hbWVzcGFjZStpO1xuICAgICAgICB2YXIgaW1hZ2VzLCBpdGVtX3dpZHRoLCBpdGVtX2hlaWdodCwgb2Zmc2V0LCBjZW50ZXIsIHByZXNzZWQsIGRpbSwgY291bnQsXG4gICAgICAgICAgICByZWZlcmVuY2UsIHJlZmVyZW5jZVksIGFtcGxpdHVkZSwgdGFyZ2V0LCB2ZWxvY2l0eSwgc2Nyb2xsaW5nLFxuICAgICAgICAgICAgeGZvcm0sIGZyYW1lLCB0aW1lc3RhbXAsIHRpY2tlciwgZHJhZ2dlZCwgdmVydGljYWxfZHJhZ2dlZDtcbiAgICAgICAgdmFyICRpbmRpY2F0b3JzID0gJCgnPHVsIGNsYXNzPVwiaW5kaWNhdG9yc1wiPjwvdWw+Jyk7XG4gICAgICAgIHZhciBzY3JvbGxpbmdUaW1lb3V0ID0gbnVsbDtcblxuXG4gICAgICAgIC8vIEluaXRpYWxpemVcbiAgICAgICAgdmFyIHZpZXcgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgc2hvd0luZGljYXRvcnMgPSB2aWV3LmF0dHIoJ2RhdGEtaW5kaWNhdG9ycycpIHx8IG9wdGlvbnMuaW5kaWNhdG9ycztcblxuXG4gICAgICAgIC8vIE9wdGlvbnNcbiAgICAgICAgdmFyIHNldENhcm91c2VsSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGZpcnN0SW1hZ2UgPSB2aWV3LmZpbmQoJy5jYXJvdXNlbC1pdGVtIGltZycpLmZpcnN0KCk7XG4gICAgICAgICAgaWYgKGZpcnN0SW1hZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RJbWFnZS5wcm9wKCdjb21wbGV0ZScpKSB7XG4gICAgICAgICAgICAgIHZpZXcuY3NzKCdoZWlnaHQnLCBmaXJzdEltYWdlLmhlaWdodCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpcnN0SW1hZ2Uub24oJ2xvYWQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZpZXcuY3NzKCdoZWlnaHQnLCAkKHRoaXMpLmhlaWdodCgpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbWFnZUhlaWdodCA9IHZpZXcuZmluZCgnLmNhcm91c2VsLWl0ZW0nKS5maXJzdCgpLmhlaWdodCgpO1xuICAgICAgICAgICAgdmlldy5jc3MoJ2hlaWdodCcsIGltYWdlSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZnVsbFdpZHRoKSB7XG4gICAgICAgICAgb3B0aW9ucy5kaXN0ID0gMDtcbiAgICAgICAgICBzZXRDYXJvdXNlbEhlaWdodCgpO1xuXG4gICAgICAgICAgLy8gT2Zmc2V0IGZpeGVkIGl0ZW1zIHdoZW4gaW5kaWNhdG9ycy5cbiAgICAgICAgICBpZiAoc2hvd0luZGljYXRvcnMpIHtcbiAgICAgICAgICAgIHZpZXcuZmluZCgnLmNhcm91c2VsLWZpeGVkLWl0ZW0nKS5hZGRDbGFzcygnd2l0aC1pbmRpY2F0b3JzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBEb24ndCBkb3VibGUgaW5pdGlhbGl6ZS5cbiAgICAgICAgaWYgKHZpZXcuaGFzQ2xhc3MoJ2luaXRpYWxpemVkJykpIHtcbiAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSB2YXJpYWJsZXNcbiAgICAgICAgICAkKHdpbmRvdykudHJpZ2dlcigncmVzaXplJyk7XG5cbiAgICAgICAgICAvLyBSZWRyYXcgY2Fyb3VzZWwuXG4gICAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjYXJvdXNlbE5leHQnLCBbMC4wMDAwMDFdKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmlldy5hZGRDbGFzcygnaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgcHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICBvZmZzZXQgPSB0YXJnZXQgPSAwO1xuICAgICAgICBpbWFnZXMgPSBbXTtcbiAgICAgICAgaXRlbV93aWR0aCA9IHZpZXcuZmluZCgnLmNhcm91c2VsLWl0ZW0nKS5maXJzdCgpLmlubmVyV2lkdGgoKTtcbiAgICAgICAgaXRlbV9oZWlnaHQgPSB2aWV3LmZpbmQoJy5jYXJvdXNlbC1pdGVtJykuZmlyc3QoKS5pbm5lckhlaWdodCgpO1xuICAgICAgICBkaW0gPSBpdGVtX3dpZHRoICogMiArIG9wdGlvbnMucGFkZGluZztcblxuICAgICAgICB2aWV3LmZpbmQoJy5jYXJvdXNlbC1pdGVtJykuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIGltYWdlcy5wdXNoKCQodGhpcylbMF0pO1xuICAgICAgICAgIGlmIChzaG93SW5kaWNhdG9ycykge1xuICAgICAgICAgICAgdmFyICRpbmRpY2F0b3IgPSAkKCc8bGkgY2xhc3M9XCJpbmRpY2F0b3ItaXRlbVwiPjwvbGk+Jyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhY3RpdmUgdG8gZmlyc3QgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICRpbmRpY2F0b3IuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2tzIG9uIGluZGljYXRvcnMuXG4gICAgICAgICAgICAkaW5kaWNhdG9yLmNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gJCh0aGlzKS5pbmRleCgpO1xuICAgICAgICAgICAgICBjeWNsZVRvKGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJGluZGljYXRvcnMuYXBwZW5kKCRpbmRpY2F0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNob3dJbmRpY2F0b3JzKSB7XG4gICAgICAgICAgdmlldy5hcHBlbmQoJGluZGljYXRvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ID0gaW1hZ2VzLmxlbmd0aDtcblxuXG4gICAgICAgIGZ1bmN0aW9uIHNldHVwRXZlbnRzKCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZpZXdbMF0uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRhcCk7XG4gICAgICAgICAgICB2aWV3WzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGRyYWcpO1xuICAgICAgICAgICAgdmlld1swXS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHJlbGVhc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2aWV3WzBdLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRhcCk7XG4gICAgICAgICAgdmlld1swXS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgICAgICB2aWV3WzBdLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCByZWxlYXNlKTtcbiAgICAgICAgICB2aWV3WzBdLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZWxlYXNlKTtcbiAgICAgICAgICB2aWV3WzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24geHBvcyhlKSB7XG4gICAgICAgICAgLy8gdG91Y2ggZXZlbnRcbiAgICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoID49IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbW91c2UgZXZlbnRcbiAgICAgICAgICByZXR1cm4gZS5jbGllbnRYO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24geXBvcyhlKSB7XG4gICAgICAgICAgLy8gdG91Y2ggZXZlbnRcbiAgICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoID49IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbW91c2UgZXZlbnRcbiAgICAgICAgICByZXR1cm4gZS5jbGllbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd3JhcCh4KSB7XG4gICAgICAgICAgcmV0dXJuICh4ID49IGNvdW50KSA/ICh4ICUgY291bnQpIDogKHggPCAwKSA/IHdyYXAoY291bnQgKyAoeCAlIGNvdW50KSkgOiB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2Nyb2xsKHgpIHtcbiAgICAgICAgICAvLyBUcmFjayBzY3JvbGxpbmcgc3RhdGVcbiAgICAgICAgICBzY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgIGlmICghdmlldy5oYXNDbGFzcygnc2Nyb2xsaW5nJykpIHtcbiAgICAgICAgICAgIHZpZXcuYWRkQ2xhc3MoJ3Njcm9sbGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Nyb2xsaW5nVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHNjcm9sbGluZ1RpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGxpbmdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZpZXcucmVtb3ZlQ2xhc3MoJ3Njcm9sbGluZycpO1xuICAgICAgICAgIH0sIG9wdGlvbnMuZHVyYXRpb24pO1xuXG4gICAgICAgICAgLy8gU3RhcnQgYWN0dWFsIHNjcm9sbFxuICAgICAgICAgIHZhciBpLCBoYWxmLCBkZWx0YSwgZGlyLCB0d2VlbiwgZWwsIGFsaWdubWVudCwgeFRyYW5zbGF0aW9uO1xuICAgICAgICAgIHZhciBsYXN0Q2VudGVyID0gY2VudGVyO1xuXG4gICAgICAgICAgb2Zmc2V0ID0gKHR5cGVvZiB4ID09PSAnbnVtYmVyJykgPyB4IDogb2Zmc2V0O1xuICAgICAgICAgIGNlbnRlciA9IE1hdGguZmxvb3IoKG9mZnNldCArIGRpbSAvIDIpIC8gZGltKTtcbiAgICAgICAgICBkZWx0YSA9IG9mZnNldCAtIGNlbnRlciAqIGRpbTtcbiAgICAgICAgICBkaXIgPSAoZGVsdGEgPCAwKSA/IDEgOiAtMTtcbiAgICAgICAgICB0d2VlbiA9IC1kaXIgKiBkZWx0YSAqIDIgLyBkaW07XG4gICAgICAgICAgaGFsZiA9IGNvdW50ID4+IDE7XG5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMuZnVsbFdpZHRoKSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSAndHJhbnNsYXRlWCgnICsgKHZpZXdbMF0uY2xpZW50V2lkdGggLSBpdGVtX3dpZHRoKSAvIDIgKyAncHgpICc7XG4gICAgICAgICAgICBhbGlnbm1lbnQgKz0gJ3RyYW5zbGF0ZVkoJyArICh2aWV3WzBdLmNsaWVudEhlaWdodCAtIGl0ZW1faGVpZ2h0KSAvIDIgKyAncHgpJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gJ3RyYW5zbGF0ZVgoMCknO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCBpbmRpY2F0b3IgYWN0aXZlXG4gICAgICAgICAgaWYgKHNob3dJbmRpY2F0b3JzKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IChjZW50ZXIgJSBjb3VudCk7XG4gICAgICAgICAgICB2YXIgYWN0aXZlSW5kaWNhdG9yID0gJGluZGljYXRvcnMuZmluZCgnLmluZGljYXRvci1pdGVtLmFjdGl2ZScpO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZUluZGljYXRvci5pbmRleCgpICE9PSBkaWZmKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZUluZGljYXRvci5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICRpbmRpY2F0b3JzLmZpbmQoJy5pbmRpY2F0b3ItaXRlbScpLmVxKGRpZmYpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjZW50ZXJcbiAgICAgICAgICAvLyBEb24ndCBzaG93IHdyYXBwZWQgaXRlbXMuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLm5vV3JhcCB8fCAoY2VudGVyID49IDAgJiYgY2VudGVyIDwgY291bnQpKSB7XG4gICAgICAgICAgICBlbCA9IGltYWdlc1t3cmFwKGNlbnRlcildO1xuXG4gICAgICAgICAgICAvLyBBZGQgYWN0aXZlIGNsYXNzIHRvIGNlbnRlciBpdGVtLlxuICAgICAgICAgICAgaWYgKCEkKGVsKS5oYXNDbGFzcygnYWN0aXZlJykpIHtcbiAgICAgICAgICAgICAgdmlldy5maW5kKCcuY2Fyb3VzZWwtaXRlbScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgJChlbCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuc3R5bGVbeGZvcm1dID0gYWxpZ25tZW50ICtcbiAgICAgICAgICAgICAgJyB0cmFuc2xhdGVYKCcgKyAoLWRlbHRhIC8gMikgKyAncHgpJyArXG4gICAgICAgICAgICAgICcgdHJhbnNsYXRlWCgnICsgKGRpciAqIG9wdGlvbnMuc2hpZnQgKiB0d2VlbiAqIGkpICsgJ3B4KScgK1xuICAgICAgICAgICAgICAnIHRyYW5zbGF0ZVooJyArIChvcHRpb25zLmRpc3QgKiB0d2VlbikgKyAncHgpJztcbiAgICAgICAgICAgIGVsLnN0eWxlLnpJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mdWxsV2lkdGgpIHsgdHdlZW5lZE9wYWNpdHkgPSAxOyB9XG4gICAgICAgICAgICBlbHNlIHsgdHdlZW5lZE9wYWNpdHkgPSAxIC0gMC4yICogdHdlZW47IH1cbiAgICAgICAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSB0d2VlbmVkT3BhY2l0eTtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gaGFsZjsgKytpKSB7XG4gICAgICAgICAgICAvLyByaWdodCBzaWRlXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mdWxsV2lkdGgpIHtcbiAgICAgICAgICAgICAgelRyYW5zbGF0aW9uID0gb3B0aW9ucy5kaXN0O1xuICAgICAgICAgICAgICB0d2VlbmVkT3BhY2l0eSA9IChpID09PSBoYWxmICYmIGRlbHRhIDwgMCkgPyAxIC0gdHdlZW4gOiAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgelRyYW5zbGF0aW9uID0gb3B0aW9ucy5kaXN0ICogKGkgKiAyICsgdHdlZW4gKiBkaXIpO1xuICAgICAgICAgICAgICB0d2VlbmVkT3BhY2l0eSA9IDEgLSAwLjIgKiAoaSAqIDIgKyB0d2VlbiAqIGRpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb24ndCBzaG93IHdyYXBwZWQgaXRlbXMuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMubm9XcmFwIHx8IGNlbnRlciArIGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICBlbCA9IGltYWdlc1t3cmFwKGNlbnRlciArIGkpXTtcbiAgICAgICAgICAgICAgZWwuc3R5bGVbeGZvcm1dID0gYWxpZ25tZW50ICtcbiAgICAgICAgICAgICAgICAnIHRyYW5zbGF0ZVgoJyArIChvcHRpb25zLnNoaWZ0ICsgKGRpbSAqIGkgLSBkZWx0YSkgLyAyKSArICdweCknICtcbiAgICAgICAgICAgICAgICAnIHRyYW5zbGF0ZVooJyArIHpUcmFuc2xhdGlvbiArICdweCknO1xuICAgICAgICAgICAgICBlbC5zdHlsZS56SW5kZXggPSAtaTtcbiAgICAgICAgICAgICAgZWwuc3R5bGUub3BhY2l0eSA9IHR3ZWVuZWRPcGFjaXR5O1xuICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBsZWZ0IHNpZGVcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZ1bGxXaWR0aCkge1xuICAgICAgICAgICAgICB6VHJhbnNsYXRpb24gPSBvcHRpb25zLmRpc3Q7XG4gICAgICAgICAgICAgIHR3ZWVuZWRPcGFjaXR5ID0gKGkgPT09IGhhbGYgJiYgZGVsdGEgPiAwKSA/IDEgLSB0d2VlbiA6IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB6VHJhbnNsYXRpb24gPSBvcHRpb25zLmRpc3QgKiAoaSAqIDIgLSB0d2VlbiAqIGRpcik7XG4gICAgICAgICAgICAgIHR3ZWVuZWRPcGFjaXR5ID0gMSAtIDAuMiAqIChpICogMiAtIHR3ZWVuICogZGlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IHNob3cgd3JhcHBlZCBpdGVtcy5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5ub1dyYXAgfHwgY2VudGVyIC0gaSA+PSAwKSB7XG4gICAgICAgICAgICAgIGVsID0gaW1hZ2VzW3dyYXAoY2VudGVyIC0gaSldO1xuICAgICAgICAgICAgICBlbC5zdHlsZVt4Zm9ybV0gPSBhbGlnbm1lbnQgK1xuICAgICAgICAgICAgICAgICcgdHJhbnNsYXRlWCgnICsgKC1vcHRpb25zLnNoaWZ0ICsgKC1kaW0gKiBpIC0gZGVsdGEpIC8gMikgKyAncHgpJyArXG4gICAgICAgICAgICAgICAgJyB0cmFuc2xhdGVaKCcgKyB6VHJhbnNsYXRpb24gKyAncHgpJztcbiAgICAgICAgICAgICAgZWwuc3R5bGUuekluZGV4ID0gLWk7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSB0d2VlbmVkT3BhY2l0eTtcbiAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2VudGVyXG4gICAgICAgICAgLy8gRG9uJ3Qgc2hvdyB3cmFwcGVkIGl0ZW1zLlxuICAgICAgICAgIGlmICghb3B0aW9ucy5ub1dyYXAgfHwgKGNlbnRlciA+PSAwICYmIGNlbnRlciA8IGNvdW50KSkge1xuICAgICAgICAgICAgZWwgPSBpbWFnZXNbd3JhcChjZW50ZXIpXTtcbiAgICAgICAgICAgIGVsLnN0eWxlW3hmb3JtXSA9IGFsaWdubWVudCArXG4gICAgICAgICAgICAgICcgdHJhbnNsYXRlWCgnICsgKC1kZWx0YSAvIDIpICsgJ3B4KScgK1xuICAgICAgICAgICAgICAnIHRyYW5zbGF0ZVgoJyArIChkaXIgKiBvcHRpb25zLnNoaWZ0ICogdHdlZW4pICsgJ3B4KScgK1xuICAgICAgICAgICAgICAnIHRyYW5zbGF0ZVooJyArIChvcHRpb25zLmRpc3QgKiB0d2VlbikgKyAncHgpJztcbiAgICAgICAgICAgIGVsLnN0eWxlLnpJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mdWxsV2lkdGgpIHsgdHdlZW5lZE9wYWNpdHkgPSAxOyB9XG4gICAgICAgICAgICBlbHNlIHsgdHdlZW5lZE9wYWNpdHkgPSAxIC0gMC4yICogdHdlZW47IH1cbiAgICAgICAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSB0d2VlbmVkT3BhY2l0eTtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG9uQ3ljbGVUbyBjYWxsYmFja1xuICAgICAgICAgIGlmIChsYXN0Q2VudGVyICE9PSBjZW50ZXIgJiZcbiAgICAgICAgICAgICAgdHlwZW9mKG9wdGlvbnMub25DeWNsZVRvKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgJGN1cnJfaXRlbSA9IHZpZXcuZmluZCgnLmNhcm91c2VsLWl0ZW0nKS5lcSh3cmFwKGNlbnRlcikpO1xuICAgICAgICAgICAgb3B0aW9ucy5vbkN5Y2xlVG8uY2FsbCh0aGlzLCAkY3Vycl9pdGVtLCBkcmFnZ2VkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cmFjaygpIHtcbiAgICAgICAgICB2YXIgbm93LCBlbGFwc2VkLCBkZWx0YSwgdjtcblxuICAgICAgICAgIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgZWxhcHNlZCA9IG5vdyAtIHRpbWVzdGFtcDtcbiAgICAgICAgICB0aW1lc3RhbXAgPSBub3c7XG4gICAgICAgICAgZGVsdGEgPSBvZmZzZXQgLSBmcmFtZTtcbiAgICAgICAgICBmcmFtZSA9IG9mZnNldDtcblxuICAgICAgICAgIHYgPSAxMDAwICogZGVsdGEgLyAoMSArIGVsYXBzZWQpO1xuICAgICAgICAgIHZlbG9jaXR5ID0gMC44ICogdiArIDAuMiAqIHZlbG9jaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXV0b1Njcm9sbCgpIHtcbiAgICAgICAgICB2YXIgZWxhcHNlZCwgZGVsdGE7XG5cbiAgICAgICAgICBpZiAoYW1wbGl0dWRlKSB7XG4gICAgICAgICAgICBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGRlbHRhID0gYW1wbGl0dWRlICogTWF0aC5leHAoLWVsYXBzZWQgLyBvcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDIgfHwgZGVsdGEgPCAtMikge1xuICAgICAgICAgICAgICAgIHNjcm9sbCh0YXJnZXQgLSBkZWx0YSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9TY3JvbGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JvbGwodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICAgICAgLy8gRGlzYWJsZSBjbGlja3MgaWYgY2Fyb3VzZWwgd2FzIGRyYWdnZWQuXG4gICAgICAgICAgaWYgKGRyYWdnZWQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmZ1bGxXaWR0aCkge1xuICAgICAgICAgICAgdmFyIGNsaWNrZWRJbmRleCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5jYXJvdXNlbC1pdGVtJykuaW5kZXgoKTtcbiAgICAgICAgICAgIHZhciBkaWZmID0gKGNlbnRlciAlIGNvdW50KSAtIGNsaWNrZWRJbmRleDtcblxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjbGlja3MgaWYgY2Fyb3VzZWwgd2FzIHNoaWZ0ZWQgYnkgY2xpY2tcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN5Y2xlVG8oY2xpY2tlZEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjeWNsZVRvKG4pIHtcbiAgICAgICAgICB2YXIgZGlmZiA9IChjZW50ZXIgJSBjb3VudCkgLSBuO1xuXG4gICAgICAgICAgLy8gQWNjb3VudCBmb3Igd3JhcGFyb3VuZC5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMubm9XcmFwKSB7XG4gICAgICAgICAgICBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYgKyBjb3VudCkgPCBNYXRoLmFicyhkaWZmKSkgeyBkaWZmICs9IGNvdW50OyB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYgLSBjb3VudCkgPCBkaWZmKSB7IGRpZmYgLT0gY291bnQ7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWxsIHByZXYgb3IgbmV4dCBhY2NvcmRpbmdseS5cbiAgICAgICAgICBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgIHZpZXcudHJpZ2dlcignY2Fyb3VzZWxOZXh0JywgW01hdGguYWJzKGRpZmYpXSk7XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICB2aWV3LnRyaWdnZXIoJ2Nhcm91c2VsUHJldicsIFtkaWZmXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdGFwKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgIHZlcnRpY2FsX2RyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgICByZWZlcmVuY2UgPSB4cG9zKGUpO1xuICAgICAgICAgIHJlZmVyZW5jZVkgPSB5cG9zKGUpO1xuXG4gICAgICAgICAgdmVsb2NpdHkgPSBhbXBsaXR1ZGUgPSAwO1xuICAgICAgICAgIGZyYW1lID0gb2Zmc2V0O1xuICAgICAgICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aWNrZXIpO1xuICAgICAgICAgIHRpY2tlciA9IHNldEludGVydmFsKHRyYWNrLCAxMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgICAgICAgdmFyIHgsIGRlbHRhLCBkZWx0YVk7XG4gICAgICAgICAgaWYgKHByZXNzZWQpIHtcbiAgICAgICAgICAgIHggPSB4cG9zKGUpO1xuICAgICAgICAgICAgeSA9IHlwb3MoZSk7XG4gICAgICAgICAgICBkZWx0YSA9IHJlZmVyZW5jZSAtIHg7XG4gICAgICAgICAgICBkZWx0YVkgPSBNYXRoLmFicyhyZWZlcmVuY2VZIC0geSk7XG4gICAgICAgICAgICBpZiAoZGVsdGFZIDwgMzAgJiYgIXZlcnRpY2FsX2RyYWdnZWQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdmVydGljYWwgc2Nyb2xsaW5nIGRvbid0IGFsbG93IGRyYWdnaW5nLlxuICAgICAgICAgICAgICBpZiAoZGVsdGEgPiAyIHx8IGRlbHRhIDwgLTIpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2UgPSB4O1xuICAgICAgICAgICAgICAgIHNjcm9sbChvZmZzZXQgKyBkZWx0YSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChkcmFnZ2VkKSB7XG4gICAgICAgICAgICAgIC8vIElmIGRyYWdnaW5nIGRvbid0IGFsbG93IHZlcnRpY2FsIHNjcm9sbC5cbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFZlcnRpY2FsIHNjcm9sbGluZy5cbiAgICAgICAgICAgICAgdmVydGljYWxfZHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRyYWdnZWQpIHtcbiAgICAgICAgICAgIC8vIElmIGRyYWdnaW5nIGRvbid0IGFsbG93IHZlcnRpY2FsIHNjcm9sbC5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVsZWFzZShlKSB7XG4gICAgICAgICAgaWYgKHByZXNzZWQpIHtcbiAgICAgICAgICAgIHByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGlja2VyKTtcbiAgICAgICAgICB0YXJnZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgaWYgKHZlbG9jaXR5ID4gMTAgfHwgdmVsb2NpdHkgPCAtMTApIHtcbiAgICAgICAgICAgIGFtcGxpdHVkZSA9IDAuOSAqIHZlbG9jaXR5O1xuICAgICAgICAgICAgdGFyZ2V0ID0gb2Zmc2V0ICsgYW1wbGl0dWRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQgPSBNYXRoLnJvdW5kKHRhcmdldCAvIGRpbSkgKiBkaW07XG5cbiAgICAgICAgICAvLyBObyB3cmFwIG9mIGl0ZW1zLlxuICAgICAgICAgIGlmIChvcHRpb25zLm5vV3JhcCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldCA+PSBkaW0gKiAoY291bnQgLSAxKSkge1xuICAgICAgICAgICAgICB0YXJnZXQgPSBkaW0gKiAoY291bnQgLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0IDwgMCkge1xuICAgICAgICAgICAgICB0YXJnZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhbXBsaXR1ZGUgPSB0YXJnZXQgLSBvZmZzZXQ7XG4gICAgICAgICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXV0b1Njcm9sbCk7XG5cbiAgICAgICAgICBpZiAoZHJhZ2dlZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgeGZvcm0gPSAndHJhbnNmb3JtJztcbiAgICAgICAgWyd3ZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXS5ldmVyeShmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgICAgdmFyIGUgPSBwcmVmaXggKyAnVHJhbnNmb3JtJztcbiAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB4Zm9ybSA9IGU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5jYXJvdXNlbC0nK3VuaXF1ZU5hbWVzcGFjZSkub24oJ3Jlc2l6ZS5jYXJvdXNlbC0nK3VuaXF1ZU5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZnVsbFdpZHRoKSB7XG4gICAgICAgICAgICBpdGVtX3dpZHRoID0gdmlldy5maW5kKCcuY2Fyb3VzZWwtaXRlbScpLmZpcnN0KCkuaW5uZXJXaWR0aCgpO1xuICAgICAgICAgICAgaXRlbV9oZWlnaHQgPSB2aWV3LmZpbmQoJy5jYXJvdXNlbC1pdGVtJykuZmlyc3QoKS5pbm5lckhlaWdodCgpO1xuICAgICAgICAgICAgZGltID0gaXRlbV93aWR0aCAqIDIgKyBvcHRpb25zLnBhZGRpbmc7XG4gICAgICAgICAgICBvZmZzZXQgPSBjZW50ZXIgKiAyICogaXRlbV93aWR0aDtcbiAgICAgICAgICAgIHRhcmdldCA9IG9mZnNldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzZXR1cEV2ZW50cygpO1xuICAgICAgICBzY3JvbGwob2Zmc2V0KTtcblxuICAgICAgICAkKHRoaXMpLm9uKCdjYXJvdXNlbE5leHQnLCBmdW5jdGlvbihlLCBuKSB7XG4gICAgICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbiA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldCA9IChkaW0gKiBNYXRoLnJvdW5kKG9mZnNldCAvIGRpbSkpICsgKGRpbSAqIG4pO1xuICAgICAgICAgIGlmIChvZmZzZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgYW1wbGl0dWRlID0gdGFyZ2V0IC0gb2Zmc2V0O1xuICAgICAgICAgICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhdXRvU2Nyb2xsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQodGhpcykub24oJ2Nhcm91c2VsUHJldicsIGZ1bmN0aW9uKGUsIG4pIHtcbiAgICAgICAgICBpZiAobiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0ID0gKGRpbSAqIE1hdGgucm91bmQob2Zmc2V0IC8gZGltKSkgLSAoZGltICogbik7XG4gICAgICAgICAgaWYgKG9mZnNldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBhbXBsaXR1ZGUgPSB0YXJnZXQgLSBvZmZzZXQ7XG4gICAgICAgICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9TY3JvbGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCh0aGlzKS5vbignY2Fyb3VzZWxTZXQnLCBmdW5jdGlvbihlLCBuKSB7XG4gICAgICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN5Y2xlVG8obik7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcblxuXG5cbiAgICB9LFxuICAgIG5leHQgOiBmdW5jdGlvbihuKSB7XG4gICAgICAkKHRoaXMpLnRyaWdnZXIoJ2Nhcm91c2VsTmV4dCcsIFtuXSk7XG4gICAgfSxcbiAgICBwcmV2IDogZnVuY3Rpb24obikge1xuICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjYXJvdXNlbFByZXYnLCBbbl0pO1xuICAgIH0sXG4gICAgc2V0IDogZnVuY3Rpb24obikge1xuICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjYXJvdXNlbFNldCcsIFtuXSk7XG4gICAgfVxuICB9O1xuXG5cbiAgICAkLmZuLmNhcm91c2VsID0gZnVuY3Rpb24obWV0aG9kT3JPcHRpb25zKSB7XG4gICAgICBpZiAoIG1ldGhvZHNbbWV0aG9kT3JPcHRpb25zXSApIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZHNbIG1ldGhvZE9yT3B0aW9ucyBdLmFwcGx5KCB0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICkpO1xuICAgICAgfSBlbHNlIGlmICggdHlwZW9mIG1ldGhvZE9yT3B0aW9ucyA9PT0gJ29iamVjdCcgfHwgISBtZXRob2RPck9wdGlvbnMgKSB7XG4gICAgICAgIC8vIERlZmF1bHQgdG8gXCJpbml0XCJcbiAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkLmVycm9yKCAnTWV0aG9kICcgKyAgbWV0aG9kT3JPcHRpb25zICsgJyBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkuY2Fyb3VzZWwnICk7XG4gICAgICB9XG4gICAgfTsgLy8gUGx1Z2luIGVuZFxufSggalF1ZXJ5ICkpOzsoZnVuY3Rpb24gKCQpIHtcblxuICB2YXIgbWV0aG9kcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW4gPSAkKCcjJyskKHRoaXMpLmF0dHIoJ2RhdGEtYWN0aXZhdGVzJykpO1xuICAgIHZhciBzY3JlZW4gPSAkKCdib2R5Jyk7XG5cbiAgICAvLyBDcmVhdGluZyB0YXAgdGFyZ2V0XG4gICAgdmFyIHRhcFRhcmdldEVsID0gJCh0aGlzKTtcbiAgICB2YXIgdGFwVGFyZ2V0V3JhcHBlciA9IHRhcFRhcmdldEVsLnBhcmVudCgnLnRhcC10YXJnZXQtd3JhcHBlcicpO1xuICAgIHZhciB0YXBUYXJnZXRXYXZlID0gdGFwVGFyZ2V0V3JhcHBlci5maW5kKCcudGFwLXRhcmdldC13YXZlJyk7XG4gICAgdmFyIHRhcFRhcmdldE9yaWdpbkVsID0gdGFwVGFyZ2V0V3JhcHBlci5maW5kKCcudGFwLXRhcmdldC1vcmlnaW4nKTtcbiAgICB2YXIgdGFwVGFyZ2V0Q29udGVudEVsID0gdGFwVGFyZ2V0RWwuZmluZCgnLnRhcC10YXJnZXQtY29udGVudCcpO1xuXG4gICAgLy8gQ3JlYXRpbmcgd3JhcHBlclxuICAgIGlmICghdGFwVGFyZ2V0V3JhcHBlci5sZW5ndGgpIHtcbiAgICAgIHRhcFRhcmdldFdyYXBwZXIgPSB0YXBUYXJnZXRFbC53cmFwKCQoJzxkaXYgY2xhc3M9XCJ0YXAtdGFyZ2V0LXdyYXBwZXJcIj48L2Rpdj4nKSkucGFyZW50KCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRpbmcgY29udGVudFxuICAgIGlmICghdGFwVGFyZ2V0Q29udGVudEVsLmxlbmd0aCkge1xuICAgICAgdGFwVGFyZ2V0Q29udGVudEVsID0gJCgnPGRpdiBjbGFzcz1cInRhcC10YXJnZXQtY29udGVudFwiPjwvZGl2PicpO1xuICAgICAgdGFwVGFyZ2V0RWwuYXBwZW5kKHRhcFRhcmdldENvbnRlbnRFbCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRpbmcgZm9yZWdyb3VuZCB3YXZlXG4gICAgaWYgKCF0YXBUYXJnZXRXYXZlLmxlbmd0aCkge1xuICAgICAgdGFwVGFyZ2V0V2F2ZSA9ICQoJzxkaXYgY2xhc3M9XCJ0YXAtdGFyZ2V0LXdhdmVcIj48L2Rpdj4nKTtcblxuICAgICAgLy8gQ3JlYXRpbmcgb3JpZ2luXG4gICAgICBpZiAoIXRhcFRhcmdldE9yaWdpbkVsLmxlbmd0aCkge1xuICAgICAgICB0YXBUYXJnZXRPcmlnaW5FbCA9IG9yaWdpbi5jbG9uZSh0cnVlLCB0cnVlKTtcbiAgICAgICAgdGFwVGFyZ2V0T3JpZ2luRWwuYWRkQ2xhc3MoJ3RhcC10YXJnZXQtb3JpZ2luJyk7XG4gICAgICAgIHRhcFRhcmdldE9yaWdpbkVsLnJlbW92ZUF0dHIoJ2lkJyk7XG4gICAgICAgIHRhcFRhcmdldE9yaWdpbkVsLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgICAgIHRhcFRhcmdldFdhdmUuYXBwZW5kKHRhcFRhcmdldE9yaWdpbkVsKTtcbiAgICAgIH1cblxuICAgICAgdGFwVGFyZ2V0V3JhcHBlci5hcHBlbmQodGFwVGFyZ2V0V2F2ZSk7XG4gICAgfVxuXG4gICAgLy8gT3BlblxuICAgIHZhciBvcGVuVGFwVGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGFwVGFyZ2V0V3JhcHBlci5pcygnLm9wZW4nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZGluZyBvcGVuIGNsYXNzXG4gICAgICB0YXBUYXJnZXRXcmFwcGVyLmFkZENsYXNzKCdvcGVuJyk7XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRhcFRhcmdldE9yaWdpbkVsLm9mZignY2xpY2sudGFwVGFyZ2V0Jykub24oJ2NsaWNrLnRhcFRhcmdldCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBjbG9zZVRhcFRhcmdldCgpO1xuICAgICAgICAgIHRhcFRhcmdldE9yaWdpbkVsLm9mZignY2xpY2sudGFwVGFyZ2V0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLm9mZignY2xpY2sudGFwVGFyZ2V0Jykub24oJ2NsaWNrLnRhcFRhcmdldCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBjbG9zZVRhcFRhcmdldCgpO1xuICAgICAgICAgICQoZG9jdW1lbnQpLm9mZignY2xpY2sudGFwVGFyZ2V0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB0aHJvdHRsZWRDYWxjID0gTWF0ZXJpYWxpemUudGhyb3R0bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsY3VsYXRlVGFwVGFyZ2V0KCk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS50YXBUYXJnZXQnKS5vbigncmVzaXplLnRhcFRhcmdldCcsIHRocm90dGxlZENhbGMpO1xuICAgICAgfSwgMCk7XG4gICAgfTtcblxuICAgIC8vIENsb3NlXG4gICAgdmFyIGNsb3NlVGFwVGFyZ2V0ID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmICghdGFwVGFyZ2V0V3JhcHBlci5pcygnLm9wZW4nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRhcFRhcmdldFdyYXBwZXIucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcbiAgICAgIHRhcFRhcmdldE9yaWdpbkVsLm9mZignY2xpY2sudGFwVGFyZ2V0JylcbiAgICAgICQoZG9jdW1lbnQpLm9mZignY2xpY2sudGFwVGFyZ2V0Jyk7XG4gICAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUudGFwVGFyZ2V0Jyk7XG4gICAgfTtcblxuICAgIC8vIFByZSBjYWxjdWxhdGVcbiAgICB2YXIgY2FsY3VsYXRlVGFwVGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBFbGVtZW50IG9yIHBhcmVudCBpcyBmaXhlZCBwb3NpdGlvbj9cbiAgICAgIHZhciBpc0ZpeGVkID0gb3JpZ2luLmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJztcbiAgICAgIGlmICghaXNGaXhlZCkge1xuICAgICAgICB2YXIgcGFyZW50cyA9IG9yaWdpbi5wYXJlbnRzKCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXNGaXhlZCA9ICQocGFyZW50c1tpXSkuY3NzKCdwb3NpdGlvbicpID09ICdmaXhlZCc7XG4gICAgICAgICAgaWYgKGlzRml4ZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGluZyBvcmlnaW5cbiAgICAgIHZhciBvcmlnaW5XaWR0aCA9IG9yaWdpbi5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gb3JpZ2luLm91dGVySGVpZ2h0KCk7XG4gICAgICB2YXIgb3JpZ2luVG9wID0gaXNGaXhlZCA/IG9yaWdpbi5vZmZzZXQoKS50b3AgLSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSA6IG9yaWdpbi5vZmZzZXQoKS50b3A7XG4gICAgICB2YXIgb3JpZ2luTGVmdCA9IGlzRml4ZWQgPyBvcmlnaW4ub2Zmc2V0KCkubGVmdCAtICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSA6IG9yaWdpbi5vZmZzZXQoKS5sZWZ0O1xuXG4gICAgICAvLyBDYWxjdWxhdGluZyBzY3JlZW5cbiAgICAgIHZhciB3aW5kb3dXaWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xuICAgICAgdmFyIHdpbmRvd0hlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKTtcbiAgICAgIHZhciBjZW50ZXJYID0gd2luZG93V2lkdGggLyAyO1xuICAgICAgdmFyIGNlbnRlclkgPSB3aW5kb3dIZWlnaHQgLyAyO1xuICAgICAgdmFyIGlzTGVmdCA9IG9yaWdpbkxlZnQgPD0gY2VudGVyWDtcbiAgICAgIHZhciBpc1JpZ2h0ID0gb3JpZ2luTGVmdCA+IGNlbnRlclg7XG4gICAgICB2YXIgaXNUb3AgPSBvcmlnaW5Ub3AgPD0gY2VudGVyWTtcbiAgICAgIHZhciBpc0JvdHRvbSA9IG9yaWdpblRvcCA+IGNlbnRlclk7XG4gICAgICB2YXIgaXNDZW50ZXJYID0gb3JpZ2luTGVmdCA+PSB3aW5kb3dXaWR0aCowLjI1ICYmIG9yaWdpbkxlZnQgPD0gd2luZG93V2lkdGgqMC43NTtcbiAgICAgIHZhciBpc0NlbnRlclkgPSBvcmlnaW5Ub3AgPj0gd2luZG93SGVpZ2h0KjAuMjUgJiYgb3JpZ2luVG9wIDw9IHdpbmRvd0hlaWdodCowLjc1O1xuXG4gICAgICAvLyBDYWxjdWxhdGluZyB0YXAgdGFyZ2V0XG4gICAgICB2YXIgdGFwVGFyZ2V0V2lkdGggPSB0YXBUYXJnZXRFbC5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgdGFwVGFyZ2V0SGVpZ2h0ID0gdGFwVGFyZ2V0RWwub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHZhciB0YXBUYXJnZXRUb3AgPSBvcmlnaW5Ub3AgKyBvcmlnaW5IZWlnaHQvMiAtIHRhcFRhcmdldEhlaWdodC8yO1xuICAgICAgdmFyIHRhcFRhcmdldExlZnQgPSBvcmlnaW5MZWZ0ICsgb3JpZ2luV2lkdGgvMiAtIHRhcFRhcmdldFdpZHRoLzI7XG4gICAgICB2YXIgdGFwVGFyZ2V0UG9zaXRpb24gPSBpc0ZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgICAgIC8vIENhbGN1bGF0aW5nIGNvbnRlbnRcbiAgICAgIHZhciB0YXBUYXJnZXRUZXh0V2lkdGggPSBpc0NlbnRlclggPyB0YXBUYXJnZXRXaWR0aCA6IHRhcFRhcmdldFdpZHRoLzIgKyBvcmlnaW5XaWR0aDtcbiAgICAgIHZhciB0YXBUYXJnZXRUZXh0SGVpZ2h0ID0gdGFwVGFyZ2V0SGVpZ2h0LzI7XG4gICAgICB2YXIgdGFwVGFyZ2V0VGV4dFRvcCA9IGlzVG9wID8gdGFwVGFyZ2V0SGVpZ2h0LzIgOiAwO1xuICAgICAgdmFyIHRhcFRhcmdldFRleHRCb3R0b20gPSAwO1xuICAgICAgdmFyIHRhcFRhcmdldFRleHRMZWZ0ID0gaXNMZWZ0ICYmICFpc0NlbnRlclggPyB0YXBUYXJnZXRXaWR0aC8yIC0gb3JpZ2luV2lkdGggOiAwO1xuICAgICAgdmFyIHRhcFRhcmdldFRleHRSaWdodCA9IDA7XG4gICAgICB2YXIgdGFwVGFyZ2V0VGV4dFBhZGRpbmcgPSBvcmlnaW5XaWR0aDtcbiAgICAgIHZhciB0YXBUYXJnZXRUZXh0QWxpZ24gPSBpc0JvdHRvbSA/ICdib3R0b20nIDogJ3RvcCc7XG5cbiAgICAgIC8vIENhbGN1bGF0aW5nIHdhdmVcbiAgICAgIHZhciB0YXBUYXJnZXRXYXZlV2lkdGggPSBvcmlnaW5XaWR0aCA+IG9yaWdpbkhlaWdodCA/IG9yaWdpbldpZHRoKjIgOiBvcmlnaW5XaWR0aCoyO1xuICAgICAgdmFyIHRhcFRhcmdldFdhdmVIZWlnaHQgPSB0YXBUYXJnZXRXYXZlV2lkdGg7XG4gICAgICB2YXIgdGFwVGFyZ2V0V2F2ZVRvcCA9IHRhcFRhcmdldEhlaWdodC8yIC0gdGFwVGFyZ2V0V2F2ZUhlaWdodC8yO1xuICAgICAgdmFyIHRhcFRhcmdldFdhdmVMZWZ0ID0gdGFwVGFyZ2V0V2lkdGgvMiAtIHRhcFRhcmdldFdhdmVXaWR0aC8yO1xuXG4gICAgICAvLyBTZXR0aW5nIHRhcCB0YXJnZXRcbiAgICAgIHZhciB0YXBUYXJnZXRXcmFwcGVyQ3NzT2JqID0ge307XG4gICAgICB0YXBUYXJnZXRXcmFwcGVyQ3NzT2JqLnRvcCA9IGlzVG9wID8gdGFwVGFyZ2V0VG9wIDogJyc7XG4gICAgICB0YXBUYXJnZXRXcmFwcGVyQ3NzT2JqLnJpZ2h0ID0gaXNSaWdodCA/IHdpbmRvd1dpZHRoIC0gdGFwVGFyZ2V0TGVmdCAtIHRhcFRhcmdldFdpZHRoIDogJyc7XG4gICAgICB0YXBUYXJnZXRXcmFwcGVyQ3NzT2JqLmJvdHRvbSA9IGlzQm90dG9tID8gd2luZG93SGVpZ2h0IC0gdGFwVGFyZ2V0VG9wIC0gdGFwVGFyZ2V0SGVpZ2h0IDogJyc7XG4gICAgICB0YXBUYXJnZXRXcmFwcGVyQ3NzT2JqLmxlZnQgPSBpc0xlZnQgPyB0YXBUYXJnZXRMZWZ0IDogJyc7XG4gICAgICB0YXBUYXJnZXRXcmFwcGVyQ3NzT2JqLnBvc2l0aW9uID0gdGFwVGFyZ2V0UG9zaXRpb247XG4gICAgICB0YXBUYXJnZXRXcmFwcGVyLmNzcyh0YXBUYXJnZXRXcmFwcGVyQ3NzT2JqKTtcblxuICAgICAgLy8gU2V0dGluZyBjb250ZW50XG4gICAgICB0YXBUYXJnZXRDb250ZW50RWwuY3NzKHtcbiAgICAgICAgd2lkdGg6IHRhcFRhcmdldFRleHRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0YXBUYXJnZXRUZXh0SGVpZ2h0LFxuICAgICAgICB0b3A6IHRhcFRhcmdldFRleHRUb3AsXG4gICAgICAgIHJpZ2h0OiB0YXBUYXJnZXRUZXh0UmlnaHQsXG4gICAgICAgIGJvdHRvbTogdGFwVGFyZ2V0VGV4dEJvdHRvbSxcbiAgICAgICAgbGVmdDogdGFwVGFyZ2V0VGV4dExlZnQsXG4gICAgICAgIHBhZGRpbmc6IHRhcFRhcmdldFRleHRQYWRkaW5nLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiB0YXBUYXJnZXRUZXh0QWxpZ25cbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXR0aW5nIHdhdmVcbiAgICAgIHRhcFRhcmdldFdhdmUuY3NzKHtcbiAgICAgICAgdG9wOiB0YXBUYXJnZXRXYXZlVG9wLFxuICAgICAgICBsZWZ0OiB0YXBUYXJnZXRXYXZlTGVmdCxcbiAgICAgICAgd2lkdGg6IHRhcFRhcmdldFdhdmVXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0YXBUYXJnZXRXYXZlSGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PSAnb3BlbicpIHtcbiAgICAgIGNhbGN1bGF0ZVRhcFRhcmdldCgpO1xuICAgICAgb3BlblRhcFRhcmdldCgpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09ICdjbG9zZScpXG4gICAgICBjbG9zZVRhcFRhcmdldCgpO1xuICAgIH0pO1xuICB9LFxuICBvcGVuOiBmdW5jdGlvbigpIHt9LFxuICBjbG9zZTogZnVuY3Rpb24oKSB7fVxuICB9O1xuXG4gICQuZm4udGFwVGFyZ2V0ID0gZnVuY3Rpb24obWV0aG9kT3JPcHRpb25zKSB7XG4gIGlmIChtZXRob2RzW21ldGhvZE9yT3B0aW9uc10gfHwgdHlwZW9mIG1ldGhvZE9yT3B0aW9ucyA9PT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cbiAgJC5lcnJvciggJ01ldGhvZCAnICsgIG1ldGhvZE9yT3B0aW9ucyArICcgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LnRhcC10YXJnZXQnICk7XG4gIH07XG5cbn0oIGpRdWVyeSApKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvbWF0ZXJpYWxpemUvYmluL21hdGVyaWFsaXplLmpzIiwiLyohIEhhbW1lci5KUyAtIHYyLjAuNyAtIDIwMTYtMDQtMjJcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEpvcmlrIFRhbmdlbGRlcjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbnZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIG5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xufVxuXG4vKipcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xudmFyIGFzc2lnbjtcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIW1lcmdlIHx8IChtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBtZXJnZSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlLFxuICAgICAgICBjaGlsZFA7XG5cbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xuICAgICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7Kn0gdmFsMVxuICogQHBhcmFtIHsqfSB2YWwyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xuICAgIHJldHVybiAodmFsMSA9PT0gdW5kZWZpbmVkKSA/IHZhbDIgOiB2YWwxO1xufVxuXG4vKipcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cblxuLyoqXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG5cbi8qKlxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG52YXIgX3VuaXF1ZUlkID0gMTtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG59XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG5cbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcblxufVxuXG5JbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gICAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cblxuLyoqXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH1cblxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gICAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gKGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpKSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG5cbiAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6ICgoaW5wdXQucG9pbnRlcnMubGVuZ3RoID5cbiAgICAgICAgc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpO1xuXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAgIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgICAgfTtcblxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuXG4vKipcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0LFxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICAgICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG5cbi8qKlxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1FaGFuZGxlcihldikge1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07XG5cbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG52YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG59O1xuXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuXG4vKipcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnN0b3JlID0gKHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXSk7XG59XG5cbmluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuXG4gICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXG4gICAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAgICAgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMudGFyZ2V0SWRzID0ge307XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkcztcblxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIHRhcmdldFRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXG4gICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuICAgIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgICB9KTtcblxuICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgICAgICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXG4gICAgXTtcbn1cblxuLyoqXG4gKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAqXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xudmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcbiAgICB0aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcblxuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb3VjaGVzID0gW107XG59XG5cbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuICAgICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbCh0aGlzLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF07XG5cbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgICAgdmFyIGxhc3RUb3VjaCA9IHt4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZfTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG4gICAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLCB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCksIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG4gICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbnZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG5cbiAgICAgICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc05vbmUgfHxcbiAgICAgICAgICAgIChoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB8fFxuICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAgICovXG4gICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgLy8gbm9uZVxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIC8vIHBhbi14IE9SIHBhbi15XG4gICAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9XG5cbiAgICAvLyBtYW5pcHVsYXRpb25cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xufVxuXG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0b3VjaE1hcCA9IHt9O1xuICAgIHZhciBjc3NTdXBwb3J0cyA9IHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5zdXBwb3J0cztcbiAgICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICAgIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaE1hcDtcbn1cblxuLyoqXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4vKipcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbn1cblxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7IC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTtcblxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxufTtcblxuLyoqXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICAgIHJldHVybiAnZW5kJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICByZXR1cm4gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtDb25zdH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgICByZXR1cm4gJ3VwJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cblxuLyoqXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcblxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG59XG5cbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9LFxuXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT0gdGhpcy5wWTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG5cbiAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRpbWU6IDI1MSwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiZcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmXG4gICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFRhcFJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG59XG5cbmluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGFwczogMSxcbiAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzIuMC43JztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBwcmVzZXQ6IFtcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX1dLFxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX0sIFsncm90YXRlJ11dLFxuICAgICAgICBbU3dpcGVSZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH1dLFxuICAgICAgICBbUGFuUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9LCBbJ3N3aXBlJ11dLFxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyLCB7ZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyfSwgWyd0YXAnXV0sXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBjc3NQcm9wczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG5cbi8qKlxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcbiAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wO1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFkZCkge1xuICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5hc3NpZ24oSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG4vLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5mcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xufSBlbHNlIHtcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG59XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oYW1tZXJqcy9oYW1tZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHRocm93IG5ldyBFcnJvcihcImRlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdFwiKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgJCA9IHdpbmRvdy5qUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoXCIuL2RhdGF0YWJsZXMuanNcIik7XG5yZXF1aXJlKCcuL21hdGVyaWFsaXplL2Jpbi9tYXRlcmlhbGl6ZS5qcycpO1xuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgJChcIi5idXR0b24tY29sbGFwc2VcIikuc2lkZU5hdigpO1xuICAgICQoJyNwb3N0cy10YWJsZScpLkRhdGFUYWJsZSgpO1xuICAgICQoJyNwcm9qZWN0cy10YWJsZScpLkRhdGFUYWJsZSgpO1xuICAgICQoJyN0YWdzJykubWF0ZXJpYWxfY2hpcCh7XG4gICAgICAgIHBsYWNlaG9sZGVyOiAnRW50ZXIgYSB0YWcnLFxuICAgICAgICBzZWNvbmRhcnlQbGFjZWhvbGRlcjogJytUYWcnLFxuICAgIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2FkbWluLmpzIiwiLyohIERhdGFUYWJsZXMgMS4xMC4xNVxuICogwqkyMDA4LTIwMTcgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBzdW1tYXJ5ICAgICBEYXRhVGFibGVzXG4gKiBAZGVzY3JpcHRpb24gUGFnaW5hdGUsIHNlYXJjaCBhbmQgb3JkZXIgSFRNTCB0YWJsZXNcbiAqIEB2ZXJzaW9uICAgICAxLjEwLjE1XG4gKiBAZmlsZSAgICAgICAganF1ZXJ5LmRhdGFUYWJsZXMuanNcbiAqIEBhdXRob3IgICAgICBTcHJ5TWVkaWEgTHRkXG4gKiBAY29udGFjdCAgICAgd3d3LmRhdGF0YWJsZXMubmV0XG4gKiBAY29weXJpZ2h0ICAgQ29weXJpZ2h0IDIwMDgtMjAxNyBTcHJ5TWVkaWEgTHRkLlxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZnJlZSBzb2Z0d2FyZSwgYXZhaWxhYmxlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqICAgTUlUIGxpY2Vuc2UgLSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0XG4gKiBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgbGljZW5zZSBmaWxlcyBmb3IgZGV0YWlscy5cbiAqXG4gKiBGb3IgZGV0YWlscyBwbGVhc2UgcmVmZXIgdG86IGh0dHA6Ly93d3cuZGF0YXRhYmxlcy5uZXRcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlLCB1bmRlZjogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSAqL1xuLypnbG9iYWxzICQscmVxdWlyZSxqUXVlcnksZGVmaW5lLF9zZWxlY3Rvcl9ydW4sX3NlbGVjdG9yX29wdHMsX3NlbGVjdG9yX2ZpcnN0LF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyxfZXh0LF9BcGksX2FwaV9yZWdpc3RlcixfYXBpX3JlZ2lzdGVyUGx1cmFsLF9yZV9uZXdfbGluZXMsX3JlX2h0bWwsX3JlX2Zvcm1hdHRlZF9udW1lcmljLF9yZV9lc2NhcGVfcmVnZXgsX2VtcHR5LF9pbnRWYWwsX251bVRvRGVjaW1hbCxfaXNOdW1iZXIsX2lzSHRtbCxfaHRtbE51bWVyaWMsX3BsdWNrLF9wbHVja19vcmRlcixfcmFuZ2UsX3N0cmlwSHRtbCxfdW5pcXVlLF9mbkJ1aWxkQWpheCxfZm5BamF4VXBkYXRlLF9mbkFqYXhQYXJhbWV0ZXJzLF9mbkFqYXhVcGRhdGVEcmF3LF9mbkFqYXhEYXRhU3JjLF9mbkFkZENvbHVtbixfZm5Db2x1bW5PcHRpb25zLF9mbkFkanVzdENvbHVtblNpemluZyxfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCxfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSxfZm5WaXNibGVDb2x1bW5zLF9mbkdldENvbHVtbnMsX2ZuQ29sdW1uVHlwZXMsX2ZuQXBwbHlDb2x1bW5EZWZzLF9mbkh1bmdhcmlhbk1hcCxfZm5DYW1lbFRvSHVuZ2FyaWFuLF9mbkxhbmd1YWdlQ29tcGF0LF9mbkJyb3dzZXJEZXRlY3QsX2ZuQWRkRGF0YSxfZm5BZGRUcixfZm5Ob2RlVG9EYXRhSW5kZXgsX2ZuTm9kZVRvQ29sdW1uSW5kZXgsX2ZuR2V0Q2VsbERhdGEsX2ZuU2V0Q2VsbERhdGEsX2ZuU3BsaXRPYmpOb3RhdGlvbixfZm5HZXRPYmplY3REYXRhRm4sX2ZuU2V0T2JqZWN0RGF0YUZuLF9mbkdldERhdGFNYXN0ZXIsX2ZuQ2xlYXJUYWJsZSxfZm5EZWxldGVJbmRleCxfZm5JbnZhbGlkYXRlLF9mbkdldFJvd0VsZW1lbnRzLF9mbkNyZWF0ZVRyLF9mbkJ1aWxkSGVhZCxfZm5EcmF3SGVhZCxfZm5EcmF3LF9mblJlRHJhdyxfZm5BZGRPcHRpb25zSHRtbCxfZm5EZXRlY3RIZWFkZXIsX2ZuR2V0VW5pcXVlVGhzLF9mbkZlYXR1cmVIdG1sRmlsdGVyLF9mbkZpbHRlckNvbXBsZXRlLF9mbkZpbHRlckN1c3RvbSxfZm5GaWx0ZXJDb2x1bW4sX2ZuRmlsdGVyLF9mbkZpbHRlckNyZWF0ZVNlYXJjaCxfZm5Fc2NhcGVSZWdleCxfZm5GaWx0ZXJEYXRhLF9mbkZlYXR1cmVIdG1sSW5mbyxfZm5VcGRhdGVJbmZvLF9mbkluZm9NYWNyb3MsX2ZuSW5pdGlhbGlzZSxfZm5Jbml0Q29tcGxldGUsX2ZuTGVuZ3RoQ2hhbmdlLF9mbkZlYXR1cmVIdG1sTGVuZ3RoLF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsX2ZuUGFnZUNoYW5nZSxfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmcsX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksX2ZuRmVhdHVyZUh0bWxUYWJsZSxfZm5TY3JvbGxEcmF3LF9mbkFwcGx5VG9DaGlsZHJlbixfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMsX2ZuVGhyb3R0bGUsX2ZuQ29udmVydFRvV2lkdGgsX2ZuR2V0V2lkZXN0Tm9kZSxfZm5HZXRNYXhMZW5TdHJpbmcsX2ZuU3RyaW5nVG9Dc3MsX2ZuU29ydEZsYXR0ZW4sX2ZuU29ydCxfZm5Tb3J0QXJpYSxfZm5Tb3J0TGlzdGVuZXIsX2ZuU29ydEF0dGFjaExpc3RlbmVyLF9mblNvcnRpbmdDbGFzc2VzLF9mblNvcnREYXRhLF9mblNhdmVTdGF0ZSxfZm5Mb2FkU3RhdGUsX2ZuU2V0dGluZ3NGcm9tTm9kZSxfZm5Mb2csX2ZuTWFwLF9mbkJpbmRBY3Rpb24sX2ZuQ2FsbGJhY2tSZWcsX2ZuQ2FsbGJhY2tGaXJlLF9mbkxlbmd0aE92ZXJmbG93LF9mblJlbmRlcmVyLF9mbkRhdGFTb3VyY2UsX2ZuUm93QXR0cmlidXRlcyovXG5cbihmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeSddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xuXHRcdFx0aWYgKCAhIHJvb3QgKSB7XG5cdFx0XHRcdC8vIENvbW1vbkpTIGVudmlyb25tZW50cyB3aXRob3V0IGEgd2luZG93IGdsb2JhbCBtdXN0IHBhc3MgYVxuXHRcdFx0XHQvLyByb290LiBUaGlzIHdpbGwgZ2l2ZSBhbiBlcnJvciBvdGhlcndpc2Vcblx0XHRcdFx0cm9vdCA9IHdpbmRvdztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhICQgKSB7XG5cdFx0XHRcdCQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IC8vIGpRdWVyeSdzIGZhY3RvcnkgY2hlY2tzIGZvciBhIGdsb2JhbCB3aW5kb3dcblx0XHRcdFx0XHRyZXF1aXJlKCdqcXVlcnknKSA6XG5cdFx0XHRcdFx0cmVxdWlyZSgnanF1ZXJ5JykoIHJvb3QgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHJvb3QsIHJvb3QuZG9jdW1lbnQgKTtcblx0XHR9O1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRmYWN0b3J5KCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0fVxufVxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIGlzIGEgcGx1Zy1pbiBmb3IgdGhlIGpRdWVyeSBKYXZhc2NyaXB0IGxpYnJhcnkuIEl0IGlzIGEgaGlnaGx5XG5cdCAqIGZsZXhpYmxlIHRvb2wsIGJhc2VkIHVwb24gdGhlIGZvdW5kYXRpb25zIG9mIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50LFxuXHQgKiB3aGljaCB3aWxsIGFkZCBhZHZhbmNlZCBpbnRlcmFjdGlvbiBjb250cm9scyB0byBhbnkgSFRNTCB0YWJsZS4gRm9yIGFcblx0ICogZnVsbCBsaXN0IG9mIGZlYXR1cmVzIHBsZWFzZSByZWZlciB0b1xuXHQgKiBbRGF0YVRhYmxlcy5uZXRdKGhyZWY9XCJodHRwOi8vZGF0YXRhYmxlcy5uZXQpLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGVgIG9iamVjdCBpcyBub3QgYSBnbG9iYWwgdmFyaWFibGUgYnV0IGlzIGFsaWFzZWRcblx0ICogdG8gYGpRdWVyeS5mbi5EYXRhVGFibGVgIGFuZCBgalF1ZXJ5LmZuLmRhdGFUYWJsZWAgdGhyb3VnaCB3aGljaCBpdCBtYXlcblx0ICogYmUgIGFjY2Vzc2VkLlxuXHQgKlxuXHQgKiAgQGNsYXNzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gW2luaXQ9e31dIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBEYXRhVGFibGVzLiBPcHRpb25zXG5cdCAqICAgIGFyZSBkZWZpbmVkIGJ5IHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9XG5cdCAqICBAcmVxdWlyZXMgalF1ZXJ5IDEuNytcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIEJhc2ljIGluaXRpYWxpc2F0aW9uXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICogICAgfSApO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gSW5pdGlhbGlzYXRpb24gd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnMgLSBpbiB0aGlzIGNhc2UsIGRpc2FibGVcblx0ICogICAgLy8gcGFnaW5hdGlvbiBhbmQgc29ydGluZy5cblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZSxcblx0ICogICAgICAgIFwic29ydFwiOiBmYWxzZVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0dmFyIERhdGFUYWJsZSA9IGZ1bmN0aW9uICggb3B0aW9ucyApXG5cdHtcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtIGEgalF1ZXJ5IHNlbGVjdG9yIGFjdGlvbiBvbiB0aGUgdGFibGUncyBUUiBlbGVtZW50cyAoZnJvbSB0aGUgdGJvZHkpIGFuZFxuXHRcdCAqIHJldHVybiB0aGUgcmVzdWx0aW5nIGpRdWVyeSBvYmplY3QuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfG5vZGV8alF1ZXJ5fSBzU2VsZWN0b3IgalF1ZXJ5IHNlbGVjdG9yIG9yIG5vZGUgY29sbGVjdGlvbiB0byBhY3Qgb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IFtvT3B0c10gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgbW9kaWZ5aW5nIHRoZSByb3dzIHRvIGJlIGluY2x1ZGVkXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMuZmlsdGVyPW5vbmVdIFNlbGVjdCBUUiBlbGVtZW50cyB0aGF0IG1lZXQgdGhlIGN1cnJlbnQgZmlsdGVyXG5cdFx0ICogICAgY3JpdGVyaW9uIChcImFwcGxpZWRcIikgb3IgYWxsIFRSIGVsZW1lbnRzIChpLmUuIG5vIGZpbHRlcikuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMub3JkZXI9Y3VycmVudF0gT3JkZXIgb2YgdGhlIFRSIGVsZW1lbnRzIGluIHRoZSBwcm9jZXNzZWQgYXJyYXkuXG5cdFx0ICogICAgQ2FuIGJlIGVpdGhlciAnY3VycmVudCcsIHdoZXJlYnkgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGUgdGFibGUgaXMgdXNlZCwgb3Jcblx0XHQgKiAgICAnb3JpZ2luYWwnIHdoZXJlYnkgdGhlIG9yaWdpbmFsIG9yZGVyIHRoZSBkYXRhIHdhcyByZWFkIGludG8gdGhlIHRhYmxlIGlzIHVzZWQuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMucGFnZT1hbGxdIExpbWl0IHRoZSBzZWxlY3Rpb24gdG8gdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgcGFnZVxuXHRcdCAqICAgIChcImN1cnJlbnRcIikgb3Igbm90IChcImFsbFwiKS4gSWYgJ2N1cnJlbnQnIGlzIGdpdmVuLCB0aGVuIG9yZGVyIGlzIGFzc3VtZWQgdG8gYmVcblx0XHQgKiAgICAnY3VycmVudCcgYW5kIGZpbHRlciBpcyAnYXBwbGllZCcsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGV5IG1pZ2h0IGJlIGdpdmVuIGFzLlxuXHRcdCAqICBAcmV0dXJucyB7b2JqZWN0fSBqUXVlcnkgb2JqZWN0LCBmaWx0ZXJlZCBieSB0aGUgZ2l2ZW4gc2VsZWN0b3IuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEhpZ2hsaWdodCBldmVyeSBzZWNvbmQgcm93XG5cdFx0ICogICAgICBvVGFibGUuJCgndHI6b2RkJykuY3NzKCdiYWNrZ3JvdW5kQ29sb3InLCAnYmx1ZScpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEZpbHRlciB0byByb3dzIHdpdGggJ1dlYmtpdCcgaW4gdGhlbSwgYWRkIGEgYmFja2dyb3VuZCBjb2xvdXIgYW5kIHRoZW5cblx0XHQgKiAgICAgIC8vIHJlbW92ZSB0aGUgZmlsdGVyLCB0aHVzIGhpZ2hsaWdodGluZyB0aGUgJ1dlYmtpdCcgcm93cyBvbmx5LlxuXHRcdCAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCdXZWJraXQnKTtcblx0XHQgKiAgICAgIG9UYWJsZS4kKCd0cicsIHtcInNlYXJjaFwiOiBcImFwcGxpZWRcIn0pLmNzcygnYmFja2dyb3VuZENvbG9yJywgJ2JsdWUnKTtcblx0XHQgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignJyk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuJCA9IGZ1bmN0aW9uICggc1NlbGVjdG9yLCBvT3B0cyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBpKHRydWUpLiQoIHNTZWxlY3Rvciwgb09wdHMgKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFsbW9zdCBpZGVudGljYWwgdG8gJCBpbiBvcGVyYXRpb24sIGJ1dCBpbiB0aGlzIGNhc2UgcmV0dXJucyB0aGUgZGF0YSBmb3IgdGhlIG1hdGNoZWRcblx0XHQgKiByb3dzIC0gYXMgc3VjaCwgdGhlIGpRdWVyeSBzZWxlY3RvciB1c2VkIHNob3VsZCBtYXRjaCBUUiByb3cgbm9kZXMgb3IgVEQvVEggY2VsbCBub2Rlc1xuXHRcdCAqIHJhdGhlciB0aGFuIGFueSBkZXNjZW5kYW50cywgc28gdGhlIGRhdGEgY2FuIGJlIG9idGFpbmVkIGZvciB0aGUgcm93L2NlbGwuIElmIG1hdGNoaW5nXG5cdFx0ICogcm93cyBhcmUgZm91bmQsIHRoZSBkYXRhIHJldHVybmVkIGlzIHRoZSBvcmlnaW5hbCBkYXRhIGFycmF5L29iamVjdCB0aGF0IHdhcyB1c2VkIHRvXG5cdFx0ICogY3JlYXRlIHRoZSByb3cgKG9yIGEgZ2VuZXJhdGVkIGFycmF5IGlmIGZyb20gYSBET00gc291cmNlKS5cblx0XHQgKlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIG9mdGVuIHVzZWZ1bCBpbi1jb21iaW5hdGlvbiB3aXRoICQgd2hlcmUgYm90aCBmdW5jdGlvbnMgYXJlIGdpdmVuIHRoZVxuXHRcdCAqIHNhbWUgcGFyYW1ldGVycyBhbmQgdGhlIGFycmF5IGluZGV4ZXMgd2lsbCBtYXRjaCBpZGVudGljYWxseS5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IHNTZWxlY3RvciBqUXVlcnkgc2VsZWN0b3Igb3Igbm9kZSBjb2xsZWN0aW9uIHRvIGFjdCBvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gW29PcHRzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBtb2RpZnlpbmcgdGhlIHJvd3MgdG8gYmUgaW5jbHVkZWRcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5maWx0ZXI9bm9uZV0gU2VsZWN0IGVsZW1lbnRzIHRoYXQgbWVldCB0aGUgY3VycmVudCBmaWx0ZXJcblx0XHQgKiAgICBjcml0ZXJpb24gKFwiYXBwbGllZFwiKSBvciBhbGwgZWxlbWVudHMgKGkuZS4gbm8gZmlsdGVyKS5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5vcmRlcj1jdXJyZW50XSBPcmRlciBvZiB0aGUgZGF0YSBpbiB0aGUgcHJvY2Vzc2VkIGFycmF5LlxuXHRcdCAqICAgIENhbiBiZSBlaXRoZXIgJ2N1cnJlbnQnLCB3aGVyZWJ5IHRoZSBjdXJyZW50IHNvcnRpbmcgb2YgdGhlIHRhYmxlIGlzIHVzZWQsIG9yXG5cdFx0ICogICAgJ29yaWdpbmFsJyB3aGVyZWJ5IHRoZSBvcmlnaW5hbCBvcmRlciB0aGUgZGF0YSB3YXMgcmVhZCBpbnRvIHRoZSB0YWJsZSBpcyB1c2VkLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLnBhZ2U9YWxsXSBMaW1pdCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHBhZ2Vcblx0XHQgKiAgICAoXCJjdXJyZW50XCIpIG9yIG5vdCAoXCJhbGxcIikuIElmICdjdXJyZW50JyBpcyBnaXZlbiwgdGhlbiBvcmRlciBpcyBhc3N1bWVkIHRvIGJlXG5cdFx0ICogICAgJ2N1cnJlbnQnIGFuZCBmaWx0ZXIgaXMgJ2FwcGxpZWQnLCByZWdhcmRsZXNzIG9mIHdoYXQgdGhleSBtaWdodCBiZSBnaXZlbiBhcy5cblx0XHQgKiAgQHJldHVybnMge2FycmF5fSBEYXRhIGZvciB0aGUgbWF0Y2hlZCBlbGVtZW50cy4gSWYgYW55IGVsZW1lbnRzLCBhcyBhIHJlc3VsdCBvZiB0aGVcblx0XHQgKiAgICBzZWxlY3Rvciwgd2VyZSBub3QgVFIsIFREIG9yIFRIIGVsZW1lbnRzIGluIHRoZSBEYXRhVGFibGUsIHRoZXkgd2lsbCBoYXZlIGEgbnVsbFxuXHRcdCAqICAgIGVudHJ5IGluIHRoZSBhcnJheS5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gR2V0IHRoZSBkYXRhIGZyb20gdGhlIGZpcnN0IHJvdyBpbiB0aGUgdGFibGVcblx0XHQgKiAgICAgIHZhciBkYXRhID0gb1RhYmxlLl8oJ3RyOmZpcnN0Jyk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIERvIHNvbWV0aGluZyB1c2VmdWwgd2l0aCB0aGUgZGF0YVxuXHRcdCAqICAgICAgYWxlcnQoIFwiRmlyc3QgY2VsbCBpczogXCIrZGF0YVswXSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEZpbHRlciB0byAnV2Via2l0JyBhbmQgZ2V0IGFsbCBkYXRhIGZvclxuXHRcdCAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCdXZWJraXQnKTtcblx0XHQgKiAgICAgIHZhciBkYXRhID0gb1RhYmxlLl8oJ3RyJywge1wic2VhcmNoXCI6IFwiYXBwbGllZFwifSk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIERvIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhXG5cdFx0ICogICAgICBhbGVydCggZGF0YS5sZW5ndGgrXCIgcm93cyBtYXRjaGVkIHRoZSBzZWFyY2hcIiApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLl8gPSBmdW5jdGlvbiAoIHNTZWxlY3Rvciwgb09wdHMgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmFwaSh0cnVlKS5yb3dzKCBzU2VsZWN0b3IsIG9PcHRzICkuZGF0YSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgRGF0YVRhYmxlcyBBcGkgaW5zdGFuY2UsIHdpdGggdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YWJsZXMgZm9yXG5cdFx0ICogdGhlIEFwaSdzIGNvbnRleHQuXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdHJhZGl0aW9uYWw9ZmFsc2VdIFNldCB0aGUgQVBJIGluc3RhbmNlJ3MgY29udGV4dCB0byBiZVxuXHRcdCAqICAgb25seSB0aGUgdGFibGUgcmVmZXJyZWQgdG8gYnkgdGhlIGBEYXRhVGFibGUuZXh0LmlBcGlJbmRleGAgb3B0aW9uLCBhcyB3YXNcblx0XHQgKiAgIHVzZWQgaW4gdGhlIEFQSSBwcmVzZW50ZWQgYnkgRGF0YVRhYmxlcyAxLjktIChpLmUuIHRoZSB0cmFkaXRpb25hbCBtb2RlKSxcblx0XHQgKiAgIG9yIGlmIGFsbCB0YWJsZXMgY2FwdHVyZWQgaW4gdGhlIGpRdWVyeSBvYmplY3Qgc2hvdWxkIGJlIHVzZWQuXG5cdFx0ICogQHJldHVybiB7RGF0YVRhYmxlcy5BcGl9XG5cdFx0ICovXG5cdFx0dGhpcy5hcGkgPSBmdW5jdGlvbiAoIHRyYWRpdGlvbmFsIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdHJhZGl0aW9uYWwgP1xuXHRcdFx0XHRuZXcgX0FwaShcblx0XHRcdFx0XHRfZm5TZXR0aW5nc0Zyb21Ob2RlKCB0aGlzWyBfZXh0LmlBcGlJbmRleCBdIClcblx0XHRcdFx0KSA6XG5cdFx0XHRcdG5ldyBfQXBpKCB0aGlzICk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBBZGQgYSBzaW5nbGUgbmV3IHJvdyBvciBtdWx0aXBsZSByb3dzIG9mIGRhdGEgdG8gdGhlIHRhYmxlLiBQbGVhc2Ugbm90ZVxuXHRcdCAqIHRoYXQgdGhpcyBpcyBzdWl0YWJsZSBmb3IgY2xpZW50LXNpZGUgcHJvY2Vzc2luZyBvbmx5IC0gaWYgeW91IGFyZSB1c2luZ1xuXHRcdCAqIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgKGkuZS4gXCJiU2VydmVyU2lkZVwiOiB0cnVlKSwgdGhlbiB0byBhZGQgZGF0YSwgeW91XG5cdFx0ICogbXVzdCBhZGQgaXQgdG8gdGhlIGRhdGEgc291cmNlLCBpLmUuIHRoZSBzZXJ2ZXItc2lkZSwgdGhyb3VnaCBhbiBBamF4IGNhbGwuXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBkYXRhIFRoZSBkYXRhIHRvIGJlIGFkZGVkIHRvIHRoZSB0YWJsZS4gVGhpcyBjYW4gYmU6XG5cdFx0ICogICAgPHVsPlxuXHRcdCAqICAgICAgPGxpPjFEIGFycmF5IG9mIGRhdGEgLSBhZGQgYSBzaW5nbGUgcm93IHdpdGggdGhlIGRhdGEgcHJvdmlkZWQ8L2xpPlxuXHRcdCAqICAgICAgPGxpPjJEIGFycmF5IG9mIGFycmF5cyAtIGFkZCBtdWx0aXBsZSByb3dzIGluIGEgc2luZ2xlIGNhbGw8L2xpPlxuXHRcdCAqICAgICAgPGxpPm9iamVjdCAtIGRhdGEgb2JqZWN0IHdoZW4gdXNpbmcgPGk+bURhdGE8L2k+PC9saT5cblx0XHQgKiAgICAgIDxsaT5hcnJheSBvZiBvYmplY3RzIC0gbXVsdGlwbGUgZGF0YSBvYmplY3RzIHdoZW4gdXNpbmcgPGk+bURhdGE8L2k+PC9saT5cblx0XHQgKiAgICA8L3VsPlxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtyZWRyYXc9dHJ1ZV0gcmVkcmF3IHRoZSB0YWJsZSBvciBub3Rcblx0XHQgKiAgQHJldHVybnMge2FycmF5fSBBbiBhcnJheSBvZiBpbnRlZ2VycywgcmVwcmVzZW50aW5nIHRoZSBsaXN0IG9mIGluZGV4ZXMgaW5cblx0XHQgKiAgICA8aT5hb0RhdGE8L2k+ICh7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9KSB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0b1xuXHRcdCAqICAgIHRoZSB0YWJsZS5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gR2xvYmFsIHZhciBmb3IgY291bnRlclxuXHRcdCAqICAgIHZhciBnaUNvdW50ID0gMjtcblx0XHQgKlxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICBmdW5jdGlvbiBmbkNsaWNrQWRkUm93KCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKS5mbkFkZERhdGEoIFtcblx0XHQgKiAgICAgICAgZ2lDb3VudCtcIi4xXCIsXG5cdFx0ICogICAgICAgIGdpQ291bnQrXCIuMlwiLFxuXHRcdCAqICAgICAgICBnaUNvdW50K1wiLjNcIixcblx0XHQgKiAgICAgICAgZ2lDb3VudCtcIi40XCIgXVxuXHRcdCAqICAgICAgKTtcblx0XHQgKlxuXHRcdCAqICAgICAgZ2lDb3VudCsrO1xuXHRcdCAqICAgIH1cblx0XHQgKi9cblx0XHR0aGlzLmZuQWRkRGF0YSA9IGZ1bmN0aW9uKCBkYXRhLCByZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFxuXHRcdFx0LyogQ2hlY2sgaWYgd2Ugd2FudCB0byBhZGQgbXVsdGlwbGUgcm93cyBvciBub3QgKi9cblx0XHRcdHZhciByb3dzID0gJC5pc0FycmF5KGRhdGEpICYmICggJC5pc0FycmF5KGRhdGFbMF0pIHx8ICQuaXNQbGFpbk9iamVjdChkYXRhWzBdKSApID9cblx0XHRcdFx0YXBpLnJvd3MuYWRkKCBkYXRhICkgOlxuXHRcdFx0XHRhcGkucm93LmFkZCggZGF0YSApO1xuXHRcdFxuXHRcdFx0aWYgKCByZWRyYXcgPT09IHVuZGVmaW5lZCB8fCByZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRyZXR1cm4gcm93cy5mbGF0dGVuKCkudG9BcnJheSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiB3aWxsIG1ha2UgRGF0YVRhYmxlcyByZWNhbGN1bGF0ZSB0aGUgY29sdW1uIHNpemVzLCBiYXNlZCBvbiB0aGUgZGF0YVxuXHRcdCAqIGNvbnRhaW5lZCBpbiB0aGUgdGFibGUgYW5kIHRoZSBzaXplcyBhcHBsaWVkIHRvIHRoZSBjb2x1bW5zIChpbiB0aGUgRE9NLCBDU1Mgb3Jcblx0XHQgKiB0aHJvdWdoIHRoZSBzV2lkdGggcGFyYW1ldGVyKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSdzXG5cdFx0ICogcGFyZW50IGVsZW1lbnQgY2hhbmdlcyAoZm9yIGV4YW1wbGUgYSB3aW5kb3cgcmVzaXplKS5cblx0XHQgKiAgQHBhcmFtIHtib29sZWFufSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdCwgeW91IHdpbGwgdHlwaWNhbGx5IHdhbnQgdG9cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzU2Nyb2xsWVwiOiBcIjIwMHB4XCIsXG5cdFx0ICogICAgICAgIFwiYlBhZ2luYXRlXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgICQod2luZG93KS5vbigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICBvVGFibGUuZm5BZGp1c3RDb2x1bW5TaXppbmcoKTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkFkanVzdENvbHVtblNpemluZyA9IGZ1bmN0aW9uICggYlJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICkuY29sdW1ucy5hZGp1c3QoKTtcblx0XHRcdHZhciBzZXR0aW5ncyA9IGFwaS5zZXR0aW5ncygpWzBdO1xuXHRcdFx0dmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XG5cdFx0XG5cdFx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdyggZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzY3JvbGwuc1ggIT09IFwiXCIgfHwgc2Nyb2xsLnNZICE9PSBcIlwiICkge1xuXHRcdFx0XHQvKiBJZiBub3QgcmVkcmF3aW5nLCBidXQgc2Nyb2xsaW5nLCB3ZSB3YW50IHRvIGFwcGx5IHRoZSBuZXcgY29sdW1uIHNpemVzIGFueXdheSAqL1xuXHRcdFx0XHRfZm5TY3JvbGxEcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUXVpY2tseSBhbmQgc2ltcGx5IGNsZWFyIGEgdGFibGVcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSByZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBJbW1lZGlhdGVseSAnbnVrZScgdGhlIGN1cnJlbnQgcm93cyAocGVyaGFwcyB3YWl0aW5nIGZvciBhbiBBamF4IGNhbGxiYWNrLi4uKVxuXHRcdCAqICAgICAgb1RhYmxlLmZuQ2xlYXJUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuQ2xlYXJUYWJsZSA9IGZ1bmN0aW9uKCBiUmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5jbGVhcigpO1xuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBleGFjdCBvcHBvc2l0ZSBvZiAnb3BlbmluZycgYSByb3csIHRoaXMgZnVuY3Rpb24gd2lsbCBjbG9zZSBhbnkgcm93cyB3aGljaFxuXHRcdCAqIGFyZSBjdXJyZW50bHkgJ29wZW4nLlxuXHRcdCAqICBAcGFyYW0ge25vZGV9IG5UciB0aGUgdGFibGUgcm93IHRvICdjbG9zZSdcblx0XHQgKiAgQHJldHVybnMge2ludH0gMCBvbiBzdWNjZXNzLCBvciAxIGlmIGZhaWxlZCAoY2FuJ3QgZmluZCB0aGUgcm93KVxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGU7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vICdvcGVuJyBhbiBpbmZvcm1hdGlvbiByb3cgd2hlbiBhIHJvdyBpcyBjbGlja2VkIG9uXG5cdFx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIGlmICggb1RhYmxlLmZuSXNPcGVuKHRoaXMpICkge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbkNsb3NlKCB0aGlzICk7XG5cdFx0ICogICAgICAgIH0gZWxzZSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuT3BlbiggdGhpcywgXCJUZW1wb3Jhcnkgcm93IG9wZW5lZFwiLCBcImluZm9fcm93XCIgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuQ2xvc2UgPSBmdW5jdGlvbiggblRyIClcblx0XHR7XG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLnJvdyggblRyICkuY2hpbGQuaGlkZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGEgcm93IGZvciB0aGUgdGFibGVcblx0XHQgKiAgQHBhcmFtIHttaXhlZH0gdGFyZ2V0IFRoZSBpbmRleCBvZiB0aGUgcm93IGZyb20gYW9EYXRhIHRvIGJlIGRlbGV0ZWQsIG9yXG5cdFx0ICogICAgdGhlIFRSIGVsZW1lbnQgeW91IHdhbnQgdG8gZGVsZXRlXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gW2NhbGxCYWNrXSBDYWxsYmFjayBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtyZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3Rcblx0XHQgKiAgQHJldHVybnMge2FycmF5fSBUaGUgcm93IHRoYXQgd2FzIGRlbGV0ZWRcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBmaXJzdCByb3dcblx0XHQgKiAgICAgIG9UYWJsZS5mbkRlbGV0ZVJvdyggMCApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuRGVsZXRlUm93ID0gZnVuY3Rpb24oIHRhcmdldCwgY2FsbGJhY2ssIHJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XHR2YXIgcm93cyA9IGFwaS5yb3dzKCB0YXJnZXQgKTtcblx0XHRcdHZhciBzZXR0aW5ncyA9IHJvd3Muc2V0dGluZ3MoKVswXTtcblx0XHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhWyByb3dzWzBdWzBdIF07XG5cdFx0XG5cdFx0XHRyb3dzLnJlbW92ZSgpO1xuXHRcdFxuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggdGhpcywgc2V0dGluZ3MsIGRhdGEgKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmICggcmVkcmF3ID09PSB1bmRlZmluZWQgfHwgcmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXN0b3JlIHRoZSB0YWJsZSB0byBpdCdzIG9yaWdpbmFsIHN0YXRlIGluIHRoZSBET00gYnkgcmVtb3ZpbmcgYWxsIG9mIERhdGFUYWJsZXNcblx0XHQgKiBlbmhhbmNlbWVudHMsIGFsdGVyYXRpb25zIHRvIHRoZSBET00gc3RydWN0dXJlIG9mIHRoZSB0YWJsZSBhbmQgZXZlbnQgbGlzdGVuZXJzLlxuXHRcdCAqICBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmU9ZmFsc2VdIENvbXBsZXRlbHkgcmVtb3ZlIHRoZSB0YWJsZSBmcm9tIHRoZSBET01cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAvLyBUaGlzIGV4YW1wbGUgaXMgZmFpcmx5IHBvaW50bGVzcyBpbiByZWFsaXR5LCBidXQgc2hvd3MgaG93IGZuRGVzdHJveSBjYW4gYmUgdXNlZFxuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgICBvVGFibGUuZm5EZXN0cm95KCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5EZXN0cm95ID0gZnVuY3Rpb24gKCByZW1vdmUgKVxuXHRcdHtcblx0XHRcdHRoaXMuYXBpKCB0cnVlICkuZGVzdHJveSggcmVtb3ZlICk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWRyYXcgdGhlIHRhYmxlXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2NvbXBsZXRlPXRydWVdIFJlLWZpbHRlciBhbmQgcmVzb3J0IChpZiBlbmFibGVkKSB0aGUgdGFibGUgYmVmb3JlIHRoZSBkcmF3LlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBSZS1kcmF3IHRoZSB0YWJsZSAtIHlvdSB3b3VsZG4ndCB3YW50IHRvIGRvIGl0IGhlcmUsIGJ1dCBpdCdzIGFuIGV4YW1wbGUgOi0pXG5cdFx0ICogICAgICBvVGFibGUuZm5EcmF3KCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5EcmF3ID0gZnVuY3Rpb24oIGNvbXBsZXRlIClcblx0XHR7XG5cdFx0XHQvLyBOb3RlIHRoYXQgdGhpcyBpc24ndCBhbiBleGFjdCBtYXRjaCB0byB0aGUgb2xkIGNhbGwgdG8gX2ZuRHJhdyAtIGl0IHRha2VzXG5cdFx0XHQvLyBpbnRvIGFjY291bnQgdGhlIG5ldyBkYXRhLCBidXQgY2FuIGhvbGQgcG9zaXRpb24uXG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLmRyYXcoIGNvbXBsZXRlICk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBGaWx0ZXIgdGhlIGlucHV0IGJhc2VkIG9uIGRhdGFcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNJbnB1dCBTdHJpbmcgdG8gZmlsdGVyIHRoZSB0YWJsZSBvblxuXHRcdCAqICBAcGFyYW0ge2ludHxudWxsfSBbaUNvbHVtbl0gQ29sdW1uIHRvIGxpbWl0IGZpbHRlcmluZyB0b1xuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiUmVnZXg9ZmFsc2VdIFRyZWF0IGFzIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3Rcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlNtYXJ0PXRydWVdIFBlcmZvcm0gc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiU2hvd0dsb2JhbD10cnVlXSBTaG93IHRoZSBpbnB1dCBnbG9iYWwgZmlsdGVyIGluIGl0J3MgaW5wdXQgYm94KGVzKVxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiQ2FzZUluc2Vuc2l0aXZlPXRydWVdIERvIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcgKHRydWUpIG9yIG5vdCAoZmFsc2UpXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNvbWV0aW1lIGxhdGVyIC0gZmlsdGVyLi4uXG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoICd0ZXN0IHN0cmluZycgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkZpbHRlciA9IGZ1bmN0aW9uKCBzSW5wdXQsIGlDb2x1bW4sIGJSZWdleCwgYlNtYXJ0LCBiU2hvd0dsb2JhbCwgYkNhc2VJbnNlbnNpdGl2ZSApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHRpZiAoIGlDb2x1bW4gPT09IG51bGwgfHwgaUNvbHVtbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRhcGkuc2VhcmNoKCBzSW5wdXQsIGJSZWdleCwgYlNtYXJ0LCBiQ2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YXBpLmNvbHVtbiggaUNvbHVtbiApLnNlYXJjaCggc0lucHV0LCBiUmVnZXgsIGJTbWFydCwgYkNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0YXBpLmRyYXcoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgZGF0YSBmb3IgdGhlIHdob2xlIHRhYmxlLCBhbiBpbmRpdmlkdWFsIHJvdyBvciBhbiBpbmRpdmlkdWFsIGNlbGwgYmFzZWQgb24gdGhlXG5cdFx0ICogcHJvdmlkZWQgcGFyYW1ldGVycy5cblx0XHQgKiAgQHBhcmFtIHtpbnR8bm9kZX0gW3NyY10gQSBUUiByb3cgbm9kZSwgVEQvVEggY2VsbCBub2RlIG9yIGFuIGludGVnZXIuIElmIGdpdmVuIGFzXG5cdFx0ICogICAgYSBUUiBub2RlIHRoZW4gdGhlIGRhdGEgc291cmNlIGZvciB0aGUgd2hvbGUgcm93IHdpbGwgYmUgcmV0dXJuZWQuIElmIGdpdmVuIGFzIGFcblx0XHQgKiAgICBURC9USCBjZWxsIG5vZGUgdGhlbiBpQ29sIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB0aGUgZGF0YSBmb3IgdGhlXG5cdFx0ICogICAgY2VsbCByZXR1cm5lZC4gSWYgZ2l2ZW4gYXMgYW4gaW50ZWdlciwgdGhlbiB0aGlzIGlzIHRyZWF0ZWQgYXMgdGhlIGFvRGF0YSBpbnRlcm5hbFxuXHRcdCAqICAgIGRhdGEgaW5kZXggZm9yIHRoZSByb3cgKHNlZSBmbkdldFBvc2l0aW9uKSBhbmQgdGhlIGRhdGEgZm9yIHRoYXQgcm93IHVzZWQuXG5cdFx0ICogIEBwYXJhbSB7aW50fSBbY29sXSBPcHRpb25hbCBjb2x1bW4gaW5kZXggdGhhdCB5b3Ugd2FudCB0aGUgZGF0YSBvZi5cblx0XHQgKiAgQHJldHVybnMge2FycmF5fG9iamVjdHxzdHJpbmd9IElmIG1Sb3cgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBkYXRhIGZvciBhbGwgcm93cyBpc1xuXHRcdCAqICAgIHJldHVybmVkLiBJZiBtUm93IGlzIGRlZmluZWQsIGp1c3QgZGF0YSBmb3IgdGhhdCByb3csIGFuZCBpcyBpQ29sIGlzXG5cdFx0ICogICAgZGVmaW5lZCwgb25seSBkYXRhIGZvciB0aGUgZGVzaWduYXRlZCBjZWxsIGlzIHJldHVybmVkLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBSb3cgZGF0YVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlLiQoJ3RyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgdmFyIGRhdGEgPSBvVGFibGUuZm5HZXREYXRhKCB0aGlzICk7XG5cdFx0ICogICAgICAgIC8vIC4uLiBkbyBzb21ldGhpbmcgd2l0aCB0aGUgYXJyYXkgLyBvYmplY3Qgb2YgZGF0YSBmb3IgdGhlIHJvd1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIEluZGl2aWR1YWwgY2VsbCBkYXRhXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICBvVGFibGUuJCgndGQnKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICB2YXIgc0RhdGEgPSBvVGFibGUuZm5HZXREYXRhKCB0aGlzICk7XG5cdFx0ICogICAgICAgIGFsZXJ0KCAnVGhlIGNlbGwgY2xpY2tlZCBvbiBoYWQgdGhlIHZhbHVlIG9mICcrc0RhdGEgKTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkdldERhdGEgPSBmdW5jdGlvbiggc3JjLCBjb2wgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFxuXHRcdFx0aWYgKCBzcmMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dmFyIHR5cGUgPSBzcmMubm9kZU5hbWUgPyBzcmMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6ICcnO1xuXHRcdFxuXHRcdFx0XHRyZXR1cm4gY29sICE9PSB1bmRlZmluZWQgfHwgdHlwZSA9PSAndGQnIHx8IHR5cGUgPT0gJ3RoJyA/XG5cdFx0XHRcdFx0YXBpLmNlbGwoIHNyYywgY29sICkuZGF0YSgpIDpcblx0XHRcdFx0XHRhcGkucm93KCBzcmMgKS5kYXRhKCkgfHwgbnVsbDtcblx0XHRcdH1cblx0XHRcblx0XHRcdHJldHVybiBhcGkuZGF0YSgpLnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldCBhbiBhcnJheSBvZiB0aGUgVFIgbm9kZXMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGFibGUncyBib2R5LiBOb3RlIHRoYXQgeW91IHdpbGxcblx0XHQgKiB0eXBpY2FsbHkgd2FudCB0byB1c2UgdGhlICckJyBBUEkgbWV0aG9kIGluIHByZWZlcmVuY2UgdG8gdGhpcyBhcyBpdCBpcyBtb3JlXG5cdFx0ICogZmxleGlibGUuXG5cdFx0ICogIEBwYXJhbSB7aW50fSBbaVJvd10gT3B0aW9uYWwgcm93IGluZGV4IGZvciB0aGUgVFIgZWxlbWVudCB5b3Ugd2FudFxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl8bm9kZX0gSWYgaVJvdyBpcyB1bmRlZmluZWQsIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIFRSIGVsZW1lbnRzXG5cdFx0ICogICAgaW4gdGhlIHRhYmxlJ3MgYm9keSwgb3IgaVJvdyBpcyBkZWZpbmVkLCBqdXN0IHRoZSBUUiBlbGVtZW50IHJlcXVlc3RlZC5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gR2V0IHRoZSBub2RlcyBmcm9tIHRoZSB0YWJsZVxuXHRcdCAqICAgICAgdmFyIG5Ob2RlcyA9IG9UYWJsZS5mbkdldE5vZGVzKCApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuR2V0Tm9kZXMgPSBmdW5jdGlvbiggaVJvdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHRyZXR1cm4gaVJvdyAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0YXBpLnJvdyggaVJvdyApLm5vZGUoKSA6XG5cdFx0XHRcdGFwaS5yb3dzKCkubm9kZXMoKS5mbGF0dGVuKCkudG9BcnJheSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBhcnJheSBpbmRleGVzIG9mIGEgcGFydGljdWxhciBjZWxsIGZyb20gaXQncyBET00gZWxlbWVudFxuXHRcdCAqIGFuZCBjb2x1bW4gaW5kZXggaW5jbHVkaW5nIGhpZGRlbiBjb2x1bW5zXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gbm9kZSB0aGlzIGNhbiBlaXRoZXIgYmUgYSBUUiwgVEQgb3IgVEggaW4gdGhlIHRhYmxlJ3MgYm9keVxuXHRcdCAqICBAcmV0dXJucyB7aW50fSBJZiBuTm9kZSBpcyBnaXZlbiBhcyBhIFRSLCB0aGVuIGEgc2luZ2xlIGluZGV4IGlzIHJldHVybmVkLCBvclxuXHRcdCAqICAgIGlmIGdpdmVuIGFzIGEgY2VsbCwgYW4gYXJyYXkgb2YgW3JvdyBpbmRleCwgY29sdW1uIGluZGV4ICh2aXNpYmxlKSxcblx0XHQgKiAgICBjb2x1bW4gaW5kZXggKGFsbCldIGlzIGdpdmVuLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBkYXRhIGZyb20gdGhlIG5vZGVcblx0XHQgKiAgICAgICAgdmFyIGFQb3MgPSBvVGFibGUuZm5HZXRQb3NpdGlvbiggdGhpcyApO1xuXHRcdCAqXG5cdFx0ICogICAgICAgIC8vIEdldCB0aGUgZGF0YSBhcnJheSBmb3IgdGhpcyByb3dcblx0XHQgKiAgICAgICAgdmFyIGFEYXRhID0gb1RhYmxlLmZuR2V0RGF0YSggYVBvc1swXSApO1xuXHRcdCAqXG5cdFx0ICogICAgICAgIC8vIFVwZGF0ZSB0aGUgZGF0YSBhcnJheSBhbmQgcmV0dXJuIHRoZSB2YWx1ZVxuXHRcdCAqICAgICAgICBhRGF0YVsgYVBvc1sxXSBdID0gJ2NsaWNrZWQnO1xuXHRcdCAqICAgICAgICB0aGlzLmlubmVySFRNTCA9ICdjbGlja2VkJztcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSW5pdCBEYXRhVGFibGVzXG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuR2V0UG9zaXRpb24gPSBmdW5jdGlvbiggbm9kZSApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG5cdFx0XG5cdFx0XHRpZiAoIG5vZGVOYW1lID09ICdUUicgKSB7XG5cdFx0XHRcdHJldHVybiBhcGkucm93KCBub2RlICkuaW5kZXgoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBub2RlTmFtZSA9PSAnVEQnIHx8IG5vZGVOYW1lID09ICdUSCcgKSB7XG5cdFx0XHRcdHZhciBjZWxsID0gYXBpLmNlbGwoIG5vZGUgKS5pbmRleCgpO1xuXHRcdFxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdGNlbGwucm93LFxuXHRcdFx0XHRcdGNlbGwuY29sdW1uVmlzaWJsZSxcblx0XHRcdFx0XHRjZWxsLmNvbHVtblxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayB0byBzZWUgaWYgYSByb3cgaXMgJ29wZW4nIG9yIG5vdC5cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBuVHIgdGhlIHRhYmxlIHJvdyB0byBjaGVja1xuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgcm93IGlzIGN1cnJlbnRseSBvcGVuLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUgdGJvZHkgdHInKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xuXHRcdCAqICAgICAgICB9IGVsc2Uge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbklzT3BlbiA9IGZ1bmN0aW9uKCBuVHIgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmFwaSggdHJ1ZSApLnJvdyggblRyICkuY2hpbGQuaXNTaG93bigpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiB3aWxsIHBsYWNlIGEgbmV3IHJvdyBkaXJlY3RseSBhZnRlciBhIHJvdyB3aGljaCBpcyBjdXJyZW50bHlcblx0XHQgKiBvbiBkaXNwbGF5IG9uIHRoZSBwYWdlLCB3aXRoIHRoZSBIVE1MIGNvbnRlbnRzIHRoYXQgaXMgcGFzc2VkIGludG8gdGhlXG5cdFx0ICogZnVuY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBhc2sgZm9yIGNvbmZpcm1hdGlvbiB0aGF0IGFcblx0XHQgKiBwYXJ0aWN1bGFyIHJlY29yZCBzaG91bGQgYmUgZGVsZXRlZC5cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBuVHIgVGhlIHRhYmxlIHJvdyB0byAnb3Blbidcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IG1IdG1sIFRoZSBIVE1MIHRvIHB1dCBpbnRvIHRoZSByb3dcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNDbGFzcyBDbGFzcyB0byBnaXZlIHRoZSBuZXcgVEQgY2VsbFxuXHRcdCAqICBAcmV0dXJucyB7bm9kZX0gVGhlIHJvdyBvcGVuZWQuIE5vdGUgdGhhdCBpZiB0aGUgdGFibGUgcm93IHBhc3NlZCBpbiBhcyB0aGVcblx0XHQgKiAgICBmaXJzdCBwYXJhbWV0ZXIsIGlzIG5vdCBmb3VuZCBpbiB0aGUgdGFibGUsIHRoaXMgbWV0aG9kIHdpbGwgc2lsZW50bHlcblx0XHQgKiAgICByZXR1cm4uXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cblx0XHQgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcblx0XHQgKiAgICAgICAgfSBlbHNlIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5PcGVuID0gZnVuY3Rpb24oIG5UciwgbUh0bWwsIHNDbGFzcyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBpKCB0cnVlIClcblx0XHRcdFx0LnJvdyggblRyIClcblx0XHRcdFx0LmNoaWxkKCBtSHRtbCwgc0NsYXNzIClcblx0XHRcdFx0LnNob3coKVxuXHRcdFx0XHQuY2hpbGQoKVswXTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoYW5nZSB0aGUgcGFnaW5hdGlvbiAtIHByb3ZpZGVzIHRoZSBpbnRlcm5hbCBsb2dpYyBmb3IgcGFnaW5hdGlvbiBpbiBhIHNpbXBsZSBBUElcblx0XHQgKiBmdW5jdGlvbi4gV2l0aCB0aGlzIGZ1bmN0aW9uIHlvdSBjYW4gaGF2ZSBhIERhdGFUYWJsZXMgdGFibGUgZ28gdG8gdGhlIG5leHQsXG5cdFx0ICogcHJldmlvdXMsIGZpcnN0IG9yIGxhc3QgcGFnZXMuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfGludH0gbUFjdGlvbiBQYWdpbmcgYWN0aW9uIHRvIHRha2U6IFwiZmlyc3RcIiwgXCJwcmV2aW91c1wiLCBcIm5leHRcIiBvciBcImxhc3RcIlxuXHRcdCAqICAgIG9yIHBhZ2UgbnVtYmVyIHRvIGp1bXAgdG8gKGludGVnZXIpLCBub3RlIHRoYXQgcGFnZSAwIGlzIHRoZSBmaXJzdCBwYWdlLlxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgICBvVGFibGUuZm5QYWdlQ2hhbmdlKCAnbmV4dCcgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblBhZ2VDaGFuZ2UgPSBmdW5jdGlvbiAoIG1BY3Rpb24sIGJSZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApLnBhZ2UoIG1BY3Rpb24gKTtcblx0XHRcblx0XHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KGZhbHNlKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNob3cgYSBwYXJ0aWN1bGFyIGNvbHVtblxuXHRcdCAqICBAcGFyYW0ge2ludH0gaUNvbCBUaGUgY29sdW1uIHdob3NlIGRpc3BsYXkgc2hvdWxkIGJlIGNoYW5nZWRcblx0XHQgKiAgQHBhcmFtIHtib29sfSBiU2hvdyBTaG93ICh0cnVlKSBvciBoaWRlIChmYWxzZSkgdGhlIGNvbHVtblxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEhpZGUgdGhlIHNlY29uZCBjb2x1bW4gYWZ0ZXIgaW5pdGlhbGlzYXRpb25cblx0XHQgKiAgICAgIG9UYWJsZS5mblNldENvbHVtblZpcyggMSwgZmFsc2UgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblNldENvbHVtblZpcyA9IGZ1bmN0aW9uICggaUNvbCwgYlNob3csIGJSZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApLmNvbHVtbiggaUNvbCApLnZpc2libGUoIGJTaG93ICk7XG5cdFx0XG5cdFx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuY29sdW1ucy5hZGp1c3QoKS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHNldHRpbmdzIGZvciBhIHBhcnRpY3VsYXIgdGFibGUgZm9yIGV4dGVybmFsIG1hbmlwdWxhdGlvblxuXHRcdCAqICBAcmV0dXJucyB7b2JqZWN0fSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdC4gU2VlXG5cdFx0ICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgdmFyIG9TZXR0aW5ncyA9IG9UYWJsZS5mblNldHRpbmdzKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNob3cgYW4gZXhhbXBsZSBwYXJhbWV0ZXIgZnJvbSB0aGUgc2V0dGluZ3Ncblx0XHQgKiAgICAgIGFsZXJ0KCBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblNldHRpbmdzID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5TZXR0aW5nc0Zyb21Ob2RlKCB0aGlzW19leHQuaUFwaUluZGV4XSApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU29ydCB0aGUgdGFibGUgYnkgYSBwYXJ0aWN1bGFyIGNvbHVtblxuXHRcdCAqICBAcGFyYW0ge2ludH0gaUNvbCB0aGUgZGF0YSBpbmRleCB0byBzb3J0IG9uLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBtYXRjaCB0aGVcblx0XHQgKiAgICAnZGlzcGxheSBpbmRleCcgaWYgeW91IGhhdmUgaGlkZGVuIGRhdGEgZW50cmllc1xuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBTb3J0IGltbWVkaWF0ZWx5IHdpdGggY29sdW1ucyAwIGFuZCAxXG5cdFx0ICogICAgICBvVGFibGUuZm5Tb3J0KCBbIFswLCdhc2MnXSwgWzEsJ2FzYyddIF0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblNvcnQgPSBmdW5jdGlvbiggYWFTb3J0IClcblx0XHR7XG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLm9yZGVyKCBhYVNvcnQgKS5kcmF3KCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gY29sdW1uXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gbk5vZGUgdGhlIGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBzb3J0IGxpc3RlbmVyIHRvXG5cdFx0ICogIEBwYXJhbSB7aW50fSBpQ29sdW1uIHRoZSBjb2x1bW4gdGhhdCBhIGNsaWNrIG9uIHRoaXMgbm9kZSB3aWxsIHNvcnQgb25cblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2ZuQ2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gc29ydCBpcyBydW5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gU29ydCBvbiBjb2x1bW4gMSwgd2hlbiAnc29ydGVyJyBpcyBjbGlja2VkIG9uXG5cdFx0ICogICAgICBvVGFibGUuZm5Tb3J0TGlzdGVuZXIoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzb3J0ZXInKSwgMSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuU29ydExpc3RlbmVyID0gZnVuY3Rpb24oIG5Ob2RlLCBpQ29sdW1uLCBmbkNhbGxiYWNrIClcblx0XHR7XG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLm9yZGVyLmxpc3RlbmVyKCBuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjayApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIGEgdGFibGUgY2VsbCBvciByb3cgLSB0aGlzIG1ldGhvZCB3aWxsIGFjY2VwdCBlaXRoZXIgYSBzaW5nbGUgdmFsdWUgdG9cblx0XHQgKiB1cGRhdGUgdGhlIGNlbGwgd2l0aCwgYW4gYXJyYXkgb2YgdmFsdWVzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggY29sdW1uIG9yXG5cdFx0ICogYW4gb2JqZWN0IGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2UuIFRoZSBmdW5jdGlvbiBpc1xuXHRcdCAqIHNlbGYtcmVmZXJlbmNpbmcgaW4gb3JkZXIgdG8gbWFrZSB0aGUgbXVsdGkgY29sdW1uIHVwZGF0ZXMgZWFzaWVyLlxuXHRcdCAqICBAcGFyYW0ge29iamVjdHxhcnJheXxzdHJpbmd9IG1EYXRhIERhdGEgdG8gdXBkYXRlIHRoZSBjZWxsL3JvdyB3aXRoXG5cdFx0ICogIEBwYXJhbSB7bm9kZXxpbnR9IG1Sb3cgVFIgZWxlbWVudCB5b3Ugd2FudCB0byB1cGRhdGUgb3IgdGhlIGFvRGF0YSBpbmRleFxuXHRcdCAqICBAcGFyYW0ge2ludH0gW2lDb2x1bW5dIFRoZSBjb2x1bW4gdG8gdXBkYXRlLCBnaXZlIGFzIG51bGwgb3IgdW5kZWZpbmVkIHRvXG5cdFx0ICogICAgdXBkYXRlIGEgd2hvbGUgcm93LlxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JBY3Rpb249dHJ1ZV0gUGVyZm9ybSBwcmUtZHJhdyBhY3Rpb25zIG9yIG5vdFxuXHRcdCAqICBAcmV0dXJucyB7aW50fSAwIG9uIHN1Y2Nlc3MsIDEgb24gZXJyb3Jcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICAgIG9UYWJsZS5mblVwZGF0ZSggJ0V4YW1wbGUgdXBkYXRlJywgMCwgMCApOyAvLyBTaW5nbGUgY2VsbFxuXHRcdCAqICAgICAgb1RhYmxlLmZuVXBkYXRlKCBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddLCAkKCd0Ym9keSB0cicpWzBdICk7IC8vIFJvd1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuVXBkYXRlID0gZnVuY3Rpb24oIG1EYXRhLCBtUm93LCBpQ29sdW1uLCBiUmVkcmF3LCBiQWN0aW9uIClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XHRcblx0XHRcdGlmICggaUNvbHVtbiA9PT0gdW5kZWZpbmVkIHx8IGlDb2x1bW4gPT09IG51bGwgKSB7XG5cdFx0XHRcdGFwaS5yb3coIG1Sb3cgKS5kYXRhKCBtRGF0YSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGFwaS5jZWxsKCBtUm93LCBpQ29sdW1uICkuZGF0YSggbURhdGEgKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmICggYkFjdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGJBY3Rpb24gKSB7XG5cdFx0XHRcdGFwaS5jb2x1bW5zLmFkanVzdCgpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZSBhIGNvbW1vbiBtZXRob2QgZm9yIHBsdWctaW5zIHRvIGNoZWNrIHRoZSB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgYmVpbmcgdXNlZCwgaW4gb3JkZXJcblx0XHQgKiB0byBlbnN1cmUgY29tcGF0aWJpbGl0eS5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNWZXJzaW9uIFZlcnNpb24gc3RyaW5nIHRvIGNoZWNrIGZvciwgaW4gdGhlIGZvcm1hdCBcIlguWS5aXCIuIE5vdGUgdGhhdCB0aGVcblx0XHQgKiAgICBmb3JtYXRzIFwiWFwiIGFuZCBcIlguWVwiIGFyZSBhbHNvIGFjY2VwdGFibGUuXG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gdGhlIHJlcXVpcmVkXG5cdFx0ICogICAgdmVyc2lvbiwgb3IgZmFsc2UgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWxlcyBpcyBub3Qgc3VpdGFibGVcblx0XHQgKiAgQG1ldGhvZFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgYWxlcnQoIG9UYWJsZS5mblZlcnNpb25DaGVjayggJzEuOS4wJyApICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5WZXJzaW9uQ2hlY2sgPSBfZXh0LmZuVmVyc2lvbkNoZWNrO1xuXHRcdFxuXG5cdFx0dmFyIF90aGF0ID0gdGhpcztcblx0XHR2YXIgZW1wdHlJbml0ID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkO1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRcdGlmICggZW1wdHlJbml0ICkge1xuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdH1cblxuXHRcdHRoaXMub0FwaSA9IHRoaXMuaW50ZXJuYWwgPSBfZXh0LmludGVybmFsO1xuXG5cdFx0Ly8gRXh0ZW5kIHdpdGggb2xkIHN0eWxlIHBsdWctaW4gQVBJIG1ldGhvZHNcblx0XHRmb3IgKCB2YXIgZm4gaW4gRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCApIHtcblx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdHRoaXNbZm5dID0gX2ZuRXh0ZXJuQXBpRnVuYyhmbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gRm9yIGVhY2ggaW5pdGlhbGlzYXRpb24gd2Ugd2FudCB0byBnaXZlIGl0IGEgY2xlYW4gaW5pdGlhbGlzYXRpb25cblx0XHRcdC8vIG9iamVjdCB0aGF0IGNhbiBiZSBiYXNoZWQgYXJvdW5kXG5cdFx0XHR2YXIgbyA9IHt9O1xuXHRcdFx0dmFyIG9Jbml0ID0gbGVuID4gMSA/IC8vIG9wdGltaXNhdGlvbiBmb3Igc2luZ2xlIHRhYmxlIGNhc2Vcblx0XHRcdFx0X2ZuRXh0ZW5kKCBvLCBvcHRpb25zLCB0cnVlICkgOlxuXHRcdFx0XHRvcHRpb25zO1xuXG5cdFx0XHQvKmdsb2JhbCBvSW5pdCxfdGhhdCxlbXB0eUluaXQqL1xuXHRcdFx0dmFyIGk9MCwgaUxlbiwgaiwgakxlbiwgaywga0xlbjtcblx0XHRcdHZhciBzSWQgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdFx0dmFyIGJJbml0SGFuZGVkT2ZmID0gZmFsc2U7XG5cdFx0XHR2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHM7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8qIFNhbml0eSBjaGVjayAqL1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ3RhYmxlJyApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkxvZyggbnVsbCwgMCwgJ05vbi10YWJsZSBub2RlIGluaXRpYWxpc2F0aW9uICgnK3RoaXMubm9kZU5hbWUrJyknLCAyICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHRoZSBkZWZhdWx0cyAqL1xuXHRcdFx0X2ZuQ29tcGF0T3B0cyggZGVmYXVsdHMgKTtcblx0XHRcdF9mbkNvbXBhdENvbHMoIGRlZmF1bHRzLmNvbHVtbiApO1xuXHRcdFx0XG5cdFx0XHQvKiBDb252ZXJ0IHRoZSBjYW1lbC1jYXNlIGRlZmF1bHRzIHRvIEh1bmdhcmlhbiAqL1xuXHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMsIGRlZmF1bHRzLCB0cnVlICk7XG5cdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cy5jb2x1bW4sIGRlZmF1bHRzLmNvbHVtbiwgdHJ1ZSApO1xuXHRcdFx0XG5cdFx0XHQvKiBTZXR0aW5nIHVwIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3QgKi9cblx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLCAkLmV4dGVuZCggb0luaXQsICR0aGlzLmRhdGEoKSApICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvKiBDaGVjayB0byBzZWUgaWYgd2UgYXJlIHJlLWluaXRpYWxpc2luZyBhIHRhYmxlICovXG5cdFx0XHR2YXIgYWxsU2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49YWxsU2V0dGluZ3MubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0dmFyIHMgPSBhbGxTZXR0aW5nc1tpXTtcblx0XHRcdFxuXHRcdFx0XHQvKiBCYXNlIGNoZWNrIG9uIHRhYmxlIG5vZGUgKi9cblx0XHRcdFx0aWYgKCBzLm5UYWJsZSA9PSB0aGlzIHx8IHMublRIZWFkLnBhcmVudE5vZGUgPT0gdGhpcyB8fCAocy5uVEZvb3QgJiYgcy5uVEZvb3QucGFyZW50Tm9kZSA9PSB0aGlzKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgYlJldHJpZXZlID0gb0luaXQuYlJldHJpZXZlICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iUmV0cmlldmUgOiBkZWZhdWx0cy5iUmV0cmlldmU7XG5cdFx0XHRcdFx0dmFyIGJEZXN0cm95ID0gb0luaXQuYkRlc3Ryb3kgIT09IHVuZGVmaW5lZCA/IG9Jbml0LmJEZXN0cm95IDogZGVmYXVsdHMuYkRlc3Ryb3k7XG5cdFx0XHRcblx0XHRcdFx0XHRpZiAoIGVtcHR5SW5pdCB8fCBiUmV0cmlldmUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJldHVybiBzLm9JbnN0YW5jZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGJEZXN0cm95IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzLm9JbnN0YW5jZS5mbkRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0X2ZuTG9nKCBzLCAwLCAnQ2Fubm90IHJlaW5pdGlhbGlzZSBEYXRhVGFibGUnLCAzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQgd2UgYXJlIGluaXRpYWxpc2luZyBoYXMgdGhlIHNhbWUgSUQgYXMgYSB0YWJsZSB3aGljaCB3YXMgcHJldmlvdXNseVxuXHRcdFx0XHQgKiBpbml0aWFsaXNlZCwgYnV0IHRoZSB0YWJsZSBub2RlcyBkb24ndCBtYXRjaCAoZnJvbSBiZWZvcmUpIHRoZW4gd2UgZGVzdHJveSB0aGUgb2xkXG5cdFx0XHRcdCAqIGluc3RhbmNlIGJ5IHNpbXBseSBkZWxldGluZyBpdC4gVGhpcyBpcyB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSB0YWJsZSBoYXMgYmVlblxuXHRcdFx0XHQgKiBkZXN0cm95ZWQgYnkgb3RoZXIgbWV0aG9kcy4gQW55b25lIHVzaW5nIG5vbi1pZCBzZWxlY3RvcnMgd2lsbCBuZWVkIHRvIGRvIHRoaXMgbWFudWFsbHlcblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmICggcy5zVGFibGVJZCA9PSB0aGlzLmlkIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFsbFNldHRpbmdzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEVuc3VyZSB0aGUgdGFibGUgaGFzIGFuIElEIC0gcmVxdWlyZWQgZm9yIGFjY2Vzc2liaWxpdHkgKi9cblx0XHRcdGlmICggc0lkID09PSBudWxsIHx8IHNJZCA9PT0gXCJcIiApXG5cdFx0XHR7XG5cdFx0XHRcdHNJZCA9IFwiRGF0YVRhYmxlc19UYWJsZV9cIisoRGF0YVRhYmxlLmV4dC5fdW5pcXVlKyspO1xuXHRcdFx0XHR0aGlzLmlkID0gc0lkO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBDcmVhdGUgdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgdGhpcyB0YWJsZSBhbmQgc2V0IHNvbWUgb2YgdGhlIGRlZmF1bHQgcGFyYW1ldGVycyAqL1xuXHRcdFx0dmFyIG9TZXR0aW5ncyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MsIHtcblx0XHRcdFx0XCJzRGVzdHJveVdpZHRoXCI6ICR0aGlzWzBdLnN0eWxlLndpZHRoLFxuXHRcdFx0XHRcInNJbnN0YW5jZVwiOiAgICAgc0lkLFxuXHRcdFx0XHRcInNUYWJsZUlkXCI6ICAgICAgc0lkXG5cdFx0XHR9ICk7XG5cdFx0XHRvU2V0dGluZ3MublRhYmxlID0gdGhpcztcblx0XHRcdG9TZXR0aW5ncy5vQXBpICAgPSBfdGhhdC5pbnRlcm5hbDtcblx0XHRcdG9TZXR0aW5ncy5vSW5pdCAgPSBvSW5pdDtcblx0XHRcdFxuXHRcdFx0YWxsU2V0dGluZ3MucHVzaCggb1NldHRpbmdzICk7XG5cdFx0XHRcblx0XHRcdC8vIE5lZWQgdG8gYWRkIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgaW5zdGFuY2UgYWZ0ZXIgdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBhZGRlZFxuXHRcdFx0Ly8gdG8gdGhlIHNldHRpbmdzIGFycmF5LCBzbyB3ZSBjYW4gc2VsZiByZWZlcmVuY2UgdGhlIHRhYmxlIGluc3RhbmNlIGlmIG1vcmUgdGhhbiBvbmVcblx0XHRcdG9TZXR0aW5ncy5vSW5zdGFuY2UgPSAoX3RoYXQubGVuZ3RoPT09MSkgPyBfdGhhdCA6ICR0aGlzLmRhdGFUYWJsZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmVmb3JlIHdlIGFwcGx5IGFsbCB0aGUgZGVmYXVsdHNcblx0XHRcdF9mbkNvbXBhdE9wdHMoIG9Jbml0ICk7XG5cdFx0XHRcblx0XHRcdGlmICggb0luaXQub0xhbmd1YWdlIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuTGFuZ3VhZ2VDb21wYXQoIG9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgbGVuZ3RoIG1lbnUgaXMgZ2l2ZW4sIGJ1dCB0aGUgaW5pdCBkaXNwbGF5IGxlbmd0aCBpcyBub3QsIHVzZSB0aGUgbGVuZ3RoIG1lbnVcblx0XHRcdGlmICggb0luaXQuYUxlbmd0aE1lbnUgJiYgISBvSW5pdC5pRGlzcGxheUxlbmd0aCApXG5cdFx0XHR7XG5cdFx0XHRcdG9Jbml0LmlEaXNwbGF5TGVuZ3RoID0gJC5pc0FycmF5KCBvSW5pdC5hTGVuZ3RoTWVudVswXSApID9cblx0XHRcdFx0XHRvSW5pdC5hTGVuZ3RoTWVudVswXVswXSA6IG9Jbml0LmFMZW5ndGhNZW51WzBdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBBcHBseSB0aGUgZGVmYXVsdHMgYW5kIGluaXQgb3B0aW9ucyB0byBtYWtlIGEgc2luZ2xlIGluaXQgb2JqZWN0IHdpbGwgYWxsXG5cdFx0XHQvLyBvcHRpb25zIGRlZmluZWQgZnJvbSBkZWZhdWx0cyBhbmQgaW5zdGFuY2Ugb3B0aW9ucy5cblx0XHRcdG9Jbml0ID0gX2ZuRXh0ZW5kKCAkLmV4dGVuZCggdHJ1ZSwge30sIGRlZmF1bHRzICksIG9Jbml0ICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gTWFwIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zIG9udG8gdGhlIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLCBvSW5pdCwgW1xuXHRcdFx0XHRcImJQYWdpbmF0ZVwiLFxuXHRcdFx0XHRcImJMZW5ndGhDaGFuZ2VcIixcblx0XHRcdFx0XCJiRmlsdGVyXCIsXG5cdFx0XHRcdFwiYlNvcnRcIixcblx0XHRcdFx0XCJiU29ydE11bHRpXCIsXG5cdFx0XHRcdFwiYkluZm9cIixcblx0XHRcdFx0XCJiUHJvY2Vzc2luZ1wiLFxuXHRcdFx0XHRcImJBdXRvV2lkdGhcIixcblx0XHRcdFx0XCJiU29ydENsYXNzZXNcIixcblx0XHRcdFx0XCJiU2VydmVyU2lkZVwiLFxuXHRcdFx0XHRcImJEZWZlclJlbmRlclwiXG5cdFx0XHRdICk7XG5cdFx0XHRfZm5NYXAoIG9TZXR0aW5ncywgb0luaXQsIFtcblx0XHRcdFx0XCJhc1N0cmlwZUNsYXNzZXNcIixcblx0XHRcdFx0XCJhamF4XCIsXG5cdFx0XHRcdFwiZm5TZXJ2ZXJEYXRhXCIsXG5cdFx0XHRcdFwiZm5Gb3JtYXROdW1iZXJcIixcblx0XHRcdFx0XCJzU2VydmVyTWV0aG9kXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nRml4ZWRcIixcblx0XHRcdFx0XCJhTGVuZ3RoTWVudVwiLFxuXHRcdFx0XHRcInNQYWdpbmF0aW9uVHlwZVwiLFxuXHRcdFx0XHRcInNBamF4U291cmNlXCIsXG5cdFx0XHRcdFwic0FqYXhEYXRhUHJvcFwiLFxuXHRcdFx0XHRcImlTdGF0ZUR1cmF0aW9uXCIsXG5cdFx0XHRcdFwic0RvbVwiLFxuXHRcdFx0XHRcImJTb3J0Q2VsbHNUb3BcIixcblx0XHRcdFx0XCJpVGFiSW5kZXhcIixcblx0XHRcdFx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCIsXG5cdFx0XHRcdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiLFxuXHRcdFx0XHRcInJlbmRlcmVyXCIsXG5cdFx0XHRcdFwic2VhcmNoRGVsYXlcIixcblx0XHRcdFx0XCJyb3dJZFwiLFxuXHRcdFx0XHRbIFwiaUNvb2tpZUR1cmF0aW9uXCIsIFwiaVN0YXRlRHVyYXRpb25cIiBdLCAvLyBiYWNrd2FyZHMgY29tcGF0XG5cdFx0XHRcdFsgXCJvU2VhcmNoXCIsIFwib1ByZXZpb3VzU2VhcmNoXCIgXSxcblx0XHRcdFx0WyBcImFvU2VhcmNoQ29sc1wiLCBcImFvUHJlU2VhcmNoQ29sc1wiIF0sXG5cdFx0XHRcdFsgXCJpRGlzcGxheUxlbmd0aFwiLCBcIl9pRGlzcGxheUxlbmd0aFwiIF0sXG5cdFx0XHRcdFsgXCJiSlF1ZXJ5VUlcIiwgXCJiSlVJXCIgXVxuXHRcdFx0XSApO1xuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub1Njcm9sbCwgb0luaXQsIFtcblx0XHRcdFx0WyBcInNTY3JvbGxYXCIsIFwic1hcIiBdLFxuXHRcdFx0XHRbIFwic1Njcm9sbFhJbm5lclwiLCBcInNYSW5uZXJcIiBdLFxuXHRcdFx0XHRbIFwic1Njcm9sbFlcIiwgXCJzWVwiIF0sXG5cdFx0XHRcdFsgXCJiU2Nyb2xsQ29sbGFwc2VcIiwgXCJiQ29sbGFwc2VcIiBdXG5cdFx0XHRdICk7XG5cdFx0XHRfZm5NYXAoIG9TZXR0aW5ncy5vTGFuZ3VhZ2UsIG9Jbml0LCBcImZuSW5mb0NhbGxiYWNrXCIgKTtcblx0XHRcdFxuXHRcdFx0LyogQ2FsbGJhY2sgZnVuY3Rpb25zIHdoaWNoIGFyZSBhcnJheSBkcml2ZW4gKi9cblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsICAgICAgIG9Jbml0LmZuRHJhd0NhbGxiYWNrLCAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvU2VydmVyUGFyYW1zJywgICAgICAgb0luaXQuZm5TZXJ2ZXJQYXJhbXMsICAgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9TdGF0ZVNhdmVQYXJhbXMnLCAgICBvSW5pdC5mblN0YXRlU2F2ZVBhcmFtcywgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsICAgIG9Jbml0LmZuU3RhdGVMb2FkUGFyYW1zLCAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvU3RhdGVMb2FkZWQnLCAgICAgICAgb0luaXQuZm5TdGF0ZUxvYWRlZCwgICAgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Sb3dDYWxsYmFjaycsICAgICAgICBvSW5pdC5mblJvd0NhbGxiYWNrLCAgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1Jvd0NyZWF0ZWRDYWxsYmFjaycsIG9Jbml0LmZuQ3JlYXRlZFJvdywgICAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvSGVhZGVyQ2FsbGJhY2snLCAgICAgb0luaXQuZm5IZWFkZXJDYWxsYmFjaywgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Gb290ZXJDYWxsYmFjaycsICAgICBvSW5pdC5mbkZvb3RlckNhbGxiYWNrLCAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0luaXRDb21wbGV0ZScsICAgICAgIG9Jbml0LmZuSW5pdENvbXBsZXRlLCAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvUHJlRHJhd0NhbGxiYWNrJywgICAgb0luaXQuZm5QcmVEcmF3Q2FsbGJhY2ssICAgJ3VzZXInICk7XG5cdFx0XHRcblx0XHRcdG9TZXR0aW5ncy5yb3dJZEZuID0gX2ZuR2V0T2JqZWN0RGF0YUZuKCBvSW5pdC5yb3dJZCApO1xuXHRcdFx0XG5cdFx0XHQvKiBCcm93c2VyIHN1cHBvcnQgZGV0ZWN0aW9uICovXG5cdFx0XHRfZm5Ccm93c2VyRGV0ZWN0KCBvU2V0dGluZ3MgKTtcblx0XHRcdFxuXHRcdFx0dmFyIG9DbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuXHRcdFx0XG5cdFx0XHQvLyBAdG9kbyBSZW1vdmUgaW4gMS4xMVxuXHRcdFx0aWYgKCBvSW5pdC5iSlF1ZXJ5VUkgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBVc2UgdGhlIEpVSSBjbGFzc2VzIG9iamVjdCBmb3IgZGlzcGxheS4gWW91IGNvdWxkIGNsb25lIHRoZSBvU3RkQ2xhc3NlcyBvYmplY3QgaWZcblx0XHRcdFx0ICogeW91IHdhbnQgdG8gaGF2ZSBtdWx0aXBsZSB0YWJsZXMgd2l0aCBtdWx0aXBsZSBpbmRlcGVuZGVudCBjbGFzc2VzXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHQkLmV4dGVuZCggb0NsYXNzZXMsIERhdGFUYWJsZS5leHQub0pVSUNsYXNzZXMsIG9Jbml0Lm9DbGFzc2VzICk7XG5cdFx0XHRcblx0XHRcdFx0aWYgKCBvSW5pdC5zRG9tID09PSBkZWZhdWx0cy5zRG9tICYmIGRlZmF1bHRzLnNEb20gPT09IFwibGZydGlwXCIgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0LyogU2V0IHRoZSBET00gdG8gdXNlIGEgbGF5b3V0IHN1aXRhYmxlIGZvciBqUXVlcnkgVUkncyB0aGVtaW5nICovXG5cdFx0XHRcdFx0b1NldHRpbmdzLnNEb20gPSAnPFwiSFwibGZyPnQ8XCJGXCJpcD4nO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0aWYgKCAhIG9TZXR0aW5ncy5yZW5kZXJlciApIHtcblx0XHRcdFx0XHRvU2V0dGluZ3MucmVuZGVyZXIgPSAnanF1ZXJ5dWknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIG9TZXR0aW5ncy5yZW5kZXJlciApICYmICEgb1NldHRpbmdzLnJlbmRlcmVyLmhlYWRlciApIHtcblx0XHRcdFx0XHRvU2V0dGluZ3MucmVuZGVyZXIuaGVhZGVyID0gJ2pxdWVyeXVpJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHQkLmV4dGVuZCggb0NsYXNzZXMsIERhdGFUYWJsZS5leHQuY2xhc3Nlcywgb0luaXQub0NsYXNzZXMgKTtcblx0XHRcdH1cblx0XHRcdCR0aGlzLmFkZENsYXNzKCBvQ2xhc3Nlcy5zVGFibGUgKTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRpZiAoIG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9PT0gdW5kZWZpbmVkIClcblx0XHRcdHtcblx0XHRcdFx0LyogRGlzcGxheSBzdGFydCBwb2ludCwgdGFraW5nIGludG8gYWNjb3VudCB0aGUgc2F2ZSBzYXZpbmcgKi9cblx0XHRcdFx0b1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gb0luaXQuaURpc3BsYXlTdGFydDtcblx0XHRcdFx0b1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gb0luaXQuaURpc3BsYXlTdGFydDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCBvSW5pdC5pRGVmZXJMb2FkaW5nICE9PSBudWxsIClcblx0XHRcdHtcblx0XHRcdFx0b1NldHRpbmdzLmJEZWZlckxvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHR2YXIgdG1wID0gJC5pc0FycmF5KCBvSW5pdC5pRGVmZXJMb2FkaW5nICk7XG5cdFx0XHRcdG9TZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5ID0gdG1wID8gb0luaXQuaURlZmVyTG9hZGluZ1swXSA6IG9Jbml0LmlEZWZlckxvYWRpbmc7XG5cdFx0XHRcdG9TZXR0aW5ncy5faVJlY29yZHNUb3RhbCA9IHRtcCA/IG9Jbml0LmlEZWZlckxvYWRpbmdbMV0gOiBvSW5pdC5pRGVmZXJMb2FkaW5nO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBMYW5ndWFnZSBkZWZpbml0aW9ucyAqL1xuXHRcdFx0dmFyIG9MYW5ndWFnZSA9IG9TZXR0aW5ncy5vTGFuZ3VhZ2U7XG5cdFx0XHQkLmV4dGVuZCggdHJ1ZSwgb0xhbmd1YWdlLCBvSW5pdC5vTGFuZ3VhZ2UgKTtcblx0XHRcdFxuXHRcdFx0aWYgKCBvTGFuZ3VhZ2Uuc1VybCApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIEdldCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgZnJvbSBhIGZpbGUgLSBiZWNhdXNlIHRoaXMgQWpheCBjYWxsIG1ha2VzIHRoZSBsYW5ndWFnZVxuXHRcdFx0XHQgKiBnZXQgYXN5bmMgdG8gdGhlIHJlbWFpbmRlciBvZiB0aGlzIGZ1bmN0aW9uIHdlIHVzZSBiSW5pdEhhbmRlZE9mZiB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHRcdCAqIF9mbkluaXRpYWxpc2Ugd2lsbCBiZSBmaXJlZCBieSB0aGUgcmV0dXJuZWQgQWpheCBoYW5kbGVyLCByYXRoZXIgdGhhbiB0aGUgY29uc3RydWN0b3Jcblx0XHRcdFx0ICovXG5cdFx0XHRcdCQuYWpheCgge1xuXHRcdFx0XHRcdGRhdGFUeXBlOiAnanNvbicsXG5cdFx0XHRcdFx0dXJsOiBvTGFuZ3VhZ2Uuc1VybCxcblx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cdFx0XHRcdFx0XHRfZm5MYW5ndWFnZUNvbXBhdCgganNvbiApO1xuXHRcdFx0XHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMub0xhbmd1YWdlLCBqc29uICk7XG5cdFx0XHRcdFx0XHQkLmV4dGVuZCggdHJ1ZSwgb0xhbmd1YWdlLCBqc29uICk7XG5cdFx0XHRcdFx0XHRfZm5Jbml0aWFsaXNlKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHQvLyBFcnJvciBvY2N1cnJlZCBsb2FkaW5nIGxhbmd1YWdlIGZpbGUsIGNvbnRpbnVlIG9uIGFzIGJlc3Qgd2UgY2FuXG5cdFx0XHRcdFx0XHRfZm5Jbml0aWFsaXNlKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0YkluaXRIYW5kZWRPZmYgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKlxuXHRcdFx0ICogU3RyaXBlc1xuXHRcdFx0ICovXG5cdFx0XHRpZiAoIG9Jbml0LmFzU3RyaXBlQ2xhc3NlcyA9PT0gbnVsbCApXG5cdFx0XHR7XG5cdFx0XHRcdG9TZXR0aW5ncy5hc1N0cmlwZUNsYXNzZXMgPVtcblx0XHRcdFx0XHRvQ2xhc3Nlcy5zU3RyaXBlT2RkLFxuXHRcdFx0XHRcdG9DbGFzc2VzLnNTdHJpcGVFdmVuXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIFJlbW92ZSByb3cgc3RyaXBlIGNsYXNzZXMgaWYgdGhleSBhcmUgYWxyZWFkeSBvbiB0aGUgdGFibGUgcm93ICovXG5cdFx0XHR2YXIgc3RyaXBlQ2xhc3NlcyA9IG9TZXR0aW5ncy5hc1N0cmlwZUNsYXNzZXM7XG5cdFx0XHR2YXIgcm93T25lID0gJHRoaXMuY2hpbGRyZW4oJ3Rib2R5JykuZmluZCgndHInKS5lcSgwKTtcblx0XHRcdGlmICggJC5pbkFycmF5KCB0cnVlLCAkLm1hcCggc3RyaXBlQ2xhc3NlcywgZnVuY3Rpb24oZWwsIGkpIHtcblx0XHRcdFx0cmV0dXJuIHJvd09uZS5oYXNDbGFzcyhlbCk7XG5cdFx0XHR9ICkgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdCQoJ3Rib2R5IHRyJywgdGhpcykucmVtb3ZlQ2xhc3MoIHN0cmlwZUNsYXNzZXMuam9pbignICcpICk7XG5cdFx0XHRcdG9TZXR0aW5ncy5hc0Rlc3Ryb3lTdHJpcGVzID0gc3RyaXBlQ2xhc3Nlcy5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKlxuXHRcdFx0ICogQ29sdW1uc1xuXHRcdFx0ICogU2VlIGlmIHdlIHNob3VsZCBsb2FkIGNvbHVtbnMgYXV0b21hdGljYWxseSBvciB1c2UgZGVmaW5lZCBvbmVzXG5cdFx0XHQgKi9cblx0XHRcdHZhciBhblRocyA9IFtdO1xuXHRcdFx0dmFyIGFvQ29sdW1uc0luaXQ7XG5cdFx0XHR2YXIgblRoZWFkID0gdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGhlYWQnKTtcblx0XHRcdGlmICggblRoZWFkLmxlbmd0aCAhPT0gMCApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLmFvSGVhZGVyLCBuVGhlYWRbMF0gKTtcblx0XHRcdFx0YW5UaHMgPSBfZm5HZXRVbmlxdWVUaHMoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBJZiBub3QgZ2l2ZW4gYSBjb2x1bW4gYXJyYXksIGdlbmVyYXRlIG9uZSB3aXRoIG51bGxzICovXG5cdFx0XHRpZiAoIG9Jbml0LmFvQ29sdW1ucyA9PT0gbnVsbCApXG5cdFx0XHR7XG5cdFx0XHRcdGFvQ29sdW1uc0luaXQgPSBbXTtcblx0XHRcdFx0Zm9yICggaT0wLCBpTGVuPWFuVGhzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhb0NvbHVtbnNJbml0LnB1c2goIG51bGwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRhb0NvbHVtbnNJbml0ID0gb0luaXQuYW9Db2x1bW5zO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBBZGQgdGhlIGNvbHVtbnMgKi9cblx0XHRcdGZvciAoIGk9MCwgaUxlbj1hb0NvbHVtbnNJbml0Lmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkFkZENvbHVtbiggb1NldHRpbmdzLCBhblRocyA/IGFuVGhzW2ldIDogbnVsbCApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBBcHBseSB0aGUgY29sdW1uIGRlZmluaXRpb25zICovXG5cdFx0XHRfZm5BcHBseUNvbHVtbkRlZnMoIG9TZXR0aW5ncywgb0luaXQuYW9Db2x1bW5EZWZzLCBhb0NvbHVtbnNJbml0LCBmdW5jdGlvbiAoaUNvbCwgb0RlZikge1xuXHRcdFx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGlDb2wsIG9EZWYgKTtcblx0XHRcdH0gKTtcblx0XHRcdFxuXHRcdFx0LyogSFRNTDUgYXR0cmlidXRlIGRldGVjdGlvbiAtIGJ1aWxkIGFuIG1EYXRhIG9iamVjdCBhdXRvbWF0aWNhbGx5IGlmIHRoZVxuXHRcdFx0ICogYXR0cmlidXRlcyBhcmUgZm91bmRcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCByb3dPbmUubGVuZ3RoICkge1xuXHRcdFx0XHR2YXIgYSA9IGZ1bmN0aW9uICggY2VsbCwgbmFtZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY2VsbC5nZXRBdHRyaWJ1dGUoICdkYXRhLScrbmFtZSApICE9PSBudWxsID8gbmFtZSA6IG51bGw7XG5cdFx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFx0JCggcm93T25lWzBdICkuY2hpbGRyZW4oJ3RoLCB0ZCcpLmVhY2goIGZ1bmN0aW9uIChpLCBjZWxsKSB7XG5cdFx0XHRcdFx0dmFyIGNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XG5cdFx0XHRcblx0XHRcdFx0XHRpZiAoIGNvbC5tRGF0YSA9PT0gaSApIHtcblx0XHRcdFx0XHRcdHZhciBzb3J0ID0gYSggY2VsbCwgJ3NvcnQnICkgfHwgYSggY2VsbCwgJ29yZGVyJyApO1xuXHRcdFx0XHRcdFx0dmFyIGZpbHRlciA9IGEoIGNlbGwsICdmaWx0ZXInICkgfHwgYSggY2VsbCwgJ3NlYXJjaCcgKTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKCBzb3J0ICE9PSBudWxsIHx8IGZpbHRlciAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0Y29sLm1EYXRhID0ge1xuXHRcdFx0XHRcdFx0XHRcdF86ICAgICAgaSsnLmRpc3BsYXknLFxuXHRcdFx0XHRcdFx0XHRcdHNvcnQ6ICAgc29ydCAhPT0gbnVsbCAgID8gaSsnLkBkYXRhLScrc29ydCAgIDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6ICAgc29ydCAhPT0gbnVsbCAgID8gaSsnLkBkYXRhLScrc29ydCAgIDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHRcdGZpbHRlcjogZmlsdGVyICE9PSBudWxsID8gaSsnLkBkYXRhLScrZmlsdGVyIDogdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFx0XHRcdFx0X2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhciBmZWF0dXJlcyA9IG9TZXR0aW5ncy5vRmVhdHVyZXM7XG5cdFx0XHR2YXIgbG9hZGVkSW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Lypcblx0XHRcdFx0ICogU29ydGluZ1xuXHRcdFx0XHQgKiBAdG9kbyBGb3IgbW9kdWxhcmlzYXRpb24gKDEuMTEpIHRoaXMgbmVlZHMgdG8gZG8gaW50byBhIHNvcnQgc3RhcnQgdXAgaGFuZGxlclxuXHRcdFx0XHQgKi9cblx0XHRcdFxuXHRcdFx0XHQvLyBJZiBhYVNvcnRpbmcgaXMgbm90IGRlZmluZWQsIHRoZW4gd2UgdXNlIHRoZSBmaXJzdCBpbmRpY2F0b3IgaW4gYXNTb3J0aW5nXG5cdFx0XHRcdC8vIGluIGNhc2UgdGhhdCBoYXMgYmVlbiBhbHRlcmVkLCBzbyB0aGUgZGVmYXVsdCBzb3J0IHJlZmxlY3RzIHRoYXQgb3B0aW9uXG5cdFx0XHRcdGlmICggb0luaXQuYWFTb3J0aW5nID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dmFyIHNvcnRpbmcgPSBvU2V0dGluZ3MuYWFTb3J0aW5nO1xuXHRcdFx0XHRcdGZvciAoIGk9MCwgaUxlbj1zb3J0aW5nLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdFx0XHRcdHNvcnRpbmdbaV1bMV0gPSBvU2V0dGluZ3MuYW9Db2x1bW5zWyBpIF0uYXNTb3J0aW5nWzBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdC8qIERvIGEgZmlyc3QgcGFzcyBvbiB0aGUgc29ydGluZyBjbGFzc2VzIChhbGxvd3MgYW55IHNpemUgY2hhbmdlcyB0byBiZSB0YWtlbiBpbnRvXG5cdFx0XHRcdCAqIGFjY291bnQsIGFuZCBhbHNvIHdpbGwgYXBwbHkgc29ydGluZyBkaXNhYmxlZCBjbGFzc2VzIGlmIGRpc2FibGVkXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRfZm5Tb3J0aW5nQ2xhc3Nlcyggb1NldHRpbmdzICk7XG5cdFx0XHRcblx0XHRcdFx0aWYgKCBmZWF0dXJlcy5iU29ydCApIHtcblx0XHRcdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG9TZXR0aW5ncy5iU29ydGVkICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYVNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0XHRcdHZhciBzb3J0ZWRDb2x1bW5zID0ge307XG5cdFx0XHRcblx0XHRcdFx0XHRcdFx0JC5lYWNoKCBhU29ydCwgZnVuY3Rpb24gKGksIHZhbCkge1xuXHRcdFx0XHRcdFx0XHRcdHNvcnRlZENvbHVtbnNbIHZhbC5zcmMgXSA9IHZhbC5kaXI7XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ29yZGVyJywgW29TZXR0aW5ncywgYVNvcnQsIHNvcnRlZENvbHVtbnNdICk7XG5cdFx0XHRcdFx0XHRcdF9mblNvcnRBcmlhKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKCBvU2V0dGluZ3MuYlNvcnRlZCB8fCBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PT0gJ3NzcCcgfHwgZmVhdHVyZXMuYkRlZmVyUmVuZGVyICkge1xuXHRcdFx0XHRcdFx0X2ZuU29ydGluZ0NsYXNzZXMoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgJ3NjJyApO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFx0Lypcblx0XHRcdFx0ICogRmluYWwgaW5pdFxuXHRcdFx0XHQgKiBDYWNoZSB0aGUgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIgYXMgcmVxdWlyZWQsIGNyZWF0aW5nIHRoZW0gaWYgbmVlZGVkXG5cdFx0XHRcdCAqL1xuXHRcdFx0XG5cdFx0XHRcdC8vIFdvcmsgYXJvdW5kIGZvciBXZWJraXQgYnVnIDgzODY3IC0gc3RvcmUgdGhlIGNhcHRpb24tc2lkZSBiZWZvcmUgcmVtb3ZpbmcgZnJvbSBkb2Ncblx0XHRcdFx0dmFyIGNhcHRpb25zID0gJHRoaXMuY2hpbGRyZW4oJ2NhcHRpb24nKS5lYWNoKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FwdGlvblNpZGUgPSAkKHRoaXMpLmNzcygnY2FwdGlvbi1zaWRlJyk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFxuXHRcdFx0XHR2YXIgdGhlYWQgPSAkdGhpcy5jaGlsZHJlbigndGhlYWQnKTtcblx0XHRcdFx0aWYgKCB0aGVhZC5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0dGhlYWQgPSAkKCc8dGhlYWQvPicpLmFwcGVuZFRvKCR0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvU2V0dGluZ3MublRIZWFkID0gdGhlYWRbMF07XG5cdFx0XHRcblx0XHRcdFx0dmFyIHRib2R5ID0gJHRoaXMuY2hpbGRyZW4oJ3Rib2R5Jyk7XG5cdFx0XHRcdGlmICggdGJvZHkubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRcdHRib2R5ID0gJCgnPHRib2R5Lz4nKS5hcHBlbmRUbygkdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0b1NldHRpbmdzLm5UQm9keSA9IHRib2R5WzBdO1xuXHRcdFx0XG5cdFx0XHRcdHZhciB0Zm9vdCA9ICR0aGlzLmNoaWxkcmVuKCd0Zm9vdCcpO1xuXHRcdFx0XHRpZiAoIHRmb290Lmxlbmd0aCA9PT0gMCAmJiBjYXB0aW9ucy5sZW5ndGggPiAwICYmIChvU2V0dGluZ3Mub1Njcm9sbC5zWCAhPT0gXCJcIiB8fCBvU2V0dGluZ3Mub1Njcm9sbC5zWSAhPT0gXCJcIikgKSB7XG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGEgc2Nyb2xsaW5nIHRhYmxlLCBhbmQgbm8gZm9vdGVyIGhhcyBiZWVuIGdpdmVuLCB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlXG5cdFx0XHRcdFx0Ly8gYSB0Zm9vdCBlbGVtZW50IGZvciB0aGUgY2FwdGlvbiBlbGVtZW50IHRvIGJlIGFwcGVuZGVkIHRvXG5cdFx0XHRcdFx0dGZvb3QgPSAkKCc8dGZvb3QvPicpLmFwcGVuZFRvKCR0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdGlmICggdGZvb3QubGVuZ3RoID09PSAwIHx8IHRmb290LmNoaWxkcmVuKCkubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRcdCR0aGlzLmFkZENsYXNzKCBvQ2xhc3Nlcy5zTm9Gb290ZXIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggdGZvb3QubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0XHRvU2V0dGluZ3MublRGb290ID0gdGZvb3RbMF07XG5cdFx0XHRcdFx0X2ZuRGV0ZWN0SGVhZGVyKCBvU2V0dGluZ3MuYW9Gb290ZXIsIG9TZXR0aW5ncy5uVEZvb3QgKTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdC8qIENoZWNrIGlmIHRoZXJlIGlzIGRhdGEgcGFzc2luZyBpbnRvIHRoZSBjb25zdHJ1Y3RvciAqL1xuXHRcdFx0XHRpZiAoIG9Jbml0LmFhRGF0YSApIHtcblx0XHRcdFx0XHRmb3IgKCBpPTAgOyBpPG9Jbml0LmFhRGF0YS5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRfZm5BZGREYXRhKCBvU2V0dGluZ3MsIG9Jbml0LmFhRGF0YVsgaSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBvU2V0dGluZ3MuYkRlZmVyTG9hZGluZyB8fCBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnZG9tJyApIHtcblx0XHRcdFx0XHQvKiBHcmFiIHRoZSBkYXRhIGZyb20gdGhlIHBhZ2UgLSBvbmx5IGRvIHRoaXMgd2hlbiBkZWZlcnJlZCBsb2FkaW5nIG9yIG5vIEFqYXhcblx0XHRcdFx0XHQgKiBzb3VyY2Ugc2luY2UgdGhlcmUgaXMgbm8gcG9pbnQgaW4gcmVhZGluZyB0aGUgRE9NIGRhdGEgaWYgd2UgYXJlIHRoZW4gZ29pbmdcblx0XHRcdFx0XHQgKiB0byByZXBsYWNlIGl0IHdpdGggQWpheCBkYXRhXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0X2ZuQWRkVHIoIG9TZXR0aW5ncywgJChvU2V0dGluZ3MublRCb2R5KS5jaGlsZHJlbigndHInKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogQ29weSB0aGUgZGF0YSBpbmRleCBhcnJheSAqL1xuXHRcdFx0XHRvU2V0dGluZ3MuYWlEaXNwbGF5ID0gb1NldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdFx0XG5cdFx0XHRcdC8qIEluaXRpYWxpc2F0aW9uIGNvbXBsZXRlIC0gdGFibGUgY2FuIGJlIGRyYXduICovXG5cdFx0XHRcdG9TZXR0aW5ncy5iSW5pdGlhbGlzZWQgPSB0cnVlO1xuXHRcdFx0XG5cdFx0XHRcdC8qIENoZWNrIGlmIHdlIG5lZWQgdG8gaW5pdGlhbGlzZSB0aGUgdGFibGUgKGl0IG1pZ2h0IG5vdCBoYXZlIGJlZW4gaGFuZGVkIG9mZiB0byB0aGVcblx0XHRcdFx0ICogbGFuZ3VhZ2UgcHJvY2Vzc29yKVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0aWYgKCBiSW5pdEhhbmRlZE9mZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qIE11c3QgYmUgZG9uZSBhZnRlciBldmVyeXRoaW5nIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdGF0ZSBzYXZpbmchICovXG5cdFx0XHRpZiAoIG9Jbml0LmJTdGF0ZVNhdmUgKVxuXHRcdFx0e1xuXHRcdFx0XHRmZWF0dXJlcy5iU3RhdGVTYXZlID0gdHJ1ZTtcblx0XHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgX2ZuU2F2ZVN0YXRlLCAnc3RhdGVfc2F2ZScgKTtcblx0XHRcdFx0X2ZuTG9hZFN0YXRlKCBvU2V0dGluZ3MsIG9Jbml0LCBsb2FkZWRJbml0ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bG9hZGVkSW5pdCgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSApO1xuXHRcdF90aGF0ID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRcblx0Lypcblx0ICogSXQgaXMgdXNlZnVsIHRvIGhhdmUgdmFyaWFibGVzIHdoaWNoIGFyZSBzY29wZWQgbG9jYWxseSBzbyBvbmx5IHRoZVxuXHQgKiBEYXRhVGFibGVzIGZ1bmN0aW9ucyBjYW4gYWNjZXNzIHRoZW0gYW5kIHRoZXkgZG9uJ3QgbGVhayBpbnRvIGdsb2JhbCBzcGFjZS5cblx0ICogQXQgdGhlIHNhbWUgdGltZSB0aGVzZSBmdW5jdGlvbnMgYXJlIG9mdGVuIHVzZWZ1bCBvdmVyIG11bHRpcGxlIGZpbGVzIGluIHRoZVxuXHQgKiBjb3JlIGFuZCBBUEksIHNvIHdlIGxpc3QsIG9yIGF0IGxlYXN0IGRvY3VtZW50LCBhbGwgdmFyaWFibGVzIHdoaWNoIGFyZSB1c2VkXG5cdCAqIGJ5IERhdGFUYWJsZXMgYXMgcHJpdmF0ZSB2YXJpYWJsZXMgaGVyZS4gVGhpcyBhbHNvIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBub1xuXHQgKiBjbGFzaGluZyBvZiB2YXJpYWJsZSBuYW1lcyBhbmQgdGhhdCB0aGV5IGNhbiBlYXNpbHkgcmVmZXJlbmNlZCBmb3IgcmV1c2UuXG5cdCAqL1xuXHRcblx0XG5cdC8vIERlZmluZWQgZWxzZSB3aGVyZVxuXHQvLyAgX3NlbGVjdG9yX3J1blxuXHQvLyAgX3NlbGVjdG9yX29wdHNcblx0Ly8gIF9zZWxlY3Rvcl9maXJzdFxuXHQvLyAgX3NlbGVjdG9yX3Jvd19pbmRleGVzXG5cdFxuXHR2YXIgX2V4dDsgLy8gRGF0YVRhYmxlLmV4dFxuXHR2YXIgX0FwaTsgLy8gRGF0YVRhYmxlLkFwaVxuXHR2YXIgX2FwaV9yZWdpc3RlcjsgLy8gRGF0YVRhYmxlLkFwaS5yZWdpc3RlclxuXHR2YXIgX2FwaV9yZWdpc3RlclBsdXJhbDsgLy8gRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbFxuXHRcblx0dmFyIF9yZV9kaWMgPSB7fTtcblx0dmFyIF9yZV9uZXdfbGluZXMgPSAvW1xcclxcbl0vZztcblx0dmFyIF9yZV9odG1sID0gLzwuKj8+L2c7XG5cdFxuXHQvLyBUaGlzIGlzIG5vdCBzdHJpY3QgSVNPODYwMSAtIERhdGUucGFyc2UoKSBpcyBxdWl0ZSBsYXgsIGFsdGhvdWdoXG5cdC8vIGltcGxlbWVudGF0aW9ucyBkaWZmZXIgYmV0d2VlbiBicm93c2Vycy5cblx0dmFyIF9yZV9kYXRlID0gL15cXGR7Miw0fVtcXC5cXC9cXC1dXFxkezEsMn1bXFwuXFwvXFwtXVxcZHsxLDJ9KFtUIF17MX1cXGR7MSwyfVs6XFwuXVxcZHsyfShbXFwuOl1cXGR7Mn0pPyk/JC87XG5cdFxuXHQvLyBFc2NhcGUgcmVndWxhciBleHByZXNzaW9uIHNwZWNpYWwgY2hhcmFjdGVyc1xuXHR2YXIgX3JlX2VzY2FwZV9yZWdleCA9IG5ldyBSZWdFeHAoICcoXFxcXCcgKyBbICcvJywgJy4nLCAnKicsICcrJywgJz8nLCAnfCcsICcoJywgJyknLCAnWycsICddJywgJ3snLCAnfScsICdcXFxcJywgJyQnLCAnXicsICctJyBdLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyApO1xuXHRcblx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gb3JlaWduX2V4Y2hhbmdlX21hcmtldFxuXHQvLyAtIFxcdTIwQkQgLSBSdXNzaWFuIHJ1YmxlLlxuXHQvLyAtIFxcdTIwYTkgLSBTb3V0aCBLb3JlYW4gV29uXG5cdC8vIC0gXFx1MjBCQSAtIFR1cmtpc2ggTGlyYVxuXHQvLyAtIFxcdTIwQjkgLSBJbmRpYW4gUnVwZWVcblx0Ly8gLSBSIC0gQnJhemlsIChSJCkgYW5kIFNvdXRoIEFmcmljYVxuXHQvLyAtIGZyIC0gU3dpc3MgRnJhbmNcblx0Ly8gLSBrciAtIFN3ZWRpc2gga3JvbmEsIE5vcndlZ2lhbiBrcm9uZSBhbmQgRGFuaXNoIGtyb25lXG5cdC8vIC0gXFx1MjAwOSBpcyB0aGluIHNwYWNlIGFuZCBcXHUyMDJGIGlzIG5hcnJvdyBuby1icmVhayBzcGFjZSwgYm90aCB1c2VkIGluIG1hbnlcblx0Ly8gICBzdGFuZGFyZHMgYXMgdGhvdXNhbmRzIHNlcGFyYXRvcnMuXG5cdHZhciBfcmVfZm9ybWF0dGVkX251bWVyaWMgPSAvWycsJMKj4oKswqUlXFx1MjAwOVxcdTIwMkZcXHUyMEJEXFx1MjBhOVxcdTIwQkFyZmtdL2dpO1xuXHRcblx0XG5cdHZhciBfZW1wdHkgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0cmV0dXJuICFkIHx8IGQgPT09IHRydWUgfHwgZCA9PT0gJy0nID8gdHJ1ZSA6IGZhbHNlO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfaW50VmFsID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdHZhciBpbnRlZ2VyID0gcGFyc2VJbnQoIHMsIDEwICk7XG5cdFx0cmV0dXJuICFpc05hTihpbnRlZ2VyKSAmJiBpc0Zpbml0ZShzKSA/IGludGVnZXIgOiBudWxsO1xuXHR9O1xuXHRcblx0Ly8gQ29udmVydCBmcm9tIGEgZm9ybWF0dGVkIG51bWJlciB3aXRoIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBgLmAgYXMgdGhlXG5cdC8vIGRlY2ltYWwgcGxhY2UsIHRvIGEgSmF2YXNjcmlwdCBudW1iZXJcblx0dmFyIF9udW1Ub0RlY2ltYWwgPSBmdW5jdGlvbiAoIG51bSwgZGVjaW1hbFBvaW50ICkge1xuXHRcdC8vIENhY2hlIGNyZWF0ZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3BlZWQgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb2Z0ZW5cblx0XHRpZiAoICEgX3JlX2RpY1sgZGVjaW1hbFBvaW50IF0gKSB7XG5cdFx0XHRfcmVfZGljWyBkZWNpbWFsUG9pbnQgXSA9IG5ldyBSZWdFeHAoIF9mbkVzY2FwZVJlZ2V4KCBkZWNpbWFsUG9pbnQgKSwgJ2cnICk7XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlb2YgbnVtID09PSAnc3RyaW5nJyAmJiBkZWNpbWFsUG9pbnQgIT09ICcuJyA/XG5cdFx0XHRudW0ucmVwbGFjZSggL1xcLi9nLCAnJyApLnJlcGxhY2UoIF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdLCAnLicgKSA6XG5cdFx0XHRudW07XG5cdH07XG5cdFxuXHRcblx0dmFyIF9pc051bWJlciA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQgKSB7XG5cdFx0dmFyIHN0clR5cGUgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZyc7XG5cdFxuXHRcdC8vIElmIGVtcHR5IHJldHVybiBpbW1lZGlhdGVseSBzbyB0aGVyZSBtdXN0IGJlIGEgbnVtYmVyIGlmIGl0IGlzIGFcblx0XHQvLyBmb3JtYXR0ZWQgc3RyaW5nICh0aGlzIHN0b3BzIHRoZSBzdHJpbmcgXCJrXCIsIG9yIFwia3JcIiwgZXRjIGJlaW5nIGRldGVjdGVkXG5cdFx0Ly8gYXMgYSBmb3JtYXR0ZWQgbnVtYmVyIGZvciBjdXJyZW5jeVxuXHRcdGlmICggX2VtcHR5KCBkICkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdGlmICggZGVjaW1hbFBvaW50ICYmIHN0clR5cGUgKSB7XG5cdFx0XHRkID0gX251bVRvRGVjaW1hbCggZCwgZGVjaW1hbFBvaW50ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZvcm1hdHRlZCAmJiBzdHJUeXBlICkge1xuXHRcdFx0ZCA9IGQucmVwbGFjZSggX3JlX2Zvcm1hdHRlZF9udW1lcmljLCAnJyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuICFpc05hTiggcGFyc2VGbG9hdChkKSApICYmIGlzRmluaXRlKCBkICk7XG5cdH07XG5cdFxuXHRcblx0Ly8gQSBzdHJpbmcgd2l0aG91dCBIVE1MIGluIGl0IGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIEhUTUwgc3RpbGxcblx0dmFyIF9pc0h0bWwgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0cmV0dXJuIF9lbXB0eSggZCApIHx8IHR5cGVvZiBkID09PSAnc3RyaW5nJztcblx0fTtcblx0XG5cdFxuXHR2YXIgX2h0bWxOdW1lcmljID0gZnVuY3Rpb24gKCBkLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCApIHtcblx0XHRpZiAoIF9lbXB0eSggZCApICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcblx0XHR2YXIgaHRtbCA9IF9pc0h0bWwoIGQgKTtcblx0XHRyZXR1cm4gISBodG1sID9cblx0XHRcdG51bGwgOlxuXHRcdFx0X2lzTnVtYmVyKCBfc3RyaXBIdG1sKCBkICksIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkICkgP1xuXHRcdFx0XHR0cnVlIDpcblx0XHRcdFx0bnVsbDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3BsdWNrID0gZnVuY3Rpb24gKCBhLCBwcm9wLCBwcm9wMiApIHtcblx0XHR2YXIgb3V0ID0gW107XG5cdFx0dmFyIGk9MCwgaWVuPWEubGVuZ3RoO1xuXHRcblx0XHQvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuXHRcdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdFx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhW2ldICYmIGFbaV1bIHByb3AgXSApIHtcblx0XHRcdFx0XHRvdXQucHVzaCggYVtpXVsgcHJvcCBdWyBwcm9wMiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGFbaV0gKSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIGFbaV1bIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdC8vIEJhc2ljYWxseSB0aGUgc2FtZSBhcyBfcGx1Y2ssIGJ1dCByYXRoZXIgdGhhbiBsb29waW5nIG92ZXIgYGFgIHdlIHVzZSBgb3JkZXJgXG5cdC8vIGFzIHRoZSBpbmRleGVzIHRvIHBpY2sgZnJvbSBgYWBcblx0dmFyIF9wbHVja19vcmRlciA9IGZ1bmN0aW9uICggYSwgb3JkZXIsIHByb3AsIHByb3AyIClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XHR2YXIgaT0wLCBpZW49b3JkZXIubGVuZ3RoO1xuXHRcblx0XHQvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuXHRcdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdFx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhWyBvcmRlcltpXSBdWyBwcm9wIF0gKSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXVsgcHJvcDIgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3JhbmdlID0gZnVuY3Rpb24gKCBsZW4sIHN0YXJ0IClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XHR2YXIgZW5kO1xuXHRcblx0XHRpZiAoIHN0YXJ0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRlbmQgPSBsZW47XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZW5kID0gc3RhcnQ7XG5cdFx0XHRzdGFydCA9IGxlbjtcblx0XHR9XG5cdFxuXHRcdGZvciAoIHZhciBpPXN0YXJ0IDsgaTxlbmQgOyBpKysgKSB7XG5cdFx0XHRvdXQucHVzaCggaSApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3JlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKCBhIClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFbaV0gKSB7IC8vIGNhcmVmdWwgLSB3aWxsIHJlbW92ZSBhbGwgZmFsc3kgdmFsdWVzIVxuXHRcdFx0XHRvdXQucHVzaCggYVtpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3N0cmlwSHRtbCA9IGZ1bmN0aW9uICggZCApIHtcblx0XHRyZXR1cm4gZC5yZXBsYWNlKCBfcmVfaHRtbCwgJycgKTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGFsbCB2YWx1ZXMgaW4gdGhlIGFycmF5IGFyZSB1bmlxdWUuIFRoaXMgbWVhbnMgd2UgY2FuIHNob3J0XG5cdCAqIGN1dCB0aGUgX3VuaXF1ZSBtZXRob2QgYXQgdGhlIGNvc3Qgb2YgYSBzaW5nbGUgbG9vcC4gQSBzb3J0ZWQgYXJyYXkgaXMgdXNlZFxuXHQgKiB0byBlYXNpbHkgY2hlY2sgdGhlIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbGwgdW5pcXVlLCBmYWxzZSBvdGhlcndpc2Vcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9hcmVBbGxVbmlxdWUgPSBmdW5jdGlvbiAoIHNyYyApIHtcblx0XHRpZiAoIHNyYy5sZW5ndGggPCAyICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcblx0XHR2YXIgc29ydGVkID0gc3JjLnNsaWNlKCkuc29ydCgpO1xuXHRcdHZhciBsYXN0ID0gc29ydGVkWzBdO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0xLCBpZW49c29ydGVkLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBzb3J0ZWRbaV0gPT09IGxhc3QgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHRsYXN0ID0gc29ydGVkW2ldO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbmQgdGhlIHVuaXF1ZSBlbGVtZW50cyBpbiBhIHNvdXJjZSBhcnJheS5cblx0ICpcblx0ICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcblx0ICogQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIHVuaXF1ZSBpdGVtc1xuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHR2YXIgX3VuaXF1ZSA9IGZ1bmN0aW9uICggc3JjIClcblx0e1xuXHRcdGlmICggX2FyZUFsbFVuaXF1ZSggc3JjICkgKSB7XG5cdFx0XHRyZXR1cm4gc3JjLnNsaWNlKCk7XG5cdFx0fVxuXHRcblx0XHQvLyBBIGZhc3RlciB1bmlxdWUgbWV0aG9kIGlzIHRvIHVzZSBvYmplY3Qga2V5cyB0byBpZGVudGlmeSB1c2VkIHZhbHVlcyxcblx0XHQvLyBidXQgdGhpcyBkb2Vzbid0IHdvcmsgd2l0aCBhcnJheXMgb3Igb2JqZWN0cywgd2hpY2ggd2UgbXVzdCBhbHNvXG5cdFx0Ly8gY29uc2lkZXIuIFNlZSBqc3BlcmYuY29tL2NvbXBhcmUtYXJyYXktdW5pcXVlLXZlcnNpb25zLzQgZm9yIG1vcmVcblx0XHQvLyBpbmZvcm1hdGlvbi5cblx0XHR2YXJcblx0XHRcdG91dCA9IFtdLFxuXHRcdFx0dmFsLFxuXHRcdFx0aSwgaWVuPXNyYy5sZW5ndGgsXG5cdFx0XHRqLCBrPTA7XG5cdFxuXHRcdGFnYWluOiBmb3IgKCBpPTAgOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhbCA9IHNyY1tpXTtcblx0XG5cdFx0XHRmb3IgKCBqPTAgOyBqPGsgOyBqKysgKSB7XG5cdFx0XHRcdGlmICggb3V0W2pdID09PSB2YWwgKSB7XG5cdFx0XHRcdFx0Y29udGludWUgYWdhaW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRvdXQucHVzaCggdmFsICk7XG5cdFx0XHRrKys7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIHV0aWxpdHkgbWV0aG9kc1xuXHQgKiBcblx0ICogVGhpcyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIG1ldGhvZHMgdGhhdCBEYXRhVGFibGVzIHVzZXMgaW50ZXJuYWxseSB0b1xuXHQgKiBjcmVhdGUgYSBEYXRhVGFibGUsIGJ1dCB3aGljaCBhcmUgbm90IGV4Y2x1c2l2ZWx5IHVzZWQgb25seSBmb3IgRGF0YVRhYmxlcy5cblx0ICogVGhlc2UgbWV0aG9kcyBjYW4gYmUgdXNlZCBieSBleHRlbnNpb24gYXV0aG9ycyB0byBzYXZlIHRoZSBkdXBsaWNhdGlvbiBvZlxuXHQgKiBjb2RlLlxuXHQgKlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLnV0aWwgPSB7XG5cdFx0LyoqXG5cdFx0ICogVGhyb3R0bGUgdGhlIGNhbGxzIHRvIGEgZnVuY3Rpb24uIEFyZ3VtZW50cyBhbmQgY29udGV4dCBhcmUgbWFpbnRhaW5lZFxuXHRcdCAqIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5cdFx0ICogQHBhcmFtIHtpbnRlZ2VyfSBmcmVxIENhbGwgZnJlcXVlbmN5IGluIG1TXG5cdFx0ICogQHJldHVybiB7ZnVuY3Rpb259IFdyYXBwZWQgZnVuY3Rpb25cblx0XHQgKi9cblx0XHR0aHJvdHRsZTogZnVuY3Rpb24gKCBmbiwgZnJlcSApIHtcblx0XHRcdHZhclxuXHRcdFx0XHRmcmVxdWVuY3kgPSBmcmVxICE9PSB1bmRlZmluZWQgPyBmcmVxIDogMjAwLFxuXHRcdFx0XHRsYXN0LFxuXHRcdFx0XHR0aW1lcjtcblx0XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRub3cgID0gK25ldyBEYXRlKCksXG5cdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cztcblx0XG5cdFx0XHRcdGlmICggbGFzdCAmJiBub3cgPCBsYXN0ICsgZnJlcXVlbmN5ICkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCggdGltZXIgKTtcblx0XG5cdFx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0Zm4uYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHR9LCBmcmVxdWVuY3kgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRsYXN0ID0gbm93O1xuXHRcdFx0XHRcdGZuLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gdmFsIHN0cmluZyB0byBlc2NhcGVcblx0XHQgKiAgQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcblx0XHQgKi9cblx0XHRlc2NhcGVSZWdleDogZnVuY3Rpb24gKCB2YWwgKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnJlcGxhY2UoIF9yZV9lc2NhcGVfcmVnZXgsICdcXFxcJDEnICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIGEgbWFwcGluZyBvYmplY3QgdGhhdCBhbGxvd3MgY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIGJlIGxvb2tlZCB1cFxuXHQgKiBmb3IgdGhlaXIgSHVuZ2FyaWFuIGNvdW50ZXJwYXJ0cy4gVGhlIG1hcHBpbmcgaXMgc3RvcmVkIGluIGEgcHJpdmF0ZVxuXHQgKiBwYXJhbWV0ZXIgY2FsbGVkIGBfaHVuZ2FyaWFuTWFwYCB3aGljaCBjYW4gYmUgYWNjZXNzZWQgb24gdGhlIHNvdXJjZSBvYmplY3QuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5IdW5nYXJpYW5NYXAgKCBvIClcblx0e1xuXHRcdHZhclxuXHRcdFx0aHVuZ2FyaWFuID0gJ2EgYWEgYWkgYW8gYXMgYiBmbiBpIG0gbyBzICcsXG5cdFx0XHRtYXRjaCxcblx0XHRcdG5ld0tleSxcblx0XHRcdG1hcCA9IHt9O1xuXHRcblx0XHQkLmVhY2goIG8sIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0bWF0Y2ggPSBrZXkubWF0Y2goL14oW15BLVpdKz8pKFtBLVpdKS8pO1xuXHRcblx0XHRcdGlmICggbWF0Y2ggJiYgaHVuZ2FyaWFuLmluZGV4T2YobWF0Y2hbMV0rJyAnKSAhPT0gLTEgKVxuXHRcdFx0e1xuXHRcdFx0XHRuZXdLZXkgPSBrZXkucmVwbGFjZSggbWF0Y2hbMF0sIG1hdGNoWzJdLnRvTG93ZXJDYXNlKCkgKTtcblx0XHRcdFx0bWFwWyBuZXdLZXkgXSA9IGtleTtcblx0XG5cdFx0XHRcdGlmICggbWF0Y2hbMV0gPT09ICdvJyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRfZm5IdW5nYXJpYW5NYXAoIG9ba2V5XSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRvLl9odW5nYXJpYW5NYXAgPSBtYXA7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVydCBmcm9tIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBIdW5nYXJpYW4sIGJhc2VkIG9uIGEgSHVuZ2FyaWFuIG1hcFxuXHQgKiBjcmVhdGVkIGJ5IF9mbkh1bmdhcmlhbk1hcC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgVGhlIG1vZGVsIG9iamVjdCB3aGljaCBob2xkcyBhbGwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZVxuXHQgKiAgICBtYXBwZWQuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gdXNlciBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHRvIEh1bmdhcmlhbi5cblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hlbiBzZXQgdG8gYHRydWVgLCBwcm9wZXJ0aWVzIHdoaWNoIGFscmVhZHkgaGF2ZSBhXG5cdCAqICAgIEh1bmdhcmlhbiB2YWx1ZSBpbiB0aGUgYHVzZXJgIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0dGVuLiBPdGhlcndpc2UgdGhleVxuXHQgKiAgICB3b24ndCBiZS5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ2FtZWxUb0h1bmdhcmlhbiAoIHNyYywgdXNlciwgZm9yY2UgKVxuXHR7XG5cdFx0aWYgKCAhIHNyYy5faHVuZ2FyaWFuTWFwICkge1xuXHRcdFx0X2ZuSHVuZ2FyaWFuTWFwKCBzcmMgKTtcblx0XHR9XG5cdFxuXHRcdHZhciBodW5nYXJpYW5LZXk7XG5cdFxuXHRcdCQuZWFjaCggdXNlciwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdFx0XHRodW5nYXJpYW5LZXkgPSBzcmMuX2h1bmdhcmlhbk1hcFsga2V5IF07XG5cdFxuXHRcdFx0aWYgKCBodW5nYXJpYW5LZXkgIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgdXNlcltodW5nYXJpYW5LZXldID09PSB1bmRlZmluZWQpIClcblx0XHRcdHtcblx0XHRcdFx0Ly8gRm9yIG9iamVjdHMsIHdlIG5lZWQgdG8gYnV6eiBkb3duIGludG8gdGhlIG9iamVjdCB0byBjb3B5IHBhcmFtZXRlcnNcblx0XHRcdFx0aWYgKCBodW5nYXJpYW5LZXkuY2hhckF0KDApID09PSAnbycgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gQ29weSB0aGUgY2FtZWxDYXNlIG9wdGlvbnMgb3ZlciB0byB0aGUgaHVuZ2FyaWFuXG5cdFx0XHRcdFx0aWYgKCAhIHVzZXJbIGh1bmdhcmlhbktleSBdICkge1xuXHRcdFx0XHRcdFx0dXNlclsgaHVuZ2FyaWFuS2V5IF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JC5leHRlbmQoIHRydWUsIHVzZXJbaHVuZ2FyaWFuS2V5XSwgdXNlcltrZXldICk7XG5cdFxuXHRcdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIHNyY1todW5nYXJpYW5LZXldLCB1c2VyW2h1bmdhcmlhbktleV0sIGZvcmNlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dXNlcltodW5nYXJpYW5LZXldID0gdXNlclsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogTGFuZ3VhZ2UgY29tcGF0aWJpbGl0eSAtIHdoZW4gY2VydGFpbiBvcHRpb25zIGFyZSBnaXZlbiwgYW5kIG90aGVycyBhcmVuJ3QsIHdlXG5cdCAqIG5lZWQgdG8gZHVwbGljYXRlIHRoZSB2YWx1ZXMgb3ZlciwgaW4gb3JkZXIgdG8gcHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHQgKiB3aXRoIG9sZGVyIGxhbmd1YWdlIGZpbGVzLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5MYW5ndWFnZUNvbXBhdCggbGFuZyApXG5cdHtcblx0XHR2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHMub0xhbmd1YWdlO1xuXHRcdHZhciB6ZXJvUmVjb3JkcyA9IGxhbmcuc1plcm9SZWNvcmRzO1xuXHRcblx0XHQvKiBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAtIGlmIHRoZXJlIGlzIG5vIHNFbXB0eVRhYmxlIGdpdmVuLCB0aGVuIHVzZSB0aGUgc2FtZSBhc1xuXHRcdCAqIHNaZXJvUmVjb3JkcyAtIGFzc3VtaW5nIHRoYXQgaXMgZ2l2ZW4uXG5cdFx0ICovXG5cdFx0aWYgKCAhIGxhbmcuc0VtcHR5VGFibGUgJiYgemVyb1JlY29yZHMgJiZcblx0XHRcdGRlZmF1bHRzLnNFbXB0eVRhYmxlID09PSBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCIgKVxuXHRcdHtcblx0XHRcdF9mbk1hcCggbGFuZywgbGFuZywgJ3NaZXJvUmVjb3JkcycsICdzRW1wdHlUYWJsZScgKTtcblx0XHR9XG5cdFxuXHRcdC8qIExpa2V3aXNlIHdpdGggbG9hZGluZyByZWNvcmRzICovXG5cdFx0aWYgKCAhIGxhbmcuc0xvYWRpbmdSZWNvcmRzICYmIHplcm9SZWNvcmRzICYmXG5cdFx0XHRkZWZhdWx0cy5zTG9hZGluZ1JlY29yZHMgPT09IFwiTG9hZGluZy4uLlwiIClcblx0XHR7XG5cdFx0XHRfZm5NYXAoIGxhbmcsIGxhbmcsICdzWmVyb1JlY29yZHMnLCAnc0xvYWRpbmdSZWNvcmRzJyApO1xuXHRcdH1cblx0XG5cdFx0Ly8gT2xkIHBhcmFtZXRlciBuYW1lIG9mIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIG1hcHBlZCBvbnRvIHRoZSBuZXdcblx0XHRpZiAoIGxhbmcuc0luZm9UaG91c2FuZHMgKSB7XG5cdFx0XHRsYW5nLnNUaG91c2FuZHMgPSBsYW5nLnNJbmZvVGhvdXNhbmRzO1xuXHRcdH1cblx0XG5cdFx0dmFyIGRlY2ltYWwgPSBsYW5nLnNEZWNpbWFsO1xuXHRcdGlmICggZGVjaW1hbCApIHtcblx0XHRcdF9hZGROdW1lcmljU29ydCggZGVjaW1hbCApO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBNYXAgb25lIHBhcmFtZXRlciBvbnRvIGFub3RoZXJcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIE9iamVjdCB0byBtYXBcblx0ICogIEBwYXJhbSB7Kn0ga25ldyBUaGUgbmV3IHBhcmFtZXRlciBuYW1lXG5cdCAqICBAcGFyYW0geyp9IG9sZCBUaGUgb2xkIHBhcmFtZXRlciBuYW1lXG5cdCAqL1xuXHR2YXIgX2ZuQ29tcGF0TWFwID0gZnVuY3Rpb24gKCBvLCBrbmV3LCBvbGQgKSB7XG5cdFx0aWYgKCBvWyBrbmV3IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG9bIG9sZCBdID0gb1sga25ldyBdO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIG1haW4gRFQgb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXdcblx0ICogb3B0aW9ucyBhcmUgbWFwcGVkIG9udG8gdGhlIG9sZCBwYXJhbWV0ZXJzLCBzbyB0aGlzIGlzIGFuIGV4dGVybmFsIGludGVyZmFjZVxuXHQgKiBjaGFuZ2Ugb25seS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbXBhdE9wdHMgKCBpbml0IClcblx0e1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyaW5nJywgICAgICAnYlNvcnQnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJNdWx0aScsICAgICdiU29ydE11bHRpJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyQ2xhc3NlcycsICAnYlNvcnRDbGFzc2VzJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyQ2VsbHNUb3AnLCAnYlNvcnRDZWxsc1RvcCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlcicsICAgICAgICAgJ2FhU29ydGluZycgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckZpeGVkJywgICAgJ2FhU29ydGluZ0ZpeGVkJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2luZycsICAgICAgICAnYlBhZ2luYXRlJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2luZ1R5cGUnLCAgICAnc1BhZ2luYXRpb25UeXBlJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2VMZW5ndGgnLCAgICAnaURpc3BsYXlMZW5ndGgnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnc2VhcmNoaW5nJywgICAgICdiRmlsdGVyJyApO1xuXHRcblx0XHQvLyBCb29sZWFuIGluaXRpYWxpc2F0aW9uIG9mIHgtc2Nyb2xsaW5nXG5cdFx0aWYgKCB0eXBlb2YgaW5pdC5zU2Nyb2xsWCA9PT0gJ2Jvb2xlYW4nICkge1xuXHRcdFx0aW5pdC5zU2Nyb2xsWCA9IGluaXQuc1Njcm9sbFggPyAnMTAwJScgOiAnJztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgaW5pdC5zY3JvbGxYID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRpbml0LnNjcm9sbFggPSBpbml0LnNjcm9sbFggPyAnMTAwJScgOiAnJztcblx0XHR9XG5cdFxuXHRcdC8vIENvbHVtbiBzZWFyY2ggb2JqZWN0cyBhcmUgaW4gYW4gYXJyYXksIHNvIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxuXHRcdC8vIGVsZW1lbnQgYnkgZWxlbWVudFxuXHRcdHZhciBzZWFyY2hDb2xzID0gaW5pdC5hb1NlYXJjaENvbHM7XG5cdFxuXHRcdGlmICggc2VhcmNoQ29scyApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1zZWFyY2hDb2xzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHNlYXJjaENvbHNbaV0gKSB7XG5cdFx0XHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgY29sdW1uIG9wdGlvbnMuIE5vdGUgdGhhdCB0aGUgbmV3IG9wdGlvbnNcblx0ICogYXJlIG1hcHBlZCBvbnRvIHRoZSBvbGQgcGFyYW1ldGVycywgc28gdGhpcyBpcyBhbiBleHRlcm5hbCBpbnRlcmZhY2UgY2hhbmdlXG5cdCAqIG9ubHkuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gaW5pdCBPYmplY3QgdG8gbWFwXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Db21wYXRDb2xzICggaW5pdCApXG5cdHtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlcmFibGUnLCAgICAgJ2JTb3J0YWJsZScgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckRhdGEnLCAgICAgJ2FEYXRhU29ydCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlclNlcXVlbmNlJywgJ2FzU29ydGluZycgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckRhdGFUeXBlJywgJ3NvcnREYXRhVHlwZScgKTtcblx0XG5cdFx0Ly8gb3JkZXJEYXRhIGNhbiBiZSBnaXZlbiBhcyBhbiBpbnRlZ2VyXG5cdFx0dmFyIGRhdGFTb3J0ID0gaW5pdC5hRGF0YVNvcnQ7XG5cdFx0aWYgKCB0eXBlb2YgZGF0YVNvcnQgPT09ICdudW1iZXInICYmICEgJC5pc0FycmF5KCBkYXRhU29ydCApICkge1xuXHRcdFx0aW5pdC5hRGF0YVNvcnQgPSBbIGRhdGFTb3J0IF07XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJyb3dzZXIgZmVhdHVyZSBkZXRlY3Rpb24gZm9yIGNhcGFiaWxpdGllcywgcXVpcmtzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQnJvd3NlckRldGVjdCggc2V0dGluZ3MgKVxuXHR7XG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0byBkbyB0aGlzIGV2ZXJ5IHRpbWUgRGF0YVRhYmxlcyBpcyBjb25zdHJ1Y3RlZCwgdGhlIHZhbHVlc1xuXHRcdC8vIGNhbGN1bGF0ZWQgYXJlIHNwZWNpZmljIHRvIHRoZSBicm93c2VyIGFuZCBPUyBjb25maWd1cmF0aW9uIHdoaWNoIHdlXG5cdFx0Ly8gZG9uJ3QgZXhwZWN0IHRvIGNoYW5nZSBiZXR3ZWVuIGluaXRpYWxpc2F0aW9uc1xuXHRcdGlmICggISBEYXRhVGFibGUuX19icm93c2VyICkge1xuXHRcdFx0dmFyIGJyb3dzZXIgPSB7fTtcblx0XHRcdERhdGFUYWJsZS5fX2Jyb3dzZXIgPSBicm93c2VyO1xuXHRcblx0XHRcdC8vIFNjcm9sbGluZyBmZWF0dXJlIC8gcXVpcmtzIGRldGVjdGlvblxuXHRcdFx0dmFyIG4gPSAkKCc8ZGl2Lz4nKVxuXHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0cG9zaXRpb246ICdmaXhlZCcsXG5cdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdGxlZnQ6ICQod2luZG93KS5zY3JvbGxMZWZ0KCkqLTEsIC8vIGFsbG93IGZvciBzY3JvbGxpbmdcblx0XHRcdFx0XHRoZWlnaHQ6IDEsXG5cdFx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdCQoJzxkaXYvPicpXG5cdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0XHR0b3A6IDEsXG5cdFx0XHRcdFx0XHRcdGxlZnQ6IDEsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAxMDAsXG5cdFx0XHRcdFx0XHRcdG92ZXJmbG93OiAnc2Nyb2xsJ1xuXHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IDEwXG5cdFx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdClcblx0XHRcdFx0LmFwcGVuZFRvKCAnYm9keScgKTtcblx0XG5cdFx0XHR2YXIgb3V0ZXIgPSBuLmNoaWxkcmVuKCk7XG5cdFx0XHR2YXIgaW5uZXIgPSBvdXRlci5jaGlsZHJlbigpO1xuXHRcblx0XHRcdC8vIE51bWJlcnMgYmVsb3csIGluIG9yZGVyLCBhcmU6XG5cdFx0XHQvLyBpbm5lci5vZmZzZXRXaWR0aCwgaW5uZXIuY2xpZW50V2lkdGgsIG91dGVyLm9mZnNldFdpZHRoLCBvdXRlci5jbGllbnRXaWR0aFxuXHRcdFx0Ly9cblx0XHRcdC8vIElFNiBYUDogICAgICAgICAgICAgICAgICAgICAgICAgICAxMDAgMTAwIDEwMCAgODNcblx0XHRcdC8vIElFNyBWaXN0YTogICAgICAgICAgICAgICAgICAgICAgICAxMDAgMTAwIDEwMCAgODNcblx0XHRcdC8vIElFIDgrIFdpbmRvd3M6ICAgICAgICAgICAgICAgICAgICAgODMgIDgzIDEwMCAgODNcblx0XHRcdC8vIEV2ZXJncmVlbiBXaW5kb3dzOiAgICAgICAgICAgICAgICAgODMgIDgzIDEwMCAgODNcblx0XHRcdC8vIEV2ZXJncmVlbiBNYWMgd2l0aCBzY3JvbGxiYXJzOiAgICAgODUgIDg1IDEwMCAgODVcblx0XHRcdC8vIEV2ZXJncmVlbiBNYWMgd2l0aG91dCBzY3JvbGxiYXJzOiAxMDAgMTAwIDEwMCAxMDBcblx0XG5cdFx0XHQvLyBHZXQgc2Nyb2xsYmFyIHdpZHRoXG5cdFx0XHRicm93c2VyLmJhcldpZHRoID0gb3V0ZXJbMF0ub2Zmc2V0V2lkdGggLSBvdXRlclswXS5jbGllbnRXaWR0aDtcblx0XG5cdFx0XHQvLyBJRTYvNyB3aWxsIG92ZXJzaXplIGEgd2lkdGggMTAwJSBlbGVtZW50IGluc2lkZSBhIHNjcm9sbGluZyBlbGVtZW50LCB0b1xuXHRcdFx0Ly8gaW5jbHVkZSB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbGJhciwgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZW5zdXJlIHRoZSBpbm5lclxuXHRcdFx0Ly8gZWxlbWVudCBpcyBjb250YWluZWQgd2l0aG91dCBmb3JjaW5nIHNjcm9sbGluZ1xuXHRcdFx0YnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemUgPSBpbm5lclswXS5vZmZzZXRXaWR0aCA9PT0gMTAwICYmIG91dGVyWzBdLmNsaWVudFdpZHRoICE9PSAxMDA7XG5cdFxuXHRcdFx0Ly8gSW4gcnRsIHRleHQgbGF5b3V0LCBzb21lIGJyb3dzZXJzIChtb3N0LCBidXQgbm90IGFsbCkgd2lsbCBwbGFjZSB0aGVcblx0XHRcdC8vIHNjcm9sbGJhciBvbiB0aGUgbGVmdCwgcmF0aGVyIHRoYW4gdGhlIHJpZ2h0LlxuXHRcdFx0YnJvd3Nlci5iU2Nyb2xsYmFyTGVmdCA9IE1hdGgucm91bmQoIGlubmVyLm9mZnNldCgpLmxlZnQgKSAhPT0gMTtcblx0XG5cdFx0XHQvLyBJRTgtIGRvbid0IHByb3ZpZGUgaGVpZ2h0IGFuZCB3aWR0aCBmb3IgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRicm93c2VyLmJCb3VuZGluZyA9IG5bMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPyB0cnVlIDogZmFsc2U7XG5cdFxuXHRcdFx0bi5yZW1vdmUoKTtcblx0XHR9XG5cdFxuXHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5vQnJvd3NlciwgRGF0YVRhYmxlLl9fYnJvd3NlciApO1xuXHRcdHNldHRpbmdzLm9TY3JvbGwuaUJhcldpZHRoID0gRGF0YVRhYmxlLl9fYnJvd3Nlci5iYXJXaWR0aDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBcnJheS5wcm90b3R5cGUgcmVkdWNlW1JpZ2h0XSBtZXRob2QsIHVzZWQgZm9yIGJyb3dzZXJzIHdoaWNoIGRvbid0IHN1cHBvcnRcblx0ICogSlMgMS42LiBEb25lIHRoaXMgd2F5IHRvIHJlZHVjZSBjb2RlIHNpemUsIHNpbmNlIHdlIGl0ZXJhdGUgZWl0aGVyIHdheVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblJlZHVjZSAoIHRoYXQsIGZuLCBpbml0LCBzdGFydCwgZW5kLCBpbmMgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRpID0gc3RhcnQsXG5cdFx0XHR2YWx1ZSxcblx0XHRcdGlzU2V0ID0gZmFsc2U7XG5cdFxuXHRcdGlmICggaW5pdCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSBpbml0O1xuXHRcdFx0aXNTZXQgPSB0cnVlO1xuXHRcdH1cblx0XG5cdFx0d2hpbGUgKCBpICE9PSBlbmQgKSB7XG5cdFx0XHRpZiAoICEgdGhhdC5oYXNPd25Qcm9wZXJ0eShpKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0dmFsdWUgPSBpc1NldCA/XG5cdFx0XHRcdGZuKCB2YWx1ZSwgdGhhdFtpXSwgaSwgdGhhdCApIDpcblx0XHRcdFx0dGhhdFtpXTtcblx0XG5cdFx0XHRpc1NldCA9IHRydWU7XG5cdFx0XHRpICs9IGluYztcblx0XHR9XG5cdFxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFkZCBhIGNvbHVtbiB0byB0aGUgbGlzdCB1c2VkIGZvciB0aGUgdGFibGUgd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBuVGggVGhlIHRoIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFkZENvbHVtbiggb1NldHRpbmdzLCBuVGggKVxuXHR7XG5cdFx0Ly8gQWRkIGNvbHVtbiB0byBhb0NvbHVtbnMgYXJyYXlcblx0XHR2YXIgb0RlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbjtcblx0XHR2YXIgaUNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHRcdHZhciBvQ29sID0gJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9Db2x1bW4sIG9EZWZhdWx0cywge1xuXHRcdFx0XCJuVGhcIjogblRoID8gblRoIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKSxcblx0XHRcdFwic1RpdGxlXCI6ICAgIG9EZWZhdWx0cy5zVGl0bGUgICAgPyBvRGVmYXVsdHMuc1RpdGxlICAgIDogblRoID8gblRoLmlubmVySFRNTCA6ICcnLFxuXHRcdFx0XCJhRGF0YVNvcnRcIjogb0RlZmF1bHRzLmFEYXRhU29ydCA/IG9EZWZhdWx0cy5hRGF0YVNvcnQgOiBbaUNvbF0sXG5cdFx0XHRcIm1EYXRhXCI6IG9EZWZhdWx0cy5tRGF0YSA/IG9EZWZhdWx0cy5tRGF0YSA6IGlDb2wsXG5cdFx0XHRpZHg6IGlDb2xcblx0XHR9ICk7XG5cdFx0b1NldHRpbmdzLmFvQ29sdW1ucy5wdXNoKCBvQ29sICk7XG5cdFxuXHRcdC8vIEFkZCBzZWFyY2ggb2JqZWN0IGZvciBjb2x1bW4gc3BlY2lmaWMgc2VhcmNoLiBOb3RlIHRoYXQgdGhlIGBzZWFyY2hDb2xzWyBpQ29sIF1gXG5cdFx0Ly8gcGFzc2VkIGludG8gZXh0ZW5kIGNhbiBiZSB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGdpdmUgYSBkZWZhdWx0XG5cdFx0Ly8gd2l0aCBvbmx5IHNvbWUgb2YgdGhlIHBhcmFtZXRlcnMgZGVmaW5lZCwgYW5kIGFsc28gbm90IGdpdmUgYSBkZWZhdWx0XG5cdFx0dmFyIHNlYXJjaENvbHMgPSBvU2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXHRcdHNlYXJjaENvbHNbIGlDb2wgXSA9ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzWyBpQ29sIF0gKTtcblx0XG5cdFx0Ly8gVXNlIHRoZSBkZWZhdWx0IGNvbHVtbiBvcHRpb25zIGZ1bmN0aW9uIHRvIGluaXRpYWxpc2UgY2xhc3NlcyBldGNcblx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGlDb2wsICQoblRoKS5kYXRhKCkgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBcHBseSBvcHRpb25zIGZvciBhIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlDb2wgY29sdW1uIGluZGV4IHRvIGNvbnNpZGVyXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb09wdGlvbnMgb2JqZWN0IHdpdGggc1R5cGUsIGJWaXNpYmxlIGFuZCBiU2VhcmNoYWJsZSBldGNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpQ29sLCBvT3B0aW9ucyApXG5cdHtcblx0XHR2YXIgb0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbIGlDb2wgXTtcblx0XHR2YXIgb0NsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIHRoID0gJChvQ29sLm5UaCk7XG5cdFxuXHRcdC8vIFRyeSB0byBnZXQgd2lkdGggaW5mb3JtYXRpb24gZnJvbSB0aGUgRE9NLiBXZSBjYW4ndCBnZXQgaXQgZnJvbSBDU1Ncblx0XHQvLyBhcyB3ZSdkIG5lZWQgdG8gcGFyc2UgdGhlIENTUyBzdHlsZXNoZWV0LiBgd2lkdGhgIG9wdGlvbiBjYW4gb3ZlcnJpZGVcblx0XHRpZiAoICEgb0NvbC5zV2lkdGhPcmlnICkge1xuXHRcdFx0Ly8gV2lkdGggYXR0cmlidXRlXG5cdFx0XHRvQ29sLnNXaWR0aE9yaWcgPSB0aC5hdHRyKCd3aWR0aCcpIHx8IG51bGw7XG5cdFxuXHRcdFx0Ly8gU3R5bGUgYXR0cmlidXRlXG5cdFx0XHR2YXIgdCA9ICh0aC5hdHRyKCdzdHlsZScpIHx8ICcnKS5tYXRjaCgvd2lkdGg6XFxzKihcXGQrW3B4ZW0lXSspLyk7XG5cdFx0XHRpZiAoIHQgKSB7XG5cdFx0XHRcdG9Db2wuc1dpZHRoT3JpZyA9IHRbMV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvKiBVc2VyIHNwZWNpZmllZCBjb2x1bW4gb3B0aW9ucyAqL1xuXHRcdGlmICggb09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvT3B0aW9ucyAhPT0gbnVsbCApXG5cdFx0e1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdF9mbkNvbXBhdENvbHMoIG9PcHRpb25zICk7XG5cdFxuXHRcdFx0Ly8gTWFwIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byB0aGVpciBIdW5nYXJpYW4gY291bnRlcnBhcnRzXG5cdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLCBvT3B0aW9ucyApO1xuXHRcblx0XHRcdC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBtRGF0YVByb3AgKi9cblx0XHRcdGlmICggb09wdGlvbnMubURhdGFQcm9wICE9PSB1bmRlZmluZWQgJiYgIW9PcHRpb25zLm1EYXRhIClcblx0XHRcdHtcblx0XHRcdFx0b09wdGlvbnMubURhdGEgPSBvT3B0aW9ucy5tRGF0YVByb3A7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBvT3B0aW9ucy5zVHlwZSApXG5cdFx0XHR7XG5cdFx0XHRcdG9Db2wuX3NNYW51YWxUeXBlID0gb09wdGlvbnMuc1R5cGU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gYGNsYXNzYCBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSmF2YXNjcmlwdCwgc28gd2UgbmVlZCB0byBwcm92aWRlXG5cdFx0XHQvLyB0aGUgYWJpbGl0eSB0byB1c2UgYSB2YWxpZCBuYW1lIGZvciB0aGUgY2FtZWwgY2FzZSBpbnB1dFxuXHRcdFx0aWYgKCBvT3B0aW9ucy5jbGFzc05hbWUgJiYgISBvT3B0aW9ucy5zQ2xhc3MgKVxuXHRcdFx0e1xuXHRcdFx0XHRvT3B0aW9ucy5zQ2xhc3MgPSBvT3B0aW9ucy5jbGFzc05hbWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0JC5leHRlbmQoIG9Db2wsIG9PcHRpb25zICk7XG5cdFx0XHRfZm5NYXAoIG9Db2wsIG9PcHRpb25zLCBcInNXaWR0aFwiLCBcInNXaWR0aE9yaWdcIiApO1xuXHRcblx0XHRcdC8qIGlEYXRhU29ydCB0byBiZSBhcHBsaWVkIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSksIGJ1dCBhRGF0YVNvcnQgd2lsbCB0YWtlXG5cdFx0XHQgKiBwcmlvcml0eSBpZiBkZWZpbmVkXG5cdFx0XHQgKi9cblx0XHRcdGlmICggb09wdGlvbnMuaURhdGFTb3J0ICE9PSB1bmRlZmluZWQgKVxuXHRcdFx0e1xuXHRcdFx0XHRvQ29sLmFEYXRhU29ydCA9IFsgb09wdGlvbnMuaURhdGFTb3J0IF07XG5cdFx0XHR9XG5cdFx0XHRfZm5NYXAoIG9Db2wsIG9PcHRpb25zLCBcImFEYXRhU29ydFwiICk7XG5cdFx0fVxuXHRcblx0XHQvKiBDYWNoZSB0aGUgZGF0YSBnZXQgYW5kIHNldCBmdW5jdGlvbnMgZm9yIHNwZWVkICovXG5cdFx0dmFyIG1EYXRhU3JjID0gb0NvbC5tRGF0YTtcblx0XHR2YXIgbURhdGEgPSBfZm5HZXRPYmplY3REYXRhRm4oIG1EYXRhU3JjICk7XG5cdFx0dmFyIG1SZW5kZXIgPSBvQ29sLm1SZW5kZXIgPyBfZm5HZXRPYmplY3REYXRhRm4oIG9Db2wubVJlbmRlciApIDogbnVsbDtcblx0XG5cdFx0dmFyIGF0dHJUZXN0ID0gZnVuY3Rpb24oIHNyYyApIHtcblx0XHRcdHJldHVybiB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyAmJiBzcmMuaW5kZXhPZignQCcpICE9PSAtMTtcblx0XHR9O1xuXHRcdG9Db2wuX2JBdHRyU3JjID0gJC5pc1BsYWluT2JqZWN0KCBtRGF0YVNyYyApICYmIChcblx0XHRcdGF0dHJUZXN0KG1EYXRhU3JjLnNvcnQpIHx8IGF0dHJUZXN0KG1EYXRhU3JjLnR5cGUpIHx8IGF0dHJUZXN0KG1EYXRhU3JjLmZpbHRlcilcblx0XHQpO1xuXHRcdG9Db2wuX3NldHRlciA9IG51bGw7XG5cdFxuXHRcdG9Db2wuZm5HZXREYXRhID0gZnVuY3Rpb24gKHJvd0RhdGEsIHR5cGUsIG1ldGEpIHtcblx0XHRcdHZhciBpbm5lckRhdGEgPSBtRGF0YSggcm93RGF0YSwgdHlwZSwgdW5kZWZpbmVkLCBtZXRhICk7XG5cdFxuXHRcdFx0cmV0dXJuIG1SZW5kZXIgJiYgdHlwZSA/XG5cdFx0XHRcdG1SZW5kZXIoIGlubmVyRGF0YSwgdHlwZSwgcm93RGF0YSwgbWV0YSApIDpcblx0XHRcdFx0aW5uZXJEYXRhO1xuXHRcdH07XG5cdFx0b0NvbC5mblNldERhdGEgPSBmdW5jdGlvbiAoIHJvd0RhdGEsIHZhbCwgbWV0YSApIHtcblx0XHRcdHJldHVybiBfZm5TZXRPYmplY3REYXRhRm4oIG1EYXRhU3JjICkoIHJvd0RhdGEsIHZhbCwgbWV0YSApO1xuXHRcdH07XG5cdFxuXHRcdC8vIEluZGljYXRlIGlmIERhdGFUYWJsZXMgc2hvdWxkIHJlYWQgRE9NIGRhdGEgYXMgYW4gb2JqZWN0IG9yIGFycmF5XG5cdFx0Ly8gVXNlZCBpbiBfZm5HZXRSb3dFbGVtZW50c1xuXHRcdGlmICggdHlwZW9mIG1EYXRhU3JjICE9PSAnbnVtYmVyJyApIHtcblx0XHRcdG9TZXR0aW5ncy5fcm93UmVhZE9iamVjdCA9IHRydWU7XG5cdFx0fVxuXHRcblx0XHQvKiBGZWF0dXJlIHNvcnRpbmcgb3ZlcnJpZGVzIGNvbHVtbiBzcGVjaWZpYyB3aGVuIG9mZiAqL1xuXHRcdGlmICggIW9TZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnQgKVxuXHRcdHtcblx0XHRcdG9Db2wuYlNvcnRhYmxlID0gZmFsc2U7XG5cdFx0XHR0aC5hZGRDbGFzcyggb0NsYXNzZXMuc1NvcnRhYmxlTm9uZSApOyAvLyBIYXZlIHRvIGFkZCBjbGFzcyBoZXJlIGFzIG9yZGVyIGV2ZW50IGlzbid0IGNhbGxlZFxuXHRcdH1cblx0XG5cdFx0LyogQ2hlY2sgdGhhdCB0aGUgY2xhc3MgYXNzaWdubWVudCBpcyBjb3JyZWN0IGZvciBzb3J0aW5nICovXG5cdFx0dmFyIGJBc2MgPSAkLmluQXJyYXkoJ2FzYycsIG9Db2wuYXNTb3J0aW5nKSAhPT0gLTE7XG5cdFx0dmFyIGJEZXNjID0gJC5pbkFycmF5KCdkZXNjJywgb0NvbC5hc1NvcnRpbmcpICE9PSAtMTtcblx0XHRpZiAoICFvQ29sLmJTb3J0YWJsZSB8fCAoIWJBc2MgJiYgIWJEZXNjKSApXG5cdFx0e1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlTm9uZTtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IFwiXCI7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBiQXNjICYmICFiRGVzYyApXG5cdFx0e1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlQXNjO1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzSlVJID0gb0NsYXNzZXMuc1NvcnRKVUlBc2NBbGxvd2VkO1xuXHRcdH1cblx0XHRlbHNlIGlmICggIWJBc2MgJiYgYkRlc2MgKVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZURlc2M7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBvQ2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlO1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzSlVJID0gb0NsYXNzZXMuc1NvcnRKVUk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkanVzdCB0aGUgdGFibGUgY29sdW1uIHdpZHRocyBmb3IgbmV3IGRhdGEuIE5vdGU6IHlvdSB3b3VsZCBwcm9iYWJseSB3YW50IHRvXG5cdCAqIGRvIGEgcmVkcmF3IGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiFcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BZGp1c3RDb2x1bW5TaXppbmcgKCBzZXR0aW5ncyApXG5cdHtcblx0XHQvKiBOb3QgaW50ZXJlc3RlZCBpbiBkb2luZyBjb2x1bW4gd2lkdGggY2FsY3VsYXRpb24gaWYgYXV0by13aWR0aCBpcyBkaXNhYmxlZCAqL1xuXHRcdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJBdXRvV2lkdGggIT09IGZhbHNlIClcblx0XHR7XG5cdFx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0XG5cdFx0XHRfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMoIHNldHRpbmdzICk7XG5cdFx0XHRmb3IgKCB2YXIgaT0wICwgaUxlbj1jb2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdGNvbHVtbnNbaV0ublRoLnN0eWxlLndpZHRoID0gY29sdW1uc1tpXS5zV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHR2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcblx0XHRpZiAoIHNjcm9sbC5zWSAhPT0gJycgfHwgc2Nyb2xsLnNYICE9PSAnJylcblx0XHR7XG5cdFx0XHRfZm5TY3JvbGxEcmF3KCBzZXR0aW5ncyApO1xuXHRcdH1cblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2NvbHVtbi1zaXppbmcnLCBbc2V0dGluZ3NdICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQ292ZXJ0IHRoZSBpbmRleCBvZiBhIHZpc2libGUgY29sdW1uIHRvIHRoZSBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSAodGFrZSBhY2NvdW50XG5cdCAqIG9mIGhpZGRlbiBjb2x1bW5zKVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBWaXNpYmxlIGNvbHVtbiBpbmRleCB0byBsb29rdXBcblx0ICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIGRhdGEgaW5kZXhcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaU1hdGNoIClcblx0e1xuXHRcdHZhciBhaVZpcyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApO1xuXHRcblx0XHRyZXR1cm4gdHlwZW9mIGFpVmlzW2lNYXRjaF0gPT09ICdudW1iZXInID9cblx0XHRcdGFpVmlzW2lNYXRjaF0gOlxuXHRcdFx0bnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb3ZlcnQgdGhlIGluZGV4IG9mIGFuIGluZGV4IGluIHRoZSBkYXRhIGFycmF5IGFuZCBjb252ZXJ0IGl0IHRvIHRoZSB2aXNpYmxlXG5cdCAqICAgY29sdW1uIGluZGV4ICh0YWtlIGFjY291bnQgb2YgaGlkZGVuIGNvbHVtbnMpXG5cdCAqICBAcGFyYW0ge2ludH0gaU1hdGNoIENvbHVtbiBpbmRleCB0byBsb29rdXBcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIGRhdGEgaW5kZXhcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoIG9TZXR0aW5ncywgaU1hdGNoIClcblx0e1xuXHRcdHZhciBhaVZpcyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApO1xuXHRcdHZhciBpUG9zID0gJC5pbkFycmF5KCBpTWF0Y2gsIGFpVmlzICk7XG5cdFxuXHRcdHJldHVybiBpUG9zICE9PSAtMSA/IGlQb3MgOiBudWxsO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgbnVtYmVyIG9mIHZpc2libGUgY29sdW1uc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2ludH0gaSB0aGUgbnVtYmVyIG9mIHZpc2libGUgY29sdW1uc1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5WaXNibGVDb2x1bW5zKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIHZpcyA9IDA7XG5cdFxuXHRcdC8vIE5vIHJlZHVjZSBpbiBJRTgsIHVzZSBhIGxvb3AgZm9yIG5vd1xuXHRcdCQuZWFjaCggb1NldHRpbmdzLmFvQ29sdW1ucywgZnVuY3Rpb24gKCBpLCBjb2wgKSB7XG5cdFx0XHRpZiAoIGNvbC5iVmlzaWJsZSAmJiAkKGNvbC5uVGgpLmNzcygnZGlzcGxheScpICE9PSAnbm9uZScgKSB7XG5cdFx0XHRcdHZpcysrO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIHZpcztcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgdGhhdCBtYXRjaCBhIGdpdmVuIHByb3BlcnR5XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc1BhcmFtIFBhcmFtZXRlciBpbiBhb0NvbHVtbnMgdG8gbG9vayBmb3IgLSB0eXBpY2FsbHlcblx0ICogICAgYlZpc2libGUgb3IgYlNlYXJjaGFibGVcblx0ICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgaW5kZXhlcyB3aXRoIG1hdGNoZWQgcHJvcGVydGllc1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsIHNQYXJhbSApXG5cdHtcblx0XHR2YXIgYSA9IFtdO1xuXHRcblx0XHQkLm1hcCggb1NldHRpbmdzLmFvQ29sdW1ucywgZnVuY3Rpb24odmFsLCBpKSB7XG5cdFx0XHRpZiAoIHZhbFtzUGFyYW1dICkge1xuXHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiBhO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgJ3R5cGUnIG9mIGEgY29sdW1uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29sdW1uVHlwZXMgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblx0XHR2YXIgdHlwZXMgPSBEYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0O1xuXHRcdHZhciBpLCBpZW4sIGosIGplbiwgaywga2VuO1xuXHRcdHZhciBjb2wsIGNlbGwsIGRldGVjdGVkVHlwZSwgY2FjaGU7XG5cdFxuXHRcdC8vIEZvciBlYWNoIGNvbHVtbiwgc3BpbiBvdmVyIHRoZSBcblx0XHRmb3IgKCBpPTAsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sID0gY29sdW1uc1tpXTtcblx0XHRcdGNhY2hlID0gW107XG5cdFxuXHRcdFx0aWYgKCAhIGNvbC5zVHlwZSAmJiBjb2wuX3NNYW51YWxUeXBlICkge1xuXHRcdFx0XHRjb2wuc1R5cGUgPSBjb2wuX3NNYW51YWxUeXBlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICEgY29sLnNUeXBlICkge1xuXHRcdFx0XHRmb3IgKCBqPTAsIGplbj10eXBlcy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRmb3IgKCBrPTAsIGtlbj1kYXRhLmxlbmd0aCA7IGs8a2VuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0Ly8gVXNlIGEgY2FjaGUgYXJyYXkgc28gd2Ugb25seSBuZWVkIHRvIGdldCB0aGUgdHlwZSBkYXRhXG5cdFx0XHRcdFx0XHQvLyBmcm9tIHRoZSBmb3JtYXR0ZXIgb25jZSAod2hlbiB1c2luZyBtdWx0aXBsZSBkZXRlY3RvcnMpXG5cdFx0XHRcdFx0XHRpZiAoIGNhY2hlW2tdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGNhY2hlW2tdID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBrLCBpLCAndHlwZScgKTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRkZXRlY3RlZFR5cGUgPSB0eXBlc1tqXSggY2FjaGVba10sIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0XHRcdFx0Ly8gSWYgbnVsbCwgdGhlbiB0aGlzIHR5cGUgY2FuJ3QgYXBwbHkgdG8gdGhpcyBjb2x1bW4sIHNvXG5cdFx0XHRcdFx0XHQvLyByYXRoZXIgdGhhbiB0ZXN0aW5nIGFsbCBjZWxscywgYnJlYWsgb3V0LiBUaGVyZSBpcyBhblxuXHRcdFx0XHRcdFx0Ly8gZXhjZXB0aW9uIGZvciB0aGUgbGFzdCB0eXBlIHdoaWNoIGlzIGBodG1sYC4gV2UgbmVlZCB0b1xuXHRcdFx0XHRcdFx0Ly8gc2NhbiBhbGwgcm93cyBzaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBtaXggc3RyaW5nIGFuZCBIVE1MXG5cdFx0XHRcdFx0XHQvLyB0eXBlc1xuXHRcdFx0XHRcdFx0aWYgKCAhIGRldGVjdGVkVHlwZSAmJiBqICE9PSB0eXBlcy5sZW5ndGgtMSApIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0Ly8gT25seSBhIHNpbmdsZSBtYXRjaCBpcyBuZWVkZWQgZm9yIGh0bWwgdHlwZSBzaW5jZSBpdCBpc1xuXHRcdFx0XHRcdFx0Ly8gYm90dG9tIG9mIHRoZSBwaWxlIGFuZCB2ZXJ5IHNpbWlsYXIgdG8gc3RyaW5nXG5cdFx0XHRcdFx0XHRpZiAoIGRldGVjdGVkVHlwZSA9PT0gJ2h0bWwnICkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIFR5cGUgaXMgdmFsaWQgZm9yIGFsbCBkYXRhIHBvaW50cyBpbiB0aGUgY29sdW1uIC0gdXNlIHRoaXNcblx0XHRcdFx0XHQvLyB0eXBlXG5cdFx0XHRcdFx0aWYgKCBkZXRlY3RlZFR5cGUgKSB7XG5cdFx0XHRcdFx0XHRjb2wuc1R5cGUgPSBkZXRlY3RlZFR5cGU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIEZhbGwgYmFjayAtIGlmIG5vIHR5cGUgd2FzIGRldGVjdGVkLCBhbHdheXMgdXNlIHN0cmluZ1xuXHRcdFx0XHRpZiAoICEgY29sLnNUeXBlICkge1xuXHRcdFx0XHRcdGNvbC5zVHlwZSA9ICdzdHJpbmcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRha2UgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyBhbmQgc3RhdGljIGNvbHVtbnMgYXJyYXlzIGFuZCBjYWxjdWxhdGUgaG93XG5cdCAqIHRoZXkgcmVsYXRlIHRvIGNvbHVtbiBpbmRleGVzLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCB0aGVuIGFwcGx5IHRoZVxuXHQgKiBkZWZpbml0aW9uIGZvdW5kIGZvciBhIGNvbHVtbiB0byBhIHN1aXRhYmxlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYW9Db2xEZWZzIFRoZSBhb0NvbHVtbkRlZnMgYXJyYXkgdGhhdCBpcyB0byBiZSBhcHBsaWVkXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhb0NvbHMgVGhlIGFvQ29sdW1ucyBhcnJheSB0aGF0IGRlZmluZXMgY29sdW1ucyBpbmRpdmlkdWFsbHlcblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIC0gdGFrZXMgdHdvIHBhcmFtZXRlcnMsIHRoZSBjYWxjdWxhdGVkXG5cdCAqICAgIGNvbHVtbiBpbmRleCBhbmQgdGhlIGRlZmluaXRpb24gZm9yIHRoYXQgY29sdW1uLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BcHBseUNvbHVtbkRlZnMoIG9TZXR0aW5ncywgYW9Db2xEZWZzLCBhb0NvbHMsIGZuIClcblx0e1xuXHRcdHZhciBpLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLCBkZWY7XG5cdFx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcblx0XHQvLyBDb2x1bW4gZGVmaW5pdGlvbnMgd2l0aCBhVGFyZ2V0c1xuXHRcdGlmICggYW9Db2xEZWZzIClcblx0XHR7XG5cdFx0XHQvKiBMb29wIG92ZXIgdGhlIGRlZmluaXRpb25zIGFycmF5IC0gbG9vcCBpbiByZXZlcnNlIHNvIGZpcnN0IGluc3RhbmNlIGhhcyBwcmlvcml0eSAqL1xuXHRcdFx0Zm9yICggaT1hb0NvbERlZnMubGVuZ3RoLTEgOyBpPj0wIDsgaS0tIClcblx0XHRcdHtcblx0XHRcdFx0ZGVmID0gYW9Db2xEZWZzW2ldO1xuXHRcblx0XHRcdFx0LyogRWFjaCBkZWZpbml0aW9uIGNhbiB0YXJnZXQgbXVsdGlwbGUgY29sdW1ucywgYXMgaXQgaXMgYW4gYXJyYXkgKi9cblx0XHRcdFx0dmFyIGFUYXJnZXRzID0gZGVmLnRhcmdldHMgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0ZGVmLnRhcmdldHMgOlxuXHRcdFx0XHRcdGRlZi5hVGFyZ2V0cztcblx0XG5cdFx0XHRcdGlmICggISAkLmlzQXJyYXkoIGFUYXJnZXRzICkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YVRhcmdldHMgPSBbIGFUYXJnZXRzIF07XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGZvciAoIGo9MCwgakxlbj1hVGFyZ2V0cy5sZW5ndGggOyBqPGpMZW4gOyBqKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgYVRhcmdldHNbal0gPT09ICdudW1iZXInICYmIGFUYXJnZXRzW2pdID49IDAgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8qIEFkZCBjb2x1bW5zIHRoYXQgd2UgZG9uJ3QgeWV0IGtub3cgYWJvdXQgKi9cblx0XHRcdFx0XHRcdHdoaWxlKCBjb2x1bW5zLmxlbmd0aCA8PSBhVGFyZ2V0c1tqXSApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdF9mbkFkZENvbHVtbiggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0LyogSW50ZWdlciwgYmFzaWMgaW5kZXggKi9cblx0XHRcdFx0XHRcdGZuKCBhVGFyZ2V0c1tqXSwgZGVmICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgYVRhcmdldHNbal0gPT09ICdudW1iZXInICYmIGFUYXJnZXRzW2pdIDwgMCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0LyogTmVnYXRpdmUgaW50ZWdlciwgcmlnaHQgdG8gbGVmdCBjb2x1bW4gY291bnRpbmcgKi9cblx0XHRcdFx0XHRcdGZuKCBjb2x1bW5zLmxlbmd0aCthVGFyZ2V0c1tqXSwgZGVmICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgYVRhcmdldHNbal0gPT09ICdzdHJpbmcnIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvKiBDbGFzcyBuYW1lIG1hdGNoaW5nIG9uIFRIIGVsZW1lbnQgKi9cblx0XHRcdFx0XHRcdGZvciAoIGs9MCwga0xlbj1jb2x1bW5zLmxlbmd0aCA7IGs8a0xlbiA7IGsrKyApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmICggYVRhcmdldHNbal0gPT0gXCJfYWxsXCIgfHxcblx0XHRcdFx0XHRcdFx0ICAgICAkKGNvbHVtbnNba10ublRoKS5oYXNDbGFzcyggYVRhcmdldHNbal0gKSApXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRmbiggaywgZGVmICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8vIFN0YXRpY2FsbHkgZGVmaW5lZCBjb2x1bW5zIGFycmF5XG5cdFx0aWYgKCBhb0NvbHMgKVxuXHRcdHtcblx0XHRcdGZvciAoIGk9MCwgaUxlbj1hb0NvbHMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0Zm4oIGksIGFvQ29sc1tpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEFkZCBhIGRhdGEgYXJyYXkgdG8gdGhlIHRhYmxlLCBjcmVhdGluZyBET00gbm9kZSBldGMuIFRoaXMgaXMgdGhlIHBhcmFsbGVsIHRvXG5cdCAqIF9mbkdhdGhlckRhdGEsIGJ1dCBmb3IgYWRkaW5nIHJvd3MgZnJvbSBhIEphdmFzY3JpcHQgc291cmNlLCByYXRoZXIgdGhhbiBhXG5cdCAqIERPTSBzb3VyY2UuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2FycmF5fSBhRGF0YSBkYXRhIGFycmF5IHRvIGJlIGFkZGVkXG5cdCAqICBAcGFyYW0ge25vZGV9IFtuVHJdIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXG5cdCAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxuXHQgKiAgQHBhcmFtIHthcnJheX0gW2FuVGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cblx0ICogICAgaWYgblRyIGlzLlxuXHQgKiAgQHJldHVybnMge2ludH0gPj0wIGlmIHN1Y2Nlc3NmdWwgKGluZGV4IG9mIG5ldyBhb0RhdGEgZW50cnkpLCAtMSBpZiBmYWlsZWRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRkRGF0YSAoIG9TZXR0aW5ncywgYURhdGFJbiwgblRyLCBhblRkcyApXG5cdHtcblx0XHQvKiBDcmVhdGUgdGhlIG9iamVjdCBmb3Igc3RvcmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIG5ldyByb3cgKi9cblx0XHR2YXIgaVJvdyA9IG9TZXR0aW5ncy5hb0RhdGEubGVuZ3RoO1xuXHRcdHZhciBvRGF0YSA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vUm93LCB7XG5cdFx0XHRzcmM6IG5UciA/ICdkb20nIDogJ2RhdGEnLFxuXHRcdFx0aWR4OiBpUm93XG5cdFx0fSApO1xuXHRcblx0XHRvRGF0YS5fYURhdGEgPSBhRGF0YUluO1xuXHRcdG9TZXR0aW5ncy5hb0RhdGEucHVzaCggb0RhdGEgKTtcblx0XG5cdFx0LyogQ3JlYXRlIHRoZSBjZWxscyAqL1xuXHRcdHZhciBuVGQsIHNUaGlzVHlwZTtcblx0XHR2YXIgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFxuXHRcdC8vIEludmFsaWRhdGUgdGhlIGNvbHVtbiB0eXBlcyBhcyB0aGUgbmV3IGRhdGEgbmVlZHMgdG8gYmUgcmV2YWxpZGF0ZWRcblx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRjb2x1bW5zW2ldLnNUeXBlID0gbnVsbDtcblx0XHR9XG5cdFxuXHRcdC8qIEFkZCB0byB0aGUgZGlzcGxheSBhcnJheSAqL1xuXHRcdG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIucHVzaCggaVJvdyApO1xuXHRcblx0XHR2YXIgaWQgPSBvU2V0dGluZ3Mucm93SWRGbiggYURhdGFJbiApO1xuXHRcdGlmICggaWQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG9TZXR0aW5ncy5hSWRzWyBpZCBdID0gb0RhdGE7XG5cdFx0fVxuXHRcblx0XHQvKiBDcmVhdGUgdGhlIERPTSBpbmZvcm1hdGlvbiwgb3IgcmVnaXN0ZXIgaXQgaWYgYWxyZWFkeSBwcmVzZW50ICovXG5cdFx0aWYgKCBuVHIgfHwgISBvU2V0dGluZ3Mub0ZlYXR1cmVzLmJEZWZlclJlbmRlciApXG5cdFx0e1xuXHRcdFx0X2ZuQ3JlYXRlVHIoIG9TZXR0aW5ncywgaVJvdywgblRyLCBhblRkcyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGlSb3c7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQWRkIG9uZSBvciBtb3JlIFRSIGVsZW1lbnRzIHRvIHRoZSB0YWJsZS4gR2VuZXJhbGx5IHdlJ2QgZXhwZWN0IHRvXG5cdCAqIHVzZSB0aGlzIGZvciByZWFkaW5nIGRhdGEgZnJvbSBhIERPTSBzb3VyY2VkIHRhYmxlLCBidXQgaXQgY291bGQgYmVcblx0ICogdXNlZCBmb3IgYW4gVFIgZWxlbWVudC4gTm90ZSB0aGF0IGlmIGEgVFIgaXMgZ2l2ZW4sIGl0IGlzIHVzZWQgKGkuZS5cblx0ICogaXQgaXMgbm90IGNsb25lZCkuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7YXJyYXl8bm9kZXxqUXVlcnl9IHRycyBUaGUgVFIgZWxlbWVudChzKSB0byBhZGQgdG8gdGhlIHRhYmxlXG5cdCAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgZm9yIHRoZSBhZGRlZCByb3dzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFkZFRyKCBzZXR0aW5ncywgdHJzIClcblx0e1xuXHRcdHZhciByb3c7XG5cdFxuXHRcdC8vIEFsbG93IGFuIGluZGl2aWR1YWwgbm9kZSB0byBiZSBwYXNzZWQgaW5cblx0XHRpZiAoICEgKHRycyBpbnN0YW5jZW9mICQpICkge1xuXHRcdFx0dHJzID0gJCh0cnMpO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRycy5tYXAoIGZ1bmN0aW9uIChpLCBlbCkge1xuXHRcdFx0cm93ID0gX2ZuR2V0Um93RWxlbWVudHMoIHNldHRpbmdzLCBlbCApO1xuXHRcdFx0cmV0dXJuIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cuZGF0YSwgZWwsIHJvdy5jZWxscyApO1xuXHRcdH0gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBUYWtlIGEgVFIgZWxlbWVudCBhbmQgY29udmVydCBpdCB0byBhbiBpbmRleCBpbiBhb0RhdGFcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7bm9kZX0gbiB0aGUgVFIgZWxlbWVudCB0byBmaW5kXG5cdCAqICBAcmV0dXJucyB7aW50fSBpbmRleCBpZiB0aGUgbm9kZSBpcyBmb3VuZCwgbnVsbCBpZiBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTm9kZVRvRGF0YUluZGV4KCBvU2V0dGluZ3MsIG4gKVxuXHR7XG5cdFx0cmV0dXJuIChuLl9EVF9Sb3dJbmRleCE9PXVuZGVmaW5lZCkgPyBuLl9EVF9Sb3dJbmRleCA6IG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogVGFrZSBhIFREIGVsZW1lbnQgYW5kIGNvbnZlcnQgaXQgaW50byBhIGNvbHVtbiBkYXRhIGluZGV4IChub3QgdGhlIHZpc2libGUgaW5kZXgpXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2ludH0gaVJvdyBUaGUgcm93IG51bWJlciB0aGUgVEQvVEggY2FuIGJlIGZvdW5kIGluXG5cdCAqICBAcGFyYW0ge25vZGV9IG4gVGhlIFREL1RIIGVsZW1lbnQgdG8gZmluZFxuXHQgKiAgQHJldHVybnMge2ludH0gaW5kZXggaWYgdGhlIG5vZGUgaXMgZm91bmQsIC0xIGlmIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Ob2RlVG9Db2x1bW5JbmRleCggb1NldHRpbmdzLCBpUm93LCBuIClcblx0e1xuXHRcdHJldHVybiAkLmluQXJyYXkoIG4sIG9TZXR0aW5ncy5hb0RhdGFbIGlSb3cgXS5hbkNlbGxzICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBkYXRhIGZvciBhIGdpdmVuIGNlbGwgZnJvbSB0aGUgaW50ZXJuYWwgY2FjaGUsIHRha2luZyBpbnRvIGFjY291bnQgZGF0YSBtYXBwaW5nXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSByb3dJZHggYW9EYXRhIHJvdyBpZFxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBDb2x1bW4gaW5kZXhcblx0ICogIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGRhdGEgZ2V0IHR5cGUgKCdkaXNwbGF5JywgJ3R5cGUnICdmaWx0ZXInICdzb3J0Jylcblx0ICogIEByZXR1cm5zIHsqfSBDZWxsIGRhdGFcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgdHlwZSApXG5cdHtcblx0XHR2YXIgZHJhdyAgICAgICAgICAgPSBzZXR0aW5ncy5pRHJhdztcblx0XHR2YXIgY29sICAgICAgICAgICAgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcblx0XHR2YXIgcm93RGF0YSAgICAgICAgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XS5fYURhdGE7XG5cdFx0dmFyIGRlZmF1bHRDb250ZW50ID0gY29sLnNEZWZhdWx0Q29udGVudDtcblx0XHR2YXIgY2VsbERhdGEgICAgICAgPSBjb2wuZm5HZXREYXRhKCByb3dEYXRhLCB0eXBlLCB7XG5cdFx0XHRzZXR0aW5nczogc2V0dGluZ3MsXG5cdFx0XHRyb3c6ICAgICAgcm93SWR4LFxuXHRcdFx0Y29sOiAgICAgIGNvbElkeFxuXHRcdH0gKTtcblx0XG5cdFx0aWYgKCBjZWxsRGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncy5pRHJhd0Vycm9yICE9IGRyYXcgJiYgZGVmYXVsdENvbnRlbnQgPT09IG51bGwgKSB7XG5cdFx0XHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsIFwiUmVxdWVzdGVkIHVua25vd24gcGFyYW1ldGVyIFwiK1xuXHRcdFx0XHRcdCh0eXBlb2YgY29sLm1EYXRhPT0nZnVuY3Rpb24nID8gJ3tmdW5jdGlvbn0nIDogXCInXCIrY29sLm1EYXRhK1wiJ1wiKStcblx0XHRcdFx0XHRcIiBmb3Igcm93IFwiK3Jvd0lkeCtcIiwgY29sdW1uIFwiK2NvbElkeCwgNCApO1xuXHRcdFx0XHRzZXR0aW5ncy5pRHJhd0Vycm9yID0gZHJhdztcblx0XHRcdH1cblx0XHRcdHJldHVybiBkZWZhdWx0Q29udGVudDtcblx0XHR9XG5cdFxuXHRcdC8vIFdoZW4gdGhlIGRhdGEgc291cmNlIGlzIG51bGwgYW5kIGEgc3BlY2lmaWMgZGF0YSB0eXBlIGlzIHJlcXVlc3RlZCAoaS5lLlxuXHRcdC8vIG5vdCB0aGUgb3JpZ2luYWwgZGF0YSksIHdlIGNhbiB1c2UgZGVmYXVsdCBjb2x1bW4gZGF0YVxuXHRcdGlmICggKGNlbGxEYXRhID09PSByb3dEYXRhIHx8IGNlbGxEYXRhID09PSBudWxsKSAmJiBkZWZhdWx0Q29udGVudCAhPT0gbnVsbCAmJiB0eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjZWxsRGF0YSA9IGRlZmF1bHRDb250ZW50O1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIGNlbGxEYXRhID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gSWYgdGhlIGRhdGEgc291cmNlIGlzIGEgZnVuY3Rpb24sIHRoZW4gd2UgcnVuIGl0IGFuZCB1c2UgdGhlIHJldHVybixcblx0XHRcdC8vIGV4ZWN1dGluZyBpbiB0aGUgc2NvcGUgb2YgdGhlIGRhdGEgb2JqZWN0IChmb3IgaW5zdGFuY2VzKVxuXHRcdFx0cmV0dXJuIGNlbGxEYXRhLmNhbGwoIHJvd0RhdGEgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggY2VsbERhdGEgPT09IG51bGwgJiYgdHlwZSA9PSAnZGlzcGxheScgKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdHJldHVybiBjZWxsRGF0YTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBTZXQgdGhlIHZhbHVlIGZvciBhIHNwZWNpZmljIGNlbGwsIGludG8gdGhlIGludGVybmFsIGRhdGEgY2FjaGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IHJvd0lkeCBhb0RhdGEgcm93IGlkXG5cdCAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxuXHQgKiAgQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gc2V0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNldENlbGxEYXRhKCBzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsIHZhbCApXG5cdHtcblx0XHR2YXIgY29sICAgICA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xuXHRcdHZhciByb3dEYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF0uX2FEYXRhO1xuXHRcblx0XHRjb2wuZm5TZXREYXRhKCByb3dEYXRhLCB2YWwsIHtcblx0XHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0XHRcdHJvdzogICAgICByb3dJZHgsXG5cdFx0XHRjb2w6ICAgICAgY29sSWR4XG5cdFx0fSAgKTtcblx0fVxuXHRcblx0XG5cdC8vIFByaXZhdGUgdmFyaWFibGUgdGhhdCBpcyB1c2VkIHRvIG1hdGNoIGFjdGlvbiBzeW50YXggaW4gdGhlIGRhdGEgcHJvcGVydHkgb2JqZWN0XG5cdHZhciBfX3JlQXJyYXkgPSAvXFxbLio/XFxdJC87XG5cdHZhciBfX3JlRm4gPSAvXFwoXFwpJC87XG5cdFxuXHQvKipcblx0ICogU3BsaXQgc3RyaW5nIG9uIHBlcmlvZHMsIHRha2luZyBpbnRvIGFjY291bnQgZXNjYXBlZCBwZXJpb2RzXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdFxuXHQgKiBAcmV0dXJuIHthcnJheX0gU3BsaXQgc3RyaW5nXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TcGxpdE9iak5vdGF0aW9uKCBzdHIgKVxuXHR7XG5cdFx0cmV0dXJuICQubWFwKCBzdHIubWF0Y2goLyhcXFxcLnxbXlxcLl0pKy9nKSB8fCBbJyddLCBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0XHRyZXR1cm4gcy5yZXBsYWNlKC9cXFxcXFwuL2csICcuJyk7XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIHNvdXJjZSBvYmplY3QsIHRha2luZ1xuXHQgKiBpbnRvIGFjY291bnQgdGhlIGFiaWxpdHkgdG8gdXNlIG5lc3RlZCBvYmplY3RzIGFzIGEgc291cmNlXG5cdCAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7ZnVuY3Rpb259IERhdGEgZ2V0IGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkdldE9iamVjdERhdGFGbiggbVNvdXJjZSApXG5cdHtcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggbVNvdXJjZSApIClcblx0XHR7XG5cdFx0XHQvKiBCdWlsZCBhbiBvYmplY3Qgb2YgZ2V0IGZ1bmN0aW9ucywgYW5kIHdyYXAgdGhlbSBpbiBhIHNpbmdsZSBjYWxsICovXG5cdFx0XHR2YXIgbyA9IHt9O1xuXHRcdFx0JC5lYWNoKCBtU291cmNlLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0b1trZXldID0gX2ZuR2V0T2JqZWN0RGF0YUZuKCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XG5cdFx0XHRcdHZhciB0ID0gb1t0eXBlXSB8fCBvLl87XG5cdFx0XHRcdHJldHVybiB0ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdHQoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBtU291cmNlID09PSBudWxsIClcblx0XHR7XG5cdFx0XHQvKiBHaXZlIGFuIGVtcHR5IHN0cmluZyBmb3IgcmVuZGVyaW5nIC8gc29ydGluZyBldGMgKi9cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSkgeyAvLyB0eXBlLCByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgbVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcblx0XHRcdFx0cmV0dXJuIG1Tb3VyY2UoIGRhdGEsIHR5cGUsIHJvdywgbWV0YSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHQgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSApXG5cdFx0e1xuXHRcdFx0LyogSWYgdGhlcmUgaXMgYSAuIGluIHRoZSBzb3VyY2Ugc3RyaW5nIHRoZW4gdGhlIGRhdGEgc291cmNlIGlzIGluIGFcblx0XHRcdCAqIG5lc3RlZCBvYmplY3Qgc28gd2UgbG9vcCBvdmVyIHRoZSBkYXRhIGZvciBlYWNoIGxldmVsIHRvIGdldCB0aGUgbmV4dFxuXHRcdFx0ICogbGV2ZWwgZG93bi4gT24gZWFjaCBsb29wIHdlIHRlc3QgZm9yIHVuZGVmaW5lZCwgYW5kIGlmIGZvdW5kIGltbWVkaWF0ZWx5XG5cdFx0XHQgKiByZXR1cm4uIFRoaXMgYWxsb3dzIGVudGlyZSBvYmplY3RzIHRvIGJlIG1pc3NpbmcgYW5kIHNEZWZhdWx0Q29udGVudCB0b1xuXHRcdFx0ICogYmUgdXNlZCBpZiBkZWZpbmVkLCByYXRoZXIgdGhhbiB0aHJvd2luZyBhbiBlcnJvclxuXHRcdFx0ICovXG5cdFx0XHR2YXIgZmV0Y2hEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHNyYykge1xuXHRcdFx0XHR2YXIgYXJyYXlOb3RhdGlvbiwgZnVuY05vdGF0aW9uLCBvdXQsIGlubmVyU3JjO1xuXHRcblx0XHRcdFx0aWYgKCBzcmMgIT09IFwiXCIgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGEgPSBfZm5TcGxpdE9iak5vdGF0aW9uKCBzcmMgKTtcblx0XG5cdFx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBzcGVjaWFsIG5vdGF0aW9uXG5cdFx0XHRcdFx0XHRhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xuXHRcdFx0XHRcdFx0ZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xuXHRcblx0XHRcdFx0XHRcdGlmICggYXJyYXlOb3RhdGlvbiApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdC8vIEFycmF5IG5vdGF0aW9uXG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBDb25kaXRpb24gYWxsb3dzIHNpbXBseSBbXSB0byBiZSBwYXNzZWQgaW5cblx0XHRcdFx0XHRcdFx0aWYgKCBhW2ldICE9PSBcIlwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0b3V0ID0gW107XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBnZXRcblx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoIDAsIGkrMSApO1xuXHRcdFx0XHRcdFx0XHRpbm5lclNyYyA9IGEuam9pbignLicpO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gVHJhdmVyc2UgZWFjaCBlbnRyeSBpbiB0aGUgYXJyYXkgZ2V0dGluZyB0aGUgcHJvcGVydGllcyByZXF1ZXN0ZWRcblx0XHRcdFx0XHRcdFx0aWYgKCAkLmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaj0wLCBqTGVuPWRhdGEubGVuZ3RoIDsgajxqTGVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0LnB1c2goIGZldGNoRGF0YSggZGF0YVtqXSwgdHlwZSwgaW5uZXJTcmMgKSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0Ly8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gaW4gYmV0d2VlbiB0aGUgYXJyYXkgbm90YXRpb24gaW5kaWNhdG9ycywgdGhhdFxuXHRcdFx0XHRcdFx0XHQvLyBpcyB1c2VkIHRvIGpvaW4gdGhlIHN0cmluZ3MgdG9nZXRoZXIsIG90aGVyd2lzZSBhbiBhcnJheSBpcyByZXR1cm5lZFxuXHRcdFx0XHRcdFx0XHR2YXIgam9pbiA9IGFycmF5Tm90YXRpb25bMF0uc3Vic3RyaW5nKDEsIGFycmF5Tm90YXRpb25bMF0ubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gKGpvaW49PT1cIlwiKSA/IG91dCA6IG91dC5qb2luKGpvaW4pO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gZmV0Y2hEYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcblx0XHRcdFx0XHRcdFx0Ly8gb2YgdGhlIHNvdXJjZSByZXF1ZXN0ZWQsIHNvIHdlIGV4aXQgZnJvbSB0aGUgbG9vcFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKCBmdW5jTm90YXRpb24gKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7IC8vIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBmZXRjaERhdGEoIGRhdGEsIHR5cGUsIG1Tb3VyY2UgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvKiBBcnJheSBvciBmbGF0IG9iamVjdCBtYXBwaW5nICovXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUpIHsgLy8gcm93IGFuZCBtZXRhIGFsc28gcGFzc2VkLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIGRhdGFbbVNvdXJjZV07XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldCBkYXRhIGZyb20gYSBzb3VyY2Ugb2JqZWN0LCB0YWtpbmdcblx0ICogaW50byBhY2NvdW50IHRoZSBhYmlsaXR5IHRvIHVzZSBuZXN0ZWQgb2JqZWN0cyBhcyBhIHNvdXJjZVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd8aW50fGZ1bmN0aW9ufSBtU291cmNlIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2Z1bmN0aW9ufSBEYXRhIHNldCBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TZXRPYmplY3REYXRhRm4oIG1Tb3VyY2UgKVxuXHR7XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIG1Tb3VyY2UgKSApXG5cdFx0e1xuXHRcdFx0LyogVW5saWtlIGdldCwgb25seSB0aGUgdW5kZXJzY29yZSAoZ2xvYmFsKSBvcHRpb24gaXMgdXNlZCBmb3IgZm9yXG5cdFx0XHQgKiBzZXR0aW5nIGRhdGEgc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBoZXJlLiBUaGlzIGlzIHdoeSBhbiBvYmplY3Rcblx0XHRcdCAqIG9wdGlvbiBpcyBub3QgZG9jdW1lbnRlZCBmb3IgYG1EYXRhYCAod2hpY2ggaXMgcmVhZC93cml0ZSksIGJ1dCBpdCBpc1xuXHRcdFx0ICogZm9yIGBtUmVuZGVyYCB3aGljaCBpcyByZWFkIG9ubHkuXG5cdFx0XHQgKi9cblx0XHRcdHJldHVybiBfZm5TZXRPYmplY3REYXRhRm4oIG1Tb3VyY2UuXyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbVNvdXJjZSA9PT0gbnVsbCApXG5cdFx0e1xuXHRcdFx0LyogTm90aGluZyB0byBkbyB3aGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsICovXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge307XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgbVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwsIG1ldGEpIHtcblx0XHRcdFx0bVNvdXJjZSggZGF0YSwgJ3NldCcsIHZhbCwgbWV0YSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHQgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSApXG5cdFx0e1xuXHRcdFx0LyogTGlrZSB0aGUgZ2V0LCB3ZSBuZWVkIHRvIGdldCBkYXRhIGZyb20gYSBuZXN0ZWQgb2JqZWN0ICovXG5cdFx0XHR2YXIgc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB2YWwsIHNyYykge1xuXHRcdFx0XHR2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oIHNyYyApLCBiO1xuXHRcdFx0XHR2YXIgYUxhc3QgPSBhW2EubGVuZ3RoLTFdO1xuXHRcdFx0XHR2YXIgYXJyYXlOb3RhdGlvbiwgZnVuY05vdGF0aW9uLCBvLCBpbm5lclNyYztcblx0XG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGlMZW49YS5sZW5ndGgtMSA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIGFycmF5IG5vdGF0aW9uIHJlcXVlc3Rcblx0XHRcdFx0XHRhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xuXHRcdFx0XHRcdGZ1bmNOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUZuKTtcblx0XG5cdFx0XHRcdFx0aWYgKCBhcnJheU5vdGF0aW9uIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVBcnJheSwgJycpO1xuXHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdID0gW107XG5cdFxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSByZW1haW5kZXIgb2YgdGhlIG5lc3RlZCBvYmplY3QgdG8gc2V0IHNvIHdlIGNhbiByZWN1cnNlXG5cdFx0XHRcdFx0XHRiID0gYS5zbGljZSgpO1xuXHRcdFx0XHRcdFx0Yi5zcGxpY2UoIDAsIGkrMSApO1xuXHRcdFx0XHRcdFx0aW5uZXJTcmMgPSBiLmpvaW4oJy4nKTtcblx0XG5cdFx0XHRcdFx0XHQvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBzZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxuXHRcdFx0XHRcdFx0aWYgKCAkLmlzQXJyYXkoIHZhbCApIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj12YWwubGVuZ3RoIDsgajxqTGVuIDsgaisrIClcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdG8gPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRzZXREYXRhKCBvLCB2YWxbal0sIGlubmVyU3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdLnB1c2goIG8gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBXZSd2ZSBiZWVuIGFza2VkIHRvIHNhdmUgZGF0YSB0byBhbiBhcnJheSwgYnV0IGl0XG5cdFx0XHRcdFx0XHRcdC8vIGlzbid0IGFycmF5IGRhdGEgdG8gYmUgc2F2ZWQuIEJlc3QgdGhhdCBjYW4gYmUgZG9uZVxuXHRcdFx0XHRcdFx0XHQvLyBpcyB0byBqdXN0IHNhdmUgdGhlIHZhbHVlLlxuXHRcdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB2YWw7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gc2V0RGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXG5cdFx0XHRcdFx0XHQvLyBvZiB0aGUgc291cmNlIGFuZCBoYXMgc2V0IHRoZSBkYXRhLCB0aHVzIHdlIGNhbiBleGl0IGhlcmVcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGZ1bmNOb3RhdGlvbiApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oIHZhbCApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG5lc3RlZCBvYmplY3QgZG9lc24ndCBjdXJyZW50bHkgZXhpc3QgLSBzaW5jZSB3ZSBhcmVcblx0XHRcdFx0XHQvLyB0cnlpbmcgdG8gc2V0IHRoZSB2YWx1ZSAtIGNyZWF0ZSBpdFxuXHRcdFx0XHRcdGlmICggZGF0YVsgYVtpXSBdID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gTGFzdCBpdGVtIGluIHRoZSBpbnB1dCAtIGkuZSwgdGhlIGFjdHVhbCBzZXRcblx0XHRcdFx0aWYgKCBhTGFzdC5tYXRjaChfX3JlRm4gKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFMYXN0LnJlcGxhY2UoX19yZUZuLCAnJykgXSggdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gSWYgYXJyYXkgbm90YXRpb24gaXMgdXNlZCwgd2UganVzdCB3YW50IHRvIHN0cmlwIGl0IGFuZCB1c2UgdGhlIHByb3BlcnR5IG5hbWVcblx0XHRcdFx0XHQvLyBhbmQgYXNzaWduIHRoZSB2YWx1ZS4gSWYgaXQgaXNuJ3QgdXNlZCwgdGhlbiB3ZSBnZXQgdGhlIHJlc3VsdCB3ZSB3YW50IGFueXdheVxuXHRcdFx0XHRcdGRhdGFbIGFMYXN0LnJlcGxhY2UoX19yZUFycmF5LCAnJykgXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIHNldERhdGEoIGRhdGEsIHZhbCwgbVNvdXJjZSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8qIEFycmF5IG9yIGZsYXQgb2JqZWN0IG1hcHBpbmcgKi9cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsKSB7IC8vIG1ldGEgaXMgYWxzbyBwYXNzZWQgaW4sIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRkYXRhW21Tb3VyY2VdID0gdmFsO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIGZ1bGwgdGFibGUgZGF0YVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMgYXJyYXkge2FycmF5fSBhRGF0YSBNYXN0ZXIgZGF0YSBhcnJheVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXREYXRhTWFzdGVyICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIE51a2UgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNsZWFyVGFibGUoIHNldHRpbmdzIClcblx0e1xuXHRcdHNldHRpbmdzLmFvRGF0YS5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFJZHMgPSB7fTtcblx0fVxuXHRcblx0XG5cdCAvKipcblx0ICogVGFrZSBhbiBhcnJheSBvZiBpbnRlZ2VycyAoaW5kZXggYXJyYXkpIGFuZCByZW1vdmUgYSB0YXJnZXQgaW50ZWdlciAodmFsdWUgLSBub3Rcblx0ICogdGhlIGtleSEpXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhIEluZGV4IGFycmF5IHRvIHRhcmdldFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlUYXJnZXQgdmFsdWUgdG8gZmluZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EZWxldGVJbmRleCggYSwgaVRhcmdldCwgc3BsaWNlIClcblx0e1xuXHRcdHZhciBpVGFyZ2V0SW5kZXggPSAtMTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0aWYgKCBhW2ldID09IGlUYXJnZXQgKVxuXHRcdFx0e1xuXHRcdFx0XHRpVGFyZ2V0SW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGFbaV0gPiBpVGFyZ2V0IClcblx0XHRcdHtcblx0XHRcdFx0YVtpXS0tO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0aWYgKCBpVGFyZ2V0SW5kZXggIT0gLTEgJiYgc3BsaWNlID09PSB1bmRlZmluZWQgKVxuXHRcdHtcblx0XHRcdGEuc3BsaWNlKCBpVGFyZ2V0SW5kZXgsIDEgKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogTWFyayBjYWNoZWQgZGF0YSBhcyBpbnZhbGlkIHN1Y2ggdGhhdCBhIHJlLXJlYWQgb2YgdGhlIGRhdGEgd2lsbCBvY2N1ciB3aGVuXG5cdCAqIHRoZSBjYWNoZWQgZGF0YSBpcyBuZXh0IHJlcXVlc3RlZC4gQWxzbyB1cGRhdGUgZnJvbSB0aGUgZGF0YSBzb3VyY2Ugb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHtpbnR9ICAgIHJvd0lkeCAgIFJvdyBpbmRleCB0byBpbnZhbGlkYXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSAgICBTb3VyY2UgdG8gaW52YWxpZGF0ZSBmcm9tOiB1bmRlZmluZWQsICdhdXRvJywgJ2RvbSdcblx0ICogICAgIG9yICdkYXRhJ1xuXHQgKiBAcGFyYW0ge2ludH0gICAgW2NvbElkeF0gQ29sdW1uIGluZGV4IHRvIGludmFsaWRhdGUuIElmIHVuZGVmaW5lZCB0aGUgd2hvbGVcblx0ICogICAgIHJvdyB3aWxsIGJlIGludmFsaWRhdGVkXG5cdCAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKlxuXHQgKiBAdG9kbyBGb3IgdGhlIG1vZHVsYXJpc2F0aW9uIG9mIHYxLjExIHRoaXMgd2lsbCBuZWVkIHRvIGJlY29tZSBhIGNhbGxiYWNrLCBzb1xuXHQgKiAgIHRoZSBzb3J0IGFuZCBmaWx0ZXIgbWV0aG9kcyBjYW4gc3Vic2NyaWJlIHRvIGl0LiBUaGF0IHdpbGwgcmVxdWlyZWRcblx0ICogICBpbml0aWFsaXNhdGlvbiBvcHRpb25zIGZvciBzb3J0aW5nLCB3aGljaCBpcyB3aHkgaXQgaXMgbm90IGFscmVhZHkgYmFrZWQgaW5cblx0ICovXG5cdGZ1bmN0aW9uIF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3dJZHgsIHNyYywgY29sSWR4IClcblx0e1xuXHRcdHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbIHJvd0lkeCBdO1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIGNlbGxXcml0ZSA9IGZ1bmN0aW9uICggY2VsbCwgY29sICkge1xuXHRcdFx0Ly8gVGhpcyBpcyB2ZXJ5IGZydXN0cmF0aW5nLCBidXQgaW4gSUUgaWYgeW91IGp1c3Qgd3JpdGUgZGlyZWN0bHlcblx0XHRcdC8vIHRvIGlubmVySFRNTCwgYW5kIGVsZW1lbnRzIHRoYXQgYXJlIG92ZXJ3cml0dGVuIGFyZSBHQydlZCxcblx0XHRcdC8vIGV2ZW4gaWYgdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gdGhlbSBlbHNld2hlcmVcblx0XHRcdHdoaWxlICggY2VsbC5jaGlsZE5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0Y2VsbC5yZW1vdmVDaGlsZCggY2VsbC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Y2VsbC5pbm5lckhUTUwgPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sLCAnZGlzcGxheScgKTtcblx0XHR9O1xuXHRcblx0XHQvLyBBcmUgd2UgcmVhZGluZyBsYXN0IGRhdGEgZnJvbSBET00gb3IgdGhlIGRhdGEgb2JqZWN0P1xuXHRcdGlmICggc3JjID09PSAnZG9tJyB8fCAoKCEgc3JjIHx8IHNyYyA9PT0gJ2F1dG8nKSAmJiByb3cuc3JjID09PSAnZG9tJykgKSB7XG5cdFx0XHQvLyBSZWFkIHRoZSBkYXRhIGZyb20gdGhlIERPTVxuXHRcdFx0cm93Ll9hRGF0YSA9IF9mbkdldFJvd0VsZW1lbnRzKFxuXHRcdFx0XHRcdHNldHRpbmdzLCByb3csIGNvbElkeCwgY29sSWR4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByb3cuX2FEYXRhXG5cdFx0XHRcdClcblx0XHRcdFx0LmRhdGE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVhZGluZyBmcm9tIGRhdGEgb2JqZWN0LCB1cGRhdGUgdGhlIERPTVxuXHRcdFx0dmFyIGNlbGxzID0gcm93LmFuQ2VsbHM7XG5cdFxuXHRcdFx0aWYgKCBjZWxscyApIHtcblx0XHRcdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRjZWxsV3JpdGUoIGNlbGxzW2NvbElkeF0sIGNvbElkeCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2VsbFdyaXRlKCBjZWxsc1tpXSwgaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gRm9yIGJvdGggcm93IGFuZCBjZWxsIGludmFsaWRhdGlvbiwgdGhlIGNhY2hlZCBkYXRhIGZvciBzb3J0aW5nIGFuZFxuXHRcdC8vIGZpbHRlcmluZyBpcyBudWxsZWQgb3V0XG5cdFx0cm93Ll9hU29ydERhdGEgPSBudWxsO1xuXHRcdHJvdy5fYUZpbHRlckRhdGEgPSBudWxsO1xuXHRcblx0XHQvLyBJbnZhbGlkYXRlIHRoZSB0eXBlIGZvciBhIHNwZWNpZmljIGNvbHVtbiAoaWYgZ2l2ZW4pIG9yIGFsbCBjb2x1bW5zIHNpbmNlXG5cdFx0Ly8gdGhlIGRhdGEgbWlnaHQgaGF2ZSBjaGFuZ2VkXG5cdFx0dmFyIGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNvbHNbIGNvbElkeCBdLnNUeXBlID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jb2xzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2xzW2ldLnNUeXBlID0gbnVsbDtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBVcGRhdGUgRGF0YVRhYmxlcyBzcGVjaWFsIGBEVF8qYCBhdHRyaWJ1dGVzIGZvciB0aGUgcm93XG5cdFx0XHRfZm5Sb3dBdHRyaWJ1dGVzKCBzZXR0aW5ncywgcm93ICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJ1aWxkIGEgZGF0YSBzb3VyY2Ugb2JqZWN0IGZyb20gYW4gSFRNTCByb3csIHJlYWRpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZVxuXHQgKiBjZWxscyB0aGF0IGFyZSBpbiB0aGUgcm93LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHtub2RlfG9iamVjdH0gVFIgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQgZGF0YSBvciBleGlzdGluZyByb3dcblx0ICogICBvYmplY3QgZnJvbSB3aGljaCB0byByZS1yZWFkIHRoZSBkYXRhIGZyb20gdGhlIGNlbGxzXG5cdCAqIEBwYXJhbSB7aW50fSBbY29sSWR4XSBPcHRpb25hbCBjb2x1bW4gaW5kZXhcblx0ICogQHBhcmFtIHthcnJheXxvYmplY3R9IFtkXSBEYXRhIHNvdXJjZSBvYmplY3QuIElmIGBjb2xJZHhgIGlzIGdpdmVuIHRoZW4gdGhpc1xuXHQgKiAgIHBhcmFtZXRlciBzaG91bGQgYWxzbyBiZSBnaXZlbiBhbmQgd2lsbCBiZSB1c2VkIHRvIHdyaXRlIHRoZSBkYXRhIGludG8uXG5cdCAqICAgT25seSB0aGUgY29sdW1uIGluIHF1ZXN0aW9uIHdpbGwgYmUgd3JpdHRlblxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0d28gcGFyYW1ldGVyczogYGRhdGFgIHRoZSBkYXRhIHJlYWQsIGluXG5cdCAqICAgZG9jdW1lbnQgb3JkZXIsIGFuZCBgY2VsbHNgIGFuZCBhcnJheSBvZiBub2RlcyAodGhleSBjYW4gYmUgdXNlZnVsIHRvIHRoZVxuXHQgKiAgIGNhbGxlciwgc28gcmF0aGVyIHRoYW4gbmVlZGluZyBhIHNlY29uZCB0cmF2ZXJzYWwgdG8gZ2V0IHRoZW0sIGp1c3QgcmV0dXJuXG5cdCAqICAgdGhlbSBmcm9tIGhlcmUpLlxuXHQgKiBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkdldFJvd0VsZW1lbnRzKCBzZXR0aW5ncywgcm93LCBjb2xJZHgsIGQgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0ZHMgPSBbXSxcblx0XHRcdHRkID0gcm93LmZpcnN0Q2hpbGQsXG5cdFx0XHRuYW1lLCBjb2wsIG8sIGk9MCwgY29udGVudHMsXG5cdFx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0b2JqZWN0UmVhZCA9IHNldHRpbmdzLl9yb3dSZWFkT2JqZWN0O1xuXHRcblx0XHQvLyBBbGxvdyB0aGUgZGF0YSBvYmplY3QgdG8gYmUgcGFzc2VkIGluLCBvciBjb25zdHJ1Y3Rcblx0XHRkID0gZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGQgOlxuXHRcdFx0b2JqZWN0UmVhZCA/XG5cdFx0XHRcdHt9IDpcblx0XHRcdFx0W107XG5cdFxuXHRcdHZhciBhdHRyID0gZnVuY3Rpb24gKCBzdHIsIHRkICApIHtcblx0XHRcdGlmICggdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHZhciBpZHggPSBzdHIuaW5kZXhPZignQCcpO1xuXHRcblx0XHRcdFx0aWYgKCBpZHggIT09IC0xICkge1xuXHRcdFx0XHRcdHZhciBhdHRyID0gc3RyLnN1YnN0cmluZyggaWR4KzEgKTtcblx0XHRcdFx0XHR2YXIgc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKCBzdHIgKTtcblx0XHRcdFx0XHRzZXR0ZXIoIGQsIHRkLmdldEF0dHJpYnV0ZSggYXR0ciApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHQvLyBSZWFkIGRhdGEgZnJvbSBhIGNlbGwgYW5kIHN0b3JlIGludG8gdGhlIGRhdGEgb2JqZWN0XG5cdFx0dmFyIGNlbGxQcm9jZXNzID0gZnVuY3Rpb24gKCBjZWxsICkge1xuXHRcdFx0aWYgKCBjb2xJZHggPT09IHVuZGVmaW5lZCB8fCBjb2xJZHggPT09IGkgKSB7XG5cdFx0XHRcdGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHRcdGNvbnRlbnRzID0gJC50cmltKGNlbGwuaW5uZXJIVE1MKTtcblx0XG5cdFx0XHRcdGlmICggY29sICYmIGNvbC5fYkF0dHJTcmMgKSB7XG5cdFx0XHRcdFx0dmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggY29sLm1EYXRhLl8gKTtcblx0XHRcdFx0XHRzZXR0ZXIoIGQsIGNvbnRlbnRzICk7XG5cdFxuXHRcdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS5zb3J0LCBjZWxsICk7XG5cdFx0XHRcdFx0YXR0ciggY29sLm1EYXRhLnR5cGUsIGNlbGwgKTtcblx0XHRcdFx0XHRhdHRyKCBjb2wubURhdGEuZmlsdGVyLCBjZWxsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRGVwZW5kaW5nIG9uIHRoZSBgZGF0YWAgb3B0aW9uIGZvciB0aGUgY29sdW1ucyB0aGUgZGF0YSBjYW5cblx0XHRcdFx0XHQvLyBiZSByZWFkIHRvIGVpdGhlciBhbiBvYmplY3Qgb3IgYW4gYXJyYXkuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3RSZWFkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhIGNvbC5fc2V0dGVyICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgc2V0dGVyIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRcdGNvbC5fc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKCBjb2wubURhdGEgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbC5fc2V0dGVyKCBkLCBjb250ZW50cyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGRbaV0gPSBjb250ZW50cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRpKys7XG5cdFx0fTtcblx0XG5cdFx0aWYgKCB0ZCApIHtcblx0XHRcdC8vIGB0cmAgZWxlbWVudCB3YXMgcGFzc2VkIGluXG5cdFx0XHR3aGlsZSAoIHRkICkge1xuXHRcdFx0XHRuYW1lID0gdGQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcblx0XG5cdFx0XHRcdGlmICggbmFtZSA9PSBcIlREXCIgfHwgbmFtZSA9PSBcIlRIXCIgKSB7XG5cdFx0XHRcdFx0Y2VsbFByb2Nlc3MoIHRkICk7XG5cdFx0XHRcdFx0dGRzLnB1c2goIHRkICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHRkID0gdGQubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gRXhpc3Rpbmcgcm93IG9iamVjdCBwYXNzZWQgaW5cblx0XHRcdHRkcyA9IHJvdy5hbkNlbGxzO1xuXHRcblx0XHRcdGZvciAoIHZhciBqPTAsIGplbj10ZHMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdGNlbGxQcm9jZXNzKCB0ZHNbal0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8vIFJlYWQgdGhlIElEIGZyb20gdGhlIERPTSBpZiBwcmVzZW50XG5cdFx0dmFyIHJvd05vZGUgPSByb3cuZmlyc3RDaGlsZCA/IHJvdyA6IHJvdy5uVHI7XG5cdFxuXHRcdGlmICggcm93Tm9kZSApIHtcblx0XHRcdHZhciBpZCA9IHJvd05vZGUuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFxuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0X2ZuU2V0T2JqZWN0RGF0YUZuKCBzZXR0aW5ncy5yb3dJZCApKCBkLCBpZCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGE6IGQsXG5cdFx0XHRjZWxsczogdGRzXG5cdFx0fTtcblx0fVxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IFRSIGVsZW1lbnQgKGFuZCBpdCdzIFREIGNoaWxkcmVuKSBmb3IgYSByb3dcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBpUm93IFJvdyB0byBjb25zaWRlclxuXHQgKiAgQHBhcmFtIHtub2RlfSBbblRySW5dIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXG5cdCAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxuXHQgKiAgQHBhcmFtIHthcnJheX0gW2FuVGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cblx0ICogICAgaWYgblRyIGlzLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DcmVhdGVUciAoIG9TZXR0aW5ncywgaVJvdywgblRySW4sIGFuVGRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0cm93ID0gb1NldHRpbmdzLmFvRGF0YVtpUm93XSxcblx0XHRcdHJvd0RhdGEgPSByb3cuX2FEYXRhLFxuXHRcdFx0Y2VsbHMgPSBbXSxcblx0XHRcdG5UciwgblRkLCBvQ29sLFxuXHRcdFx0aSwgaUxlbjtcblx0XG5cdFx0aWYgKCByb3cublRyID09PSBudWxsIClcblx0XHR7XG5cdFx0XHRuVHIgPSBuVHJJbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXHRcblx0XHRcdHJvdy5uVHIgPSBuVHI7XG5cdFx0XHRyb3cuYW5DZWxscyA9IGNlbGxzO1xuXHRcblx0XHRcdC8qIFVzZSBhIHByaXZhdGUgcHJvcGVydHkgb24gdGhlIG5vZGUgdG8gYWxsb3cgcmVzZXJ2ZSBtYXBwaW5nIGZyb20gdGhlIG5vZGVcblx0XHRcdCAqIHRvIHRoZSBhb0RhdGEgYXJyYXkgZm9yIGZhc3QgbG9vayB1cFxuXHRcdFx0ICovXG5cdFx0XHRuVHIuX0RUX1Jvd0luZGV4ID0gaVJvdztcblx0XG5cdFx0XHQvKiBTcGVjaWFsIHBhcmFtZXRlcnMgY2FuIGJlIGdpdmVuIGJ5IHRoZSBkYXRhIHNvdXJjZSB0byBiZSB1c2VkIG9uIHRoZSByb3cgKi9cblx0XHRcdF9mblJvd0F0dHJpYnV0ZXMoIG9TZXR0aW5ncywgcm93ICk7XG5cdFxuXHRcdFx0LyogUHJvY2VzcyBlYWNoIGNvbHVtbiAqL1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPW9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0b0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XG5cdFxuXHRcdFx0XHRuVGQgPSBuVHJJbiA/IGFuVGRzW2ldIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggb0NvbC5zQ2VsbFR5cGUgKTtcblx0XHRcdFx0blRkLl9EVF9DZWxsSW5kZXggPSB7XG5cdFx0XHRcdFx0cm93OiBpUm93LFxuXHRcdFx0XHRcdGNvbHVtbjogaVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Y2VsbHMucHVzaCggblRkICk7XG5cdFxuXHRcdFx0XHQvLyBOZWVkIHRvIGNyZWF0ZSB0aGUgSFRNTCBpZiBuZXcsIG9yIGlmIGEgcmVuZGVyaW5nIGZ1bmN0aW9uIGlzIGRlZmluZWRcblx0XHRcdFx0aWYgKCAoIW5UckluIHx8IG9Db2wubVJlbmRlciB8fCBvQ29sLm1EYXRhICE9PSBpKSAmJlxuXHRcdFx0XHRcdCAoISQuaXNQbGFpbk9iamVjdChvQ29sLm1EYXRhKSB8fCBvQ29sLm1EYXRhLl8gIT09IGkrJy5kaXNwbGF5Jylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0blRkLmlubmVySFRNTCA9IF9mbkdldENlbGxEYXRhKCBvU2V0dGluZ3MsIGlSb3csIGksICdkaXNwbGF5JyApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvKiBBZGQgdXNlciBkZWZpbmVkIGNsYXNzICovXG5cdFx0XHRcdGlmICggb0NvbC5zQ2xhc3MgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0blRkLmNsYXNzTmFtZSArPSAnICcrb0NvbC5zQ2xhc3M7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIFZpc2liaWxpdHkgLSBhZGQgb3IgcmVtb3ZlIGFzIHJlcXVpcmVkXG5cdFx0XHRcdGlmICggb0NvbC5iVmlzaWJsZSAmJiAhIG5UckluIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5Uci5hcHBlbmRDaGlsZCggblRkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoICEgb0NvbC5iVmlzaWJsZSAmJiBuVHJJbiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuVGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggblRkICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGlmICggb0NvbC5mbkNyZWF0ZWRDZWxsIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG9Db2wuZm5DcmVhdGVkQ2VsbC5jYWxsKCBvU2V0dGluZ3Mub0luc3RhbmNlLFxuXHRcdFx0XHRcdFx0blRkLCBfZm5HZXRDZWxsRGF0YSggb1NldHRpbmdzLCBpUm93LCBpICksIHJvd0RhdGEsIGlSb3csIGlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1Jvd0NyZWF0ZWRDYWxsYmFjaycsIG51bGwsIFtuVHIsIHJvd0RhdGEsIGlSb3ddICk7XG5cdFx0fVxuXHRcblx0XHQvLyBSZW1vdmUgb25jZSB3ZWJraXQgYnVnIDEzMTgxOSBhbmQgQ2hyb21pdW0gYnVnIDM2NTYxOSBoYXZlIGJlZW4gcmVzb2x2ZWRcblx0XHQvLyBhbmQgZGVwbG95ZWRcblx0XHRyb3cublRyLnNldEF0dHJpYnV0ZSggJ3JvbGUnLCAncm93JyApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkZCBhdHRyaWJ1dGVzIHRvIGEgcm93IGJhc2VkIG9uIHRoZSBzcGVjaWFsIGBEVF8qYCBwYXJhbWV0ZXJzIGluIGEgZGF0YVxuXHQgKiBzb3VyY2Ugb2JqZWN0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gRGF0YVRhYmxlcyByb3cgb2JqZWN0IGZvciB0aGUgcm93IHRvIGJlIG1vZGlmaWVkXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblJvd0F0dHJpYnV0ZXMoIHNldHRpbmdzLCByb3cgKVxuXHR7XG5cdFx0dmFyIHRyID0gcm93Lm5Ucjtcblx0XHR2YXIgZGF0YSA9IHJvdy5fYURhdGE7XG5cdFxuXHRcdGlmICggdHIgKSB7XG5cdFx0XHR2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKCBkYXRhICk7XG5cdFxuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0dHIuaWQgPSBpZDtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGRhdGEuRFRfUm93Q2xhc3MgKSB7XG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgY2xhc3NlcyBhZGRlZCBieSBEVF9Sb3dDbGFzcyBiZWZvcmVcblx0XHRcdFx0dmFyIGEgPSBkYXRhLkRUX1Jvd0NsYXNzLnNwbGl0KCcgJyk7XG5cdFx0XHRcdHJvdy5fX3Jvd2MgPSByb3cuX19yb3djID9cblx0XHRcdFx0XHRfdW5pcXVlKCByb3cuX19yb3djLmNvbmNhdCggYSApICkgOlxuXHRcdFx0XHRcdGE7XG5cdFxuXHRcdFx0XHQkKHRyKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggcm93Ll9fcm93Yy5qb2luKCcgJykgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggZGF0YS5EVF9Sb3dDbGFzcyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggZGF0YS5EVF9Sb3dBdHRyICkge1xuXHRcdFx0XHQkKHRyKS5hdHRyKCBkYXRhLkRUX1Jvd0F0dHIgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGRhdGEuRFRfUm93RGF0YSApIHtcblx0XHRcdFx0JCh0cikuZGF0YSggZGF0YS5EVF9Sb3dEYXRhICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgSFRNTCBoZWFkZXIgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5CdWlsZEhlYWQoIG9TZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgaSwgaWVuLCBjZWxsLCByb3csIGNvbHVtbjtcblx0XHR2YXIgdGhlYWQgPSBvU2V0dGluZ3MublRIZWFkO1xuXHRcdHZhciB0Zm9vdCA9IG9TZXR0aW5ncy5uVEZvb3Q7XG5cdFx0dmFyIGNyZWF0ZUhlYWRlciA9ICQoJ3RoLCB0ZCcsIHRoZWFkKS5sZW5ndGggPT09IDA7XG5cdFx0dmFyIGNsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcblx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdHJvdyA9ICQoJzx0ci8+JykuYXBwZW5kVG8oIHRoZWFkICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1tpXTtcblx0XHRcdGNlbGwgPSAkKCBjb2x1bW4ublRoICkuYWRkQ2xhc3MoIGNvbHVtbi5zQ2xhc3MgKTtcblx0XG5cdFx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdFx0Y2VsbC5hcHBlbmRUbyggcm93ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gMS4xMSBtb3ZlIGludG8gc29ydGluZ1xuXHRcdFx0aWYgKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0XHRjZWxsLmFkZENsYXNzKCBjb2x1bW4uc1NvcnRpbmdDbGFzcyApO1xuXHRcblx0XHRcdFx0aWYgKCBjb2x1bW4uYlNvcnRhYmxlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQuYXR0ciggJ3RhYmluZGV4Jywgb1NldHRpbmdzLmlUYWJJbmRleCApXG5cdFx0XHRcdFx0XHQuYXR0ciggJ2FyaWEtY29udHJvbHMnLCBvU2V0dGluZ3Muc1RhYmxlSWQgKTtcblx0XG5cdFx0XHRcdFx0X2ZuU29ydEF0dGFjaExpc3RlbmVyKCBvU2V0dGluZ3MsIGNvbHVtbi5uVGgsIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggY29sdW1uLnNUaXRsZSAhPSBjZWxsWzBdLmlubmVySFRNTCApIHtcblx0XHRcdFx0Y2VsbC5odG1sKCBjb2x1bW4uc1RpdGxlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0X2ZuUmVuZGVyZXIoIG9TZXR0aW5ncywgJ2hlYWRlcicgKShcblx0XHRcdFx0b1NldHRpbmdzLCBjZWxsLCBjb2x1bW4sIGNsYXNzZXNcblx0XHRcdCk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLmFvSGVhZGVyLCB0aGVhZCApO1xuXHRcdH1cblx0XHRcblx0XHQvKiBBUklBIHJvbGUgZm9yIHRoZSByb3dzICovXG5cdCBcdCQodGhlYWQpLmZpbmQoJz50cicpLmF0dHIoJ3JvbGUnLCAncm93Jyk7XG5cdFxuXHRcdC8qIERlYWwgd2l0aCB0aGUgZm9vdGVyIC0gYWRkIGNsYXNzZXMgaWYgcmVxdWlyZWQgKi9cblx0XHQkKHRoZWFkKS5maW5kKCc+dHI+dGgsID50cj50ZCcpLmFkZENsYXNzKCBjbGFzc2VzLnNIZWFkZXJUSCApO1xuXHRcdCQodGZvb3QpLmZpbmQoJz50cj50aCwgPnRyPnRkJykuYWRkQ2xhc3MoIGNsYXNzZXMuc0Zvb3RlclRIICk7XG5cdFxuXHRcdC8vIENhY2hlIHRoZSBmb290ZXIgY2VsbHMuIE5vdGUgdGhhdCB3ZSBvbmx5IHRha2UgdGhlIGNlbGxzIGZyb20gdGhlIGZpcnN0XG5cdFx0Ly8gcm93IGluIHRoZSBmb290ZXIuIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcm93IHRoZSB1c2VyIHdhbnRzIHRvXG5cdFx0Ly8gaW50ZXJhY3Qgd2l0aCwgdGhleSBuZWVkIHRvIHVzZSB0aGUgdGFibGUoKS5mb290KCkgbWV0aG9kLiBOb3RlIGFsc28gdGhpc1xuXHRcdC8vIGFsbG93cyBjZWxscyB0byBiZSB1c2VkIGZvciBtdWx0aXBsZSBjb2x1bW5zIHVzaW5nIGNvbHNwYW5cblx0XHRpZiAoIHRmb290ICE9PSBudWxsICkge1xuXHRcdFx0dmFyIGNlbGxzID0gb1NldHRpbmdzLmFvRm9vdGVyWzBdO1xuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcdFx0XHRjb2x1bW4ublRmID0gY2VsbHNbaV0uY2VsbDtcblx0XG5cdFx0XHRcdGlmICggY29sdW1uLnNDbGFzcyApIHtcblx0XHRcdFx0XHQkKGNvbHVtbi5uVGYpLmFkZENsYXNzKCBjb2x1bW4uc0NsYXNzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRHJhdyB0aGUgaGVhZGVyIChvciBmb290ZXIpIGVsZW1lbnQgYmFzZWQgb24gdGhlIGNvbHVtbiB2aXNpYmlsaXR5IHN0YXRlcy4gVGhlXG5cdCAqIG1ldGhvZG9sb2d5IGhlcmUgaXMgdG8gdXNlIHRoZSBsYXlvdXQgYXJyYXkgZnJvbSBfZm5EZXRlY3RIZWFkZXIsIG1vZGlmaWVkIGZvclxuXHQgKiB0aGUgaW5zdGFudGFuZW91cyBjb2x1bW4gdmlzaWJpbGl0eSwgdG8gY29uc3RydWN0IHRoZSBuZXcgbGF5b3V0LiBUaGUgZ3JpZCBpc1xuXHQgKiB0cmF2ZXJzZWQgb3ZlciBjZWxsIGF0IGEgdGltZSBpbiBhIHJvd3MgeCBjb2x1bW5zIGdyaWQgZmFzaGlvbiwgYWx0aG91Z2ggZWFjaFxuXHQgKiBjZWxsIGluc2VydCBjYW4gY292ZXIgbXVsdGlwbGUgZWxlbWVudHMgaW4gdGhlIGdyaWQgLSB3aGljaCBpcyB0cmFja3MgdXNpbmcgdGhlXG5cdCAqIGFBcHBsaWVkIGFycmF5LiBDZWxsIGluc2VydHMgaW4gdGhlIGdyaWQgd2lsbCBvbmx5IG9jY3VyIHdoZXJlIHRoZXJlIGlzbid0XG5cdCAqIGFscmVhZHkgYSBjZWxsIGluIHRoYXQgcG9zaXRpb24uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0gYXJyYXkge29iamVjdHN9IGFvU291cmNlIExheW91dCBhcnJheSBmcm9tIF9mbkRldGVjdEhlYWRlclxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBbYkluY2x1ZGVIaWRkZW49ZmFsc2VdIElmIHRydWUgdGhlbiBpbmNsdWRlIHRoZSBoaWRkZW4gY29sdW1ucyBpbiB0aGUgY2FsYyxcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRHJhd0hlYWQoIG9TZXR0aW5ncywgYW9Tb3VyY2UsIGJJbmNsdWRlSGlkZGVuIClcblx0e1xuXHRcdHZhciBpLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLCBuLCBuTG9jYWxUcjtcblx0XHR2YXIgYW9Mb2NhbCA9IFtdO1xuXHRcdHZhciBhQXBwbGllZCA9IFtdO1xuXHRcdHZhciBpQ29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHRcdHZhciBpUm93c3BhbiwgaUNvbHNwYW47XG5cdFxuXHRcdGlmICggISBhb1NvdXJjZSApXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAgYkluY2x1ZGVIaWRkZW4gPT09IHVuZGVmaW5lZCApXG5cdFx0e1xuXHRcdFx0YkluY2x1ZGVIaWRkZW4gPSBmYWxzZTtcblx0XHR9XG5cdFxuXHRcdC8qIE1ha2UgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgbGF5b3V0IGFycmF5LCBidXQgd2l0aG91dCB0aGUgdmlzaWJsZSBjb2x1bW5zIGluIGl0ICovXG5cdFx0Zm9yICggaT0wLCBpTGVuPWFvU291cmNlLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0YW9Mb2NhbFtpXSA9IGFvU291cmNlW2ldLnNsaWNlKCk7XG5cdFx0XHRhb0xvY2FsW2ldLm5UciA9IGFvU291cmNlW2ldLm5Ucjtcblx0XG5cdFx0XHQvKiBSZW1vdmUgYW55IGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBoaWRkZW4gKi9cblx0XHRcdGZvciAoIGo9aUNvbHVtbnMtMSA7IGo+PTAgOyBqLS0gKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoICFvU2V0dGluZ3MuYW9Db2x1bW5zW2pdLmJWaXNpYmxlICYmICFiSW5jbHVkZUhpZGRlbiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhb0xvY2FsW2ldLnNwbGljZSggaiwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogUHJlcCB0aGUgYXBwbGllZCBhcnJheSAtIGl0IG5lZWRzIGFuIGVsZW1lbnQgZm9yIGVhY2ggcm93ICovXG5cdFx0XHRhQXBwbGllZC5wdXNoKCBbXSApO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wLCBpTGVuPWFvTG9jYWwubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRuTG9jYWxUciA9IGFvTG9jYWxbaV0ublRyO1xuXHRcblx0XHRcdC8qIEFsbCBjZWxscyBhcmUgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHNvIGVtcHR5IG91dCB0aGUgcm93ICovXG5cdFx0XHRpZiAoIG5Mb2NhbFRyIClcblx0XHRcdHtcblx0XHRcdFx0d2hpbGUoIChuID0gbkxvY2FsVHIuZmlyc3RDaGlsZCkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bkxvY2FsVHIucmVtb3ZlQ2hpbGQoIG4gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGZvciAoIGo9MCwgakxlbj1hb0xvY2FsW2ldLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHR7XG5cdFx0XHRcdGlSb3dzcGFuID0gMTtcblx0XHRcdFx0aUNvbHNwYW4gPSAxO1xuXHRcblx0XHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBjZWxsIChyb3cvY29sc3BhbikgY292ZXJpbmcgb3VyIHRhcmdldFxuXHRcdFx0XHQgKiBpbnNlcnQgcG9pbnQuIElmIHRoZXJlIGlzLCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoIGFBcHBsaWVkW2ldW2pdID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bkxvY2FsVHIuYXBwZW5kQ2hpbGQoIGFvTG9jYWxbaV1bal0uY2VsbCApO1xuXHRcdFx0XHRcdGFBcHBsaWVkW2ldW2pdID0gMTtcblx0XG5cdFx0XHRcdFx0LyogRXhwYW5kIHRoZSBjZWxsIHRvIGNvdmVyIGFzIG1hbnkgcm93cyBhcyBuZWVkZWQgKi9cblx0XHRcdFx0XHR3aGlsZSAoIGFvTG9jYWxbaStpUm93c3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdCAgICAgICAgYW9Mb2NhbFtpXVtqXS5jZWxsID09IGFvTG9jYWxbaStpUm93c3Bhbl1bal0uY2VsbCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YUFwcGxpZWRbaStpUm93c3Bhbl1bal0gPSAxO1xuXHRcdFx0XHRcdFx0aVJvd3NwYW4rKztcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8qIEV4cGFuZCB0aGUgY2VsbCB0byBjb3ZlciBhcyBtYW55IGNvbHVtbnMgYXMgbmVlZGVkICovXG5cdFx0XHRcdFx0d2hpbGUgKCBhb0xvY2FsW2ldW2oraUNvbHNwYW5dICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0XHQgICAgICAgIGFvTG9jYWxbaV1bal0uY2VsbCA9PSBhb0xvY2FsW2ldW2oraUNvbHNwYW5dLmNlbGwgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8qIE11c3QgdXBkYXRlIHRoZSBhcHBsaWVkIGFycmF5IG92ZXIgdGhlIHJvd3MgZm9yIHRoZSBjb2x1bW5zICovXG5cdFx0XHRcdFx0XHRmb3IgKCBrPTAgOyBrPGlSb3dzcGFuIDsgaysrIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0YUFwcGxpZWRbaStrXVtqK2lDb2xzcGFuXSA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpQ29sc3BhbisrO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0LyogRG8gdGhlIGFjdHVhbCBleHBhbnNpb24gaW4gdGhlIERPTSAqL1xuXHRcdFx0XHRcdCQoYW9Mb2NhbFtpXVtqXS5jZWxsKVxuXHRcdFx0XHRcdFx0LmF0dHIoJ3Jvd3NwYW4nLCBpUm93c3Bhbilcblx0XHRcdFx0XHRcdC5hdHRyKCdjb2xzcGFuJywgaUNvbHNwYW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEluc2VydCB0aGUgcmVxdWlyZWQgVFIgbm9kZXMgaW50byB0aGUgdGFibGUgZm9yIGRpc3BsYXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRHJhdyggb1NldHRpbmdzIClcblx0e1xuXHRcdC8qIFByb3ZpZGUgYSBwcmUtY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3IGlzIGZhbHNlIGlzIHJldHVybmVkICovXG5cdFx0dmFyIGFQcmVEcmF3ID0gX2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICdwcmVEcmF3JywgW29TZXR0aW5nc10gKTtcblx0XHRpZiAoICQuaW5BcnJheSggZmFsc2UsIGFQcmVEcmF3ICkgIT09IC0xIClcblx0XHR7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyIGksIGlMZW4sIG47XG5cdFx0dmFyIGFuUm93cyA9IFtdO1xuXHRcdHZhciBpUm93Q291bnQgPSAwO1xuXHRcdHZhciBhc1N0cmlwZUNsYXNzZXMgPSBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzO1xuXHRcdHZhciBpU3RyaXBlcyA9IGFzU3RyaXBlQ2xhc3Nlcy5sZW5ndGg7XG5cdFx0dmFyIGlPcGVuUm93cyA9IG9TZXR0aW5ncy5hb09wZW5Sb3dzLmxlbmd0aDtcblx0XHR2YXIgb0xhbmcgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xuXHRcdHZhciBpSW5pdERpc3BsYXlTdGFydCA9IG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcblx0XHR2YXIgYlNlcnZlclNpZGUgPSBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnc3NwJztcblx0XHR2YXIgYWlEaXNwbGF5ID0gb1NldHRpbmdzLmFpRGlzcGxheTtcblx0XG5cdFx0b1NldHRpbmdzLmJEcmF3aW5nID0gdHJ1ZTtcblx0XG5cdFx0LyogQ2hlY2sgYW5kIHNlZSBpZiB3ZSBoYXZlIGFuIGluaXRpYWwgZHJhdyBwb3NpdGlvbiBmcm9tIHN0YXRlIHNhdmluZyAqL1xuXHRcdGlmICggaUluaXREaXNwbGF5U3RhcnQgIT09IHVuZGVmaW5lZCAmJiBpSW5pdERpc3BsYXlTdGFydCAhPT0gLTEgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IGJTZXJ2ZXJTaWRlID9cblx0XHRcdFx0aUluaXREaXNwbGF5U3RhcnQgOlxuXHRcdFx0XHRpSW5pdERpc3BsYXlTdGFydCA+PSBvU2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpID9cblx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRpSW5pdERpc3BsYXlTdGFydDtcblx0XG5cdFx0XHRvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSAtMTtcblx0XHR9XG5cdFxuXHRcdHZhciBpRGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0O1xuXHRcdHZhciBpRGlzcGxheUVuZCA9IG9TZXR0aW5ncy5mbkRpc3BsYXlFbmQoKTtcblx0XG5cdFx0LyogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBkcmF3IGludGVyY2VwdCAqL1xuXHRcdGlmICggb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gZmFsc2U7XG5cdFx0XHRvU2V0dGluZ3MuaURyYXcrKztcblx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBvU2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhYlNlcnZlclNpZGUgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5pRHJhdysrO1xuXHRcdH1cblx0XHRlbHNlIGlmICggIW9TZXR0aW5ncy5iRGVzdHJveWluZyAmJiAhX2ZuQWpheFVwZGF0ZSggb1NldHRpbmdzICkgKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGlmICggYWlEaXNwbGF5Lmxlbmd0aCAhPT0gMCApXG5cdFx0e1xuXHRcdFx0dmFyIGlTdGFydCA9IGJTZXJ2ZXJTaWRlID8gMCA6IGlEaXNwbGF5U3RhcnQ7XG5cdFx0XHR2YXIgaUVuZCA9IGJTZXJ2ZXJTaWRlID8gb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggOiBpRGlzcGxheUVuZDtcblx0XG5cdFx0XHRmb3IgKCB2YXIgaj1pU3RhcnQgOyBqPGlFbmQgOyBqKysgKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgaURhdGFJbmRleCA9IGFpRGlzcGxheVtqXTtcblx0XHRcdFx0dmFyIGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGFbIGlEYXRhSW5kZXggXTtcblx0XHRcdFx0aWYgKCBhb0RhdGEublRyID09PSBudWxsIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF9mbkNyZWF0ZVRyKCBvU2V0dGluZ3MsIGlEYXRhSW5kZXggKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0dmFyIG5Sb3cgPSBhb0RhdGEublRyO1xuXHRcblx0XHRcdFx0LyogUmVtb3ZlIHRoZSBvbGQgc3RyaXBpbmcgY2xhc3NlcyBhbmQgdGhlbiBhZGQgdGhlIG5ldyBvbmUgKi9cblx0XHRcdFx0aWYgKCBpU3RyaXBlcyAhPT0gMCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgc1N0cmlwZSA9IGFzU3RyaXBlQ2xhc3Nlc1sgaVJvd0NvdW50ICUgaVN0cmlwZXMgXTtcblx0XHRcdFx0XHRpZiAoIGFvRGF0YS5fc1Jvd1N0cmlwZSAhPSBzU3RyaXBlIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQkKG5Sb3cpLnJlbW92ZUNsYXNzKCBhb0RhdGEuX3NSb3dTdHJpcGUgKS5hZGRDbGFzcyggc1N0cmlwZSApO1xuXHRcdFx0XHRcdFx0YW9EYXRhLl9zUm93U3RyaXBlID0gc1N0cmlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIFJvdyBjYWxsYmFjayBmdW5jdGlvbnMgLSBtaWdodCB3YW50IHRvIG1hbmlwdWxhdGUgdGhlIHJvd1xuXHRcdFx0XHQvLyBpUm93Q291bnQgYW5kIGogYXJlIG5vdCBjdXJyZW50bHkgZG9jdW1lbnRlZC4gQXJlIHRoZXkgYXQgYWxsXG5cdFx0XHRcdC8vIHVzZWZ1bD9cblx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgbnVsbCxcblx0XHRcdFx0XHRbblJvdywgYW9EYXRhLl9hRGF0YSwgaVJvd0NvdW50LCBqXSApO1xuXHRcblx0XHRcdFx0YW5Sb3dzLnB1c2goIG5Sb3cgKTtcblx0XHRcdFx0aVJvd0NvdW50Kys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvKiBUYWJsZSBpcyBlbXB0eSAtIGNyZWF0ZSBhIHJvdyB3aXRoIGFuIGVtcHR5IG1lc3NhZ2UgaW4gaXQgKi9cblx0XHRcdHZhciBzWmVybyA9IG9MYW5nLnNaZXJvUmVjb3Jkcztcblx0XHRcdGlmICggb1NldHRpbmdzLmlEcmF3ID09IDEgJiYgIF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09ICdhamF4JyApXG5cdFx0XHR7XG5cdFx0XHRcdHNaZXJvID0gb0xhbmcuc0xvYWRpbmdSZWNvcmRzO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG9MYW5nLnNFbXB0eVRhYmxlICYmIG9TZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpID09PSAwIClcblx0XHRcdHtcblx0XHRcdFx0c1plcm8gPSBvTGFuZy5zRW1wdHlUYWJsZTtcblx0XHRcdH1cblx0XG5cdFx0XHRhblJvd3NbIDAgXSA9ICQoICc8dHIvPicsIHsgJ2NsYXNzJzogaVN0cmlwZXMgPyBhc1N0cmlwZUNsYXNzZXNbMF0gOiAnJyB9IClcblx0XHRcdFx0LmFwcGVuZCggJCgnPHRkIC8+Jywge1xuXHRcdFx0XHRcdCd2YWxpZ24nOiAgJ3RvcCcsXG5cdFx0XHRcdFx0J2NvbFNwYW4nOiBfZm5WaXNibGVDb2x1bW5zKCBvU2V0dGluZ3MgKSxcblx0XHRcdFx0XHQnY2xhc3MnOiAgIG9TZXR0aW5ncy5vQ2xhc3Nlcy5zUm93RW1wdHlcblx0XHRcdFx0fSApLmh0bWwoIHNaZXJvICkgKVswXTtcblx0XHR9XG5cdFxuXHRcdC8qIEhlYWRlciBhbmQgZm9vdGVyIGNhbGxiYWNrcyAqL1xuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9IZWFkZXJDYWxsYmFjaycsICdoZWFkZXInLCBbICQob1NldHRpbmdzLm5USGVhZCkuY2hpbGRyZW4oJ3RyJylbMF0sXG5cdFx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9Gb290ZXJDYWxsYmFjaycsICdmb290ZXInLCBbICQob1NldHRpbmdzLm5URm9vdCkuY2hpbGRyZW4oJ3RyJylbMF0sXG5cdFx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cdFxuXHRcdHZhciBib2R5ID0gJChvU2V0dGluZ3MublRCb2R5KTtcblx0XG5cdFx0Ym9keS5jaGlsZHJlbigpLmRldGFjaCgpO1xuXHRcdGJvZHkuYXBwZW5kKCAkKGFuUm93cykgKTtcblx0XG5cdFx0LyogQ2FsbCBhbGwgcmVxdWlyZWQgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgZW5kIG9mIGEgZHJhdyAqL1xuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCAnZHJhdycsIFtvU2V0dGluZ3NdICk7XG5cdFxuXHRcdC8qIERyYXcgaXMgY29tcGxldGUsIHNvcnRpbmcgYW5kIGZpbHRlcmluZyBtdXN0IGJlIGFzIHdlbGwgKi9cblx0XHRvU2V0dGluZ3MuYlNvcnRlZCA9IGZhbHNlO1xuXHRcdG9TZXR0aW5ncy5iRmlsdGVyZWQgPSBmYWxzZTtcblx0XHRvU2V0dGluZ3MuYkRyYXdpbmcgPSBmYWxzZTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIHRhYmxlIC0gdGFraW5nIGFjY291bnQgb2YgdGhlIHZhcmlvdXMgZmVhdHVyZXMgd2hpY2ggYXJlIGVuYWJsZWRcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW2hvbGRQb3NpdGlvbl0gS2VlcCB0aGUgY3VycmVudCBwYWdpbmcgcG9zaXRpb24uIEJ5IGRlZmF1bHRcblx0ICogICAgdGhlIHBhZ2luZyBpcyByZXNldCB0byB0aGUgZmlyc3QgcGFnZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcyxcblx0XHRcdHNvcnQgICAgID0gZmVhdHVyZXMuYlNvcnQsXG5cdFx0XHRmaWx0ZXIgICA9IGZlYXR1cmVzLmJGaWx0ZXI7XG5cdFxuXHRcdGlmICggc29ydCApIHtcblx0XHRcdF9mblNvcnQoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZpbHRlciApIHtcblx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gTm8gZmlsdGVyaW5nLCBzbyB3ZSB3YW50IHRvIGp1c3QgdXNlIHRoZSBkaXNwbGF5IG1hc3RlclxuXHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGhvbGRQb3NpdGlvbiAhPT0gdHJ1ZSApIHtcblx0XHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gMDtcblx0XHR9XG5cdFxuXHRcdC8vIExldCBhbnkgbW9kdWxlcyBrbm93IGFib3V0IHRoZSBkcmF3IGhvbGQgcG9zaXRpb24gc3RhdGUgKHVzZWQgYnlcblx0XHQvLyBzY3JvbGxpbmcgaW50ZXJuYWxseSlcblx0XHRzZXR0aW5ncy5fZHJhd0hvbGQgPSBob2xkUG9zaXRpb247XG5cdFxuXHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdHNldHRpbmdzLl9kcmF3SG9sZCA9IGZhbHNlO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkZCB0aGUgb3B0aW9ucyB0byB0aGUgcGFnZSBIVE1MIGZvciB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRkT3B0aW9uc0h0bWwgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIHRhYmxlID0gJChvU2V0dGluZ3MublRhYmxlKTtcblx0XHR2YXIgaG9sZGluZyA9ICQoJzxkaXYvPicpLmluc2VydEJlZm9yZSggdGFibGUgKTsgLy8gSG9sZGluZyBlbGVtZW50IGZvciBzcGVlZFxuXHRcdHZhciBmZWF0dXJlcyA9IG9TZXR0aW5ncy5vRmVhdHVyZXM7XG5cdFxuXHRcdC8vIEFsbCBEYXRhVGFibGVzIGFyZSB3cmFwcGVkIGluIGEgZGl2XG5cdFx0dmFyIGluc2VydCA9ICQoJzxkaXYvPicsIHtcblx0XHRcdGlkOiAgICAgIG9TZXR0aW5ncy5zVGFibGVJZCsnX3dyYXBwZXInLFxuXHRcdFx0J2NsYXNzJzogY2xhc3Nlcy5zV3JhcHBlciArIChvU2V0dGluZ3MublRGb290ID8gJycgOiAnICcrY2xhc3Nlcy5zTm9Gb290ZXIpXG5cdFx0fSApO1xuXHRcblx0XHRvU2V0dGluZ3MubkhvbGRpbmcgPSBob2xkaW5nWzBdO1xuXHRcdG9TZXR0aW5ncy5uVGFibGVXcmFwcGVyID0gaW5zZXJ0WzBdO1xuXHRcdG9TZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSA9IG9TZXR0aW5ncy5uVGFibGUubmV4dFNpYmxpbmc7XG5cdFxuXHRcdC8qIExvb3Agb3ZlciB0aGUgdXNlciBzZXQgcG9zaXRpb25pbmcgYW5kIHBsYWNlIHRoZSBlbGVtZW50cyBhcyBuZWVkZWQgKi9cblx0XHR2YXIgYURvbSA9IG9TZXR0aW5ncy5zRG9tLnNwbGl0KCcnKTtcblx0XHR2YXIgZmVhdHVyZU5vZGUsIGNPcHRpb24sIG5OZXdOb2RlLCBjTmV4dCwgc0F0dHIsIGo7XG5cdFx0Zm9yICggdmFyIGk9MCA7IGk8YURvbS5sZW5ndGggOyBpKysgKVxuXHRcdHtcblx0XHRcdGZlYXR1cmVOb2RlID0gbnVsbDtcblx0XHRcdGNPcHRpb24gPSBhRG9tW2ldO1xuXHRcblx0XHRcdGlmICggY09wdGlvbiA9PSAnPCcgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBOZXcgY29udGFpbmVyIGRpdiAqL1xuXHRcdFx0XHRuTmV3Tm9kZSA9ICQoJzxkaXYvPicpWzBdO1xuXHRcblx0XHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBhcHBlbmQgYW4gaWQgYW5kL29yIGEgY2xhc3MgbmFtZSB0byB0aGUgY29udGFpbmVyICovXG5cdFx0XHRcdGNOZXh0ID0gYURvbVtpKzFdO1xuXHRcdFx0XHRpZiAoIGNOZXh0ID09IFwiJ1wiIHx8IGNOZXh0ID09ICdcIicgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c0F0dHIgPSBcIlwiO1xuXHRcdFx0XHRcdGogPSAyO1xuXHRcdFx0XHRcdHdoaWxlICggYURvbVtpK2pdICE9IGNOZXh0IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzQXR0ciArPSBhRG9tW2kral07XG5cdFx0XHRcdFx0XHRqKys7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvKiBSZXBsYWNlIGpRdWVyeSBVSSBjb25zdGFudHMgQHRvZG8gZGVwcmVjaWF0ZWQgKi9cblx0XHRcdFx0XHRpZiAoIHNBdHRyID09IFwiSFwiIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzQXR0ciA9IGNsYXNzZXMuc0pVSUhlYWRlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHNBdHRyID09IFwiRlwiIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzQXR0ciA9IGNsYXNzZXMuc0pVSUZvb3Rlcjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8qIFRoZSBhdHRyaWJ1dGUgY2FuIGJlIGluIHRoZSBmb3JtYXQgb2YgXCIjaWQuY2xhc3NcIiwgXCIjaWRcIiBvciBcImNsYXNzXCIgVGhpcyBsb2dpY1xuXHRcdFx0XHRcdCAqIGJyZWFrcyB0aGUgc3RyaW5nIGludG8gcGFydHMgYW5kIGFwcGxpZXMgdGhlbSBhcyBuZWVkZWRcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRpZiAoIHNBdHRyLmluZGV4T2YoJy4nKSAhPSAtMSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGFTcGxpdCA9IHNBdHRyLnNwbGl0KCcuJyk7XG5cdFx0XHRcdFx0XHRuTmV3Tm9kZS5pZCA9IGFTcGxpdFswXS5zdWJzdHIoMSwgYVNwbGl0WzBdLmxlbmd0aC0xKTtcblx0XHRcdFx0XHRcdG5OZXdOb2RlLmNsYXNzTmFtZSA9IGFTcGxpdFsxXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHNBdHRyLmNoYXJBdCgwKSA9PSBcIiNcIiApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bk5ld05vZGUuaWQgPSBzQXR0ci5zdWJzdHIoMSwgc0F0dHIubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bk5ld05vZGUuY2xhc3NOYW1lID0gc0F0dHI7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRpICs9IGo7IC8qIE1vdmUgYWxvbmcgdGhlIHBvc2l0aW9uIGFycmF5ICovXG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGluc2VydC5hcHBlbmQoIG5OZXdOb2RlICk7XG5cdFx0XHRcdGluc2VydCA9ICQobk5ld05vZGUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJz4nIClcblx0XHRcdHtcblx0XHRcdFx0LyogRW5kIGNvbnRhaW5lciBkaXYgKi9cblx0XHRcdFx0aW5zZXJ0ID0gaW5zZXJ0LnBhcmVudCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQHRvZG8gTW92ZSBvcHRpb25zIGludG8gdGhlaXIgb3duIHBsdWdpbnM/XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAnbCcgJiYgZmVhdHVyZXMuYlBhZ2luYXRlICYmIGZlYXR1cmVzLmJMZW5ndGhDaGFuZ2UgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBMZW5ndGggKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbExlbmd0aCggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAnZicgJiYgZmVhdHVyZXMuYkZpbHRlciApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIEZpbHRlciAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sRmlsdGVyKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdyJyAmJiBmZWF0dXJlcy5iUHJvY2Vzc2luZyApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIHBSb2Nlc3NpbmcgKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmcoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJ3QnIClcblx0XHRcdHtcblx0XHRcdFx0LyogVGFibGUgKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFRhYmxlKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICAnaScgJiYgZmVhdHVyZXMuYkluZm8gKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBJbmZvICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxJbmZvKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdwJyAmJiBmZWF0dXJlcy5iUGFnaW5hdGUgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBQYWdpbmF0aW9uICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggRGF0YVRhYmxlLmV4dC5mZWF0dXJlLmxlbmd0aCAhPT0gMCApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIFBsdWctaW4gZmVhdHVyZXMgKi9cblx0XHRcdFx0dmFyIGFvRmVhdHVyZXMgPSBEYXRhVGFibGUuZXh0LmZlYXR1cmU7XG5cdFx0XHRcdGZvciAoIHZhciBrPTAsIGtMZW49YW9GZWF0dXJlcy5sZW5ndGggOyBrPGtMZW4gOyBrKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKCBjT3B0aW9uID09IGFvRmVhdHVyZXNba10uY0ZlYXR1cmUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZlYXR1cmVOb2RlID0gYW9GZWF0dXJlc1trXS5mbkluaXQoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogQWRkIHRvIHRoZSAyRCBmZWF0dXJlcyBhcnJheSAqL1xuXHRcdFx0aWYgKCBmZWF0dXJlTm9kZSApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBhYW5GZWF0dXJlcyA9IG9TZXR0aW5ncy5hYW5GZWF0dXJlcztcblx0XG5cdFx0XHRcdGlmICggISBhYW5GZWF0dXJlc1tjT3B0aW9uXSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhYW5GZWF0dXJlc1tjT3B0aW9uXSA9IFtdO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRhYW5GZWF0dXJlc1tjT3B0aW9uXS5wdXNoKCBmZWF0dXJlTm9kZSApO1xuXHRcdFx0XHRpbnNlcnQuYXBwZW5kKCBmZWF0dXJlTm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogQnVpbHQgb3VyIERPTSBzdHJ1Y3R1cmUgLSByZXBsYWNlIHRoZSBob2xkaW5nIGRpdiB3aXRoIHdoYXQgd2Ugd2FudCAqL1xuXHRcdGhvbGRpbmcucmVwbGFjZVdpdGgoIGluc2VydCApO1xuXHRcdG9TZXR0aW5ncy5uSG9sZGluZyA9IG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogVXNlIHRoZSBET00gc291cmNlIHRvIGNyZWF0ZSB1cCBhbiBhcnJheSBvZiBoZWFkZXIgY2VsbHMuIFRoZSBpZGVhIGhlcmUgaXMgdG9cblx0ICogY3JlYXRlIGEgbGF5b3V0IGdyaWQgKGFycmF5KSBvZiByb3dzIHggY29sdW1ucywgd2hpY2ggY29udGFpbnMgYSByZWZlcmVuY2Vcblx0ICogdG8gdGhlIGNlbGwgdGhhdCB0aGF0IHBvaW50IGluIHRoZSBncmlkIChyZWdhcmRsZXNzIG9mIGNvbC9yb3dzcGFuKSwgc3VjaCB0aGF0XG5cdCAqIGFueSBjb2x1bW4gLyByb3cgY291bGQgYmUgcmVtb3ZlZCBhbmQgdGhlIG5ldyBncmlkIGNvbnN0cnVjdGVkXG5cdCAqICBAcGFyYW0gYXJyYXkge29iamVjdH0gYUxheW91dCBBcnJheSB0byBzdG9yZSB0aGUgY2FsY3VsYXRlZCBsYXlvdXQgaW5cblx0ICogIEBwYXJhbSB7bm9kZX0gblRoZWFkIFRoZSBoZWFkZXIvZm9vdGVyIGVsZW1lbnQgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EZXRlY3RIZWFkZXIgKCBhTGF5b3V0LCBuVGhlYWQgKVxuXHR7XG5cdFx0dmFyIG5UcnMgPSAkKG5UaGVhZCkuY2hpbGRyZW4oJ3RyJyk7XG5cdFx0dmFyIG5UciwgbkNlbGw7XG5cdFx0dmFyIGksIGssIGwsIGlMZW4sIGpMZW4sIGlDb2xTaGlmdGVkLCBpQ29sdW1uLCBpQ29sc3BhbiwgaVJvd3NwYW47XG5cdFx0dmFyIGJVbmlxdWU7XG5cdFx0dmFyIGZuU2hpZnRDb2wgPSBmdW5jdGlvbiAoIGEsIGksIGogKSB7XG5cdFx0XHR2YXIgayA9IGFbaV07XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoIGtbal0gKSB7XG5cdFx0XHRcdGorKztcblx0XHRcdH1cblx0XHRcdHJldHVybiBqO1xuXHRcdH07XG5cdFxuXHRcdGFMYXlvdXQuc3BsaWNlKCAwLCBhTGF5b3V0Lmxlbmd0aCApO1xuXHRcblx0XHQvKiBXZSBrbm93IGhvdyBtYW55IHJvd3MgdGhlcmUgYXJlIGluIHRoZSBsYXlvdXQgLSBzbyBwcmVwIGl0ICovXG5cdFx0Zm9yICggaT0wLCBpTGVuPW5UcnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRhTGF5b3V0LnB1c2goIFtdICk7XG5cdFx0fVxuXHRcblx0XHQvKiBDYWxjdWxhdGUgYSBsYXlvdXQgYXJyYXkgKi9cblx0XHRmb3IgKCBpPTAsIGlMZW49blRycy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdG5UciA9IG5UcnNbaV07XG5cdFx0XHRpQ29sdW1uID0gMDtcblx0XG5cdFx0XHQvKiBGb3IgZXZlcnkgY2VsbCBpbiB0aGUgcm93Li4uICovXG5cdFx0XHRuQ2VsbCA9IG5Uci5maXJzdENoaWxkO1xuXHRcdFx0d2hpbGUgKCBuQ2VsbCApIHtcblx0XHRcdFx0aWYgKCBuQ2VsbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09IFwiVERcIiB8fFxuXHRcdFx0XHQgICAgIG5DZWxsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gXCJUSFwiIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8qIEdldCB0aGUgY29sIGFuZCByb3dzcGFuIGF0dHJpYnV0ZXMgZnJvbSB0aGUgRE9NIGFuZCBzYW5pdGlzZSB0aGVtICovXG5cdFx0XHRcdFx0aUNvbHNwYW4gPSBuQ2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSAqIDE7XG5cdFx0XHRcdFx0aVJvd3NwYW4gPSBuQ2VsbC5nZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nKSAqIDE7XG5cdFx0XHRcdFx0aUNvbHNwYW4gPSAoIWlDb2xzcGFuIHx8IGlDb2xzcGFuPT09MCB8fCBpQ29sc3Bhbj09PTEpID8gMSA6IGlDb2xzcGFuO1xuXHRcdFx0XHRcdGlSb3dzcGFuID0gKCFpUm93c3BhbiB8fCBpUm93c3Bhbj09PTAgfHwgaVJvd3NwYW49PT0xKSA/IDEgOiBpUm93c3Bhbjtcblx0XG5cdFx0XHRcdFx0LyogVGhlcmUgbWlnaHQgYmUgY29sc3BhbiBjZWxscyBhbHJlYWR5IGluIHRoaXMgcm93LCBzbyBzaGlmdCBvdXIgdGFyZ2V0XG5cdFx0XHRcdFx0ICogYWNjb3JkaW5nbHlcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRpQ29sU2hpZnRlZCA9IGZuU2hpZnRDb2woIGFMYXlvdXQsIGksIGlDb2x1bW4gKTtcblx0XG5cdFx0XHRcdFx0LyogQ2FjaGUgY2FsY3VsYXRpb24gZm9yIHVuaXF1ZSBjb2x1bW5zICovXG5cdFx0XHRcdFx0YlVuaXF1ZSA9IGlDb2xzcGFuID09PSAxID8gdHJ1ZSA6IGZhbHNlO1xuXHRcblx0XHRcdFx0XHQvKiBJZiB0aGVyZSBpcyBjb2wgLyByb3dzcGFuLCBjb3B5IHRoZSBpbmZvcm1hdGlvbiBpbnRvIHRoZSBsYXlvdXQgZ3JpZCAqL1xuXHRcdFx0XHRcdGZvciAoIGw9MCA7IGw8aUNvbHNwYW4gOyBsKysgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZvciAoIGs9MCA7IGs8aVJvd3NwYW4gOyBrKysgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRhTGF5b3V0W2kra11baUNvbFNoaWZ0ZWQrbF0gPSB7XG5cdFx0XHRcdFx0XHRcdFx0XCJjZWxsXCI6IG5DZWxsLFxuXHRcdFx0XHRcdFx0XHRcdFwidW5pcXVlXCI6IGJVbmlxdWVcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YUxheW91dFtpK2tdLm5UciA9IG5Ucjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bkNlbGwgPSBuQ2VsbC5uZXh0U2libGluZztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2V0IGFuIGFycmF5IG9mIHVuaXF1ZSB0aCBlbGVtZW50cywgb25lIGZvciBlYWNoIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBuSGVhZGVyIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBsYXlvdXQgZnJvbSB0aGlzIG5vZGUgLSBvcHRpb25hbFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYUxheW91dCB0aGVhZC90Zm9vdCBsYXlvdXQgZnJvbSBfZm5EZXRlY3RIZWFkZXIgLSBvcHRpb25hbFxuXHQgKiAgQHJldHVybnMgYXJyYXkge25vZGV9IGFSZXR1cm4gbGlzdCBvZiB1bmlxdWUgdGgnc1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRVbmlxdWVUaHMgKCBvU2V0dGluZ3MsIG5IZWFkZXIsIGFMYXlvdXQgKVxuXHR7XG5cdFx0dmFyIGFSZXR1cm4gPSBbXTtcblx0XHRpZiAoICFhTGF5b3V0IClcblx0XHR7XG5cdFx0XHRhTGF5b3V0ID0gb1NldHRpbmdzLmFvSGVhZGVyO1xuXHRcdFx0aWYgKCBuSGVhZGVyIClcblx0XHRcdHtcblx0XHRcdFx0YUxheW91dCA9IFtdO1xuXHRcdFx0XHRfZm5EZXRlY3RIZWFkZXIoIGFMYXlvdXQsIG5IZWFkZXIgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49YUxheW91dC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdGZvciAoIHZhciBqPTAsIGpMZW49YUxheW91dFtpXS5sZW5ndGggOyBqPGpMZW4gOyBqKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIGFMYXlvdXRbaV1bal0udW5pcXVlICYmXG5cdFx0XHRcdFx0ICghYVJldHVybltqXSB8fCAhb1NldHRpbmdzLmJTb3J0Q2VsbHNUb3ApIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFSZXR1cm5bal0gPSBhTGF5b3V0W2ldW2pdLmNlbGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBhUmV0dXJuO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIGFuIEFqYXggY2FsbCBiYXNlZCBvbiB0aGUgdGFibGUncyBzZXR0aW5ncywgdGFraW5nIGludG8gYWNjb3VudCB0aGF0XG5cdCAqIHBhcmFtZXRlcnMgY2FuIGhhdmUgbXVsdGlwbGUgZm9ybXMsIGFuZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyLCByZXF1aXJlZCBieVxuXHQgKiAgICAgRGF0YVRhYmxlcyAtIG1heSBiZSBhdWdtZW50ZWQgYnkgZGV2ZWxvcGVyIGNhbGxiYWNrc1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiBkYXRhIGlzIG9idGFpbmVkXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5CdWlsZEFqYXgoIG9TZXR0aW5ncywgZGF0YSwgZm4gKVxuXHR7XG5cdFx0Ly8gQ29tcGF0aWJpbGl0eSB3aXRoIDEuOS0sIGFsbG93IGZuU2VydmVyRGF0YSBhbmQgZXZlbnQgdG8gbWFuaXB1bGF0ZVxuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9TZXJ2ZXJQYXJhbXMnLCAnc2VydmVyUGFyYW1zJywgW2RhdGFdICk7XG5cdFxuXHRcdC8vIENvbnZlcnQgdG8gb2JqZWN0IGJhc2VkIGZvciAxLjEwKyBpZiB1c2luZyB0aGUgb2xkIGFycmF5IHNjaGVtZSB3aGljaCBjYW5cblx0XHQvLyBjb21lIGZyb20gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBvciBzZXJ2ZXJQYXJhbXNcblx0XHRpZiAoIGRhdGEgJiYgJC5pc0FycmF5KGRhdGEpICkge1xuXHRcdFx0dmFyIHRtcCA9IHt9O1xuXHRcdFx0dmFyIHJicmFja2V0ID0gLyguKj8pXFxbXFxdJC87XG5cdFxuXHRcdFx0JC5lYWNoKCBkYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdFx0dmFyIG1hdGNoID0gdmFsLm5hbWUubWF0Y2gocmJyYWNrZXQpO1xuXHRcblx0XHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0XHQvLyBTdXBwb3J0IGZvciBhcnJheXNcblx0XHRcdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzBdO1xuXHRcblx0XHRcdFx0XHRpZiAoICEgdG1wWyBuYW1lIF0gKSB7XG5cdFx0XHRcdFx0XHR0bXBbIG5hbWUgXSA9IFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bXBbIG5hbWUgXS5wdXNoKCB2YWwudmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0bXBbdmFsLm5hbWVdID0gdmFsLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHRkYXRhID0gdG1wO1xuXHRcdH1cblx0XG5cdFx0dmFyIGFqYXhEYXRhO1xuXHRcdHZhciBhamF4ID0gb1NldHRpbmdzLmFqYXg7XG5cdFx0dmFyIGluc3RhbmNlID0gb1NldHRpbmdzLm9JbnN0YW5jZTtcblx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoIGpzb24gKSB7XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3hocicsIFtvU2V0dGluZ3MsIGpzb24sIG9TZXR0aW5ncy5qcVhIUl0gKTtcblx0XHRcdGZuKCBqc29uICk7XG5cdFx0fTtcblx0XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIGFqYXggKSAmJiBhamF4LmRhdGEgKVxuXHRcdHtcblx0XHRcdGFqYXhEYXRhID0gYWpheC5kYXRhO1xuXHRcblx0XHRcdHZhciBuZXdEYXRhID0gJC5pc0Z1bmN0aW9uKCBhamF4RGF0YSApID9cblx0XHRcdFx0YWpheERhdGEoIGRhdGEsIG9TZXR0aW5ncyApIDogIC8vIGZuIGNhbiBtYW5pcHVsYXRlIGRhdGEgb3IgcmV0dXJuXG5cdFx0XHRcdGFqYXhEYXRhOyAgICAgICAgICAgICAgICAgICAgICAvLyBhbiBvYmplY3Qgb2JqZWN0IG9yIGFycmF5IHRvIG1lcmdlXG5cdFxuXHRcdFx0Ly8gSWYgdGhlIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZywgdXNlIHRoYXQgYWxvbmVcblx0XHRcdGRhdGEgPSAkLmlzRnVuY3Rpb24oIGFqYXhEYXRhICkgJiYgbmV3RGF0YSA/XG5cdFx0XHRcdG5ld0RhdGEgOlxuXHRcdFx0XHQkLmV4dGVuZCggdHJ1ZSwgZGF0YSwgbmV3RGF0YSApO1xuXHRcblx0XHRcdC8vIFJlbW92ZSB0aGUgZGF0YSBwcm9wZXJ0eSBhcyB3ZSd2ZSByZXNvbHZlZCBpdCBhbHJlYWR5IGFuZCBkb24ndCB3YW50XG5cdFx0XHQvLyBqUXVlcnkgdG8gZG8gaXQgYWdhaW4gKGl0IGlzIHJlc3RvcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uKVxuXHRcdFx0ZGVsZXRlIGFqYXguZGF0YTtcblx0XHR9XG5cdFxuXHRcdHZhciBiYXNlQWpheCA9IHtcblx0XHRcdFwiZGF0YVwiOiBkYXRhLFxuXHRcdFx0XCJzdWNjZXNzXCI6IGZ1bmN0aW9uIChqc29uKSB7XG5cdFx0XHRcdHZhciBlcnJvciA9IGpzb24uZXJyb3IgfHwganNvbi5zRXJyb3I7XG5cdFx0XHRcdGlmICggZXJyb3IgKSB7XG5cdFx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsIGVycm9yICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdG9TZXR0aW5ncy5qc29uID0ganNvbjtcblx0XHRcdFx0Y2FsbGJhY2soIGpzb24gKTtcblx0XHRcdH0sXG5cdFx0XHRcImRhdGFUeXBlXCI6IFwianNvblwiLFxuXHRcdFx0XCJjYWNoZVwiOiBmYWxzZSxcblx0XHRcdFwidHlwZVwiOiBvU2V0dGluZ3Muc1NlcnZlck1ldGhvZCxcblx0XHRcdFwiZXJyb3JcIjogZnVuY3Rpb24gKHhociwgZXJyb3IsIHRocm93bikge1xuXHRcdFx0XHR2YXIgcmV0ID0gX2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBudWxsLCBvU2V0dGluZ3MuanFYSFJdICk7XG5cdFxuXHRcdFx0XHRpZiAoICQuaW5BcnJheSggdHJ1ZSwgcmV0ICkgPT09IC0xICkge1xuXHRcdFx0XHRcdGlmICggZXJyb3IgPT0gXCJwYXJzZXJlcnJvclwiICkge1xuXHRcdFx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsICdJbnZhbGlkIEpTT04gcmVzcG9uc2UnLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblx0XHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnQWpheCBlcnJvcicsIDcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBvU2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0Ly8gU3RvcmUgdGhlIGRhdGEgc3VibWl0dGVkIGZvciB0aGUgQVBJXG5cdFx0b1NldHRpbmdzLm9BamF4RGF0YSA9IGRhdGE7XG5cdFxuXHRcdC8vIEFsbG93IHBsdWctaW5zIGFuZCBleHRlcm5hbCBwcm9jZXNzZXMgdG8gbW9kaWZ5IHRoZSBkYXRhXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICdwcmVYaHInLCBbb1NldHRpbmdzLCBkYXRhXSApO1xuXHRcblx0XHRpZiAoIG9TZXR0aW5ncy5mblNlcnZlckRhdGEgKVxuXHRcdHtcblx0XHRcdC8vIERhdGFUYWJsZXMgMS45LSBjb21wYXRpYmlsaXR5XG5cdFx0XHRvU2V0dGluZ3MuZm5TZXJ2ZXJEYXRhLmNhbGwoIGluc3RhbmNlLFxuXHRcdFx0XHRvU2V0dGluZ3Muc0FqYXhTb3VyY2UsXG5cdFx0XHRcdCQubWFwKCBkYXRhLCBmdW5jdGlvbiAodmFsLCBrZXkpIHsgLy8gTmVlZCB0byBjb252ZXJ0IGJhY2sgdG8gMS45IHRyYWQgZm9ybWF0XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZToga2V5LCB2YWx1ZTogdmFsIH07XG5cdFx0XHRcdH0gKSxcblx0XHRcdFx0Y2FsbGJhY2ssXG5cdFx0XHRcdG9TZXR0aW5nc1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9TZXR0aW5ncy5zQWpheFNvdXJjZSB8fCB0eXBlb2YgYWpheCA9PT0gJ3N0cmluZycgKVxuXHRcdHtcblx0XHRcdC8vIERhdGFUYWJsZXMgMS45LSBjb21wYXRpYmlsaXR5XG5cdFx0XHRvU2V0dGluZ3MuanFYSFIgPSAkLmFqYXgoICQuZXh0ZW5kKCBiYXNlQWpheCwge1xuXHRcdFx0XHR1cmw6IGFqYXggfHwgb1NldHRpbmdzLnNBamF4U291cmNlXG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICQuaXNGdW5jdGlvbiggYWpheCApIClcblx0XHR7XG5cdFx0XHQvLyBJcyBhIGZ1bmN0aW9uIC0gbGV0IHRoZSBjYWxsZXIgZGVmaW5lIHdoYXQgbmVlZHMgdG8gYmUgZG9uZVxuXHRcdFx0b1NldHRpbmdzLmpxWEhSID0gYWpheC5jYWxsKCBpbnN0YW5jZSwgZGF0YSwgY2FsbGJhY2ssIG9TZXR0aW5ncyApO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Ly8gT2JqZWN0IHRvIGV4dGVuZCB0aGUgYmFzZSBzZXR0aW5nc1xuXHRcdFx0b1NldHRpbmdzLmpxWEhSID0gJC5hamF4KCAkLmV4dGVuZCggYmFzZUFqYXgsIGFqYXggKSApO1xuXHRcblx0XHRcdC8vIFJlc3RvcmUgZm9yIG5leHQgdGltZSBhcm91bmRcblx0XHRcdGFqYXguZGF0YSA9IGFqYXhEYXRhO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIHRhYmxlIHVzaW5nIGFuIEFqYXggY2FsbFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gQmxvY2sgdGhlIHRhYmxlIGRyYXdpbmcgb3Igbm90XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFqYXhVcGRhdGUoIHNldHRpbmdzIClcblx0e1xuXHRcdGlmICggc2V0dGluZ3MuYkFqYXhEYXRhR2V0ICkge1xuXHRcdFx0c2V0dGluZ3MuaURyYXcrKztcblx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgdHJ1ZSApO1xuXHRcblx0XHRcdF9mbkJ1aWxkQWpheChcblx0XHRcdFx0c2V0dGluZ3MsXG5cdFx0XHRcdF9mbkFqYXhQYXJhbWV0ZXJzKCBzZXR0aW5ncyApLFxuXHRcdFx0XHRmdW5jdGlvbihqc29uKSB7XG5cdFx0XHRcdFx0X2ZuQWpheFVwZGF0ZURyYXcoIHNldHRpbmdzLCBqc29uICk7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBCdWlsZCB1cCB0aGUgcGFyYW1ldGVycyBpbiBhbiBvYmplY3QgbmVlZGVkIGZvciBhIHNlcnZlci1zaWRlIHByb2Nlc3Npbmdcblx0ICogcmVxdWVzdC4gTm90ZSB0aGF0IHRoaXMgaXMgYmFzaWNhbGx5IGRvbmUgdHdpY2UsIGlzIGRpZmZlcmVudCB3YXlzIC0gYSBtb2Rlcm5cblx0ICogbWV0aG9kIHdoaWNoIGlzIHVzZWQgYnkgZGVmYXVsdCBpbiBEYXRhVGFibGVzIDEuMTAgd2hpY2ggdXNlcyBvYmplY3RzIGFuZFxuXHQgKiBhcnJheXMsIG9yIHRoZSAxLjktIG1ldGhvZCB3aXRoIGlzIG5hbWUgLyB2YWx1ZSBwYWlycy4gMS45IG1ldGhvZCBpcyB1c2VkIGlmXG5cdCAqIHRoZSBzQWpheFNvdXJjZSBvcHRpb24gaXMgdXNlZCBpbiB0aGUgaW5pdGlhbGlzYXRpb24sIG9yIHRoZSBsZWdhY3lBamF4XG5cdCAqIG9wdGlvbiBpcyBzZXQuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7Ym9vbH0gYmxvY2sgdGhlIHRhYmxlIGRyYXdpbmcgb3Igbm90XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFqYXhQYXJhbWV0ZXJzKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoLFxuXHRcdFx0ZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXMsXG5cdFx0XHRwcmVTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsXG5cdFx0XHRwcmVDb2xTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHMsXG5cdFx0XHRpLCBkYXRhID0gW10sIGRhdGFQcm9wLCBjb2x1bW4sIGNvbHVtblNlYXJjaCxcblx0XHRcdHNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggc2V0dGluZ3MgKSxcblx0XHRcdGRpc3BsYXlTdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0ZGlzcGxheUxlbmd0aCA9IGZlYXR1cmVzLmJQYWdpbmF0ZSAhPT0gZmFsc2UgP1xuXHRcdFx0XHRzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggOlxuXHRcdFx0XHQtMTtcblx0XG5cdFx0dmFyIHBhcmFtID0gZnVuY3Rpb24gKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdGRhdGEucHVzaCggeyAnbmFtZSc6IG5hbWUsICd2YWx1ZSc6IHZhbHVlIH0gKTtcblx0XHR9O1xuXHRcblx0XHQvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJsZSBtZXRob2Rcblx0XHRwYXJhbSggJ3NFY2hvJywgICAgICAgICAgc2V0dGluZ3MuaURyYXcgKTtcblx0XHRwYXJhbSggJ2lDb2x1bW5zJywgICAgICAgY29sdW1uQ291bnQgKTtcblx0XHRwYXJhbSggJ3NDb2x1bW5zJywgICAgICAgX3BsdWNrKCBjb2x1bW5zLCAnc05hbWUnICkuam9pbignLCcpICk7XG5cdFx0cGFyYW0oICdpRGlzcGxheVN0YXJ0JywgIGRpc3BsYXlTdGFydCApO1xuXHRcdHBhcmFtKCAnaURpc3BsYXlMZW5ndGgnLCBkaXNwbGF5TGVuZ3RoICk7XG5cdFxuXHRcdC8vIERhdGFUYWJsZXMgMS4xMCsgbWV0aG9kXG5cdFx0dmFyIGQgPSB7XG5cdFx0XHRkcmF3OiAgICBzZXR0aW5ncy5pRHJhdyxcblx0XHRcdGNvbHVtbnM6IFtdLFxuXHRcdFx0b3JkZXI6ICAgW10sXG5cdFx0XHRzdGFydDogICBkaXNwbGF5U3RhcnQsXG5cdFx0XHRsZW5ndGg6ICBkaXNwbGF5TGVuZ3RoLFxuXHRcdFx0c2VhcmNoOiAge1xuXHRcdFx0XHR2YWx1ZTogcHJlU2VhcmNoLnNTZWFyY2gsXG5cdFx0XHRcdHJlZ2V4OiBwcmVTZWFyY2guYlJlZ2V4XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0Zm9yICggaT0wIDsgaTxjb2x1bW5Db3VudCA7IGkrKyApIHtcblx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbaV07XG5cdFx0XHRjb2x1bW5TZWFyY2ggPSBwcmVDb2xTZWFyY2hbaV07XG5cdFx0XHRkYXRhUHJvcCA9IHR5cGVvZiBjb2x1bW4ubURhdGE9PVwiZnVuY3Rpb25cIiA/ICdmdW5jdGlvbicgOiBjb2x1bW4ubURhdGEgO1xuXHRcblx0XHRcdGQuY29sdW1ucy5wdXNoKCB7XG5cdFx0XHRcdGRhdGE6ICAgICAgIGRhdGFQcm9wLFxuXHRcdFx0XHRuYW1lOiAgICAgICBjb2x1bW4uc05hbWUsXG5cdFx0XHRcdHNlYXJjaGFibGU6IGNvbHVtbi5iU2VhcmNoYWJsZSxcblx0XHRcdFx0b3JkZXJhYmxlOiAgY29sdW1uLmJTb3J0YWJsZSxcblx0XHRcdFx0c2VhcmNoOiAgICAge1xuXHRcdFx0XHRcdHZhbHVlOiBjb2x1bW5TZWFyY2guc1NlYXJjaCxcblx0XHRcdFx0XHRyZWdleDogY29sdW1uU2VhcmNoLmJSZWdleFxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0cGFyYW0oIFwibURhdGFQcm9wX1wiK2ksIGRhdGFQcm9wICk7XG5cdFxuXHRcdFx0aWYgKCBmZWF0dXJlcy5iRmlsdGVyICkge1xuXHRcdFx0XHRwYXJhbSggJ3NTZWFyY2hfJytpLCAgICAgY29sdW1uU2VhcmNoLnNTZWFyY2ggKTtcblx0XHRcdFx0cGFyYW0oICdiUmVnZXhfJytpLCAgICAgIGNvbHVtblNlYXJjaC5iUmVnZXggKTtcblx0XHRcdFx0cGFyYW0oICdiU2VhcmNoYWJsZV8nK2ksIGNvbHVtbi5iU2VhcmNoYWJsZSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggZmVhdHVyZXMuYlNvcnQgKSB7XG5cdFx0XHRcdHBhcmFtKCAnYlNvcnRhYmxlXycraSwgY29sdW1uLmJTb3J0YWJsZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0aWYgKCBmZWF0dXJlcy5iRmlsdGVyICkge1xuXHRcdFx0cGFyYW0oICdzU2VhcmNoJywgcHJlU2VhcmNoLnNTZWFyY2ggKTtcblx0XHRcdHBhcmFtKCAnYlJlZ2V4JywgcHJlU2VhcmNoLmJSZWdleCApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBmZWF0dXJlcy5iU29ydCApIHtcblx0XHRcdCQuZWFjaCggc29ydCwgZnVuY3Rpb24gKCBpLCB2YWwgKSB7XG5cdFx0XHRcdGQub3JkZXIucHVzaCggeyBjb2x1bW46IHZhbC5jb2wsIGRpcjogdmFsLmRpciB9ICk7XG5cdFxuXHRcdFx0XHRwYXJhbSggJ2lTb3J0Q29sXycraSwgdmFsLmNvbCApO1xuXHRcdFx0XHRwYXJhbSggJ3NTb3J0RGlyXycraSwgdmFsLmRpciApO1xuXHRcdFx0fSApO1xuXHRcblx0XHRcdHBhcmFtKCAnaVNvcnRpbmdDb2xzJywgc29ydC5sZW5ndGggKTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIHRoZSBsZWdhY3kuYWpheCBwYXJhbWV0ZXIgaXMgbnVsbCwgdGhlbiB3ZSBhdXRvbWF0aWNhbGx5IGRlY2lkZSB3aGljaFxuXHRcdC8vIGZvcm0gdG8gdXNlLCBiYXNlZCBvbiBzQWpheFNvdXJjZVxuXHRcdHZhciBsZWdhY3kgPSBEYXRhVGFibGUuZXh0LmxlZ2FjeS5hamF4O1xuXHRcdGlmICggbGVnYWN5ID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLnNBamF4U291cmNlID8gZGF0YSA6IGQ7XG5cdFx0fVxuXHRcblx0XHQvLyBPdGhlcndpc2UsIGlmIGxlZ2FjeSBoYXMgYmVlbiBzcGVjaWZpZWQgdGhlbiB3ZSB1c2UgdGhhdCB0byBkZWNpZGUgb24gdGhlXG5cdFx0Ly8gZm9ybVxuXHRcdHJldHVybiBsZWdhY3kgPyBkYXRhIDogZDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBEYXRhIHRoZSBkYXRhIGZyb20gdGhlIHNlcnZlciAobnVraW5nIHRoZSBvbGQpIGFuZCByZWRyYXcgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBqc29uIGRhdGEgcmV0dXJuIGZyb20gdGhlIHNlcnZlci5cblx0ICogIEBwYXJhbSB7c3RyaW5nfSBqc29uLnNFY2hvIFRyYWNraW5nIGZsYWcgZm9yIERhdGFUYWJsZXMgdG8gbWF0Y2ggcmVxdWVzdHNcblx0ICogIEBwYXJhbSB7aW50fSBqc29uLmlUb3RhbFJlY29yZHMgTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGRhdGEgc2V0LCBub3QgYWNjb3VudGluZyBmb3IgZmlsdGVyaW5nXG5cdCAqICBAcGFyYW0ge2ludH0ganNvbi5pVG90YWxEaXNwbGF5UmVjb3JkcyBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgZGF0YSBzZXQsIGFjY291bnRpbmcgZm9yIGZpbHRlcmluZ1xuXHQgKiAgQHBhcmFtIHthcnJheX0ganNvbi5hYURhdGEgVGhlIGRhdGEgdG8gZGlzcGxheSBvbiB0aGlzIHBhZ2Vcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBbanNvbi5zQ29sdW1uc10gQ29sdW1uIG9yZGVyaW5nIChzTmFtZSwgY29tbWEgc2VwYXJhdGVkKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BamF4VXBkYXRlRHJhdyAoIHNldHRpbmdzLCBqc29uIClcblx0e1xuXHRcdC8vIHYxLjEwIHVzZXMgY2FtZWxDYXNlIHZhcmlhYmxlcywgd2hpbGUgMS45IHVzZXMgSHVuZ2FyaWFuIG5vdGF0aW9uLlxuXHRcdC8vIFN1cHBvcnQgYm90aFxuXHRcdHZhciBjb21wYXQgPSBmdW5jdGlvbiAoIG9sZCwgbW9kZXJuICkge1xuXHRcdFx0cmV0dXJuIGpzb25bb2xkXSAhPT0gdW5kZWZpbmVkID8ganNvbltvbGRdIDoganNvblttb2Rlcm5dO1xuXHRcdH07XG5cdFxuXHRcdHZhciBkYXRhID0gX2ZuQWpheERhdGFTcmMoIHNldHRpbmdzLCBqc29uICk7XG5cdFx0dmFyIGRyYXcgICAgICAgICAgICA9IGNvbXBhdCggJ3NFY2hvJywgICAgICAgICAgICAgICAgJ2RyYXcnICk7XG5cdFx0dmFyIHJlY29yZHNUb3RhbCAgICA9IGNvbXBhdCggJ2lUb3RhbFJlY29yZHMnLCAgICAgICAgJ3JlY29yZHNUb3RhbCcgKTtcblx0XHR2YXIgcmVjb3Jkc0ZpbHRlcmVkID0gY29tcGF0KCAnaVRvdGFsRGlzcGxheVJlY29yZHMnLCAncmVjb3Jkc0ZpbHRlcmVkJyApO1xuXHRcblx0XHRpZiAoIGRyYXcgKSB7XG5cdFx0XHQvLyBQcm90ZWN0IGFnYWluc3Qgb3V0IG9mIHNlcXVlbmNlIHJldHVybnNcblx0XHRcdGlmICggZHJhdyoxIDwgc2V0dGluZ3MuaURyYXcgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNldHRpbmdzLmlEcmF3ID0gZHJhdyAqIDE7XG5cdFx0fVxuXHRcblx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRcdHNldHRpbmdzLl9pUmVjb3Jkc1RvdGFsICAgPSBwYXJzZUludChyZWNvcmRzVG90YWwsIDEwKTtcblx0XHRzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5ID0gcGFyc2VJbnQocmVjb3Jkc0ZpbHRlcmVkLCAxMCk7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGRhdGFbaV0gKTtcblx0XHR9XG5cdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFxuXHRcdHNldHRpbmdzLmJBamF4RGF0YUdldCA9IGZhbHNlO1xuXHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdGlmICggISBzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSApIHtcblx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MsIGpzb24gKTtcblx0XHR9XG5cdFxuXHRcdHNldHRpbmdzLmJBamF4RGF0YUdldCA9IHRydWU7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgZGF0YSBmcm9tIHRoZSBKU09OIGRhdGEgc291cmNlIHRvIHVzZSBmb3IgZHJhd2luZyBhIHRhYmxlLiBVc2luZ1xuXHQgKiBgX2ZuR2V0T2JqZWN0RGF0YUZuYCBhbGxvd3MgdGhlIGRhdGEgdG8gYmUgc291cmNlZCBmcm9tIGEgcHJvcGVydHkgb2YgdGhlXG5cdCAqIHNvdXJjZSBvYmplY3QsIG9yIGZyb20gYSBwcm9jZXNzaW5nIGZ1bmN0aW9uLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtICB7b2JqZWN0fSBqc29uIERhdGEgc291cmNlIG9iamVjdCAvIGFycmF5IGZyb20gdGhlIHNlcnZlclxuXHQgKiAgQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIGRhdGEgdG8gdXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BamF4RGF0YVNyYyAoIG9TZXR0aW5ncywganNvbiApXG5cdHtcblx0XHR2YXIgZGF0YVNyYyA9ICQuaXNQbGFpbk9iamVjdCggb1NldHRpbmdzLmFqYXggKSAmJiBvU2V0dGluZ3MuYWpheC5kYXRhU3JjICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0b1NldHRpbmdzLmFqYXguZGF0YVNyYyA6XG5cdFx0XHRvU2V0dGluZ3Muc0FqYXhEYXRhUHJvcDsgLy8gQ29tcGF0aWJpbGl0eSB3aXRoIDEuOS0uXG5cdFxuXHRcdC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLiBJbiBvcmRlciB0byByZWFkIGZyb20gYWFEYXRhLCBjaGVjayBpZiB0aGVcblx0XHQvLyBkZWZhdWx0IGhhcyBiZWVuIGNoYW5nZWQsIGlmIG5vdCwgY2hlY2sgZm9yIGFhRGF0YVxuXHRcdGlmICggZGF0YVNyYyA9PT0gJ2RhdGEnICkge1xuXHRcdFx0cmV0dXJuIGpzb24uYWFEYXRhIHx8IGpzb25bZGF0YVNyY107XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gZGF0YVNyYyAhPT0gXCJcIiA/XG5cdFx0XHRfZm5HZXRPYmplY3REYXRhRm4oIGRhdGFTcmMgKSgganNvbiApIDpcblx0XHRcdGpzb247XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgZmlsdGVyaW5nIHRleHRcblx0ICogIEByZXR1cm5zIHtub2RlfSBGaWx0ZXIgY29udHJvbCBlbGVtZW50XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sRmlsdGVyICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHR2YXIgdGFibGVJZCA9IHNldHRpbmdzLnNUYWJsZUlkO1xuXHRcdHZhciBsYW5ndWFnZSA9IHNldHRpbmdzLm9MYW5ndWFnZTtcblx0XHR2YXIgcHJldmlvdXNTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XG5cdFx0dmFyIGZlYXR1cmVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXM7XG5cdFx0dmFyIGlucHV0ID0gJzxpbnB1dCB0eXBlPVwic2VhcmNoXCIgY2xhc3M9XCInK2NsYXNzZXMuc0ZpbHRlcklucHV0KydcIi8+Jztcblx0XG5cdFx0dmFyIHN0ciA9IGxhbmd1YWdlLnNTZWFyY2g7XG5cdFx0c3RyID0gc3RyLm1hdGNoKC9fSU5QVVRfLykgP1xuXHRcdFx0c3RyLnJlcGxhY2UoJ19JTlBVVF8nLCBpbnB1dCkgOlxuXHRcdFx0c3RyK2lucHV0O1xuXHRcblx0XHR2YXIgZmlsdGVyID0gJCgnPGRpdi8+Jywge1xuXHRcdFx0XHQnaWQnOiAhIGZlYXR1cmVzLmYgPyB0YWJsZUlkKydfZmlsdGVyJyA6IG51bGwsXG5cdFx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc0ZpbHRlclxuXHRcdFx0fSApXG5cdFx0XHQuYXBwZW5kKCAkKCc8bGFiZWwvPicgKS5hcHBlbmQoIHN0ciApICk7XG5cdFxuXHRcdHZhciBzZWFyY2hGbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0LyogVXBkYXRlIGFsbCBvdGhlciBmaWx0ZXIgaW5wdXQgZWxlbWVudHMgZm9yIHRoZSBuZXcgZGlzcGxheSAqL1xuXHRcdFx0dmFyIG4gPSBmZWF0dXJlcy5mO1xuXHRcdFx0dmFyIHZhbCA9ICF0aGlzLnZhbHVlID8gXCJcIiA6IHRoaXMudmFsdWU7IC8vIG1lbnRhbCBJRTggZml4IDotKFxuXHRcblx0XHRcdC8qIE5vdyBkbyB0aGUgZmlsdGVyICovXG5cdFx0XHRpZiAoIHZhbCAhPSBwcmV2aW91c1NlYXJjaC5zU2VhcmNoICkge1xuXHRcdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHtcblx0XHRcdFx0XHRcInNTZWFyY2hcIjogdmFsLFxuXHRcdFx0XHRcdFwiYlJlZ2V4XCI6IHByZXZpb3VzU2VhcmNoLmJSZWdleCxcblx0XHRcdFx0XHRcImJTbWFydFwiOiBwcmV2aW91c1NlYXJjaC5iU21hcnQgLFxuXHRcdFx0XHRcdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiBwcmV2aW91c1NlYXJjaC5iQ2FzZUluc2Vuc2l0aXZlXG5cdFx0XHRcdH0gKTtcblx0XG5cdFx0XHRcdC8vIE5lZWQgdG8gcmVkcmF3LCB3aXRob3V0IHJlc29ydGluZ1xuXHRcdFx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IDA7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0dmFyIHNlYXJjaERlbGF5ID0gc2V0dGluZ3Muc2VhcmNoRGVsYXkgIT09IG51bGwgP1xuXHRcdFx0c2V0dGluZ3Muc2VhcmNoRGVsYXkgOlxuXHRcdFx0X2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PT0gJ3NzcCcgP1xuXHRcdFx0XHQ0MDAgOlxuXHRcdFx0XHQwO1xuXHRcblx0XHR2YXIganFGaWx0ZXIgPSAkKCdpbnB1dCcsIGZpbHRlcilcblx0XHRcdC52YWwoIHByZXZpb3VzU2VhcmNoLnNTZWFyY2ggKVxuXHRcdFx0LmF0dHIoICdwbGFjZWhvbGRlcicsIGxhbmd1YWdlLnNTZWFyY2hQbGFjZWhvbGRlciApXG5cdFx0XHQub24oXG5cdFx0XHRcdCdrZXl1cC5EVCBzZWFyY2guRFQgaW5wdXQuRFQgcGFzdGUuRFQgY3V0LkRUJyxcblx0XHRcdFx0c2VhcmNoRGVsYXkgP1xuXHRcdFx0XHRcdF9mblRocm90dGxlKCBzZWFyY2hGbiwgc2VhcmNoRGVsYXkgKSA6XG5cdFx0XHRcdFx0c2VhcmNoRm5cblx0XHRcdClcblx0XHRcdC5vbiggJ2tleXByZXNzLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvKiBQcmV2ZW50IGZvcm0gc3VibWlzc2lvbiAqL1xuXHRcdFx0XHRpZiAoIGUua2V5Q29kZSA9PSAxMyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gKVxuXHRcdFx0LmF0dHIoJ2FyaWEtY29udHJvbHMnLCB0YWJsZUlkKTtcblx0XG5cdFx0Ly8gVXBkYXRlIHRoZSBpbnB1dCBlbGVtZW50cyB3aGVuZXZlciB0aGUgdGFibGUgaXMgZmlsdGVyZWRcblx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdzZWFyY2guZHQuRFQnLCBmdW5jdGlvbiAoIGV2LCBzICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyA9PT0gcyApIHtcblx0XHRcdFx0Ly8gSUU5IHRocm93cyBhbiAndW5rbm93biBlcnJvcicgaWYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpcyB1c2VkXG5cdFx0XHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3IgZnJhbWUuLi5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIGpxRmlsdGVyWzBdICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0anFGaWx0ZXIudmFsKCBwcmV2aW91c1NlYXJjaC5zU2VhcmNoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gZmlsdGVyWzBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgdGFibGUgdXNpbmcgYm90aCB0aGUgZ2xvYmFsIGZpbHRlciBhbmQgY29sdW1uIGJhc2VkIGZpbHRlcmluZ1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZWFyY2ggc2VhcmNoIGluZm9ybWF0aW9uXG5cdCAqICBAcGFyYW0ge2ludH0gW2lGb3JjZV0gZm9yY2UgYSByZXNlYXJjaCBvZiB0aGUgbWFzdGVyIGFycmF5ICgxKSBvciBub3QgKHVuZGVmaW5lZCBvciAwKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GaWx0ZXJDb21wbGV0ZSAoIG9TZXR0aW5ncywgb0lucHV0LCBpRm9yY2UgKVxuXHR7XG5cdFx0dmFyIG9QcmV2U2VhcmNoID0gb1NldHRpbmdzLm9QcmV2aW91c1NlYXJjaDtcblx0XHR2YXIgYW9QcmV2U2VhcmNoID0gb1NldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcblx0XHR2YXIgZm5TYXZlRmlsdGVyID0gZnVuY3Rpb24gKCBvRmlsdGVyICkge1xuXHRcdFx0LyogU2F2ZSB0aGUgZmlsdGVyaW5nIHZhbHVlcyAqL1xuXHRcdFx0b1ByZXZTZWFyY2guc1NlYXJjaCA9IG9GaWx0ZXIuc1NlYXJjaDtcblx0XHRcdG9QcmV2U2VhcmNoLmJSZWdleCA9IG9GaWx0ZXIuYlJlZ2V4O1xuXHRcdFx0b1ByZXZTZWFyY2guYlNtYXJ0ID0gb0ZpbHRlci5iU21hcnQ7XG5cdFx0XHRvUHJldlNlYXJjaC5iQ2FzZUluc2Vuc2l0aXZlID0gb0ZpbHRlci5iQ2FzZUluc2Vuc2l0aXZlO1xuXHRcdH07XG5cdFx0dmFyIGZuUmVnZXggPSBmdW5jdGlvbiAoIG8gKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBiRXNjYXBlUmVnZXggb3B0aW9uXG5cdFx0XHRyZXR1cm4gby5iRXNjYXBlUmVnZXggIT09IHVuZGVmaW5lZCA/ICFvLmJFc2NhcGVSZWdleCA6IG8uYlJlZ2V4O1xuXHRcdH07XG5cdFxuXHRcdC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cblx0XHQvLyBAdG9kbyBBcyBwZXIgc29ydCAtIGNhbiB0aGlzIGJlIG1vdmVkIGludG8gYW4gZXZlbnQgaGFuZGxlcj9cblx0XHRfZm5Db2x1bW5UeXBlcyggb1NldHRpbmdzICk7XG5cdFxuXHRcdC8qIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgYWxsIGZpbHRlcmluZyBpcyBkb25lIGJ5IHRoZSBzZXJ2ZXIsIHNvIG5vIHBvaW50IGhhbmdpbmcgYXJvdW5kIGhlcmUgKi9cblx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApICE9ICdzc3AnIClcblx0XHR7XG5cdFx0XHQvKiBHbG9iYWwgZmlsdGVyICovXG5cdFx0XHRfZm5GaWx0ZXIoIG9TZXR0aW5ncywgb0lucHV0LnNTZWFyY2gsIGlGb3JjZSwgZm5SZWdleChvSW5wdXQpLCBvSW5wdXQuYlNtYXJ0LCBvSW5wdXQuYkNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdFx0Zm5TYXZlRmlsdGVyKCBvSW5wdXQgKTtcblx0XG5cdFx0XHQvKiBOb3cgZG8gdGhlIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlciAqL1xuXHRcdFx0Zm9yICggdmFyIGk9MCA7IGk8YW9QcmV2U2VhcmNoLmxlbmd0aCA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkZpbHRlckNvbHVtbiggb1NldHRpbmdzLCBhb1ByZXZTZWFyY2hbaV0uc1NlYXJjaCwgaSwgZm5SZWdleChhb1ByZXZTZWFyY2hbaV0pLFxuXHRcdFx0XHRcdGFvUHJldlNlYXJjaFtpXS5iU21hcnQsIGFvUHJldlNlYXJjaFtpXS5iQ2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogQ3VzdG9tIGZpbHRlcmluZyAqL1xuXHRcdFx0X2ZuRmlsdGVyQ3VzdG9tKCBvU2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGZuU2F2ZUZpbHRlciggb0lucHV0ICk7XG5cdFx0fVxuXHRcblx0XHQvKiBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHdlIGhhdmUgYmVlbiBmaWx0ZXJpbmcgKi9cblx0XHRvU2V0dGluZ3MuYkZpbHRlcmVkID0gdHJ1ZTtcblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3NlYXJjaCcsIFtvU2V0dGluZ3NdICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXBwbHkgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ3VzdG9tKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgZmlsdGVycyA9IERhdGFUYWJsZS5leHQuc2VhcmNoO1xuXHRcdHZhciBkaXNwbGF5Um93cyA9IHNldHRpbmdzLmFpRGlzcGxheTtcblx0XHR2YXIgcm93LCByb3dJZHg7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1maWx0ZXJzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0dmFyIHJvd3MgPSBbXTtcblx0XG5cdFx0XHQvLyBMb29wIG92ZXIgZWFjaCByb3cgYW5kIHNlZSBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWRcblx0XHRcdGZvciAoIHZhciBqPTAsIGplbj1kaXNwbGF5Um93cy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0cm93SWR4ID0gZGlzcGxheVJvd3NbIGogXTtcblx0XHRcdFx0cm93ID0gc2V0dGluZ3MuYW9EYXRhWyByb3dJZHggXTtcblx0XG5cdFx0XHRcdGlmICggZmlsdGVyc1tpXSggc2V0dGluZ3MsIHJvdy5fYUZpbHRlckRhdGEsIHJvd0lkeCwgcm93Ll9hRGF0YSwgaiApICkge1xuXHRcdFx0XHRcdHJvd3MucHVzaCggcm93SWR4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTbyB0aGUgYXJyYXkgcmVmZXJlbmNlIGRvZXNuJ3QgYnJlYWsgc2V0IHRoZSByZXN1bHRzIGludG8gdGhlXG5cdFx0XHQvLyBleGlzdGluZyBhcnJheVxuXHRcdFx0ZGlzcGxheVJvd3MubGVuZ3RoID0gMDtcblx0XHRcdCQubWVyZ2UoIGRpc3BsYXlSb3dzLCByb3dzICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgdGFibGUgb24gYSBwZXItY29sdW1uIGJhc2lzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc0lucHV0IHN0cmluZyB0byBmaWx0ZXIgb25cblx0ICogIEBwYXJhbSB7aW50fSBpQ29sdW1uIGNvbHVtbiB0byBmaWx0ZXJcblx0ICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IHNlYXJjaCBzdHJpbmcgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJTbWFydCB1c2Ugc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBiQ2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zdGl2ZSBtYXRjaGluZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ29sdW1uICggc2V0dGluZ3MsIHNlYXJjaFN0ciwgY29sSWR4LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG5cdHtcblx0XHRpZiAoIHNlYXJjaFN0ciA9PT0gJycgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXIgZGF0YTtcblx0XHR2YXIgb3V0ID0gW107XG5cdFx0dmFyIGRpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXk7XG5cdFx0dmFyIHJwU2VhcmNoID0gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKCBzZWFyY2hTdHIsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlICk7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAgOyBpPGRpc3BsYXkubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0ZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgZGlzcGxheVtpXSBdLl9hRmlsdGVyRGF0YVsgY29sSWR4IF07XG5cdFxuXHRcdFx0aWYgKCBycFNlYXJjaC50ZXN0KCBkYXRhICkgKSB7XG5cdFx0XHRcdG91dC5wdXNoKCBkaXNwbGF5W2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBvdXQ7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRmlsdGVyIHRoZSBkYXRhIHRhYmxlIGJhc2VkIG9uIHVzZXIgaW5wdXQgYW5kIGRyYXcgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBzdHJpbmcgdG8gZmlsdGVyIG9uXG5cdCAqICBAcGFyYW0ge2ludH0gZm9yY2Ugb3B0aW9uYWwgLSBmb3JjZSBhIHJlc2VhcmNoIG9mIHRoZSBtYXN0ZXIgYXJyYXkgKDEpIG9yIG5vdCAodW5kZWZpbmVkIG9yIDApXG5cdCAqICBAcGFyYW0ge2Jvb2x9IHJlZ2V4IHRyZWF0IGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBzbWFydCBwZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gY2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zdGl2ZSBtYXRjaGluZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyKCBzZXR0aW5ncywgaW5wdXQsIGZvcmNlLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG5cdHtcblx0XHR2YXIgcnBTZWFyY2ggPSBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdHZhciBwcmV2U2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLnNTZWFyY2g7XG5cdFx0dmFyIGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XG5cdFx0dmFyIGRpc3BsYXksIGludmFsaWRhdGVkLCBpO1xuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xuXHRcblx0XHQvLyBOZWVkIHRvIHRha2UgYWNjb3VudCBvZiBjdXN0b20gZmlsdGVyaW5nIGZ1bmN0aW9ucyAtIGFsd2F5cyBmaWx0ZXJcblx0XHRpZiAoIERhdGFUYWJsZS5leHQuc2VhcmNoLmxlbmd0aCAhPT0gMCApIHtcblx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdC8vIENoZWNrIGlmIGFueSBvZiB0aGUgcm93cyB3ZXJlIGludmFsaWRhdGVkXG5cdFx0aW52YWxpZGF0ZWQgPSBfZm5GaWx0ZXJEYXRhKCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBJZiB0aGUgaW5wdXQgaXMgYmxhbmsgLSB3ZSBqdXN0IHdhbnQgdGhlIGZ1bGwgZGF0YSBzZXRcblx0XHRpZiAoIGlucHV0Lmxlbmd0aCA8PSAwICkge1xuXHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE5ldyBzZWFyY2ggLSBzdGFydCBmcm9tIHRoZSBtYXN0ZXIgYXJyYXlcblx0XHRcdGlmICggaW52YWxpZGF0ZWQgfHxcblx0XHRcdFx0IGZvcmNlIHx8XG5cdFx0XHRcdCBwcmV2U2VhcmNoLmxlbmd0aCA+IGlucHV0Lmxlbmd0aCB8fFxuXHRcdFx0XHQgaW5wdXQuaW5kZXhPZihwcmV2U2VhcmNoKSAhPT0gMCB8fFxuXHRcdFx0XHQgc2V0dGluZ3MuYlNvcnRlZCAvLyBPbiByZXNvcnQsIHRoZSBkaXNwbGF5IG1hc3RlciBuZWVkcyB0byBiZVxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAvLyByZS1maWx0ZXJlZCBzaW5jZSBpbmRleGVzIHdpbGwgaGF2ZSBjaGFuZ2VkXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlYXJjaCB0aGUgZGlzcGxheSBhcnJheVxuXHRcdFx0ZGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheTtcblx0XG5cdFx0XHRmb3IgKCBpPTAgOyBpPGRpc3BsYXkubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJwU2VhcmNoLnRlc3QoIHNldHRpbmdzLmFvRGF0YVsgZGlzcGxheVtpXSBdLl9zRmlsdGVyUm93ICkgKSB7XG5cdFx0XHRcdFx0ZmlsdGVyZWQucHVzaCggZGlzcGxheVtpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gZmlsdGVyZWQ7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJ1aWxkIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBzdWl0YWJsZSBmb3Igc2VhcmNoaW5nIGEgdGFibGVcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBzU2VhcmNoIHN0cmluZyB0byBzZWFyY2ggZm9yXG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJSZWdleCB0cmVhdCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gYlNtYXJ0IHBlcmZvcm0gc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBiQ2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zaXRpdmUgbWF0Y2hpbmcgb3Igbm90XG5cdCAqICBAcmV0dXJucyB7UmVnRXhwfSBjb25zdHJ1Y3RlZCBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKCBzZWFyY2gsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlIClcblx0e1xuXHRcdHNlYXJjaCA9IHJlZ2V4ID9cblx0XHRcdHNlYXJjaCA6XG5cdFx0XHRfZm5Fc2NhcGVSZWdleCggc2VhcmNoICk7XG5cdFx0XG5cdFx0aWYgKCBzbWFydCApIHtcblx0XHRcdC8qIEZvciBzbWFydCBmaWx0ZXJpbmcgd2Ugd2FudCB0byBhbGxvdyB0aGUgc2VhcmNoIHRvIHdvcmsgcmVnYXJkbGVzcyBvZlxuXHRcdFx0ICogd29yZCBvcmRlci4gV2UgYWxzbyB3YW50IGRvdWJsZSBxdW90ZWQgdGV4dCB0byBiZSBwcmVzZXJ2ZWQsIHNvIHdvcmRcblx0XHRcdCAqIG9yZGVyIGlzIGltcG9ydGFudCAtIGEgbGEgZ29vZ2xlLiBTbyB0aGlzIGlzIHdoYXQgd2Ugd2FudCB0b1xuXHRcdFx0ICogZ2VuZXJhdGU6XG5cdFx0XHQgKiBcblx0XHRcdCAqIF4oPz0uKj9cXGJvbmVcXGIpKD89Lio/XFxidHdvIHRocmVlXFxiKSg/PS4qP1xcYmZvdXJcXGIpLiokXG5cdFx0XHQgKi9cblx0XHRcdHZhciBhID0gJC5tYXAoIHNlYXJjaC5tYXRjaCggL1wiW15cIl0rXCJ8W14gXSsvZyApIHx8IFsnJ10sIGZ1bmN0aW9uICggd29yZCApIHtcblx0XHRcdFx0aWYgKCB3b3JkLmNoYXJBdCgwKSA9PT0gJ1wiJyApIHtcblx0XHRcdFx0XHR2YXIgbSA9IHdvcmQubWF0Y2goIC9eXCIoLiopXCIkLyApO1xuXHRcdFx0XHRcdHdvcmQgPSBtID8gbVsxXSA6IHdvcmQ7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJldHVybiB3b3JkLnJlcGxhY2UoJ1wiJywgJycpO1xuXHRcdFx0fSApO1xuXHRcblx0XHRcdHNlYXJjaCA9ICdeKD89Lio/JythLmpvaW4oICcpKD89Lio/JyApKycpLiokJztcblx0XHR9XG5cdFxuXHRcdHJldHVybiBuZXcgUmVnRXhwKCBzZWFyY2gsIGNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6ICcnICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRXNjYXBlIGEgc3RyaW5nIHN1Y2ggdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNWYWwgc3RyaW5nIHRvIGVzY2FwZVxuXHQgKiAgQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0dmFyIF9mbkVzY2FwZVJlZ2V4ID0gRGF0YVRhYmxlLnV0aWwuZXNjYXBlUmVnZXg7XG5cdFxuXHR2YXIgX19maWx0ZXJfZGl2ID0gJCgnPGRpdj4nKVswXTtcblx0dmFyIF9fZmlsdGVyX2Rpdl90ZXh0Q29udGVudCA9IF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkO1xuXHRcblx0Ly8gVXBkYXRlIHRoZSBmaWx0ZXJpbmcgZGF0YSBmb3IgZWFjaCByb3cgaWYgbmVlZGVkIChieSBpbnZhbGlkYXRpb24gb3IgZmlyc3QgcnVuKVxuXHRmdW5jdGlvbiBfZm5GaWx0ZXJEYXRhICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0dmFyIGNvbHVtbjtcblx0XHR2YXIgaSwgaiwgaWVuLCBqZW4sIGZpbHRlckRhdGEsIGNlbGxEYXRhLCByb3c7XG5cdFx0dmFyIGZvbWF0dGVycyA9IERhdGFUYWJsZS5leHQudHlwZS5zZWFyY2g7XG5cdFx0dmFyIHdhc0ludmFsaWRhdGVkID0gZmFsc2U7XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPXNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpXTtcblx0XG5cdFx0XHRpZiAoICEgcm93Ll9hRmlsdGVyRGF0YSApIHtcblx0XHRcdFx0ZmlsdGVyRGF0YSA9IFtdO1xuXHRcblx0XHRcdFx0Zm9yICggaj0wLCBqZW49Y29sdW1ucy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2pdO1xuXHRcblx0XHRcdFx0XHRpZiAoIGNvbHVtbi5iU2VhcmNoYWJsZSApIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBqLCAnZmlsdGVyJyApO1xuXHRcblx0XHRcdFx0XHRcdGlmICggZm9tYXR0ZXJzWyBjb2x1bW4uc1R5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBmb21hdHRlcnNbIGNvbHVtbi5zVHlwZSBdKCBjZWxsRGF0YSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdC8vIFNlYXJjaCBpbiBEYXRhVGFibGVzIDEuMTAgaXMgc3RyaW5nIGJhc2VkLiBJbiAxLjExIHRoaXNcblx0XHRcdFx0XHRcdC8vIHNob3VsZCBiZSBhbHRlcmVkIHRvIGFsc28gYWxsb3cgc3RyaWN0IHR5cGUgY2hlY2tpbmcuXG5cdFx0XHRcdFx0XHRpZiAoIGNlbGxEYXRhID09PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRjZWxsRGF0YSA9ICcnO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIGNlbGxEYXRhICE9PSAnc3RyaW5nJyAmJiBjZWxsRGF0YS50b1N0cmluZyApIHtcblx0XHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBjZWxsRGF0YS50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gJyc7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBJZiBpdCBsb29rcyBsaWtlIHRoZXJlIGlzIGFuIEhUTUwgZW50aXR5IGluIHRoZSBzdHJpbmcsXG5cdFx0XHRcdFx0Ly8gYXR0ZW1wdCB0byBkZWNvZGUgaXQgc28gc29ydGluZyB3b3JrcyBhcyBleHBlY3RlZC4gTm90ZSB0aGF0XG5cdFx0XHRcdFx0Ly8gd2UgY291bGQgdXNlIGEgc2luZ2xlIGxpbmUgb2YgalF1ZXJ5IHRvIGRvIHRoaXMsIGJ1dCB0aGUgRE9NXG5cdFx0XHRcdFx0Ly8gbWV0aG9kIHVzZWQgaGVyZSBpcyBtdWNoIGZhc3RlciBodHRwOi8vanNwZXJmLmNvbS9odG1sLWRlY29kZVxuXHRcdFx0XHRcdGlmICggY2VsbERhdGEuaW5kZXhPZiAmJiBjZWxsRGF0YS5pbmRleE9mKCcmJykgIT09IC0xICkge1xuXHRcdFx0XHRcdFx0X19maWx0ZXJfZGl2LmlubmVySFRNTCA9IGNlbGxEYXRhO1xuXHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgP1xuXHRcdFx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYudGV4dENvbnRlbnQgOlxuXHRcdFx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYuaW5uZXJUZXh0O1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0aWYgKCBjZWxsRGF0YS5yZXBsYWNlICkge1xuXHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBjZWxsRGF0YS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRmaWx0ZXJEYXRhLnB1c2goIGNlbGxEYXRhICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJvdy5fYUZpbHRlckRhdGEgPSBmaWx0ZXJEYXRhO1xuXHRcdFx0XHRyb3cuX3NGaWx0ZXJSb3cgPSBmaWx0ZXJEYXRhLmpvaW4oJyAgJyk7XG5cdFx0XHRcdHdhc0ludmFsaWRhdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiB3YXNJbnZhbGlkYXRlZDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gdGhlIGludGVybmFsIEh1bmdhcmlhbiBub3RhdGlvbiB0byBjYW1lbENhc2UgZm9yIGV4dGVybmFsXG5cdCAqIGludGVyYWN0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb2JqIE9iamVjdCB0byBjb252ZXJ0XG5cdCAqICBAcmV0dXJucyB7b2JqZWN0fSBJbnZlcnRlZCBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2VhcmNoVG9DYW1lbCAoIG9iaiApXG5cdHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VhcmNoOiAgICAgICAgICBvYmouc1NlYXJjaCxcblx0XHRcdHNtYXJ0OiAgICAgICAgICAgb2JqLmJTbWFydCxcblx0XHRcdHJlZ2V4OiAgICAgICAgICAgb2JqLmJSZWdleCxcblx0XHRcdGNhc2VJbnNlbnNpdGl2ZTogb2JqLmJDYXNlSW5zZW5zaXRpdmVcblx0XHR9O1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gY2FtZWxDYXNlIG5vdGF0aW9uIHRvIHRoZSBpbnRlcm5hbCBIdW5nYXJpYW4uIFdlIGNvdWxkIHVzZSB0aGVcblx0ICogSHVuZ2FyaWFuIGNvbnZlcnQgZnVuY3Rpb24gaGVyZSwgYnV0IHRoaXMgaXMgY2xlYW5lclxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgdG8gY29udmVydFxuXHQgKiAgQHJldHVybnMge29iamVjdH0gSW52ZXJ0ZWQgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNlYXJjaFRvSHVuZyAoIG9iaiApXG5cdHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c1NlYXJjaDogICAgICAgICAgb2JqLnNlYXJjaCxcblx0XHRcdGJTbWFydDogICAgICAgICAgIG9iai5zbWFydCxcblx0XHRcdGJSZWdleDogICAgICAgICAgIG9iai5yZWdleCxcblx0XHRcdGJDYXNlSW5zZW5zaXRpdmU6IG9iai5jYXNlSW5zZW5zaXRpdmVcblx0XHR9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIHRoZSBpbmZvIGRpc3BsYXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBJbmZvcm1hdGlvbiBlbGVtZW50XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sSW5mbyAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0dGlkID0gc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0XHRub2RlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzLmksXG5cdFx0XHRuID0gJCgnPGRpdi8+Jywge1xuXHRcdFx0XHQnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zSW5mbyxcblx0XHRcdFx0J2lkJzogISBub2RlcyA/IHRpZCsnX2luZm8nIDogbnVsbFxuXHRcdFx0fSApO1xuXHRcblx0XHRpZiAoICEgbm9kZXMgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZGlzcGxheSBvbiBlYWNoIGRyYXdcblx0XHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFx0XCJmblwiOiBfZm5VcGRhdGVJbmZvLFxuXHRcdFx0XHRcInNOYW1lXCI6IFwiaW5mb3JtYXRpb25cIlxuXHRcdFx0fSApO1xuXHRcblx0XHRcdG5cblx0XHRcdFx0LmF0dHIoICdyb2xlJywgJ3N0YXR1cycgKVxuXHRcdFx0XHQuYXR0ciggJ2FyaWEtbGl2ZScsICdwb2xpdGUnICk7XG5cdFxuXHRcdFx0Ly8gVGFibGUgaXMgZGVzY3JpYmVkIGJ5IG91ciBpbmZvIGRpdlxuXHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLmF0dHIoICdhcmlhLWRlc2NyaWJlZGJ5JywgdGlkKydfaW5mbycgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBuWzBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgaW5mb3JtYXRpb24gZWxlbWVudHMgaW4gdGhlIGRpc3BsYXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5VcGRhdGVJbmZvICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0LyogU2hvdyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUgKi9cblx0XHR2YXIgbm9kZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcy5pO1xuXHRcdGlmICggbm9kZXMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyXG5cdFx0XHRsYW5nICA9IHNldHRpbmdzLm9MYW5ndWFnZSxcblx0XHRcdHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQrMSxcblx0XHRcdGVuZCAgID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0XHRtYXggICA9IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXG5cdFx0XHR0b3RhbCA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdG91dCAgID0gdG90YWwgP1xuXHRcdFx0XHRsYW5nLnNJbmZvIDpcblx0XHRcdFx0bGFuZy5zSW5mb0VtcHR5O1xuXHRcblx0XHRpZiAoIHRvdGFsICE9PSBtYXggKSB7XG5cdFx0XHQvKiBSZWNvcmQgc2V0IGFmdGVyIGZpbHRlcmluZyAqL1xuXHRcdFx0b3V0ICs9ICcgJyArIGxhbmcuc0luZm9GaWx0ZXJlZDtcblx0XHR9XG5cdFxuXHRcdC8vIENvbnZlcnQgdGhlIG1hY3Jvc1xuXHRcdG91dCArPSBsYW5nLnNJbmZvUG9zdEZpeDtcblx0XHRvdXQgPSBfZm5JbmZvTWFjcm9zKCBzZXR0aW5ncywgb3V0ICk7XG5cdFxuXHRcdHZhciBjYWxsYmFjayA9IGxhbmcuZm5JbmZvQ2FsbGJhY2s7XG5cdFx0aWYgKCBjYWxsYmFjayAhPT0gbnVsbCApIHtcblx0XHRcdG91dCA9IGNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSxcblx0XHRcdFx0c2V0dGluZ3MsIHN0YXJ0LCBlbmQsIG1heCwgdG90YWwsIG91dFxuXHRcdFx0KTtcblx0XHR9XG5cdFxuXHRcdCQobm9kZXMpLmh0bWwoIG91dCApO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuSW5mb01hY3JvcyAoIHNldHRpbmdzLCBzdHIgKVxuXHR7XG5cdFx0Ly8gV2hlbiBpbmZpbml0ZSBzY3JvbGxpbmcsIHdlIGFyZSBhbHdheXMgc3RhcnRpbmcgYXQgMS4gX2lEaXNwbGF5U3RhcnQgaXMgdXNlZCBvbmx5XG5cdFx0Ly8gaW50ZXJuYWxseVxuXHRcdHZhclxuXHRcdFx0Zm9ybWF0dGVyICA9IHNldHRpbmdzLmZuRm9ybWF0TnVtYmVyLFxuXHRcdFx0c3RhcnQgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0KzEsXG5cdFx0XHRsZW4gICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0dmlzICAgICAgICA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xO1xuXHRcblx0XHRyZXR1cm4gc3RyLlxuXHRcdFx0cmVwbGFjZSgvX1NUQVJUXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHN0YXJ0ICkgKS5cblx0XHRcdHJlcGxhY2UoL19FTkRfL2csICAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSApICkuXG5cdFx0XHRyZXBsYWNlKC9fTUFYXy9nLCAgIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSApICkuXG5cdFx0XHRyZXBsYWNlKC9fVE9UQUxfL2csIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgdmlzICkgKS5cblx0XHRcdHJlcGxhY2UoL19QQUdFXy9nLCAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKCBzdGFydCAvIGxlbiApICkgKS5cblx0XHRcdHJlcGxhY2UoL19QQUdFU18vZywgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXMgLyBsZW4gKSApICk7XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIERyYXcgdGhlIHRhYmxlIGZvciB0aGUgZmlyc3QgdGltZSwgYWRkaW5nIGFsbCByZXF1aXJlZCBmZWF0dXJlc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkluaXRpYWxpc2UgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgaSwgaUxlbiwgaUFqYXhTdGFydD1zZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucywgY29sdW1uO1xuXHRcdHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcztcblx0XHR2YXIgZGVmZXJMb2FkaW5nID0gc2V0dGluZ3MuYkRlZmVyTG9hZGluZzsgLy8gdmFsdWUgbW9kaWZpZWQgYnkgdGhlIGRyYXdcblx0XG5cdFx0LyogRW5zdXJlIHRoYXQgdGhlIHRhYmxlIGRhdGEgaXMgZnVsbHkgaW5pdGlhbGlzZWQgKi9cblx0XHRpZiAoICEgc2V0dGluZ3MuYkluaXRpYWxpc2VkICkge1xuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKXsgX2ZuSW5pdGlhbGlzZSggc2V0dGluZ3MgKTsgfSwgMjAwICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvKiBTaG93IHRoZSBkaXNwbGF5IEhUTUwgb3B0aW9ucyAqL1xuXHRcdF9mbkFkZE9wdGlvbnNIdG1sKCBzZXR0aW5ncyApO1xuXHRcblx0XHQvKiBCdWlsZCBhbmQgZHJhdyB0aGUgaGVhZGVyIC8gZm9vdGVyIGZvciB0aGUgdGFibGUgKi9cblx0XHRfZm5CdWlsZEhlYWQoIHNldHRpbmdzICk7XG5cdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlciApO1xuXHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9Gb290ZXIgKTtcblx0XG5cdFx0LyogT2theSB0byBzaG93IHRoYXQgc29tZXRoaW5nIGlzIGdvaW5nIG9uIG5vdyAqL1xuXHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgdHJ1ZSApO1xuXHRcblx0XHQvKiBDYWxjdWxhdGUgc2l6ZXMgZm9yIGNvbHVtbnMgKi9cblx0XHRpZiAoIGZlYXR1cmVzLmJBdXRvV2lkdGggKSB7XG5cdFx0XHRfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcblx0XHRcdGlmICggY29sdW1uLnNXaWR0aCApIHtcblx0XHRcdFx0Y29sdW1uLm5UaC5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb2x1bW4uc1dpZHRoICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncHJlSW5pdCcsIFtzZXR0aW5nc10gKTtcblx0XG5cdFx0Ly8gSWYgdGhlcmUgaXMgZGVmYXVsdCBzb3J0aW5nIHJlcXVpcmVkIC0gbGV0J3MgZG8gaXQuIFRoZSBzb3J0IGZ1bmN0aW9uXG5cdFx0Ly8gd2lsbCBkbyB0aGUgZHJhd2luZyBmb3IgdXMuIE90aGVyd2lzZSB3ZSBkcmF3IHRoZSB0YWJsZSByZWdhcmRsZXNzIG9mIHRoZVxuXHRcdC8vIEFqYXggc291cmNlIC0gdGhpcyBhbGxvd3MgdGhlIHRhYmxlIHRvIGxvb2sgaW5pdGlhbGlzZWQgZm9yIEFqYXggc291cmNpbmdcblx0XHQvLyBkYXRhIChzaG93ICdsb2FkaW5nJyBtZXNzYWdlIHBvc3NpYmx5KVxuXHRcdF9mblJlRHJhdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0Ly8gU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBpbml0IGNvbXBsZXRlIGlzIGRvbmUgYnkgX2ZuQWpheFVwZGF0ZURyYXdcblx0XHR2YXIgZGF0YVNyYyA9IF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICk7XG5cdFx0aWYgKCBkYXRhU3JjICE9ICdzc3AnIHx8IGRlZmVyTG9hZGluZyApIHtcblx0XHRcdC8vIGlmIHRoZXJlIGlzIGFuIGFqYXggc291cmNlIGxvYWQgdGhlIGRhdGFcblx0XHRcdGlmICggZGF0YVNyYyA9PSAnYWpheCcgKSB7XG5cdFx0XHRcdF9mbkJ1aWxkQWpheCggc2V0dGluZ3MsIFtdLCBmdW5jdGlvbihqc29uKSB7XG5cdFx0XHRcdFx0dmFyIGFEYXRhID0gX2ZuQWpheERhdGFTcmMoIHNldHRpbmdzLCBqc29uICk7XG5cdFxuXHRcdFx0XHRcdC8vIEdvdCB0aGUgZGF0YSAtIGFkZCBpdCB0byB0aGUgdGFibGVcblx0XHRcdFx0XHRmb3IgKCBpPTAgOyBpPGFEYXRhLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0XHRcdF9mbkFkZERhdGEoIHNldHRpbmdzLCBhRGF0YVtpXSApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIGluaXQgZGlzcGxheSBmb3IgY29va2llIHNhdmluZy4gV2UndmUgYWxyZWFkeSBkb25lXG5cdFx0XHRcdFx0Ly8gYSBmaWx0ZXIsIGFuZCB0aGVyZWZvcmUgY2xlYXJlZCBpdCBiZWZvcmUuIFNvIHdlIG5lZWQgdG8gbWFrZVxuXHRcdFx0XHRcdC8vIGl0IGFwcGVhciAnZnJlc2gnXG5cdFx0XHRcdFx0c2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSBpQWpheFN0YXJ0O1xuXHRcblx0XHRcdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdFx0XHRfZm5Jbml0Q29tcGxldGUoIHNldHRpbmdzLCBqc29uICk7XG5cdFx0XHRcdH0sIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0XHRfZm5Jbml0Q29tcGxldGUoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERyYXcgdGhlIHRhYmxlIGZvciB0aGUgZmlyc3QgdGltZSwgYWRkaW5nIGFsbCByZXF1aXJlZCBmZWF0dXJlc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IFtqc29uXSBKU09OIGZyb20gdGhlIHNlcnZlciB0aGF0IGNvbXBsZXRlZCB0aGUgdGFibGUsIGlmIHVzaW5nIEFqYXggc291cmNlXG5cdCAqICAgIHdpdGggY2xpZW50LXNpZGUgcHJvY2Vzc2luZyAob3B0aW9uYWwpXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkluaXRDb21wbGV0ZSAoIHNldHRpbmdzLCBqc29uIClcblx0e1xuXHRcdHNldHRpbmdzLl9iSW5pdENvbXBsZXRlID0gdHJ1ZTtcblx0XG5cdFx0Ly8gV2hlbiBkYXRhIHdhcyBhZGRlZCBhZnRlciB0aGUgaW5pdGlhbGlzYXRpb24gKGRhdGEgb3IgQWpheCkgd2UgbmVlZCB0b1xuXHRcdC8vIGNhbGN1bGF0ZSB0aGUgY29sdW1uIHNpemluZ1xuXHRcdGlmICgganNvbiB8fCBzZXR0aW5ncy5vSW5pdC5hYURhdGEgKSB7XG5cdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncGx1Z2luLWluaXQnLCBbc2V0dGluZ3MsIGpzb25dICk7XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvSW5pdENvbXBsZXRlJywgJ2luaXQnLCBbc2V0dGluZ3MsIGpzb25dICk7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5MZW5ndGhDaGFuZ2UgKCBzZXR0aW5ncywgdmFsIClcblx0e1xuXHRcdHZhciBsZW4gPSBwYXJzZUludCggdmFsLCAxMCApO1xuXHRcdHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA9IGxlbjtcblx0XG5cdFx0X2ZuTGVuZ3RoT3ZlcmZsb3coIHNldHRpbmdzICk7XG5cdFxuXHRcdC8vIEZpcmUgbGVuZ3RoIGNoYW5nZSBldmVudFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdsZW5ndGgnLCBbc2V0dGluZ3MsIGxlbl0gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdXNlciBkaXNwbGF5IGxlbmd0aCBjaGFuZ2luZ1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gRGlzcGxheSBsZW5ndGggZmVhdHVyZSBub2RlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sTGVuZ3RoICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRjbGFzc2VzICA9IHNldHRpbmdzLm9DbGFzc2VzLFxuXHRcdFx0dGFibGVJZCAgPSBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdG1lbnUgICAgID0gc2V0dGluZ3MuYUxlbmd0aE1lbnUsXG5cdFx0XHRkMiAgICAgICA9ICQuaXNBcnJheSggbWVudVswXSApLFxuXHRcdFx0bGVuZ3RocyAgPSBkMiA/IG1lbnVbMF0gOiBtZW51LFxuXHRcdFx0bGFuZ3VhZ2UgPSBkMiA/IG1lbnVbMV0gOiBtZW51O1xuXHRcblx0XHR2YXIgc2VsZWN0ID0gJCgnPHNlbGVjdC8+Jywge1xuXHRcdFx0J25hbWUnOiAgICAgICAgICB0YWJsZUlkKydfbGVuZ3RoJyxcblx0XHRcdCdhcmlhLWNvbnRyb2xzJzogdGFibGVJZCxcblx0XHRcdCdjbGFzcyc6ICAgICAgICAgY2xhc3Nlcy5zTGVuZ3RoU2VsZWN0XG5cdFx0fSApO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49bGVuZ3Rocy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHNlbGVjdFswXVsgaSBdID0gbmV3IE9wdGlvbiggbGFuZ3VhZ2VbaV0sIGxlbmd0aHNbaV0gKTtcblx0XHR9XG5cdFxuXHRcdHZhciBkaXYgPSAkKCc8ZGl2PjxsYWJlbC8+PC9kaXY+JykuYWRkQ2xhc3MoIGNsYXNzZXMuc0xlbmd0aCApO1xuXHRcdGlmICggISBzZXR0aW5ncy5hYW5GZWF0dXJlcy5sICkge1xuXHRcdFx0ZGl2WzBdLmlkID0gdGFibGVJZCsnX2xlbmd0aCc7XG5cdFx0fVxuXHRcblx0XHRkaXYuY2hpbGRyZW4oKS5hcHBlbmQoXG5cdFx0XHRzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0xlbmd0aE1lbnUucmVwbGFjZSggJ19NRU5VXycsIHNlbGVjdFswXS5vdXRlckhUTUwgKVxuXHRcdCk7XG5cdFxuXHRcdC8vIENhbid0IHVzZSBgc2VsZWN0YCB2YXJpYWJsZSBhcyB1c2VyIG1pZ2h0IHByb3ZpZGUgdGhlaXIgb3duIGFuZCB0aGVcblx0XHQvLyByZWZlcmVuY2UgaXMgYnJva2VuIGJ5IHRoZSB1c2Ugb2Ygb3V0ZXJIVE1MXG5cdFx0JCgnc2VsZWN0JywgZGl2KVxuXHRcdFx0LnZhbCggc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIClcblx0XHRcdC5vbiggJ2NoYW5nZS5EVCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0X2ZuTGVuZ3RoQ2hhbmdlKCBzZXR0aW5ncywgJCh0aGlzKS52YWwoKSApO1xuXHRcdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fSApO1xuXHRcblx0XHQvLyBVcGRhdGUgbm9kZSB2YWx1ZSB3aGVuZXZlciBhbnl0aGluZyBjaGFuZ2VzIHRoZSB0YWJsZSdzIGxlbmd0aFxuXHRcdCQoc2V0dGluZ3MublRhYmxlKS5vbiggJ2xlbmd0aC5kdC5EVCcsIGZ1bmN0aW9uIChlLCBzLCBsZW4pIHtcblx0XHRcdGlmICggc2V0dGluZ3MgPT09IHMgKSB7XG5cdFx0XHRcdCQoJ3NlbGVjdCcsIGRpdikudmFsKCBsZW4gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiBkaXZbMF07XG5cdH1cblx0XG5cdFxuXHRcblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogTm90ZSB0aGF0IG1vc3Qgb2YgdGhlIHBhZ2luZyBsb2dpYyBpcyBkb25lIGluXG5cdCAqIERhdGFUYWJsZS5leHQucGFnZXJcblx0ICovXG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIGRlZmF1bHQgcGFnaW5hdGlvblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge25vZGV9IFBhZ2luYXRpb24gZmVhdHVyZSBub2RlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdHR5cGUgICA9IHNldHRpbmdzLnNQYWdpbmF0aW9uVHlwZSxcblx0XHRcdHBsdWdpbiA9IERhdGFUYWJsZS5leHQucGFnZXJbIHR5cGUgXSxcblx0XHRcdG1vZGVybiA9IHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicsXG5cdFx0XHRyZWRyYXcgPSBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9LFxuXHRcdFx0bm9kZSA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCBzZXR0aW5ncy5vQ2xhc3Nlcy5zUGFnaW5nICsgdHlwZSApWzBdLFxuXHRcdFx0ZmVhdHVyZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcztcblx0XG5cdFx0aWYgKCAhIG1vZGVybiApIHtcblx0XHRcdHBsdWdpbi5mbkluaXQoIHNldHRpbmdzLCBub2RlLCByZWRyYXcgKTtcblx0XHR9XG5cdFxuXHRcdC8qIEFkZCBhIGRyYXcgY2FsbGJhY2sgZm9yIHRoZSBwYWdpbmF0aW9uIG9uIGZpcnN0IGluc3RhbmNlLCB0byB1cGRhdGUgdGhlIHBhZ2luZyBkaXNwbGF5ICovXG5cdFx0aWYgKCAhIGZlYXR1cmVzLnAgKVxuXHRcdHtcblx0XHRcdG5vZGUuaWQgPSBzZXR0aW5ncy5zVGFibGVJZCsnX3BhZ2luYXRlJztcblx0XG5cdFx0XHRzZXR0aW5ncy5hb0RyYXdDYWxsYmFjay5wdXNoKCB7XG5cdFx0XHRcdFwiZm5cIjogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdFx0XHRcdGlmICggbW9kZXJuICkge1xuXHRcdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHRcdHN0YXJ0ICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdFx0XHRcdFx0bGVuICAgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdFx0XHRcdFx0dmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdFx0XHRcdFx0YWxsICAgICAgICA9IGxlbiA9PT0gLTEsXG5cdFx0XHRcdFx0XHRcdHBhZ2UgPSBhbGwgPyAwIDogTWF0aC5jZWlsKCBzdGFydCAvIGxlbiApLFxuXHRcdFx0XHRcdFx0XHRwYWdlcyA9IGFsbCA/IDEgOiBNYXRoLmNlaWwoIHZpc1JlY29yZHMgLyBsZW4gKSxcblx0XHRcdFx0XHRcdFx0YnV0dG9ucyA9IHBsdWdpbihwYWdlLCBwYWdlcyksXG5cdFx0XHRcdFx0XHRcdGksIGllbjtcblx0XG5cdFx0XHRcdFx0XHRmb3IgKCBpPTAsIGllbj1mZWF0dXJlcy5wLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0XHRfZm5SZW5kZXJlciggc2V0dGluZ3MsICdwYWdlQnV0dG9uJyApKFxuXHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzLCBmZWF0dXJlcy5wW2ldLCBpLCBidXR0b25zLCBwYWdlLCBwYWdlc1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHBsdWdpbi5mblVwZGF0ZSggc2V0dGluZ3MsIHJlZHJhdyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0XCJzTmFtZVwiOiBcInBhZ2luYXRpb25cIlxuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQWx0ZXIgdGhlIGRpc3BsYXkgc2V0dGluZ3MgdG8gY2hhbmdlIHRoZSBwYWdlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7c3RyaW5nfGludH0gYWN0aW9uIFBhZ2luZyBhY3Rpb24gdG8gdGFrZTogXCJmaXJzdFwiLCBcInByZXZpb3VzXCIsXG5cdCAqICAgIFwibmV4dFwiIG9yIFwibGFzdFwiIG9yIHBhZ2UgbnVtYmVyIHRvIGp1bXAgdG8gKGludGVnZXIpXG5cdCAqICBAcGFyYW0gW2Jvb2xdIHJlZHJhdyBBdXRvbWF0aWNhbGx5IGRyYXcgdGhlIHVwZGF0ZSBvciBub3Rcblx0ICogIEByZXR1cm5zIHtib29sfSB0cnVlIHBhZ2UgaGFzIGNoYW5nZWQsIGZhbHNlIC0gbm8gY2hhbmdlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblBhZ2VDaGFuZ2UgKCBzZXR0aW5ncywgYWN0aW9uLCByZWRyYXcgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRzdGFydCAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGxlbiAgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdHJlY29yZHMgICA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKTtcblx0XG5cdFx0aWYgKCByZWNvcmRzID09PSAwIHx8IGxlbiA9PT0gLTEgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBhY3Rpb24gPT09IFwibnVtYmVyXCIgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gYWN0aW9uICogbGVuO1xuXHRcblx0XHRcdGlmICggc3RhcnQgPiByZWNvcmRzIClcblx0XHRcdHtcblx0XHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggYWN0aW9uID09IFwiZmlyc3RcIiApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdH1cblx0XHRlbHNlIGlmICggYWN0aW9uID09IFwicHJldmlvdXNcIiApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSBsZW4gPj0gMCA/XG5cdFx0XHRcdHN0YXJ0IC0gbGVuIDpcblx0XHRcdFx0MDtcblx0XG5cdFx0XHRpZiAoIHN0YXJ0IDwgMCApXG5cdFx0XHR7XG5cdFx0XHQgIHN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcIm5leHRcIiApXG5cdFx0e1xuXHRcdFx0aWYgKCBzdGFydCArIGxlbiA8IHJlY29yZHMgKVxuXHRcdFx0e1xuXHRcdFx0XHRzdGFydCArPSBsZW47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJsYXN0XCIgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gTWF0aC5mbG9vciggKHJlY29yZHMtMSkgLyBsZW4pICogbGVuO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0X2ZuTG9nKCBzZXR0aW5ncywgMCwgXCJVbmtub3duIHBhZ2luZyBhY3Rpb246IFwiK2FjdGlvbiwgNSApO1xuXHRcdH1cblx0XG5cdFx0dmFyIGNoYW5nZWQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCAhPT0gc3RhcnQ7XG5cdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBzdGFydDtcblx0XG5cdFx0aWYgKCBjaGFuZ2VkICkge1xuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3BhZ2UnLCBbc2V0dGluZ3NdICk7XG5cdFxuXHRcdFx0aWYgKCByZWRyYXcgKSB7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gY2hhbmdlZDtcblx0fVxuXHRcblx0XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIHRoZSBwcm9jZXNzaW5nIG5vZGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge25vZGV9IFByb2Nlc3NpbmcgZWxlbWVudFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmcgKCBzZXR0aW5ncyApXG5cdHtcblx0XHRyZXR1cm4gJCgnPGRpdi8+Jywge1xuXHRcdFx0XHQnaWQnOiAhIHNldHRpbmdzLmFhbkZlYXR1cmVzLnIgPyBzZXR0aW5ncy5zVGFibGVJZCsnX3Byb2Nlc3NpbmcnIDogbnVsbCxcblx0XHRcdFx0J2NsYXNzJzogc2V0dGluZ3Mub0NsYXNzZXMuc1Byb2Nlc3Npbmdcblx0XHRcdH0gKVxuXHRcdFx0Lmh0bWwoIHNldHRpbmdzLm9MYW5ndWFnZS5zUHJvY2Vzc2luZyApXG5cdFx0XHQuaW5zZXJ0QmVmb3JlKCBzZXR0aW5ncy5uVGFibGUgKVswXTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBEaXNwbGF5IG9yIGhpZGUgdGhlIHByb2Nlc3NpbmcgaW5kaWNhdG9yXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gc2hvdyBTaG93IHRoZSBwcm9jZXNzaW5nIGluZGljYXRvciAodHJ1ZSkgb3Igbm90IChmYWxzZSlcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkgKCBzZXR0aW5ncywgc2hvdyApXG5cdHtcblx0XHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iUHJvY2Vzc2luZyApIHtcblx0XHRcdCQoc2V0dGluZ3MuYWFuRmVhdHVyZXMucikuY3NzKCAnZGlzcGxheScsIHNob3cgPyAnYmxvY2snIDogJ25vbmUnICk7XG5cdFx0fVxuXHRcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncHJvY2Vzc2luZycsIFtzZXR0aW5ncywgc2hvd10gKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFkZCBhbnkgY29udHJvbCBlbGVtZW50cyBmb3IgdGhlIHRhYmxlIC0gc3BlY2lmaWNhbGx5IHNjcm9sbGluZ1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gTm9kZSB0byBhZGQgdG8gdGhlIERPTVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbFRhYmxlICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIHRhYmxlID0gJChzZXR0aW5ncy5uVGFibGUpO1xuXHRcblx0XHQvLyBBZGQgdGhlIEFSSUEgZ3JpZCByb2xlIHRvIHRoZSB0YWJsZVxuXHRcdHRhYmxlLmF0dHIoICdyb2xlJywgJ2dyaWQnICk7XG5cdFxuXHRcdC8vIFNjcm9sbGluZyBmcm9tIGhlcmUgb24gaW5cblx0XHR2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcblx0XG5cdFx0aWYgKCBzY3JvbGwuc1ggPT09ICcnICYmIHNjcm9sbC5zWSA9PT0gJycgKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3MublRhYmxlO1xuXHRcdH1cblx0XG5cdFx0dmFyIHNjcm9sbFggPSBzY3JvbGwuc1g7XG5cdFx0dmFyIHNjcm9sbFkgPSBzY3JvbGwuc1k7XG5cdFx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHR2YXIgY2FwdGlvbiA9IHRhYmxlLmNoaWxkcmVuKCdjYXB0aW9uJyk7XG5cdFx0dmFyIGNhcHRpb25TaWRlID0gY2FwdGlvbi5sZW5ndGggPyBjYXB0aW9uWzBdLl9jYXB0aW9uU2lkZSA6IG51bGw7XG5cdFx0dmFyIGhlYWRlckNsb25lID0gJCggdGFibGVbMF0uY2xvbmVOb2RlKGZhbHNlKSApO1xuXHRcdHZhciBmb290ZXJDbG9uZSA9ICQoIHRhYmxlWzBdLmNsb25lTm9kZShmYWxzZSkgKTtcblx0XHR2YXIgZm9vdGVyID0gdGFibGUuY2hpbGRyZW4oJ3Rmb290Jyk7XG5cdFx0dmFyIF9kaXYgPSAnPGRpdi8+Jztcblx0XHR2YXIgc2l6ZSA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRcdHJldHVybiAhcyA/IG51bGwgOiBfZm5TdHJpbmdUb0NzcyggcyApO1xuXHRcdH07XG5cdFxuXHRcdGlmICggISBmb290ZXIubGVuZ3RoICkge1xuXHRcdFx0Zm9vdGVyID0gbnVsbDtcblx0XHR9XG5cdFxuXHRcdC8qXG5cdFx0ICogVGhlIEhUTUwgc3RydWN0dXJlIHRoYXQgd2Ugd2FudCB0byBnZW5lcmF0ZSBpbiB0aGlzIGZ1bmN0aW9uIGlzOlxuXHRcdCAqICBkaXYgLSBzY3JvbGxlclxuXHRcdCAqICAgIGRpdiAtIHNjcm9sbCBoZWFkXG5cdFx0ICogICAgICBkaXYgLSBzY3JvbGwgaGVhZCBpbm5lclxuXHRcdCAqICAgICAgICB0YWJsZSAtIHNjcm9sbCBoZWFkIHRhYmxlXG5cdFx0ICogICAgICAgICAgdGhlYWQgLSB0aGVhZFxuXHRcdCAqICAgIGRpdiAtIHNjcm9sbCBib2R5XG5cdFx0ICogICAgICB0YWJsZSAtIHRhYmxlIChtYXN0ZXIgdGFibGUpXG5cdFx0ICogICAgICAgIHRoZWFkIC0gdGhlYWQgY2xvbmUgZm9yIHNpemluZ1xuXHRcdCAqICAgICAgICB0Ym9keSAtIHRib2R5XG5cdFx0ICogICAgZGl2IC0gc2Nyb2xsIGZvb3Rcblx0XHQgKiAgICAgIGRpdiAtIHNjcm9sbCBmb290IGlubmVyXG5cdFx0ICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGZvb3QgdGFibGVcblx0XHQgKiAgICAgICAgICB0Zm9vdCAtIHRmb290XG5cdFx0ICovXG5cdFx0dmFyIHNjcm9sbGVyID0gJCggX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxXcmFwcGVyIH0gKVxuXHRcdFx0LmFwcGVuZChcblx0XHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEhlYWQgfSApXG5cdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nLFxuXHRcdFx0XHRcdFx0cG9zaXRpb246ICdyZWxhdGl2ZScsXG5cdFx0XHRcdFx0XHRib3JkZXI6IDAsXG5cdFx0XHRcdFx0XHR3aWR0aDogc2Nyb2xsWCA/IHNpemUoc2Nyb2xsWCkgOiAnMTAwJSdcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEhlYWRJbm5lciB9IClcblx0XHRcdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0XHRcdCdib3gtc2l6aW5nJzogJ2NvbnRlbnQtYm94Jyxcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogc2Nyb2xsLnNYSW5uZXIgfHwgJzEwMCUnXG5cdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdGhlYWRlckNsb25lXG5cdFx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQXR0cignaWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmNzcyggJ21hcmdpbi1sZWZ0JywgMCApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKCBjYXB0aW9uU2lkZSA9PT0gJ3RvcCcgPyBjYXB0aW9uIDogbnVsbCApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS5jaGlsZHJlbigndGhlYWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdFx0LmFwcGVuZChcblx0XHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEJvZHkgfSApXG5cdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0cG9zaXRpb246ICdyZWxhdGl2ZScsXG5cdFx0XHRcdFx0XHRvdmVyZmxvdzogJ2F1dG8nLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHNpemUoIHNjcm9sbFggKVxuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hcHBlbmQoIHRhYmxlIClcblx0XHRcdCk7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0c2Nyb2xsZXIuYXBwZW5kKFxuXHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsRm9vdCB9IClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdFx0XHRib3JkZXI6IDAsXG5cdFx0XHRcdFx0XHR3aWR0aDogc2Nyb2xsWCA/IHNpemUoc2Nyb2xsWCkgOiAnMTAwJSdcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEZvb3RJbm5lciB9IClcblx0XHRcdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0XHRmb290ZXJDbG9uZVxuXHRcdFx0XHRcdFx0XHRcdFx0LnJlbW92ZUF0dHIoJ2lkJylcblx0XHRcdFx0XHRcdFx0XHRcdC5jc3MoICdtYXJnaW4tbGVmdCcsIDAgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZCggY2FwdGlvblNpZGUgPT09ICdib3R0b20nID8gY2FwdGlvbiA6IG51bGwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFibGUuY2hpbGRyZW4oJ3Rmb290Jylcblx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdClcblx0XHRcdCk7XG5cdFx0fVxuXHRcblx0XHR2YXIgY2hpbGRyZW4gPSBzY3JvbGxlci5jaGlsZHJlbigpO1xuXHRcdHZhciBzY3JvbGxIZWFkID0gY2hpbGRyZW5bMF07XG5cdFx0dmFyIHNjcm9sbEJvZHkgPSBjaGlsZHJlblsxXTtcblx0XHR2YXIgc2Nyb2xsRm9vdCA9IGZvb3RlciA/IGNoaWxkcmVuWzJdIDogbnVsbDtcblx0XG5cdFx0Ly8gV2hlbiB0aGUgYm9keSBpcyBzY3JvbGxlZCwgdGhlbiB3ZSBhbHNvIHdhbnQgdG8gc2Nyb2xsIHRoZSBoZWFkZXJzXG5cdFx0aWYgKCBzY3JvbGxYICkge1xuXHRcdFx0JChzY3JvbGxCb2R5KS5vbiggJ3Njcm9sbC5EVCcsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHZhciBzY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xuXHRcblx0XHRcdFx0c2Nyb2xsSGVhZC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblx0XG5cdFx0XHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0XHRcdHNjcm9sbEZvb3Quc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdCQoc2Nyb2xsQm9keSkuY3NzKFxuXHRcdFx0c2Nyb2xsWSAmJiBzY3JvbGwuYkNvbGxhcHNlID8gJ21heC1oZWlnaHQnIDogJ2hlaWdodCcsIFxuXHRcdFx0c2Nyb2xsWVxuXHRcdCk7XG5cdFxuXHRcdHNldHRpbmdzLm5TY3JvbGxIZWFkID0gc2Nyb2xsSGVhZDtcblx0XHRzZXR0aW5ncy5uU2Nyb2xsQm9keSA9IHNjcm9sbEJvZHk7XG5cdFx0c2V0dGluZ3MublNjcm9sbEZvb3QgPSBzY3JvbGxGb290O1xuXHRcblx0XHQvLyBPbiByZWRyYXcgLSBhbGlnbiBjb2x1bW5zXG5cdFx0c2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCgge1xuXHRcdFx0XCJmblwiOiBfZm5TY3JvbGxEcmF3LFxuXHRcdFx0XCJzTmFtZVwiOiBcInNjcm9sbGluZ1wiXG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gc2Nyb2xsZXJbMF07XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgaGVhZGVyLCBmb290ZXIgYW5kIGJvZHkgdGFibGVzIGZvciByZXNpemluZyAtIGkuZS4gY29sdW1uXG5cdCAqIGFsaWdubWVudC5cblx0ICpcblx0ICogV2VsY29tZSB0byB0aGUgbW9zdCBob3JyaWJsZSBmdW5jdGlvbiBEYXRhVGFibGVzLiBUaGUgcHJvY2VzcyB0aGF0IHRoaXNcblx0ICogZnVuY3Rpb24gZm9sbG93cyBpcyBiYXNpY2FsbHk6XG5cdCAqICAgMS4gUmUtY3JlYXRlIHRoZSB0YWJsZSBpbnNpZGUgdGhlIHNjcm9sbGluZyBkaXZcblx0ICogICAyLiBUYWtlIGxpdmUgbWVhc3VyZW1lbnRzIGZyb20gdGhlIERPTVxuXHQgKiAgIDMuIEFwcGx5IHRoZSBtZWFzdXJlbWVudHMgdG8gYWxpZ24gdGhlIGNvbHVtbnNcblx0ICogICA0LiBDbGVhbiB1cFxuXHQgKlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNjcm9sbERyYXcgKCBzZXR0aW5ncyApXG5cdHtcblx0XHQvLyBHaXZlbiB0aGF0IHRoaXMgaXMgc3VjaCBhIG1vbnN0ZXIgZnVuY3Rpb24sIGEgbG90IG9mIHZhcmlhYmxlcyBhcmUgdXNlXG5cdFx0Ly8gdG8gdHJ5IGFuZCBrZWVwIHRoZSBtaW5pbWlzZWQgc2l6ZSBhcyBzbWFsbCBhcyBwb3NzaWJsZVxuXHRcdHZhclxuXHRcdFx0c2Nyb2xsICAgICAgICAgPSBzZXR0aW5ncy5vU2Nyb2xsLFxuXHRcdFx0c2Nyb2xsWCAgICAgICAgPSBzY3JvbGwuc1gsXG5cdFx0XHRzY3JvbGxYSW5uZXIgICA9IHNjcm9sbC5zWElubmVyLFxuXHRcdFx0c2Nyb2xsWSAgICAgICAgPSBzY3JvbGwuc1ksXG5cdFx0XHRiYXJXaWR0aCAgICAgICA9IHNjcm9sbC5pQmFyV2lkdGgsXG5cdFx0XHRkaXZIZWFkZXIgICAgICA9ICQoc2V0dGluZ3MublNjcm9sbEhlYWQpLFxuXHRcdFx0ZGl2SGVhZGVyU3R5bGUgPSBkaXZIZWFkZXJbMF0uc3R5bGUsXG5cdFx0XHRkaXZIZWFkZXJJbm5lciA9IGRpdkhlYWRlci5jaGlsZHJlbignZGl2JyksXG5cdFx0XHRkaXZIZWFkZXJJbm5lclN0eWxlID0gZGl2SGVhZGVySW5uZXJbMF0uc3R5bGUsXG5cdFx0XHRkaXZIZWFkZXJUYWJsZSA9IGRpdkhlYWRlcklubmVyLmNoaWxkcmVuKCd0YWJsZScpLFxuXHRcdFx0ZGl2Qm9keUVsICAgICAgPSBzZXR0aW5ncy5uU2Nyb2xsQm9keSxcblx0XHRcdGRpdkJvZHkgICAgICAgID0gJChkaXZCb2R5RWwpLFxuXHRcdFx0ZGl2Qm9keVN0eWxlICAgPSBkaXZCb2R5RWwuc3R5bGUsXG5cdFx0XHRkaXZGb290ZXIgICAgICA9ICQoc2V0dGluZ3MublNjcm9sbEZvb3QpLFxuXHRcdFx0ZGl2Rm9vdGVySW5uZXIgPSBkaXZGb290ZXIuY2hpbGRyZW4oJ2RpdicpLFxuXHRcdFx0ZGl2Rm9vdGVyVGFibGUgPSBkaXZGb290ZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcblx0XHRcdGhlYWRlciAgICAgICAgID0gJChzZXR0aW5ncy5uVEhlYWQpLFxuXHRcdFx0dGFibGUgICAgICAgICAgPSAkKHNldHRpbmdzLm5UYWJsZSksXG5cdFx0XHR0YWJsZUVsICAgICAgICA9IHRhYmxlWzBdLFxuXHRcdFx0dGFibGVTdHlsZSAgICAgPSB0YWJsZUVsLnN0eWxlLFxuXHRcdFx0Zm9vdGVyICAgICAgICAgPSBzZXR0aW5ncy5uVEZvb3QgPyAkKHNldHRpbmdzLm5URm9vdCkgOiBudWxsLFxuXHRcdFx0YnJvd3NlciAgICAgICAgPSBzZXR0aW5ncy5vQnJvd3Nlcixcblx0XHRcdGllNjcgICAgICAgICAgID0gYnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemUsXG5cdFx0XHRkdEhlYWRlckNlbGxzICA9IF9wbHVjayggc2V0dGluZ3MuYW9Db2x1bW5zLCAnblRoJyApLFxuXHRcdFx0aGVhZGVyVHJnRWxzLCBmb290ZXJUcmdFbHMsXG5cdFx0XHRoZWFkZXJTcmNFbHMsIGZvb3RlclNyY0Vscyxcblx0XHRcdGhlYWRlckNvcHksIGZvb3RlckNvcHksXG5cdFx0XHRoZWFkZXJXaWR0aHM9W10sIGZvb3RlcldpZHRocz1bXSxcblx0XHRcdGhlYWRlckNvbnRlbnQ9W10sIGZvb3RlckNvbnRlbnQ9W10sXG5cdFx0XHRpZHgsIGNvcnJlY3Rpb24sIHNhbml0eVdpZHRoLFxuXHRcdFx0emVyb091dCA9IGZ1bmN0aW9uKG5TaXplcikge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSBuU2l6ZXIuc3R5bGU7XG5cdFx0XHRcdHN0eWxlLnBhZGRpbmdUb3AgPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiMFwiO1xuXHRcdFx0XHRzdHlsZS5ib3JkZXJUb3BXaWR0aCA9IFwiMFwiO1xuXHRcdFx0XHRzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCA9IFwiMFwiO1xuXHRcdFx0XHRzdHlsZS5oZWlnaHQgPSAwO1xuXHRcdFx0fTtcblx0XG5cdFx0Ly8gSWYgdGhlIHNjcm9sbGJhciB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkIGZyb20gdGhlIGxhc3QgZHJhdywgd2UgbmVlZCB0b1xuXHRcdC8vIGFkanVzdCB0aGUgY29sdW1uIHNpemVzIGFzIHRoZSB0YWJsZSB3aWR0aCB3aWxsIGhhdmUgY2hhbmdlZCB0byBhY2NvdW50XG5cdFx0Ly8gZm9yIHRoZSBzY3JvbGxiYXJcblx0XHR2YXIgc2Nyb2xsQmFyVmlzID0gZGl2Qm9keUVsLnNjcm9sbEhlaWdodCA+IGRpdkJvZHlFbC5jbGllbnRIZWlnaHQ7XG5cdFx0XG5cdFx0aWYgKCBzZXR0aW5ncy5zY3JvbGxCYXJWaXMgIT09IHNjcm9sbEJhclZpcyAmJiBzZXR0aW5ncy5zY3JvbGxCYXJWaXMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNldHRpbmdzLnNjcm9sbEJhclZpcyA9IHNjcm9sbEJhclZpcztcblx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0XHRcdHJldHVybjsgLy8gYWRqdXN0IGNvbHVtbiBzaXppbmcgd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW5cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzZXR0aW5ncy5zY3JvbGxCYXJWaXMgPSBzY3JvbGxCYXJWaXM7XG5cdFx0fVxuXHRcblx0XHQvKlxuXHRcdCAqIDEuIFJlLWNyZWF0ZSB0aGUgdGFibGUgaW5zaWRlIHRoZSBzY3JvbGxpbmcgZGl2XG5cdFx0ICovXG5cdFxuXHRcdC8vIFJlbW92ZSB0aGUgb2xkIG1pbmltaXNlZCB0aGVhZCBhbmQgdGZvb3QgZWxlbWVudHMgaW4gdGhlIGlubmVyIHRhYmxlXG5cdFx0dGFibGUuY2hpbGRyZW4oJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuXHRcblx0XHRpZiAoIGZvb3RlciApIHtcblx0XHRcdGZvb3RlckNvcHkgPSBmb290ZXIuY2xvbmUoKS5wcmVwZW5kVG8oIHRhYmxlICk7XG5cdFx0XHRmb290ZXJUcmdFbHMgPSBmb290ZXIuZmluZCgndHInKTsgLy8gdGhlIG9yaWdpbmFsIHRmb290IGlzIGluIGl0cyBvd24gdGFibGUgYW5kIG11c3QgYmUgc2l6ZWRcblx0XHRcdGZvb3RlclNyY0VscyA9IGZvb3RlckNvcHkuZmluZCgndHInKTtcblx0XHR9XG5cdFxuXHRcdC8vIENsb25lIHRoZSBjdXJyZW50IGhlYWRlciBhbmQgZm9vdGVyIGVsZW1lbnRzIGFuZCB0aGVuIHBsYWNlIGl0IGludG8gdGhlIGlubmVyIHRhYmxlXG5cdFx0aGVhZGVyQ29weSA9IGhlYWRlci5jbG9uZSgpLnByZXBlbmRUbyggdGFibGUgKTtcblx0XHRoZWFkZXJUcmdFbHMgPSBoZWFkZXIuZmluZCgndHInKTsgLy8gb3JpZ2luYWwgaGVhZGVyIGlzIGluIGl0cyBvd24gdGFibGVcblx0XHRoZWFkZXJTcmNFbHMgPSBoZWFkZXJDb3B5LmZpbmQoJ3RyJyk7XG5cdFx0aGVhZGVyQ29weS5maW5kKCd0aCwgdGQnKS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuXHRcblx0XG5cdFx0Lypcblx0XHQgKiAyLiBUYWtlIGxpdmUgbWVhc3VyZW1lbnRzIGZyb20gdGhlIERPTSAtIGRvIG5vdCBhbHRlciB0aGUgRE9NIGl0c2VsZiFcblx0XHQgKi9cblx0XG5cdFx0Ly8gUmVtb3ZlIG9sZCBzaXppbmcgYW5kIGFwcGx5IHRoZSBjYWxjdWxhdGVkIGNvbHVtbiB3aWR0aHNcblx0XHQvLyBHZXQgdGhlIHVuaXF1ZSBjb2x1bW4gaGVhZGVycyBpbiB0aGUgbmV3bHkgY3JlYXRlZCAoY2xvbmVkKSBoZWFkZXIuIFdlIHdhbnQgdG8gYXBwbHkgdGhlXG5cdFx0Ly8gY2FsY3VsYXRlZCBzaXplcyB0byB0aGlzIGhlYWRlclxuXHRcdGlmICggISBzY3JvbGxYIClcblx0XHR7XG5cdFx0XHRkaXZCb2R5U3R5bGUud2lkdGggPSAnMTAwJSc7XG5cdFx0XHRkaXZIZWFkZXJbMF0uc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cdFx0fVxuXHRcblx0XHQkLmVhY2goIF9mbkdldFVuaXF1ZVRocyggc2V0dGluZ3MsIGhlYWRlckNvcHkgKSwgZnVuY3Rpb24gKCBpLCBlbCApIHtcblx0XHRcdGlkeCA9IF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBzZXR0aW5ncywgaSApO1xuXHRcdFx0ZWwuc3R5bGUud2lkdGggPSBzZXR0aW5ncy5hb0NvbHVtbnNbaWR4XS5zV2lkdGg7XG5cdFx0fSApO1xuXHRcblx0XHRpZiAoIGZvb3RlciApIHtcblx0XHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24obikge1xuXHRcdFx0XHRuLnN0eWxlLndpZHRoID0gXCJcIjtcblx0XHRcdH0sIGZvb3RlclNyY0VscyApO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2l6ZSB0aGUgdGFibGUgYXMgYSB3aG9sZVxuXHRcdHNhbml0eVdpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXHRcdGlmICggc2Nyb2xsWCA9PT0gXCJcIiApIHtcblx0XHRcdC8vIE5vIHggc2Nyb2xsaW5nXG5cdFx0XHR0YWJsZVN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG5cdFxuXHRcdFx0Ly8gSUU3IHdpbGwgbWFrZSB0aGUgd2lkdGggb2YgdGhlIHRhYmxlIHdoZW4gMTAwJSBpbmNsdWRlIHRoZSBzY3JvbGxiYXJcblx0XHRcdC8vIC0gd2hpY2ggaXMgc2hvdWxkbid0LiBXaGVuIHRoZXJlIGlzIGEgc2Nyb2xsYmFyIHdlIG5lZWQgdG8gdGFrZSB0aGlzXG5cdFx0XHQvLyBpbnRvIGFjY291bnQuXG5cdFx0XHRpZiAoIGllNjcgJiYgKHRhYmxlLmZpbmQoJ3Rib2R5JykuaGVpZ2h0KCkgPiBkaXZCb2R5RWwub2Zmc2V0SGVpZ2h0IHx8XG5cdFx0XHRcdGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIilcblx0XHRcdCkge1xuXHRcdFx0XHR0YWJsZVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIHRhYmxlLm91dGVyV2lkdGgoKSAtIGJhcldpZHRoKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBSZWNhbGN1bGF0ZSB0aGUgc2FuaXR5IHdpZHRoXG5cdFx0XHRzYW5pdHlXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNjcm9sbFhJbm5lciAhPT0gXCJcIiApIHtcblx0XHRcdC8vIGxlZ2FjeSB4IHNjcm9sbCBpbm5lciBoYXMgYmVlbiBnaXZlbiAtIHVzZSBpdFxuXHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHNjcm9sbFhJbm5lcik7XG5cdFxuXHRcdFx0Ly8gUmVjYWxjdWxhdGUgdGhlIHNhbml0eSB3aWR0aFxuXHRcdFx0c2FuaXR5V2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XG5cdFx0fVxuXHRcblx0XHQvLyBIaWRkZW4gaGVhZGVyIHNob3VsZCBoYXZlIHplcm8gaGVpZ2h0LCBzbyByZW1vdmUgcGFkZGluZyBhbmQgYm9yZGVycy4gVGhlblxuXHRcdC8vIHNldCB0aGUgd2lkdGggYmFzZWQgb24gdGhlIHJlYWwgaGVhZGVyc1xuXHRcblx0XHQvLyBBcHBseSBhbGwgc3R5bGVzIGluIG9uZSBwYXNzXG5cdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCB6ZXJvT3V0LCBoZWFkZXJTcmNFbHMgKTtcblx0XG5cdFx0Ly8gUmVhZCBhbGwgd2lkdGhzIGluIG5leHQgcGFzc1xuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblNpemVyKSB7XG5cdFx0XHRoZWFkZXJDb250ZW50LnB1c2goIG5TaXplci5pbm5lckhUTUwgKTtcblx0XHRcdGhlYWRlcldpZHRocy5wdXNoKCBfZm5TdHJpbmdUb0NzcyggJChuU2l6ZXIpLmNzcygnd2lkdGgnKSApICk7XG5cdFx0fSwgaGVhZGVyU3JjRWxzICk7XG5cdFxuXHRcdC8vIEFwcGx5IGFsbCB3aWR0aHMgaW4gZmluYWwgcGFzc1xuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblRvU2l6ZSwgaSkge1xuXHRcdFx0Ly8gT25seSBhcHBseSB3aWR0aHMgdG8gdGhlIERhdGFUYWJsZXMgZGV0ZWN0ZWQgaGVhZGVyIGNlbGxzIC0gdGhpc1xuXHRcdFx0Ly8gcHJldmVudHMgY29tcGxleCBoZWFkZXJzIGZyb20gaGF2aW5nIGNvbnRyYWRpY3Rvcnkgc2l6ZXMgYXBwbGllZFxuXHRcdFx0aWYgKCAkLmluQXJyYXkoIG5Ub1NpemUsIGR0SGVhZGVyQ2VsbHMgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdG5Ub1NpemUuc3R5bGUud2lkdGggPSBoZWFkZXJXaWR0aHNbaV07XG5cdFx0XHR9XG5cdFx0fSwgaGVhZGVyVHJnRWxzICk7XG5cdFxuXHRcdCQoaGVhZGVyU3JjRWxzKS5oZWlnaHQoMCk7XG5cdFxuXHRcdC8qIFNhbWUgYWdhaW4gd2l0aCB0aGUgZm9vdGVyIGlmIHdlIGhhdmUgb25lICovXG5cdFx0aWYgKCBmb290ZXIgKVxuXHRcdHtcblx0XHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggemVyb091dCwgZm9vdGVyU3JjRWxzICk7XG5cdFxuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIpIHtcblx0XHRcdFx0Zm9vdGVyQ29udGVudC5wdXNoKCBuU2l6ZXIuaW5uZXJIVE1MICk7XG5cdFx0XHRcdGZvb3RlcldpZHRocy5wdXNoKCBfZm5TdHJpbmdUb0NzcyggJChuU2l6ZXIpLmNzcygnd2lkdGgnKSApICk7XG5cdFx0XHR9LCBmb290ZXJTcmNFbHMgKTtcblx0XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5Ub1NpemUsIGkpIHtcblx0XHRcdFx0blRvU2l6ZS5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcblx0XHRcdH0sIGZvb3RlclRyZ0VscyApO1xuXHRcblx0XHRcdCQoZm9vdGVyU3JjRWxzKS5oZWlnaHQoMCk7XG5cdFx0fVxuXHRcblx0XG5cdFx0Lypcblx0XHQgKiAzLiBBcHBseSB0aGUgbWVhc3VyZW1lbnRzXG5cdFx0ICovXG5cdFxuXHRcdC8vIFwiSGlkZVwiIHRoZSBoZWFkZXIgYW5kIGZvb3RlciB0aGF0IHdlIHVzZWQgZm9yIHRoZSBzaXppbmcuIFdlIG5lZWQgdG8ga2VlcFxuXHRcdC8vIHRoZSBjb250ZW50IG9mIHRoZSBjZWxsIHNvIHRoYXQgdGhlIHdpZHRoIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBhbmQgYm9keVxuXHRcdC8vIGJvdGggbWF0Y2gsIGJ1dCB3ZSB3YW50IHRvIGhpZGUgaXQgY29tcGxldGVseS4gV2Ugd2FudCB0byBhbHNvIGZpeCB0aGVpclxuXHRcdC8vIHdpZHRoIHRvIHdoYXQgdGhleSBjdXJyZW50bHkgYXJlXG5cdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIsIGkpIHtcblx0XHRcdG5TaXplci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImRhdGFUYWJsZXNfc2l6aW5nXCIgc3R5bGU9XCJoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47XCI+JytoZWFkZXJDb250ZW50W2ldKyc8L2Rpdj4nO1xuXHRcdFx0blNpemVyLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdH0sIGhlYWRlclNyY0VscyApO1xuXHRcblx0XHRpZiAoIGZvb3RlciApXG5cdFx0e1xuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIsIGkpIHtcblx0XHRcdFx0blNpemVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiZGF0YVRhYmxlc19zaXppbmdcIiBzdHlsZT1cImhlaWdodDowO292ZXJmbG93OmhpZGRlbjtcIj4nK2Zvb3RlckNvbnRlbnRbaV0rJzwvZGl2Pic7XG5cdFx0XHRcdG5TaXplci5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcblx0XHRcdH0sIGZvb3RlclNyY0VscyApO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2FuaXR5IGNoZWNrIHRoYXQgdGhlIHRhYmxlIGlzIG9mIGEgc2Vuc2libGUgd2lkdGguIElmIG5vdCB0aGVuIHdlIGFyZSBnb2luZyB0byBnZXRcblx0XHQvLyBtaXNhbGlnbm1lbnQgLSB0cnkgdG8gcHJldmVudCB0aGlzIGJ5IG5vdCBhbGxvd2luZyB0aGUgdGFibGUgdG8gc2hyaW5rIGJlbG93IGl0cyBtaW4gd2lkdGhcblx0XHRpZiAoIHRhYmxlLm91dGVyV2lkdGgoKSA8IHNhbml0eVdpZHRoIClcblx0XHR7XG5cdFx0XHQvLyBUaGUgbWluIHdpZHRoIGRlcGVuZHMgdXBvbiBpZiB3ZSBoYXZlIGEgdmVydGljYWwgc2Nyb2xsYmFyIHZpc2libGUgb3Igbm90ICovXG5cdFx0XHRjb3JyZWN0aW9uID0gKChkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0XHRkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpKSA/XG5cdFx0XHRcdFx0c2FuaXR5V2lkdGgrYmFyV2lkdGggOlxuXHRcdFx0XHRcdHNhbml0eVdpZHRoO1xuXHRcblx0XHRcdC8vIElFNi83IGFyZSBhIGxhdyB1bnRvIHRoZW1zZWx2ZXMuLi5cblx0XHRcdGlmICggaWU2NyAmJiAoZGl2Qm9keUVsLnNjcm9sbEhlaWdodCA+XG5cdFx0XHRcdGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbi1iYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFuZCBnaXZlIHRoZSB1c2VyIGEgd2FybmluZyB0aGF0IHdlJ3ZlIHN0b3BwZWQgdGhlIHRhYmxlIGdldHRpbmcgdG9vIHNtYWxsXG5cdFx0XHRpZiAoIHNjcm9sbFggPT09IFwiXCIgfHwgc2Nyb2xsWElubmVyICE9PSBcIlwiICkge1xuXHRcdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAxLCAnUG9zc2libGUgY29sdW1uIG1pc2FsaWdubWVudCcsIDYgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGNvcnJlY3Rpb24gPSAnMTAwJSc7XG5cdFx0fVxuXHRcblx0XHQvLyBBcHBseSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRzXG5cdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGNvcnJlY3Rpb24gKTtcblx0XHRkaXZIZWFkZXJTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb3JyZWN0aW9uICk7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0c2V0dGluZ3MublNjcm9sbEZvb3Quc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbiApO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogNC4gQ2xlYW4gdXBcblx0XHQgKi9cblx0XHRpZiAoICEgc2Nyb2xsWSApIHtcblx0XHRcdC8qIElFNzwgcHV0cyBhIHZlcnRpY2FsIHNjcm9sbGJhciBpbiBwbGFjZSAod2hlbiBpdCBzaG91bGRuJ3QgYmUpIGR1ZSB0byBzdWJ0cmFjdGluZ1xuXHRcdFx0ICogdGhlIHNjcm9sbGJhciBoZWlnaHQgZnJvbSB0aGUgdmlzaWJsZSBkaXNwbGF5LCByYXRoZXIgdGhhbiBhZGRpbmcgaXQgb24uIFdlIG5lZWQgdG9cblx0XHRcdCAqIHNldCB0aGUgaGVpZ2h0IGluIG9yZGVyIHRvIHNvcnQgdGhpcy4gRG9uJ3Qgd2FudCB0byBkbyBpdCBpbiBhbnkgb3RoZXIgYnJvd3NlcnMuXG5cdFx0XHQgKi9cblx0XHRcdGlmICggaWU2NyApIHtcblx0XHRcdFx0ZGl2Qm9keVN0eWxlLmhlaWdodCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZUVsLm9mZnNldEhlaWdodCtiYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogRmluYWxseSBzZXQgdGhlIHdpZHRoJ3Mgb2YgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRhYmxlcyAqL1xuXHRcdHZhciBpT3V0ZXJXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0XHRkaXZIZWFkZXJUYWJsZVswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBpT3V0ZXJXaWR0aCApO1xuXHRcdGRpdkhlYWRlcklubmVyU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XG5cdFx0Ly8gRmlndXJlIG91dCBpZiB0aGVyZSBhcmUgc2Nyb2xsYmFyIHByZXNlbnQgLSBpZiBzbyB0aGVuIHdlIG5lZWQgYSB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdG9cblx0XHQvLyBwcm92aWRlIGEgYml0IG1vcmUgc3BhY2UgdG8gYWxsb3cgXCJvdmVyZmxvd1wiIHNjcm9sbGluZyAoaS5lLiBwYXN0IHRoZSBzY3JvbGxiYXIpXG5cdFx0dmFyIGJTY3JvbGxpbmcgPSB0YWJsZS5oZWlnaHQoKSA+IGRpdkJvZHlFbC5jbGllbnRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiO1xuXHRcdHZhciBwYWRkaW5nID0gJ3BhZGRpbmcnICsgKGJyb3dzZXIuYlNjcm9sbGJhckxlZnQgPyAnTGVmdCcgOiAnUmlnaHQnICk7XG5cdFx0ZGl2SGVhZGVySW5uZXJTdHlsZVsgcGFkZGluZyBdID0gYlNjcm9sbGluZyA/IGJhcldpZHRoK1wicHhcIiA6IFwiMHB4XCI7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0ZGl2Rm9vdGVyVGFibGVbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XHRcdGRpdkZvb3RlcklubmVyWzBdLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGlPdXRlcldpZHRoICk7XG5cdFx0XHRkaXZGb290ZXJJbm5lclswXS5zdHlsZVtwYWRkaW5nXSA9IGJTY3JvbGxpbmcgPyBiYXJXaWR0aCtcInB4XCIgOiBcIjBweFwiO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29ycmVjdCBET00gb3JkZXJpbmcgZm9yIGNvbGdyb3VwIC0gY29tZXMgYmVmb3JlIHRoZSB0aGVhZFxuXHRcdHRhYmxlLmNoaWxkcmVuKCdjb2xncm91cCcpLmluc2VydEJlZm9yZSggdGFibGUuY2hpbGRyZW4oJ3RoZWFkJykgKTtcblx0XG5cdFx0LyogQWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyIGluIGNhc2Ugd2UgbG9vc2UgdGhlIHktc2Nyb2xsYmFyICovXG5cdFx0ZGl2Qm9keS5zY3JvbGwoKTtcblx0XG5cdFx0Ly8gSWYgc29ydGluZyBvciBmaWx0ZXJpbmcgaGFzIG9jY3VycmVkLCBqdW1wIHRoZSBzY3JvbGxpbmcgYmFjayB0byB0aGUgdG9wXG5cdFx0Ly8gb25seSBpZiB3ZSBhcmVuJ3QgaG9sZGluZyB0aGUgcG9zaXRpb25cblx0XHRpZiAoIChzZXR0aW5ncy5iU29ydGVkIHx8IHNldHRpbmdzLmJGaWx0ZXJlZCkgJiYgISBzZXR0aW5ncy5fZHJhd0hvbGQgKSB7XG5cdFx0XHRkaXZCb2R5RWwuc2Nyb2xsVG9wID0gMDtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGx5IGEgZ2l2ZW4gZnVuY3Rpb24gdG8gdGhlIGRpc3BsYXkgY2hpbGQgbm9kZXMgb2YgYW4gZWxlbWVudCBhcnJheSAodHlwaWNhbGx5XG5cdCAqIFREIGNoaWxkcmVuIG9mIFRSIHJvd3Ncblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIE1ldGhvZCB0byBhcHBseSB0byB0aGUgb2JqZWN0c1xuXHQgKiAgQHBhcmFtIGFycmF5IHtub2Rlc30gYW4xIExpc3Qgb2YgZWxlbWVudHMgdG8gbG9vayB0aHJvdWdoIGZvciBkaXNwbGF5IGNoaWxkcmVuXG5cdCAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjIgQW5vdGhlciBsaXN0IChpZGVudGljYWwgc3RydWN0dXJlIHRvIHRoZSBmaXJzdCkgLSBvcHRpb25hbFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BcHBseVRvQ2hpbGRyZW4oIGZuLCBhbjEsIGFuMiApXG5cdHtcblx0XHR2YXIgaW5kZXg9MCwgaT0wLCBpTGVuPWFuMS5sZW5ndGg7XG5cdFx0dmFyIG5Ob2RlMSwgbk5vZGUyO1xuXHRcblx0XHR3aGlsZSAoIGkgPCBpTGVuICkge1xuXHRcdFx0bk5vZGUxID0gYW4xW2ldLmZpcnN0Q2hpbGQ7XG5cdFx0XHRuTm9kZTIgPSBhbjIgPyBhbjJbaV0uZmlyc3RDaGlsZCA6IG51bGw7XG5cdFxuXHRcdFx0d2hpbGUgKCBuTm9kZTEgKSB7XG5cdFx0XHRcdGlmICggbk5vZGUxLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdGlmICggYW4yICkge1xuXHRcdFx0XHRcdFx0Zm4oIG5Ob2RlMSwgbk5vZGUyLCBpbmRleCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGZuKCBuTm9kZTEsIGluZGV4ICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRuTm9kZTEgPSBuTm9kZTEubmV4dFNpYmxpbmc7XG5cdFx0XHRcdG5Ob2RlMiA9IGFuMiA/IG5Ob2RlMi5uZXh0U2libGluZyA6IG51bGw7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aSsrO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdFxuXHR2YXIgX19yZV9odG1sX3JlbW92ZSA9IC88Lio/Pi9nO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIGNvbHVtbnMgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0YWJsZSA9IG9TZXR0aW5ncy5uVGFibGUsXG5cdFx0XHRjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdHNjcm9sbCA9IG9TZXR0aW5ncy5vU2Nyb2xsLFxuXHRcdFx0c2Nyb2xsWSA9IHNjcm9sbC5zWSxcblx0XHRcdHNjcm9sbFggPSBzY3JvbGwuc1gsXG5cdFx0XHRzY3JvbGxYSW5uZXIgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRcdGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGgsXG5cdFx0XHR2aXNpYmxlQ29sdW1ucyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApLFxuXHRcdFx0aGVhZGVyQ2VsbHMgPSAkKCd0aCcsIG9TZXR0aW5ncy5uVEhlYWQpLFxuXHRcdFx0dGFibGVXaWR0aEF0dHIgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIC8vIGZyb20gRE9NIGVsZW1lbnRcblx0XHRcdHRhYmxlQ29udGFpbmVyID0gdGFibGUucGFyZW50Tm9kZSxcblx0XHRcdHVzZXJJbnB1dHMgPSBmYWxzZSxcblx0XHRcdGksIGNvbHVtbiwgY29sdW1uSWR4LCB3aWR0aCwgb3V0ZXJXaWR0aCxcblx0XHRcdGJyb3dzZXIgPSBvU2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0XHRpZTY3ID0gYnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemU7XG5cdFxuXHRcdHZhciBzdHlsZVdpZHRoID0gdGFibGUuc3R5bGUud2lkdGg7XG5cdFx0aWYgKCBzdHlsZVdpZHRoICYmIHN0eWxlV2lkdGguaW5kZXhPZignJScpICE9PSAtMSApIHtcblx0XHRcdHRhYmxlV2lkdGhBdHRyID0gc3R5bGVXaWR0aDtcblx0XHR9XG5cdFxuXHRcdC8qIENvbnZlcnQgYW55IHVzZXIgaW5wdXQgc2l6ZXMgaW50byBwaXhlbCBzaXplcyAqL1xuXHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXTtcblx0XG5cdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdGNvbHVtbi5zV2lkdGggPSBfZm5Db252ZXJ0VG9XaWR0aCggY29sdW1uLnNXaWR0aE9yaWcsIHRhYmxlQ29udGFpbmVyICk7XG5cdFxuXHRcdFx0XHR1c2VySW5wdXRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8qIElmIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgRE9NIGVxdWFscyB0aGUgbnVtYmVyIHRoYXQgd2UgaGF2ZSB0b1xuXHRcdCAqIHByb2Nlc3MgaW4gRGF0YVRhYmxlcywgdGhlbiB3ZSBjYW4gdXNlIHRoZSBvZmZzZXRzIHRoYXQgYXJlIGNyZWF0ZWQgYnlcblx0XHQgKiB0aGUgd2ViLSBicm93c2VyLiBObyBjdXN0b20gc2l6ZXMgY2FuIGJlIHNldCBpbiBvcmRlciBmb3IgdGhpcyB0byBoYXBwZW4sXG5cdFx0ICogbm9yIHNjcm9sbGluZyB1c2VkXG5cdFx0ICovXG5cdFx0aWYgKCBpZTY3IHx8ICEgdXNlcklucHV0cyAmJiAhIHNjcm9sbFggJiYgISBzY3JvbGxZICYmXG5cdFx0ICAgICBjb2x1bW5Db3VudCA9PSBfZm5WaXNibGVDb2x1bW5zKCBvU2V0dGluZ3MgKSAmJlxuXHRcdCAgICAgY29sdW1uQ291bnQgPT0gaGVhZGVyQ2VsbHMubGVuZ3RoXG5cdFx0KSB7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPGNvbHVtbkNvdW50IDsgaSsrICkge1xuXHRcdFx0XHR2YXIgY29sSWR4ID0gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaSApO1xuXHRcblx0XHRcdFx0aWYgKCBjb2xJZHggIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0Y29sdW1uc1sgY29sSWR4IF0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGhlYWRlckNlbGxzLmVxKGkpLndpZHRoKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIGNvbnN0cnVjdCBhIHNpbmdsZSByb3csIHdvcnN0IGNhc2UsIHRhYmxlIHdpdGggdGhlIHdpZGVzdFxuXHRcdFx0Ly8gbm9kZSBpbiB0aGUgZGF0YSwgYXNzaWduIGFueSB1c2VyIGRlZmluZWQgd2lkdGhzLCB0aGVuIGluc2VydCBpdCBpbnRvXG5cdFx0XHQvLyB0aGUgRE9NIGFuZCBhbGxvdyB0aGUgYnJvd3NlciB0byBkbyBhbGwgdGhlIGhhcmQgd29yayBvZiBjYWxjdWxhdGluZ1xuXHRcdFx0Ly8gdGFibGUgd2lkdGhzXG5cdFx0XHR2YXIgdG1wVGFibGUgPSAkKHRhYmxlKS5jbG9uZSgpIC8vIGRvbid0IHVzZSBjbG9uZU5vZGUgLSBJRTggd2lsbCByZW1vdmUgZXZlbnRzIG9uIHRoZSBtYWluIHRhYmxlXG5cdFx0XHRcdC5jc3MoICd2aXNpYmlsaXR5JywgJ2hpZGRlbicgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggJ2lkJyApO1xuXHRcblx0XHRcdC8vIENsZWFuIHVwIHRoZSB0YWJsZSBib2R5XG5cdFx0XHR0bXBUYWJsZS5maW5kKCd0Ym9keSB0cicpLnJlbW92ZSgpO1xuXHRcdFx0dmFyIHRyID0gJCgnPHRyLz4nKS5hcHBlbmRUbyggdG1wVGFibGUuZmluZCgndGJvZHknKSApO1xuXHRcblx0XHRcdC8vIENsb25lIHRoZSB0YWJsZSBoZWFkZXIgYW5kIGZvb3RlciAtIHdlIGNhbid0IHVzZSB0aGUgaGVhZGVyIC8gZm9vdGVyXG5cdFx0XHQvLyBmcm9tIHRoZSBjbG9uZWQgdGFibGUsIHNpbmNlIGlmIHNjcm9sbGluZyBpcyBhY3RpdmUsIHRoZSB0YWJsZSdzXG5cdFx0XHQvLyByZWFsIGhlYWRlciBhbmQgZm9vdGVyIGFyZSBjb250YWluZWQgaW4gZGlmZmVyZW50IHRhYmxlIHRhZ3Ncblx0XHRcdHRtcFRhYmxlLmZpbmQoJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuXHRcdFx0dG1wVGFibGVcblx0XHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRIZWFkKS5jbG9uZSgpIClcblx0XHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRGb290KS5jbG9uZSgpICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIGFueSBhc3NpZ25lZCB3aWR0aHMgZnJvbSB0aGUgZm9vdGVyIChmcm9tIHNjcm9sbGluZylcblx0XHRcdHRtcFRhYmxlLmZpbmQoJ3Rmb290IHRoLCB0Zm9vdCB0ZCcpLmNzcygnd2lkdGgnLCAnJyk7XG5cdFxuXHRcdFx0Ly8gQXBwbHkgY3VzdG9tIHNpemluZyB0byB0aGUgY2xvbmVkIGhlYWRlclxuXHRcdFx0aGVhZGVyQ2VsbHMgPSBfZm5HZXRVbmlxdWVUaHMoIG9TZXR0aW5ncywgdG1wVGFibGUuZmluZCgndGhlYWQnKVswXSApO1xuXHRcblx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdO1xuXHRcblx0XHRcdFx0aGVhZGVyQ2VsbHNbaV0uc3R5bGUud2lkdGggPSBjb2x1bW4uc1dpZHRoT3JpZyAhPT0gbnVsbCAmJiBjb2x1bW4uc1dpZHRoT3JpZyAhPT0gJycgP1xuXHRcdFx0XHRcdF9mblN0cmluZ1RvQ3NzKCBjb2x1bW4uc1dpZHRoT3JpZyApIDpcblx0XHRcdFx0XHQnJztcblx0XG5cdFx0XHRcdC8vIEZvciBzY3JvbGxYIHdlIG5lZWQgdG8gZm9yY2UgdGhlIGNvbHVtbiB3aWR0aCBvdGhlcndpc2UgdGhlXG5cdFx0XHRcdC8vIGJyb3dzZXIgd2lsbCBjb2xsYXBzZSBpdC4gSWYgdGhpcyB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHRcdC8vIHdpZHRoIHRoZSBjb2x1bW4gcmVxdWlyZXMsIHRoZW4gaXQgd2lsbCBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGhPcmlnICYmIHNjcm9sbFggKSB7XG5cdFx0XHRcdFx0JCggaGVhZGVyQ2VsbHNbaV0gKS5hcHBlbmQoICQoJzxkaXYvPicpLmNzcygge1xuXHRcdFx0XHRcdFx0d2lkdGg6IGNvbHVtbi5zV2lkdGhPcmlnLFxuXHRcdFx0XHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0XHRcdFx0cGFkZGluZzogMCxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0XHRcdH0gKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gRmluZCB0aGUgd2lkZXN0IGNlbGwgZm9yIGVhY2ggY29sdW1uIGFuZCBwdXQgaXQgaW50byB0aGUgdGFibGVcblx0XHRcdGlmICggb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggKSB7XG5cdFx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRcdGNvbHVtbklkeCA9IHZpc2libGVDb2x1bW5zW2ldO1xuXHRcdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbIGNvbHVtbklkeCBdO1xuXHRcblx0XHRcdFx0XHQkKCBfZm5HZXRXaWRlc3ROb2RlKCBvU2V0dGluZ3MsIGNvbHVtbklkeCApIClcblx0XHRcdFx0XHRcdC5jbG9uZSggZmFsc2UgKVxuXHRcdFx0XHRcdFx0LmFwcGVuZCggY29sdW1uLnNDb250ZW50UGFkZGluZyApXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHRyICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUaWR5IHRoZSB0ZW1wb3JhcnkgdGFibGUgLSByZW1vdmUgbmFtZSBhdHRyaWJ1dGVzIHNvIHRoZXJlIGFyZW4ndFxuXHRcdFx0Ly8gZHVwbGljYXRlZCBpbiB0aGUgZG9tIChyYWRpbyBlbGVtZW50cyBmb3IgZXhhbXBsZSlcblx0XHRcdCQoJ1tuYW1lXScsIHRtcFRhYmxlKS5yZW1vdmVBdHRyKCduYW1lJyk7XG5cdFxuXHRcdFx0Ly8gVGFibGUgaGFzIGJlZW4gYnVpbHQsIGF0dGFjaCB0byB0aGUgZG9jdW1lbnQgc28gd2UgY2FuIHdvcmsgd2l0aCBpdC5cblx0XHRcdC8vIEEgaG9sZGluZyBlbGVtZW50IGlzIHVzZWQsIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZiB0aGUgY29udGFpbmVyXG5cdFx0XHQvLyB3aXRoIG1pbmltYWwgaGVpZ2h0LCBzbyBpdCBoYXMgbm8gZWZmZWN0IG9uIGlmIHRoZSBjb250YWluZXIgc2Nyb2xsc1xuXHRcdFx0Ly8gb3Igbm90LiBPdGhlcndpc2UgaXQgbWlnaHQgdHJpZ2dlciBzY3JvbGxpbmcgd2hlbiBpdCBhY3R1YWxseSBpc24ndFxuXHRcdFx0Ly8gbmVlZGVkXG5cdFx0XHR2YXIgaG9sZGVyID0gJCgnPGRpdi8+JykuY3NzKCBzY3JvbGxYIHx8IHNjcm9sbFkgP1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHRcdFx0fSA6XG5cdFx0XHRcdFx0e31cblx0XHRcdFx0KVxuXHRcdFx0XHQuYXBwZW5kKCB0bXBUYWJsZSApXG5cdFx0XHRcdC5hcHBlbmRUbyggdGFibGVDb250YWluZXIgKTtcblx0XG5cdFx0XHQvLyBXaGVuIHNjcm9sbGluZyAoWCBvciBZKSB3ZSB3YW50IHRvIHNldCB0aGUgd2lkdGggb2YgdGhlIHRhYmxlIGFzIFxuXHRcdFx0Ly8gYXBwcm9wcmlhdGUuIEhvd2V2ZXIsIHdoZW4gbm90IHNjcm9sbGluZyBsZWF2ZSB0aGUgdGFibGUgd2lkdGggYXMgaXRcblx0XHRcdC8vIGlzLiBUaGlzIHJlc3VsdHMgaW4gc2xpZ2h0bHkgZGlmZmVyZW50LCBidXQgSSB0aGluayBjb3JyZWN0IGJlaGF2aW91clxuXHRcdFx0aWYgKCBzY3JvbGxYICYmIHNjcm9sbFhJbm5lciApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHNjcm9sbFhJbm5lciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNjcm9sbFggKSB7XG5cdFx0XHRcdHRtcFRhYmxlLmNzcyggJ3dpZHRoJywgJ2F1dG8nICk7XG5cdFx0XHRcdHRtcFRhYmxlLnJlbW92ZUF0dHIoJ3dpZHRoJyk7XG5cdFxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyB3aWR0aCBhdHRyaWJ1dGUgb3Igc3R5bGUsIHRoZW4gYWxsb3cgdGhlIHRhYmxlIHRvXG5cdFx0XHRcdC8vIGNvbGxhcHNlXG5cdFx0XHRcdGlmICggdG1wVGFibGUud2lkdGgoKSA8IHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICYmIHRhYmxlV2lkdGhBdHRyICkge1xuXHRcdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2Nyb2xsWSApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZVdpZHRoQXR0ciApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEdldCB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW4gaW4gdGhlIGNvbnN0cnVjdGVkIHRhYmxlIC0gd2UgbmVlZCB0b1xuXHRcdFx0Ly8ga25vdyB0aGUgaW5uZXIgd2lkdGggKHNvIGl0IGNhbiBiZSBhc3NpZ25lZCB0byB0aGUgb3RoZXIgdGFibGUnc1xuXHRcdFx0Ly8gY2VsbHMpIGFuZCB0aGUgb3V0ZXIgd2lkdGggc28gd2UgY2FuIGNhbGN1bGF0ZSB0aGUgZnVsbCB3aWR0aCBvZiB0aGVcblx0XHRcdC8vIHRhYmxlLiBUaGlzIGlzIHNhZmUgc2luY2UgRGF0YVRhYmxlcyByZXF1aXJlcyBhIHVuaXF1ZSBjZWxsIGZvciBlYWNoXG5cdFx0XHQvLyBjb2x1bW4sIGJ1dCBpZiBldmVyIGEgaGVhZGVyIGNhbiBzcGFuIG11bHRpcGxlIGNvbHVtbnMsIHRoaXMgd2lsbFxuXHRcdFx0Ly8gbmVlZCB0byBiZSBtb2RpZmllZC5cblx0XHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0dmFyIGNlbGwgPSAkKGhlYWRlckNlbGxzW2ldKTtcblx0XHRcdFx0dmFyIGJvcmRlciA9IGNlbGwub3V0ZXJXaWR0aCgpIC0gY2VsbC53aWR0aCgpO1xuXHRcblx0XHRcdFx0Ly8gVXNlIGdldEJvdW5kaW5nLi4uIHdoZXJlIHBvc3NpYmxlIChub3QgSUU4LSkgYmVjYXVzZSBpdCBjYW4gZ2l2ZVxuXHRcdFx0XHQvLyBzdWItcGl4ZWwgYWNjdXJhY3ksIHdoaWNoIHdlIHRoZW4gd2FudCB0byByb3VuZCB1cCFcblx0XHRcdFx0dmFyIGJvdW5kaW5nID0gYnJvd3Nlci5iQm91bmRpbmcgP1xuXHRcdFx0XHRcdE1hdGguY2VpbCggaGVhZGVyQ2VsbHNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA6XG5cdFx0XHRcdFx0Y2VsbC5vdXRlcldpZHRoKCk7XG5cdFxuXHRcdFx0XHQvLyBUb3RhbCBpcyB0cmFja2VkIHRvIHJlbW92ZSBhbnkgc3ViLXBpeGVsIGVycm9ycyBhcyB0aGUgb3V0ZXJXaWR0aFxuXHRcdFx0XHQvLyBvZiB0aGUgdGFibGUgbWlnaHQgbm90IGVxdWFsIHRoZSB0b3RhbCBnaXZlbiBoZXJlIChJRSEpLlxuXHRcdFx0XHR0b3RhbCArPSBib3VuZGluZztcblx0XG5cdFx0XHRcdC8vIFdpZHRoIGZvciBlYWNoIGNvbHVtbiB0byB1c2Vcblx0XHRcdFx0Y29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXS5zV2lkdGggPSBfZm5TdHJpbmdUb0NzcyggYm91bmRpbmcgLSBib3JkZXIgKTtcblx0XHRcdH1cblx0XG5cdFx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0b3RhbCApO1xuXHRcblx0XHRcdC8vIEZpbmlzaGVkIHdpdGggdGhlIHRhYmxlIC0gZGl0Y2ggaXRcblx0XHRcdGhvbGRlci5yZW1vdmUoKTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIHRoZXJlIGlzIGEgd2lkdGggYXR0ciwgd2Ugd2FudCB0byBhdHRhY2ggYW4gZXZlbnQgbGlzdGVuZXIgd2hpY2hcblx0XHQvLyBhbGxvd3MgdGhlIHRhYmxlIHNpemluZyB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB3aGVuIHRoZSB3aW5kb3cgaXNcblx0XHQvLyByZXNpemVkLiBVc2UgdGhlIHdpZHRoIGF0dHIgcmF0aGVyIHRoYW4gQ1NTLCBzaW5jZSB3ZSBjYW4ndCBrbm93IGlmIHRoZVxuXHRcdC8vIENTUyBpcyBhIHJlbGF0aXZlIHZhbHVlIG9yIGFic29sdXRlIC0gRE9NIHJlYWQgaXMgYWx3YXlzIHB4LlxuXHRcdGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZVdpZHRoQXR0ciApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAodGFibGVXaWR0aEF0dHIgfHwgc2Nyb2xsWCkgJiYgISBvU2V0dGluZ3MuX3Jlc3pFdnQgKSB7XG5cdFx0XHR2YXIgYmluZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0JCh3aW5kb3cpLm9uKCdyZXNpemUuRFQtJytvU2V0dGluZ3Muc0luc3RhbmNlLCBfZm5UaHJvdHRsZSggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggb1NldHRpbmdzICk7XG5cdFx0XHRcdH0gKSApO1xuXHRcdFx0fTtcblx0XG5cdFx0XHQvLyBJRTYvNyB3aWxsIGNyYXNoIGlmIHdlIGJpbmQgYSByZXNpemUgZXZlbnQgaGFuZGxlciBvbiBwYWdlIGxvYWQuXG5cdFx0XHQvLyBUbyBiZSByZW1vdmVkIGluIDEuMTEgd2hpY2ggZHJvcHMgSUU2Lzcgc3VwcG9ydFxuXHRcdFx0aWYgKCBpZTY3ICkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBiaW5kUmVzaXplLCAxMDAwICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YmluZFJlc2l6ZSgpO1xuXHRcdFx0fVxuXHRcblx0XHRcdG9TZXR0aW5ncy5fcmVzekV2dCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRocm90dGxlIHRoZSBjYWxscyB0byBhIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIGNvbnRleHQgYXJlIG1haW50YWluZWQgZm9yXG5cdCAqIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHQgKiAgQHBhcmFtIHtpbnR9IFtmcmVxPTIwMF0gY2FsbCBmcmVxdWVuY3kgaW4gbVNcblx0ICogIEByZXR1cm5zIHtmdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHR2YXIgX2ZuVGhyb3R0bGUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZTtcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVydCBhIENTUyB1bml0IHdpZHRoIHRvIHBpeGVscyAoZS5nLiAyZW0pXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gd2lkdGggd2lkdGggdG8gYmUgY29udmVydGVkXG5cdCAqICBAcGFyYW0ge25vZGV9IHBhcmVudCBwYXJlbnQgdG8gZ2V0IHRoZSB3aXRoIGZvciAocmVxdWlyZWQgZm9yIHJlbGF0aXZlIHdpZHRocykgLSBvcHRpb25hbFxuXHQgKiAgQHJldHVybnMge2ludH0gd2lkdGggaW4gcGl4ZWxzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbnZlcnRUb1dpZHRoICggd2lkdGgsIHBhcmVudCApXG5cdHtcblx0XHRpZiAoICEgd2lkdGggKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFxuXHRcdHZhciBuID0gJCgnPGRpdi8+Jylcblx0XHRcdC5jc3MoICd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKCB3aWR0aCApIClcblx0XHRcdC5hcHBlbmRUbyggcGFyZW50IHx8IGRvY3VtZW50LmJvZHkgKTtcblx0XG5cdFx0dmFyIHZhbCA9IG5bMF0ub2Zmc2V0V2lkdGg7XG5cdFx0bi5yZW1vdmUoKTtcblx0XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHdpZGVzdCBub2RlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gd2lkZXN0IHRhYmxlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0V2lkZXN0Tm9kZSggc2V0dGluZ3MsIGNvbElkeCApXG5cdHtcblx0XHR2YXIgaWR4ID0gX2ZuR2V0TWF4TGVuU3RyaW5nKCBzZXR0aW5ncywgY29sSWR4ICk7XG5cdFx0aWYgKCBpZHggPCAwICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgaWR4IF07XG5cdFx0cmV0dXJuICEgZGF0YS5uVHIgPyAvLyBNaWdodCBub3QgaGF2ZSBiZWVuIGNyZWF0ZWQgd2hlbiBkZWZlcnJlZCByZW5kZXJpbmdcblx0XHRcdCQoJzx0ZC8+JykuaHRtbCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpZHgsIGNvbElkeCwgJ2Rpc3BsYXknICkgKVswXSA6XG5cdFx0XHRkYXRhLmFuQ2VsbHNbIGNvbElkeCBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgbWF4aW11bSBzdHJsZW4gZm9yIGVhY2ggZGF0YSBjb2x1bW5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3Rcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IG1heCBzdHJpbmcgbGVuZ3RoIGZvciBlYWNoIGNvbHVtblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRNYXhMZW5TdHJpbmcoIHNldHRpbmdzLCBjb2xJZHggKVxuXHR7XG5cdFx0dmFyIHMsIG1heD0tMSwgbWF4SWR4ID0gLTE7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JyApKycnO1xuXHRcdFx0cyA9IHMucmVwbGFjZSggX19yZV9odG1sX3JlbW92ZSwgJycgKTtcblx0XHRcdHMgPSBzLnJlcGxhY2UoIC8mbmJzcDsvZywgJyAnICk7XG5cdFxuXHRcdFx0aWYgKCBzLmxlbmd0aCA+IG1heCApIHtcblx0XHRcdFx0bWF4ID0gcy5sZW5ndGg7XG5cdFx0XHRcdG1heElkeCA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbWF4SWR4O1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGVuZCBhIENTUyB1bml0IChvbmx5IGlmIHJlcXVpcmVkKSB0byBhIHN0cmluZ1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRvIGNzcy1pZnlcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IHZhbHVlIHdpdGggY3NzIHVuaXRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU3RyaW5nVG9Dc3MoIHMgKVxuXHR7XG5cdFx0aWYgKCBzID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuICcwcHgnO1xuXHRcdH1cblx0XG5cdFx0aWYgKCB0eXBlb2YgcyA9PSAnbnVtYmVyJyApIHtcblx0XHRcdHJldHVybiBzIDwgMCA/XG5cdFx0XHRcdCcwcHgnIDpcblx0XHRcdFx0cysncHgnO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ2hlY2sgaXQgaGFzIGEgdW5pdCBjaGFyYWN0ZXIgYWxyZWFkeVxuXHRcdHJldHVybiBzLm1hdGNoKC9cXGQkLykgP1xuXHRcdFx0cysncHgnIDpcblx0XHRcdHM7XG5cdH1cblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuU29ydEZsYXR0ZW4gKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGksIGlMZW4sIGssIGtMZW4sXG5cdFx0XHRhU29ydCA9IFtdLFxuXHRcdFx0YWlPcmlnID0gW10sXG5cdFx0XHRhb0NvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRhRGF0YVNvcnQsIGlDb2wsIHNUeXBlLCBzcmNDb2wsXG5cdFx0XHRmaXhlZCA9IHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkLFxuXHRcdFx0Zml4ZWRPYmogPSAkLmlzUGxhaW5PYmplY3QoIGZpeGVkICksXG5cdFx0XHRuZXN0ZWRTb3J0ID0gW10sXG5cdFx0XHRhZGQgPSBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0XHRcdGlmICggYS5sZW5ndGggJiYgISAkLmlzQXJyYXkoIGFbMF0gKSApIHtcblx0XHRcdFx0XHQvLyAxRCBhcnJheVxuXHRcdFx0XHRcdG5lc3RlZFNvcnQucHVzaCggYSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIDJEIGFycmF5XG5cdFx0XHRcdFx0JC5tZXJnZSggbmVzdGVkU29ydCwgYSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcblx0XHQvLyBCdWlsZCB0aGUgc29ydCBhcnJheSwgd2l0aCBwcmUtZml4IGFuZCBwb3N0LWZpeCBvcHRpb25zIGlmIHRoZXkgaGF2ZSBiZWVuXG5cdFx0Ly8gc3BlY2lmaWVkXG5cdFx0aWYgKCAkLmlzQXJyYXkoIGZpeGVkICkgKSB7XG5cdFx0XHRhZGQoIGZpeGVkICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZpeGVkT2JqICYmIGZpeGVkLnByZSApIHtcblx0XHRcdGFkZCggZml4ZWQucHJlICk7XG5cdFx0fVxuXHRcblx0XHRhZGQoIHNldHRpbmdzLmFhU29ydGluZyApO1xuXHRcblx0XHRpZiAoZml4ZWRPYmogJiYgZml4ZWQucG9zdCApIHtcblx0XHRcdGFkZCggZml4ZWQucG9zdCApO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wIDsgaTxuZXN0ZWRTb3J0Lmxlbmd0aCA7IGkrKyApXG5cdFx0e1xuXHRcdFx0c3JjQ29sID0gbmVzdGVkU29ydFtpXVswXTtcblx0XHRcdGFEYXRhU29ydCA9IGFvQ29sdW1uc1sgc3JjQ29sIF0uYURhdGFTb3J0O1xuXHRcblx0XHRcdGZvciAoIGs9MCwga0xlbj1hRGF0YVNvcnQubGVuZ3RoIDsgazxrTGVuIDsgaysrIClcblx0XHRcdHtcblx0XHRcdFx0aUNvbCA9IGFEYXRhU29ydFtrXTtcblx0XHRcdFx0c1R5cGUgPSBhb0NvbHVtbnNbIGlDb2wgXS5zVHlwZSB8fCAnc3RyaW5nJztcblx0XG5cdFx0XHRcdGlmICggbmVzdGVkU29ydFtpXS5faWR4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0bmVzdGVkU29ydFtpXS5faWR4ID0gJC5pbkFycmF5KCBuZXN0ZWRTb3J0W2ldWzFdLCBhb0NvbHVtbnNbaUNvbF0uYXNTb3J0aW5nICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGFTb3J0LnB1c2goIHtcblx0XHRcdFx0XHRzcmM6ICAgICAgIHNyY0NvbCxcblx0XHRcdFx0XHRjb2w6ICAgICAgIGlDb2wsXG5cdFx0XHRcdFx0ZGlyOiAgICAgICBuZXN0ZWRTb3J0W2ldWzFdLFxuXHRcdFx0XHRcdGluZGV4OiAgICAgbmVzdGVkU29ydFtpXS5faWR4LFxuXHRcdFx0XHRcdHR5cGU6ICAgICAgc1R5cGUsXG5cdFx0XHRcdFx0Zm9ybWF0dGVyOiBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbIHNUeXBlK1wiLXByZVwiIF1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGFTb3J0O1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKiAgQHRvZG8gVGhpcyByZWFsbHkgbmVlZHMgc3BsaXQgdXAhXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Tb3J0ICggb1NldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0aSwgaWVuLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLFxuXHRcdFx0c0RhdGFUeXBlLCBuVGgsXG5cdFx0XHRhaU9yaWcgPSBbXSxcblx0XHRcdG9FeHRTb3J0ID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLFxuXHRcdFx0YW9EYXRhID0gb1NldHRpbmdzLmFvRGF0YSxcblx0XHRcdGFvQ29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRhRGF0YVNvcnQsIGRhdGEsIGlDb2wsIHNUeXBlLCBvU29ydCxcblx0XHRcdGZvcm1hdHRlcnMgPSAwLFxuXHRcdFx0c29ydENvbCxcblx0XHRcdGRpc3BsYXlNYXN0ZXIgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLFxuXHRcdFx0YVNvcnQ7XG5cdFxuXHRcdC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cblx0XHQvLyBAdG9kbyBDYW4gdGhpcyBiZSBtb3ZlZCBpbnRvIGEgJ2RhdGEtcmVhZHknIGhhbmRsZXIgd2hpY2ggaXMgY2FsbGVkIHdoZW5cblx0XHQvLyAgIGRhdGEgaXMgZ29pbmcgdG8gYmUgdXNlZCBpbiB0aGUgdGFibGU/XG5cdFx0X2ZuQ29sdW1uVHlwZXMoIG9TZXR0aW5ncyApO1xuXHRcblx0XHRhU29ydCA9IF9mblNvcnRGbGF0dGVuKCBvU2V0dGluZ3MgKTtcblx0XG5cdFx0Zm9yICggaT0wLCBpZW49YVNvcnQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzb3J0Q29sID0gYVNvcnRbaV07XG5cdFxuXHRcdFx0Ly8gVHJhY2sgaWYgd2UgY2FuIHVzZSB0aGUgZmFzdCBzb3J0IGFsZ29yaXRobVxuXHRcdFx0aWYgKCBzb3J0Q29sLmZvcm1hdHRlciApIHtcblx0XHRcdFx0Zm9ybWF0dGVycysrO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIExvYWQgdGhlIGRhdGEgbmVlZGVkIGZvciB0aGUgc29ydCwgZm9yIGVhY2ggY2VsbFxuXHRcdFx0X2ZuU29ydERhdGEoIG9TZXR0aW5ncywgc29ydENvbC5jb2wgKTtcblx0XHR9XG5cdFxuXHRcdC8qIE5vIHNvcnRpbmcgcmVxdWlyZWQgaWYgc2VydmVyLXNpZGUgb3Igbm8gc29ydGluZyBhcnJheSAqL1xuXHRcdGlmICggX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgIT0gJ3NzcCcgJiYgYVNvcnQubGVuZ3RoICE9PSAwIClcblx0XHR7XG5cdFx0XHQvLyBDcmVhdGUgYSB2YWx1ZSAtIGtleSBhcnJheSBvZiB0aGUgY3VycmVudCByb3cgcG9zaXRpb25zIHN1Y2ggdGhhdCB3ZSBjYW4gdXNlIHRoZWlyXG5cdFx0XHQvLyBjdXJyZW50IHBvc2l0aW9uIGR1cmluZyB0aGUgc29ydCwgaWYgdmFsdWVzIG1hdGNoLCBpbiBvcmRlciB0byBwZXJmb3JtIHN0YWJsZSBzb3J0aW5nXG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49ZGlzcGxheU1hc3Rlci5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRcdGFpT3JpZ1sgZGlzcGxheU1hc3RlcltpXSBdID0gaTtcblx0XHRcdH1cblx0XG5cdFx0XHQvKiBEbyB0aGUgc29ydCAtIGhlcmUgd2Ugd2FudCBtdWx0aS1jb2x1bW4gc29ydGluZyBiYXNlZCBvbiBhIGdpdmVuIGRhdGEgc291cmNlIChjb2x1bW4pXG5cdFx0XHQgKiBhbmQgc29ydGluZyBmdW5jdGlvbiAoZnJvbSBvU29ydCkgaW4gYSBjZXJ0YWluIGRpcmVjdGlvbi4gSXQncyByZWFzb25hYmx5IGNvbXBsZXggdG9cblx0XHRcdCAqIGZvbGxvdyBvbiBpdCdzIG93biwgYnV0IHRoaXMgaXMgd2hhdCB3ZSB3YW50IChleGFtcGxlIHR3byBjb2x1bW4gc29ydGluZyk6XG5cdFx0XHQgKiAgZm5Mb2NhbFNvcnRpbmcgPSBmdW5jdGlvbihhLGIpe1xuXHRcdFx0ICogICAgdmFyIGlUZXN0O1xuXHRcdFx0ICogICAgaVRlc3QgPSBvU29ydFsnc3RyaW5nLWFzYyddKCdkYXRhMTEnLCAnZGF0YTEyJyk7XG5cdFx0XHQgKiAgICAgIGlmIChpVGVzdCAhPT0gMClcblx0XHRcdCAqICAgICAgICByZXR1cm4gaVRlc3Q7XG5cdFx0XHQgKiAgICBpVGVzdCA9IG9Tb3J0WydudW1lcmljLWRlc2MnXSgnZGF0YTIxJywgJ2RhdGEyMicpO1xuXHRcdFx0ICogICAgaWYgKGlUZXN0ICE9PSAwKVxuXHRcdFx0ICogICAgICByZXR1cm4gaVRlc3Q7XG5cdFx0XHQgKiAgICByZXR1cm4gb1NvcnRbJ251bWVyaWMtYXNjJ10oIGFpT3JpZ1thXSwgYWlPcmlnW2JdICk7XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICogQmFzaWNhbGx5IHdlIGhhdmUgYSB0ZXN0IGZvciBlYWNoIHNvcnRpbmcgY29sdW1uLCBpZiB0aGUgZGF0YSBpbiB0aGF0IGNvbHVtbiBpcyBlcXVhbCxcblx0XHRcdCAqIHRlc3QgdGhlIG5leHQgY29sdW1uLiBJZiBhbGwgY29sdW1ucyBtYXRjaCwgdGhlbiB3ZSB1c2UgYSBudW1lcmljIHNvcnQgb24gdGhlIHJvd1xuXHRcdFx0ICogcG9zaXRpb25zIGluIHRoZSBvcmlnaW5hbCBkYXRhIGFycmF5IHRvIHByb3ZpZGUgYSBzdGFibGUgc29ydC5cblx0XHRcdCAqXG5cdFx0XHQgKiBOb3RlIC0gSSBrbm93IGl0IHNlZW1zIGV4Y2Vzc2l2ZSB0byBoYXZlIHR3byBzb3J0aW5nIG1ldGhvZHMsIGJ1dCB0aGUgZmlyc3QgaXMgYXJvdW5kXG5cdFx0XHQgKiAxNSUgZmFzdGVyLCBzbyB0aGUgc2Vjb25kIGlzIG9ubHkgbWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBzb3J0aW5nXG5cdFx0XHQgKiBtZXRob2RzIHdoaWNoIGRvIG5vdCBoYXZlIGEgcHJlLXNvcnQgZm9ybWF0dGluZyBmdW5jdGlvbi5cblx0XHRcdCAqL1xuXHRcdFx0aWYgKCBmb3JtYXR0ZXJzID09PSBhU29ydC5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIEFsbCBzb3J0IHR5cGVzIGhhdmUgZm9ybWF0dGluZyBmdW5jdGlvbnNcblx0XHRcdFx0ZGlzcGxheU1hc3Rlci5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHR4LCB5LCBrLCB0ZXN0LCBzb3J0LFxuXHRcdFx0XHRcdFx0bGVuPWFTb3J0Lmxlbmd0aCxcblx0XHRcdFx0XHRcdGRhdGFBID0gYW9EYXRhW2FdLl9hU29ydERhdGEsXG5cdFx0XHRcdFx0XHRkYXRhQiA9IGFvRGF0YVtiXS5fYVNvcnREYXRhO1xuXHRcblx0XHRcdFx0XHRmb3IgKCBrPTAgOyBrPGxlbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdHNvcnQgPSBhU29ydFtrXTtcblx0XG5cdFx0XHRcdFx0XHR4ID0gZGF0YUFbIHNvcnQuY29sIF07XG5cdFx0XHRcdFx0XHR5ID0gZGF0YUJbIHNvcnQuY29sIF07XG5cdFxuXHRcdFx0XHRcdFx0dGVzdCA9IHg8eSA/IC0xIDogeD55ID8gMSA6IDA7XG5cdFx0XHRcdFx0XHRpZiAoIHRlc3QgIT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzb3J0LmRpciA9PT0gJ2FzYycgPyB0ZXN0IDogLXRlc3Q7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHR4ID0gYWlPcmlnW2FdO1xuXHRcdFx0XHRcdHkgPSBhaU9yaWdbYl07XG5cdFx0XHRcdFx0cmV0dXJuIHg8eSA/IC0xIDogeD55ID8gMSA6IDA7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBEZXByZWNpYXRlZCAtIHJlbW92ZSBpbiAxLjExIChwcm92aWRpbmcgYSBwbHVnLWluIG9wdGlvbilcblx0XHRcdFx0Ly8gTm90IGFsbCBzb3J0IHR5cGVzIGhhdmUgZm9ybWF0dGluZyBtZXRob2RzLCBzbyB3ZSBoYXZlIHRvIGNhbGwgdGhlaXIgc29ydGluZ1xuXHRcdFx0XHQvLyBtZXRob2RzLlxuXHRcdFx0XHRkaXNwbGF5TWFzdGVyLnNvcnQoIGZ1bmN0aW9uICggYSwgYiApIHtcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdHgsIHksIGssIGwsIHRlc3QsIHNvcnQsIGZuLFxuXHRcdFx0XHRcdFx0bGVuPWFTb3J0Lmxlbmd0aCxcblx0XHRcdFx0XHRcdGRhdGFBID0gYW9EYXRhW2FdLl9hU29ydERhdGEsXG5cdFx0XHRcdFx0XHRkYXRhQiA9IGFvRGF0YVtiXS5fYVNvcnREYXRhO1xuXHRcblx0XHRcdFx0XHRmb3IgKCBrPTAgOyBrPGxlbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdHNvcnQgPSBhU29ydFtrXTtcblx0XG5cdFx0XHRcdFx0XHR4ID0gZGF0YUFbIHNvcnQuY29sIF07XG5cdFx0XHRcdFx0XHR5ID0gZGF0YUJbIHNvcnQuY29sIF07XG5cdFxuXHRcdFx0XHRcdFx0Zm4gPSBvRXh0U29ydFsgc29ydC50eXBlK1wiLVwiK3NvcnQuZGlyIF0gfHwgb0V4dFNvcnRbIFwic3RyaW5nLVwiK3NvcnQuZGlyIF07XG5cdFx0XHRcdFx0XHR0ZXN0ID0gZm4oIHgsIHkgKTtcblx0XHRcdFx0XHRcdGlmICggdGVzdCAhPT0gMCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRlc3Q7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHR4ID0gYWlPcmlnW2FdO1xuXHRcdFx0XHRcdHkgPSBhaU9yaWdbYl07XG5cdFx0XHRcdFx0cmV0dXJuIHg8eSA/IC0xIDogeD55ID8gMSA6IDA7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8qIFRlbGwgdGhlIGRyYXcgZnVuY3Rpb24gdGhhdCB3ZSBoYXZlIHNvcnRlZCB0aGUgZGF0YSAqL1xuXHRcdG9TZXR0aW5ncy5iU29ydGVkID0gdHJ1ZTtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIF9mblNvcnRBcmlhICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGxhYmVsO1xuXHRcdHZhciBuZXh0U29ydDtcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0XHR2YXIgYVNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggc2V0dGluZ3MgKTtcblx0XHR2YXIgb0FyaWEgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub0FyaWE7XG5cdFxuXHRcdC8vIEFSSUEgYXR0cmlidXRlcyAtIG5lZWQgdG8gbG9vcCBhbGwgY29sdW1ucywgdG8gdXBkYXRlIGFsbCAocmVtb3Zpbmcgb2xkXG5cdFx0Ly8gYXR0cmlidXRlcyBhcyBuZWVkZWQpXG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1jb2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0dmFyIGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHR2YXIgYXNTb3J0aW5nID0gY29sLmFzU29ydGluZztcblx0XHRcdHZhciBzVGl0bGUgPSBjb2wuc1RpdGxlLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICk7XG5cdFx0XHR2YXIgdGggPSBjb2wublRoO1xuXHRcblx0XHRcdC8vIElFNyBpcyB0aHJvd2luZyBhbiBlcnJvciB3aGVuIHNldHRpbmcgdGhlc2UgcHJvcGVydGllcyB3aXRoIGpRdWVyeSdzXG5cdFx0XHQvLyBhdHRyKCkgYW5kIHJlbW92ZUF0dHIoKSBtZXRob2RzLi4uXG5cdFx0XHR0aC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtc29ydCcpO1xuXHRcblx0XHRcdC8qIEluIEFSSUEgb25seSB0aGUgZmlyc3Qgc29ydGluZyBjb2x1bW4gY2FuIGJlIG1hcmtlZCBhcyBzb3J0aW5nIC0gbm8gbXVsdGktc29ydCBvcHRpb24gKi9cblx0XHRcdGlmICggY29sLmJTb3J0YWJsZSApIHtcblx0XHRcdFx0aWYgKCBhU29ydC5sZW5ndGggPiAwICYmIGFTb3J0WzBdLmNvbCA9PSBpICkge1xuXHRcdFx0XHRcdHRoLnNldEF0dHJpYnV0ZSgnYXJpYS1zb3J0JywgYVNvcnRbMF0uZGlyPT1cImFzY1wiID8gXCJhc2NlbmRpbmdcIiA6IFwiZGVzY2VuZGluZ1wiICk7XG5cdFx0XHRcdFx0bmV4dFNvcnQgPSBhc1NvcnRpbmdbIGFTb3J0WzBdLmluZGV4KzEgXSB8fCBhc1NvcnRpbmdbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bmV4dFNvcnQgPSBhc1NvcnRpbmdbMF07XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGxhYmVsID0gc1RpdGxlICsgKCBuZXh0U29ydCA9PT0gXCJhc2NcIiA/XG5cdFx0XHRcdFx0b0FyaWEuc1NvcnRBc2NlbmRpbmcgOlxuXHRcdFx0XHRcdG9BcmlhLnNTb3J0RGVzY2VuZGluZ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxhYmVsID0gc1RpdGxlO1xuXHRcdFx0fVxuXHRcblx0XHRcdHRoLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRnVuY3Rpb24gdG8gcnVuIG9uIHVzZXIgc29ydCByZXF1ZXN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7bm9kZX0gYXR0YWNoVG8gbm9kZSB0byBhdHRhY2ggdGhlIGhhbmRsZXIgdG9cblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIHNvcnRpbmcgaW5kZXhcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW2FwcGVuZD1mYWxzZV0gQXBwZW5kIHRoZSByZXF1ZXN0ZWQgc29ydCB0byB0aGUgZXhpc3Rpbmdcblx0ICogICAgc29ydCBpZiB0cnVlIChpLmUuIG11bHRpLWNvbHVtbiBzb3J0KVxuXHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Tb3J0TGlzdGVuZXIgKCBzZXR0aW5ncywgY29sSWR4LCBhcHBlbmQsIGNhbGxiYWNrIClcblx0e1xuXHRcdHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbIGNvbElkeCBdO1xuXHRcdHZhciBzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nO1xuXHRcdHZhciBhc1NvcnRpbmcgPSBjb2wuYXNTb3J0aW5nO1xuXHRcdHZhciBuZXh0U29ydElkeDtcblx0XHR2YXIgbmV4dCA9IGZ1bmN0aW9uICggYSwgb3ZlcmZsb3cgKSB7XG5cdFx0XHR2YXIgaWR4ID0gYS5faWR4O1xuXHRcdFx0aWYgKCBpZHggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aWR4ID0gJC5pbkFycmF5KCBhWzFdLCBhc1NvcnRpbmcgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gaWR4KzEgPCBhc1NvcnRpbmcubGVuZ3RoID9cblx0XHRcdFx0aWR4KzEgOlxuXHRcdFx0XHRvdmVyZmxvdyA/XG5cdFx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdFx0MDtcblx0XHR9O1xuXHRcblx0XHQvLyBDb252ZXJ0IHRvIDJEIGFycmF5IGlmIG5lZWRlZFxuXHRcdGlmICggdHlwZW9mIHNvcnRpbmdbMF0gPT09ICdudW1iZXInICkge1xuXHRcdFx0c29ydGluZyA9IHNldHRpbmdzLmFhU29ydGluZyA9IFsgc29ydGluZyBdO1xuXHRcdH1cblx0XG5cdFx0Ly8gSWYgYXBwZW5kaW5nIHRoZSBzb3J0IHRoZW4gd2UgYXJlIG11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdFx0aWYgKCBhcHBlbmQgJiYgc2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0TXVsdGkgKSB7XG5cdFx0XHQvLyBBcmUgd2UgYWxyZWFkeSBkb2luZyBzb21lIGtpbmQgb2Ygc29ydCBvbiB0aGlzIGNvbHVtbj9cblx0XHRcdHZhciBzb3J0SWR4ID0gJC5pbkFycmF5KCBjb2xJZHgsIF9wbHVjayhzb3J0aW5nLCAnMCcpICk7XG5cdFxuXHRcdFx0aWYgKCBzb3J0SWR4ICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gWWVzLCBtb2RpZnkgdGhlIHNvcnRcblx0XHRcdFx0bmV4dFNvcnRJZHggPSBuZXh0KCBzb3J0aW5nW3NvcnRJZHhdLCB0cnVlICk7XG5cdFxuXHRcdFx0XHRpZiAoIG5leHRTb3J0SWR4ID09PSBudWxsICYmIHNvcnRpbmcubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdG5leHRTb3J0SWR4ID0gMDsgLy8gY2FuJ3QgcmVtb3ZlIHNvcnRpbmcgY29tcGxldGVseVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRpZiAoIG5leHRTb3J0SWR4ID09PSBudWxsICkge1xuXHRcdFx0XHRcdHNvcnRpbmcuc3BsaWNlKCBzb3J0SWR4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c29ydGluZ1tzb3J0SWR4XVsxXSA9IGFzU29ydGluZ1sgbmV4dFNvcnRJZHggXTtcblx0XHRcdFx0XHRzb3J0aW5nW3NvcnRJZHhdLl9pZHggPSBuZXh0U29ydElkeDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE5vIHNvcnQgb24gdGhpcyBjb2x1bW4geWV0XG5cdFx0XHRcdHNvcnRpbmcucHVzaCggWyBjb2xJZHgsIGFzU29ydGluZ1swXSwgMCBdICk7XG5cdFx0XHRcdHNvcnRpbmdbc29ydGluZy5sZW5ndGgtMV0uX2lkeCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzb3J0aW5nLmxlbmd0aCAmJiBzb3J0aW5nWzBdWzBdID09IGNvbElkeCApIHtcblx0XHRcdC8vIFNpbmdsZSBjb2x1bW4gLSBhbHJlYWR5IHNvcnRpbmcgb24gdGhpcyBjb2x1bW4sIG1vZGlmeSB0aGUgc29ydFxuXHRcdFx0bmV4dFNvcnRJZHggPSBuZXh0KCBzb3J0aW5nWzBdICk7XG5cdFxuXHRcdFx0c29ydGluZy5sZW5ndGggPSAxO1xuXHRcdFx0c29ydGluZ1swXVsxXSA9IGFzU29ydGluZ1sgbmV4dFNvcnRJZHggXTtcblx0XHRcdHNvcnRpbmdbMF0uX2lkeCA9IG5leHRTb3J0SWR4O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFNpbmdsZSBjb2x1bW4gLSBzb3J0IG9ubHkgb24gdGhpcyBjb2x1bW5cblx0XHRcdHNvcnRpbmcubGVuZ3RoID0gMDtcblx0XHRcdHNvcnRpbmcucHVzaCggWyBjb2xJZHgsIGFzU29ydGluZ1swXSBdICk7XG5cdFx0XHRzb3J0aW5nWzBdLl9pZHggPSAwO1xuXHRcdH1cblx0XG5cdFx0Ly8gUnVuIHRoZSBzb3J0IGJ5IGNhbGxpbmcgYSBmdWxsIHJlZHJhd1xuXHRcdF9mblJlRHJhdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0Ly8gY2FsbGJhY2sgdXNlZCBmb3IgYXN5bmMgdXNlciBpbnRlcmFjdGlvblxuXHRcdGlmICggdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRjYWxsYmFjayggc2V0dGluZ3MgKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXR0YWNoIGEgc29ydCBoYW5kbGVyIChjbGljaykgdG8gYSBub2RlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7bm9kZX0gYXR0YWNoVG8gbm9kZSB0byBhdHRhY2ggdGhlIGhhbmRsZXIgdG9cblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIHNvcnRpbmcgaW5kZXhcblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU29ydEF0dGFjaExpc3RlbmVyICggc2V0dGluZ3MsIGF0dGFjaFRvLCBjb2xJZHgsIGNhbGxiYWNrIClcblx0e1xuXHRcdHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbIGNvbElkeCBdO1xuXHRcblx0XHRfZm5CaW5kQWN0aW9uKCBhdHRhY2hUbywge30sIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHQvKiBJZiB0aGUgY29sdW1uIGlzIG5vdCBzb3J0YWJsZSAtIGRvbid0IHRvIGFueXRoaW5nICovXG5cdFx0XHRpZiAoIGNvbC5iU29ydGFibGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSWYgcHJvY2Vzc2luZyBpcyBlbmFibGVkIHVzZSBhIHRpbWVvdXQgdG8gYWxsb3cgdGhlIHByb2Nlc3Npbmdcblx0XHRcdC8vIGRpc3BsYXkgdG8gYmUgc2hvd24gLSBvdGhlcndpc2UgdG8gaXQgc3luY2hyb25vdXNseVxuXHRcdFx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlByb2Nlc3NpbmcgKSB7XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgdHJ1ZSApO1xuXHRcblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0X2ZuU29ydExpc3RlbmVyKCBzZXR0aW5ncywgY29sSWR4LCBlLnNoaWZ0S2V5LCBjYWxsYmFjayApO1xuXHRcblx0XHRcdFx0XHQvLyBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLCB0aGUgZHJhdyBjYWxsYmFjayB3aWxsIHJlbW92ZSB0aGVcblx0XHRcdFx0XHQvLyBwcm9jZXNzaW5nIGRpc3BsYXlcblx0XHRcdFx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgIT09ICdzc3AnICkge1xuXHRcdFx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgMCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdF9mblNvcnRMaXN0ZW5lciggc2V0dGluZ3MsIGNvbElkeCwgZS5zaGlmdEtleSwgY2FsbGJhY2sgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogU2V0IHRoZSBzb3J0aW5nIGNsYXNzZXMgb24gdGFibGUncyBib2R5LCBOb3RlOiBpdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBmdW5jdGlvblxuXHQgKiB3aGVuIGJTb3J0IGFuZCBiU29ydENsYXNzZXMgYXJlIGZhbHNlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNvcnRpbmdDbGFzc2VzKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgb2xkU29ydCA9IHNldHRpbmdzLmFMYXN0U29ydDtcblx0XHR2YXIgc29ydENsYXNzID0gc2V0dGluZ3Mub0NsYXNzZXMuc1NvcnRDb2x1bW47XG5cdFx0dmFyIHNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggc2V0dGluZ3MgKTtcblx0XHR2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXM7XG5cdFx0dmFyIGksIGllbiwgY29sSWR4O1xuXHRcblx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0ICYmIGZlYXR1cmVzLmJTb3J0Q2xhc3NlcyApIHtcblx0XHRcdC8vIFJlbW92ZSBvbGQgc29ydGluZyBjbGFzc2VzXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1vbGRTb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2xJZHggPSBvbGRTb3J0W2ldLnNyYztcblx0XG5cdFx0XHRcdC8vIFJlbW92ZSBjb2x1bW4gc29ydGluZ1xuXHRcdFx0XHQkKCBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ2FuQ2VsbHMnLCBjb2xJZHggKSApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBzb3J0Q2xhc3MgKyAoaTwyID8gaSsxIDogMykgKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBBZGQgbmV3IGNvbHVtbiBzb3J0aW5nXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1zb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2xJZHggPSBzb3J0W2ldLnNyYztcblx0XG5cdFx0XHRcdCQoIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbElkeCApIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIHNvcnRDbGFzcyArIChpPDIgPyBpKzEgOiAzKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0c2V0dGluZ3MuYUxhc3RTb3J0ID0gc29ydDtcblx0fVxuXHRcblx0XG5cdC8vIEdldCB0aGUgZGF0YSB0byBzb3J0IGEgY29sdW1uLCBiZSBpdCBmcm9tIGNhY2hlLCBmcmVzaCAocG9wdWxhdGluZyB0aGVcblx0Ly8gY2FjaGUpLCBvciBmcm9tIGEgc29ydCBmb3JtYXR0ZXJcblx0ZnVuY3Rpb24gX2ZuU29ydERhdGEoIHNldHRpbmdzLCBpZHggKVxuXHR7XG5cdFx0Ly8gQ3VzdG9tIHNvcnRpbmcgZnVuY3Rpb24gLSBwcm92aWRlZCBieSB0aGUgc29ydCBkYXRhIHR5cGVcblx0XHR2YXIgY29sdW1uID0gc2V0dGluZ3MuYW9Db2x1bW5zWyBpZHggXTtcblx0XHR2YXIgY3VzdG9tU29ydCA9IERhdGFUYWJsZS5leHQub3JkZXJbIGNvbHVtbi5zU29ydERhdGFUeXBlIF07XG5cdFx0dmFyIGN1c3RvbURhdGE7XG5cdFxuXHRcdGlmICggY3VzdG9tU29ydCApIHtcblx0XHRcdGN1c3RvbURhdGEgPSBjdXN0b21Tb3J0LmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIGlkeCxcblx0XHRcdFx0X2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoIHNldHRpbmdzLCBpZHggKVxuXHRcdFx0KTtcblx0XHR9XG5cdFxuXHRcdC8vIFVzZSAvIHBvcHVsYXRlIGNhY2hlXG5cdFx0dmFyIHJvdywgY2VsbERhdGE7XG5cdFx0dmFyIGZvcm1hdHRlciA9IERhdGFUYWJsZS5leHQudHlwZS5vcmRlclsgY29sdW1uLnNUeXBlK1wiLXByZVwiIF07XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRyb3cgPSBzZXR0aW5ncy5hb0RhdGFbaV07XG5cdFxuXHRcdFx0aWYgKCAhIHJvdy5fYVNvcnREYXRhICkge1xuXHRcdFx0XHRyb3cuX2FTb3J0RGF0YSA9IFtdO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggISByb3cuX2FTb3J0RGF0YVtpZHhdIHx8IGN1c3RvbVNvcnQgKSB7XG5cdFx0XHRcdGNlbGxEYXRhID0gY3VzdG9tU29ydCA/XG5cdFx0XHRcdFx0Y3VzdG9tRGF0YVtpXSA6IC8vIElmIHRoZXJlIHdhcyBhIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLCB1c2UgZGF0YSBmcm9tIHRoZXJlXG5cdFx0XHRcdFx0X2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBpZHgsICdzb3J0JyApO1xuXHRcblx0XHRcdFx0cm93Ll9hU29ydERhdGFbIGlkeCBdID0gZm9ybWF0dGVyID9cblx0XHRcdFx0XHRmb3JtYXR0ZXIoIGNlbGxEYXRhICkgOlxuXHRcdFx0XHRcdGNlbGxEYXRhO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdFxuXHQvKipcblx0ICogU2F2ZSB0aGUgc3RhdGUgb2YgYSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TYXZlU3RhdGUgKCBzZXR0aW5ncyApXG5cdHtcblx0XHRpZiAoICFzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSB8fCBzZXR0aW5ncy5iRGVzdHJveWluZyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0LyogU3RvcmUgdGhlIGludGVyZXN0aW5nIHZhcmlhYmxlcyAqL1xuXHRcdHZhciBzdGF0ZSA9IHtcblx0XHRcdHRpbWU6ICAgICtuZXcgRGF0ZSgpLFxuXHRcdFx0c3RhcnQ6ICAgc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRsZW5ndGg6ICBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHRvcmRlcjogICAkLmV4dGVuZCggdHJ1ZSwgW10sIHNldHRpbmdzLmFhU29ydGluZyApLFxuXHRcdFx0c2VhcmNoOiAgX2ZuU2VhcmNoVG9DYW1lbCggc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoICksXG5cdFx0XHRjb2x1bW5zOiAkLm1hcCggc2V0dGluZ3MuYW9Db2x1bW5zLCBmdW5jdGlvbiAoIGNvbCwgaSApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR2aXNpYmxlOiBjb2wuYlZpc2libGUsXG5cdFx0XHRcdFx0c2VhcmNoOiBfZm5TZWFyY2hUb0NhbWVsKCBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHNbaV0gKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSApXG5cdFx0fTtcblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgXCJhb1N0YXRlU2F2ZVBhcmFtc1wiLCAnc3RhdGVTYXZlUGFyYW1zJywgW3NldHRpbmdzLCBzdGF0ZV0gKTtcblx0XG5cdFx0c2V0dGluZ3Mub1NhdmVkU3RhdGUgPSBzdGF0ZTtcblx0XHRzZXR0aW5ncy5mblN0YXRlU2F2ZUNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHN0YXRlICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBsb2FkIGEgc2F2ZWQgdGFibGUgc3RhdGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvSW5pdCBEYXRhVGFibGVzIGluaXQgb2JqZWN0IHNvIHdlIGNhbiBvdmVycmlkZSBzZXR0aW5nc1xuXHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBzdGF0ZSBoYXMgYmVlbiBsb2FkZWRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTG9hZFN0YXRlICggc2V0dGluZ3MsIG9Jbml0LCBjYWxsYmFjayApXG5cdHtcblx0XHR2YXIgaSwgaWVuO1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcdHZhciBsb2FkZWQgPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0XHRpZiAoICEgcyB8fCAhIHMudGltZSApIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFsbG93IGN1c3RvbSBhbmQgcGx1Zy1pbiBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIHRvIGFsdGVyIHRoZSBzYXZlZCBkYXRhIHNldCBhbmRcblx0XHRcdC8vIGNhbmNlbGxpbmcgb2YgbG9hZGluZyBieSByZXR1cm5pbmcgZmFsc2Vcblx0XHRcdHZhciBhYlN0YXRlTG9hZCA9IF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsICdzdGF0ZUxvYWRQYXJhbXMnLCBbc2V0dGluZ3MsIHNdICk7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggZmFsc2UsIGFiU3RhdGVMb2FkICkgIT09IC0xICkge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gUmVqZWN0IG9sZCBkYXRhXG5cdFx0XHR2YXIgZHVyYXRpb24gPSBzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbjtcblx0XHRcdGlmICggZHVyYXRpb24gPiAwICYmIHMudGltZSA8ICtuZXcgRGF0ZSgpIC0gKGR1cmF0aW9uKjEwMDApICkge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gTnVtYmVyIG9mIGNvbHVtbnMgaGF2ZSBjaGFuZ2VkIC0gYWxsIGJldHMgYXJlIG9mZiwgbm8gcmVzdG9yZSBvZiBzZXR0aW5nc1xuXHRcdFx0aWYgKCBzLmNvbHVtbnMgJiYgY29sdW1ucy5sZW5ndGggIT09IHMuY29sdW1ucy5sZW5ndGggKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTdG9yZSB0aGUgc2F2ZWQgc3RhdGUgc28gaXQgbWlnaHQgYmUgYWNjZXNzZWQgYXQgYW55IHRpbWVcblx0XHRcdHNldHRpbmdzLm9Mb2FkZWRTdGF0ZSA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgcyApO1xuXHRcblx0XHRcdC8vIFJlc3RvcmUga2V5IGZlYXR1cmVzIC0gdG9kbyAtIGZvciAxLjExIHRoaXMgbmVlZHMgdG8gYmUgZG9uZSBieVxuXHRcdFx0Ly8gc3Vic2NyaWJlZCBldmVudHNcblx0XHRcdGlmICggcy5zdGFydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCAgICA9IHMuc3RhcnQ7XG5cdFx0XHRcdHNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gcy5zdGFydDtcblx0XHRcdH1cblx0XHRcdGlmICggcy5sZW5ndGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoICAgPSBzLmxlbmd0aDtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBPcmRlclxuXHRcdFx0aWYgKCBzLm9yZGVyICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdFx0XHQkLmVhY2goIHMub3JkZXIsIGZ1bmN0aW9uICggaSwgY29sICkge1xuXHRcdFx0XHRcdHNldHRpbmdzLmFhU29ydGluZy5wdXNoKCBjb2xbMF0gPj0gY29sdW1ucy5sZW5ndGggP1xuXHRcdFx0XHRcdFx0WyAwLCBjb2xbMV0gXSA6XG5cdFx0XHRcdFx0XHRjb2xcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VhcmNoXG5cdFx0XHRpZiAoIHMuc2VhcmNoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIF9mblNlYXJjaFRvSHVuZyggcy5zZWFyY2ggKSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIENvbHVtbnNcblx0XHRcdC8vXG5cdFx0XHRpZiAoIHMuY29sdW1ucyApIHtcblx0XHRcdFx0Zm9yICggaT0wLCBpZW49cy5jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdHZhciBjb2wgPSBzLmNvbHVtbnNbaV07XG5cdFxuXHRcdFx0XHRcdC8vIFZpc2liaWxpdHlcblx0XHRcdFx0XHRpZiAoIGNvbC52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRjb2x1bW5zW2ldLmJWaXNpYmxlID0gY29sLnZpc2libGU7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBTZWFyY2hcblx0XHRcdFx0XHRpZiAoIGNvbC5zZWFyY2ggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHNbaV0sIF9mblNlYXJjaFRvSHVuZyggY29sLnNlYXJjaCApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvU3RhdGVMb2FkZWQnLCAnc3RhdGVMb2FkZWQnLCBbc2V0dGluZ3MsIHNdICk7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlICkge1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhciBzdGF0ZSA9IHNldHRpbmdzLmZuU3RhdGVMb2FkQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgbG9hZGVkICk7XG5cdFxuXHRcdGlmICggc3RhdGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGxvYWRlZCggc3RhdGUgKTtcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlLCB3YWl0IGZvciB0aGUgbG9hZGVkIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBzZXR0aW5ncyBvYmplY3QgZm9yIGEgcGFydGljdWxhciB0YWJsZVxuXHQgKiAgQHBhcmFtIHtub2RlfSB0YWJsZSB0YWJsZSB3ZSBhcmUgdXNpbmcgYXMgYSBkYXRhVGFibGVcblx0ICogIEByZXR1cm5zIHtvYmplY3R9IFNldHRpbmdzIG9iamVjdCAtIG9yIG51bGwgaWYgbm90IGZvdW5kXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNldHRpbmdzRnJvbU5vZGUgKCB0YWJsZSApXG5cdHtcblx0XHR2YXIgc2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdFx0dmFyIGlkeCA9ICQuaW5BcnJheSggdGFibGUsIF9wbHVjayggc2V0dGluZ3MsICduVGFibGUnICkgKTtcblx0XG5cdFx0cmV0dXJuIGlkeCAhPT0gLTEgP1xuXHRcdFx0c2V0dGluZ3NbIGlkeCBdIDpcblx0XHRcdG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogTG9nIGFuIGVycm9yIG1lc3NhZ2Vcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGxldmVsIGxvZyBlcnJvciBtZXNzYWdlcywgb3IgZGlzcGxheSB0aGVtIHRvIHRoZSB1c2VyXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gbXNnIGVycm9yIG1lc3NhZ2Vcblx0ICogIEBwYXJhbSB7aW50fSB0biBUZWNobmljYWwgbm90ZSBpZCB0byBnZXQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3IuXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkxvZyggc2V0dGluZ3MsIGxldmVsLCBtc2csIHRuIClcblx0e1xuXHRcdG1zZyA9ICdEYXRhVGFibGVzIHdhcm5pbmc6ICcrXG5cdFx0XHQoc2V0dGluZ3MgPyAndGFibGUgaWQ9JytzZXR0aW5ncy5zVGFibGVJZCsnIC0gJyA6ICcnKSttc2c7XG5cdFxuXHRcdGlmICggdG4gKSB7XG5cdFx0XHRtc2cgKz0gJy4gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBlcnJvciwgcGxlYXNlIHNlZSAnK1xuXHRcdFx0J2h0dHA6Ly9kYXRhdGFibGVzLm5ldC90bi8nK3RuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAhIGxldmVsICApIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHByZSAxLjEwXG5cdFx0XHR2YXIgZXh0ID0gRGF0YVRhYmxlLmV4dDtcblx0XHRcdHZhciB0eXBlID0gZXh0LnNFcnJNb2RlIHx8IGV4dC5lcnJNb2RlO1xuXHRcblx0XHRcdGlmICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdlcnJvcicsIFsgc2V0dGluZ3MsIHRuLCBtc2cgXSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggdHlwZSA9PSAnYWxlcnQnICkge1xuXHRcdFx0XHRhbGVydCggbXNnICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PSAndGhyb3cnICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHR0eXBlKCBzZXR0aW5ncywgdG4sIG1zZyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5sb2cgKSB7XG5cdFx0XHRjb25zb2xlLmxvZyggbXNnICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNlZSBpZiBhIHByb3BlcnR5IGlzIGRlZmluZWQgb24gb25lIG9iamVjdCwgaWYgc28gYXNzaWduIGl0IHRvIHRoZSBvdGhlciBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSByZXQgdGFyZ2V0IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBzb3VyY2Ugb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gbmFtZSBwcm9wZXJ0eVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IFttYXBwZWROYW1lXSBuYW1lIHRvIG1hcCB0b28gLSBvcHRpb25hbCwgbmFtZSB1c2VkIGlmIG5vdCBnaXZlblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5NYXAoIHJldCwgc3JjLCBuYW1lLCBtYXBwZWROYW1lIClcblx0e1xuXHRcdGlmICggJC5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHQkLmVhY2goIG5hbWUsIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0aWYgKCAkLmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRcdF9mbk1hcCggcmV0LCBzcmMsIHZhbFswXSwgdmFsWzFdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0X2ZuTWFwKCByZXQsIHNyYywgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHRpZiAoIG1hcHBlZE5hbWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG1hcHBlZE5hbWUgPSBuYW1lO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBzcmNbbmFtZV0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldFttYXBwZWROYW1lXSA9IHNyY1tuYW1lXTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRXh0ZW5kIG9iamVjdHMgLSB2ZXJ5IHNpbWlsYXIgdG8galF1ZXJ5LmV4dGVuZCwgYnV0IGRlZXAgY29weSBvYmplY3RzLCBhbmRcblx0ICogc2hhbGxvdyBjb3B5IGFycmF5cy4gVGhlIHJlYXNvbiB3ZSBuZWVkIHRvIGRvIHRoaXMsIGlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0b1xuXHQgKiBkZWVwIGNvcHkgYXJyYXkgaW5pdCB2YWx1ZXMgKHN1Y2ggYXMgYWFTb3J0aW5nKSBzaW5jZSB0aGUgZGV2IHdvdWxkbid0IGJlXG5cdCAqIGFibGUgdG8gb3ZlcnJpZGUgdGhlbSwgYnV0IHdlIGRvIHdhbnQgdG8gZGVlcCBjb3B5IGFycmF5cy5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvdXQgT2JqZWN0IHRvIGV4dGVuZFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGV4dGVuZGVyIE9iamVjdCBmcm9tIHdoaWNoIHRoZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYXBwbGllZCB0b1xuXHQgKiAgICAgIG91dFxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBicmVha1JlZnMgSWYgdHJ1ZSwgdGhlbiBhcnJheXMgd2lsbCBiZSBzbGljZWQgdG8gdGFrZSBhblxuXHQgKiAgICAgIGluZGVwZW5kZW50IGNvcHkgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSBgZGF0YWAgb3IgYGFhRGF0YWAgcGFyYW1ldGVyc1xuXHQgKiAgICAgIGlmIHRoZXkgYXJlIHByZXNlbnQuIFRoaXMgaXMgc28geW91IGNhbiBwYXNzIGluIGEgY29sbGVjdGlvbiB0b1xuXHQgKiAgICAgIERhdGFUYWJsZXMgYW5kIGhhdmUgdGhhdCB1c2VkIGFzIHlvdXIgZGF0YSBzb3VyY2Ugd2l0aG91dCBicmVha2luZyB0aGVcblx0ICogICAgICByZWZlcmVuY2VzXG5cdCAqICBAcmV0dXJucyB7b2JqZWN0fSBvdXQgUmVmZXJlbmNlLCBqdXN0IGZvciBjb252ZW5pZW5jZSAtIG91dCA9PT0gdGhlIHJldHVybi5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKiAgQHRvZG8gVGhpcyBkb2Vzbid0IHRha2UgYWNjb3VudCBvZiBhcnJheXMgaW5zaWRlIHRoZSBkZWVwIGNvcGllZCBvYmplY3RzLlxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRXh0ZW5kKCBvdXQsIGV4dGVuZGVyLCBicmVha1JlZnMgKVxuXHR7XG5cdFx0dmFyIHZhbDtcblx0XG5cdFx0Zm9yICggdmFyIHByb3AgaW4gZXh0ZW5kZXIgKSB7XG5cdFx0XHRpZiAoIGV4dGVuZGVyLmhhc093blByb3BlcnR5KHByb3ApICkge1xuXHRcdFx0XHR2YWwgPSBleHRlbmRlcltwcm9wXTtcblx0XG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWwgKSApIHtcblx0XHRcdFx0XHRpZiAoICEgJC5pc1BsYWluT2JqZWN0KCBvdXRbcHJvcF0gKSApIHtcblx0XHRcdFx0XHRcdG91dFtwcm9wXSA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkLmV4dGVuZCggdHJ1ZSwgb3V0W3Byb3BdLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggYnJlYWtSZWZzICYmIHByb3AgIT09ICdkYXRhJyAmJiBwcm9wICE9PSAnYWFEYXRhJyAmJiAkLmlzQXJyYXkodmFsKSApIHtcblx0XHRcdFx0XHRvdXRbcHJvcF0gPSB2YWwuc2xpY2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvdXRbcHJvcF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQmluZCBhbiBldmVudCBoYW5kZXJzIHRvIGFsbG93IGEgY2xpY2sgb3IgcmV0dXJuIGtleSB0byBhY3RpdmF0ZSB0aGUgY2FsbGJhY2suXG5cdCAqIFRoaXMgaXMgZ29vZCBmb3IgYWNjZXNzaWJpbGl0eSBzaW5jZSBhIHJldHVybiBvbiB0aGUga2V5Ym9hcmQgd2lsbCBoYXZlIHRoZVxuXHQgKiBzYW1lIGVmZmVjdCBhcyBhIGNsaWNrLCBpZiB0aGUgZWxlbWVudCBoYXMgZm9jdXMuXG5cdCAqICBAcGFyYW0ge2VsZW1lbnR9IG4gRWxlbWVudCB0byBiaW5kIHRoZSBhY3Rpb24gdG9cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvRGF0YSBEYXRhIG9iamVjdCB0byBwYXNzIHRvIHRoZSB0cmlnZ2VyZWQgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQmluZEFjdGlvbiggbiwgb0RhdGEsIGZuIClcblx0e1xuXHRcdCQobilcblx0XHRcdC5vbiggJ2NsaWNrLkRUJywgb0RhdGEsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0bi5ibHVyKCk7IC8vIFJlbW92ZSBmb2N1cyBvdXRsaW5lIGZvciBtb3VzZSB1c2Vyc1xuXHRcdFx0XHRcdGZuKGUpO1xuXHRcdFx0XHR9IClcblx0XHRcdC5vbiggJ2tleXByZXNzLkRUJywgb0RhdGEsIGZ1bmN0aW9uIChlKXtcblx0XHRcdFx0XHRpZiAoIGUud2hpY2ggPT09IDEzICkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0Zm4oZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IClcblx0XHRcdC5vbiggJ3NlbGVjdHN0YXJ0LkRUJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8qIFRha2UgdGhlIGJydXRhbCBhcHByb2FjaCB0byBjYW5jZWxsaW5nIHRleHQgc2VsZWN0aW9uICovXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9ICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbi4gRWFzaWx5IGFsbG93cyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIHRvXG5cdCAqIGFuIGFycmF5IHN0b3JlIG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IGNhbiB0aGVuIGFsbCBiZSBjYWxsZWQgdG9nZXRoZXIuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc1N0b3JlIE5hbWUgb2YgdGhlIGFycmF5IHN0b3JhZ2UgZm9yIHRoZSBjYWxsYmFja3MgaW4gb1NldHRpbmdzXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYmFja1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNOYW1lIElkZW50aWZ5aW5nIG5hbWUgZm9yIHRoZSBjYWxsYmFjayAoaS5lLiBhIGxhYmVsKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCBzU3RvcmUsIGZuLCBzTmFtZSApXG5cdHtcblx0XHRpZiAoIGZuIClcblx0XHR7XG5cdFx0XHRvU2V0dGluZ3Nbc1N0b3JlXS5wdXNoKCB7XG5cdFx0XHRcdFwiZm5cIjogZm4sXG5cdFx0XHRcdFwic05hbWVcIjogc05hbWVcblx0XHRcdH0gKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRmlyZSBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHRyaWdnZXIgZXZlbnRzLiBOb3RlIHRoYXQgdGhlIGxvb3Agb3ZlciB0aGVcblx0ICogY2FsbGJhY2sgYXJyYXkgc3RvcmUgaXMgZG9uZSBiYWNrd2FyZHMhIEZ1cnRoZXIgbm90ZSB0aGF0IHlvdSBkbyBub3Qgd2FudCB0b1xuXHQgKiBmaXJlIG9mZiB0cmlnZ2VycyBpbiB0aW1lIHNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgKGZvciBleGFtcGxlIGNlbGwgY3JlYXRpb24pXG5cdCAqIGFzIGl0cyBzbG93LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gY2FsbGJhY2tBcnIgTmFtZSBvZiB0aGUgYXJyYXkgc3RvcmFnZSBmb3IgdGhlIGNhbGxiYWNrcyBpblxuXHQgKiAgICAgIG9TZXR0aW5nc1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIHRoZSBqUXVlcnkgY3VzdG9tIGV2ZW50IHRvIHRyaWdnZXIuIElmXG5cdCAqICAgICAgbnVsbCBubyB0cmlnZ2VyIGlzIGZpcmVkXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAvXG5cdCAqICAgICAgdHJpZ2dlclxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBjYWxsYmFja0FyciwgZXZlbnROYW1lLCBhcmdzIClcblx0e1xuXHRcdHZhciByZXQgPSBbXTtcblx0XG5cdFx0aWYgKCBjYWxsYmFja0FyciApIHtcblx0XHRcdHJldCA9ICQubWFwKCBzZXR0aW5nc1tjYWxsYmFja0Fycl0uc2xpY2UoKS5yZXZlcnNlKCksIGZ1bmN0aW9uICh2YWwsIGkpIHtcblx0XHRcdFx0cmV0dXJuIHZhbC5mbi5hcHBseSggc2V0dGluZ3Mub0luc3RhbmNlLCBhcmdzICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGV2ZW50TmFtZSAhPT0gbnVsbCApIHtcblx0XHRcdHZhciBlID0gJC5FdmVudCggZXZlbnROYW1lKycuZHQnICk7XG5cdFxuXHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLnRyaWdnZXIoIGUsIGFyZ3MgKTtcblx0XG5cdFx0XHRyZXQucHVzaCggZS5yZXN1bHQgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiByZXQ7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5MZW5ndGhPdmVyZmxvdyAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0c3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGVuZCA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuXHRcdFx0bGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoO1xuXHRcblx0XHQvKiBJZiB3ZSBoYXZlIHNwYWNlIHRvIHNob3cgZXh0cmEgcm93cyAoYmFja2luZyB1cCBmcm9tIHRoZSBlbmQgcG9pbnQgLSB0aGVuIGRvIHNvICovXG5cdFx0aWYgKCBzdGFydCA+PSBlbmQgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gZW5kIC0gbGVuO1xuXHRcdH1cblx0XG5cdFx0Ly8gS2VlcCB0aGUgc3RhcnQgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHRzdGFydCAtPSAoc3RhcnQgJSBsZW4pO1xuXHRcblx0XHRpZiAoIGxlbiA9PT0gLTEgfHwgc3RhcnQgPCAwIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuUmVuZGVyZXIoIHNldHRpbmdzLCB0eXBlIClcblx0e1xuXHRcdHZhciByZW5kZXJlciA9IHNldHRpbmdzLnJlbmRlcmVyO1xuXHRcdHZhciBob3N0ID0gRGF0YVRhYmxlLmV4dC5yZW5kZXJlclt0eXBlXTtcblx0XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHJlbmRlcmVyICkgJiYgcmVuZGVyZXJbdHlwZV0gKSB7XG5cdFx0XHQvLyBTcGVjaWZpYyByZW5kZXJlciBmb3IgdGhpcyB0eXBlLiBJZiBhdmFpbGFibGUgdXNlIGl0LCBvdGhlcndpc2UgdXNlXG5cdFx0XHQvLyB0aGUgZGVmYXVsdC5cblx0XHRcdHJldHVybiBob3N0W3JlbmRlcmVyW3R5cGVdXSB8fCBob3N0Ll87XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgcmVuZGVyZXIgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0Ly8gQ29tbW9uIHJlbmRlcmVyIC0gaWYgdGhlcmUgaXMgb25lIGF2YWlsYWJsZSBmb3IgdGhpcyB0eXBlIHVzZSBpdCxcblx0XHRcdC8vIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHRcblx0XHRcdHJldHVybiBob3N0W3JlbmRlcmVyXSB8fCBob3N0Ll87XG5cdFx0fVxuXHRcblx0XHQvLyBVc2UgdGhlIGRlZmF1bHRcblx0XHRyZXR1cm4gaG9zdC5fO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERldGVjdCB0aGUgZGF0YSBzb3VyY2UgYmVpbmcgdXNlZCBmb3IgdGhlIHRhYmxlLiBVc2VkIHRvIHNpbXBsaWZ5IHRoZSBjb2RlXG5cdCAqIGEgbGl0dGxlIChhamF4KSBhbmQgdG8gbWFrZSBpdCBjb21wcmVzcyBhIGxpdHRsZSBzbWFsbGVyLlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7c3RyaW5nfSBEYXRhIHNvdXJjZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EYXRhU291cmNlICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlNlcnZlclNpZGUgKSB7XG5cdFx0XHRyZXR1cm4gJ3NzcCc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzZXR0aW5ncy5hamF4IHx8IHNldHRpbmdzLnNBamF4U291cmNlICkge1xuXHRcdFx0cmV0dXJuICdhamF4Jztcblx0XHR9XG5cdFx0cmV0dXJuICdkb20nO1xuXHR9XG5cdFxuXG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbXB1dGVkIHN0cnVjdHVyZSBvZiB0aGUgRGF0YVRhYmxlcyBBUEksIGRlZmluZWQgYnkgdGhlIG9wdGlvbnMgcGFzc2VkIHRvXG5cdCAqIGBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyKClgIHdoZW4gYnVpbGRpbmcgdGhlIEFQSS5cblx0ICpcblx0ICogVGhlIHN0cnVjdHVyZSBpcyBidWlsdCBpbiBvcmRlciB0byBzcGVlZCBjcmVhdGlvbiBhbmQgZXh0ZW5zaW9uIG9mIHRoZSBBcGlcblx0ICogb2JqZWN0cyBzaW5jZSB0aGUgZXh0ZW5zaW9ucyBhcmUgZWZmZWN0aXZlbHkgcHJlLXBhcnNlZC5cblx0ICpcblx0ICogVGhlIGFycmF5IGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZSwgd2hlcmUgdGhpc1xuXHQgKiBiYXNlIGFycmF5IHJlcHJlc2VudHMgdGhlIEFwaSBwcm90b3R5cGUgYmFzZTpcblx0ICpcblx0ICogICAgIFtcblx0ICogICAgICAge1xuXHQgKiAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxuXHQgKiAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XG5cdCAqICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxuXHQgKiAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XG5cdCAqICAgICAgIH0sXG5cdCAqICAgICAgIHtcblx0ICogICAgICAgICBuYW1lOiAgICAgJ3Jvdydcblx0ICogICAgICAgICB2YWw6ICAgICAgIHt9LFxuXHQgKiAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcblx0ICogICAgICAgICBwcm9wRXh0OiAgIFtcblx0ICogICAgICAgICAgIHtcblx0ICogICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcblx0ICogICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcblx0ICogICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuXHQgKiAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cblx0ICogICAgICAgICAgIH0sXG5cdCAqICAgICAgICAgICAuLi5cblx0ICogICAgICAgICBdXG5cdCAqICAgICAgIH1cblx0ICogICAgIF1cblx0ICpcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHR2YXIgX19hcGlTdHJ1Y3QgPSBbXTtcblx0XG5cdFxuXHQvKipcblx0ICogYEFycmF5LnByb3RvdHlwZWAgcmVmZXJlbmNlLlxuXHQgKlxuXHQgKiBAdHlwZSBvYmplY3Rcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9fYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblx0XG5cdFxuXHQvKipcblx0ICogQWJzdHJhY3Rpb24gZm9yIGBjb250ZXh0YCBwYXJhbWV0ZXIgb2YgdGhlIGBBcGlgIGNvbnN0cnVjdG9yIHRvIGFsbG93IGl0IHRvXG5cdCAqIHRha2Ugc2V2ZXJhbCBkaWZmZXJlbnQgZm9ybXMgZm9yIGVhc2Ugb2YgdXNlLlxuXHQgKlxuXHQgKiBFYWNoIG9mIHRoZSBpbnB1dCBwYXJhbWV0ZXIgdHlwZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBEYXRhVGFibGVzIHNldHRpbmdzXG5cdCAqIG9iamVjdCB3aGVyZSBwb3NzaWJsZS5cblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfG5vZGV8alF1ZXJ5fG9iamVjdH0gbWl4ZWQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIENhbiBiZSBvbmVcblx0ICogICBvZjpcblx0ICpcblx0ICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXG5cdCAqICAgICB3aXRoIGJlIGZvdW5kIGFuZCB1c2VkLlxuXHQgKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG5cdCAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxuXHQgKiAgICogYG9iamVjdGAgLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgICogYERhdGFUYWJsZXMuQXBpYCAtIEFQSSBpbnN0YW5jZVxuXHQgKiBAcmV0dXJuIHthcnJheXxudWxsfSBNYXRjaGluZyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuIGBudWxsYCBvclxuXHQgKiAgIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIGlmIG5vIG1hdGNoaW5nIERhdGFUYWJsZSBpcyBmb3VuZC5cblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF90b1NldHRpbmdzID0gZnVuY3Rpb24gKCBtaXhlZCApXG5cdHtcblx0XHR2YXIgaWR4LCBqcTtcblx0XHR2YXIgc2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdFx0dmFyIHRhYmxlcyA9ICQubWFwKCBzZXR0aW5ncywgZnVuY3Rpb24gKGVsLCBpKSB7XG5cdFx0XHRyZXR1cm4gZWwublRhYmxlO1xuXHRcdH0gKTtcblx0XG5cdFx0aWYgKCAhIG1peGVkICkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbWl4ZWQublRhYmxlICYmIG1peGVkLm9BcGkgKSB7XG5cdFx0XHQvLyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0cmV0dXJuIFsgbWl4ZWQgXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1peGVkLm5vZGVOYW1lICYmIG1peGVkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0YWJsZScgKSB7XG5cdFx0XHQvLyBUYWJsZSBub2RlXG5cdFx0XHRpZHggPSAkLmluQXJyYXkoIG1peGVkLCB0YWJsZXMgKTtcblx0XHRcdHJldHVybiBpZHggIT09IC0xID8gWyBzZXR0aW5nc1tpZHhdIF0gOiBudWxsO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbWl4ZWQgJiYgdHlwZW9mIG1peGVkLnNldHRpbmdzID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0cmV0dXJuIG1peGVkLnNldHRpbmdzKCkudG9BcnJheSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIG1peGVkID09PSAnc3RyaW5nJyApIHtcblx0XHRcdC8vIGpRdWVyeSBzZWxlY3RvclxuXHRcdFx0anEgPSAkKG1peGVkKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1peGVkIGluc3RhbmNlb2YgJCApIHtcblx0XHRcdC8vIGpRdWVyeSBvYmplY3QgKGFsc28gRGF0YVRhYmxlcyBpbnN0YW5jZSlcblx0XHRcdGpxID0gbWl4ZWQ7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGpxICkge1xuXHRcdFx0cmV0dXJuIGpxLm1hcCggZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRpZHggPSAkLmluQXJyYXkoIHRoaXMsIHRhYmxlcyApO1xuXHRcdFx0XHRyZXR1cm4gaWR4ICE9PSAtMSA/IHNldHRpbmdzW2lkeF0gOiBudWxsO1xuXHRcdFx0fSApLnRvQXJyYXkoKTtcblx0XHR9XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgQVBJIGNsYXNzIC0gdXNlZCB0byBjb250cm9sIGFuZCBpbnRlcmZhY2Ugd2l0aCAgb25lIG9yIG1vcmVcblx0ICogRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMuXG5cdCAqXG5cdCAqIFRoZSBBUEkgY2xhc3MgaXMgaGVhdmlseSBiYXNlZCBvbiBqUXVlcnksIHByZXNlbnRpbmcgYSBjaGFpbmFibGUgaW50ZXJmYWNlXG5cdCAqIHRoYXQgeW91IGNhbiB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0YWJsZXMuIEVhY2ggaW5zdGFuY2Ugb2YgdGhlIEFQSSBjbGFzcyBoYXNcblx0ICogYSBcImNvbnRleHRcIiAtIGkuZS4gdGhlIHRhYmxlcyB0aGF0IGl0IHdpbGwgb3BlcmF0ZSBvbi4gVGhpcyBjb3VsZCBiZSBhIHNpbmdsZVxuXHQgKiB0YWJsZSwgYWxsIHRhYmxlcyBvbiBhIHBhZ2Ugb3IgYSBzdWItc2V0IHRoZXJlb2YuXG5cdCAqXG5cdCAqIEFkZGl0aW9uYWxseSB0aGUgQVBJIGlzIGRlc2lnbmVkIHRvIGFsbG93IHlvdSB0byBlYXNpbHkgd29yayB3aXRoIHRoZSBkYXRhIGluXG5cdCAqIHRoZSB0YWJsZXMsIHJldHJpZXZpbmcgYW5kIG1hbmlwdWxhdGluZyBpdCBhcyByZXF1aXJlZC4gVGhpcyBpcyBkb25lIGJ5XG5cdCAqIHByZXNlbnRpbmcgdGhlIEFQSSBjbGFzcyBhcyBhbiBhcnJheSBsaWtlIGludGVyZmFjZS4gVGhlIGNvbnRlbnRzIG9mIHRoZVxuXHQgKiBhcnJheSBkZXBlbmQgdXBvbiB0aGUgYWN0aW9ucyByZXF1ZXN0ZWQgYnkgZWFjaCBtZXRob2QgKGZvciBleGFtcGxlXG5cdCAqIGByb3dzKCkubm9kZXMoKWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygbm9kZXMsIHdoaWxlIGByb3dzKCkuZGF0YSgpYCB3aWxsXG5cdCAqIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGFycmF5cyBkZXBlbmRpbmcgdXBvbiB5b3VyIHRhYmxlJ3Ncblx0ICogY29uZmlndXJhdGlvbikuIFRoZSBBUEkgb2JqZWN0IGhhcyBhIG51bWJlciBvZiBhcnJheSBsaWtlIG1ldGhvZHMgKGBwdXNoYCxcblx0ICogYHBvcGAsIGByZXZlcnNlYCBldGMpIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyAoYGVhY2hgLCBgcGx1Y2tgLFxuXHQgKiBgdW5pcXVlYCBldGMpIHRvIGFzc2lzdCB5b3VyIHdvcmtpbmcgd2l0aCB0aGUgZGF0YSBoZWxkIGluIGEgdGFibGUuXG5cdCAqXG5cdCAqIE1vc3QgbWV0aG9kcyAodGhvc2Ugd2hpY2ggcmV0dXJuIGFuIEFwaSBpbnN0YW5jZSkgYXJlIGNoYWluYWJsZSwgd2hpY2ggbWVhbnNcblx0ICogdGhlIHJldHVybiBmcm9tIGEgbWV0aG9kIGNhbGwgYWxzbyBoYXMgYWxsIG9mIHRoZSBtZXRob2RzIGF2YWlsYWJsZSB0aGF0IHRoZVxuXHQgKiB0b3AgbGV2ZWwgb2JqZWN0IGhhZC4gRm9yIGV4YW1wbGUsIHRoZXNlIHR3byBjYWxscyBhcmUgZXF1aXZhbGVudDpcblx0ICpcblx0ICogICAgIC8vIE5vdCBjaGFpbmVkXG5cdCAqICAgICBhcGkucm93LmFkZCggey4uLn0gKTtcblx0ICogICAgIGFwaS5kcmF3KCk7XG5cdCAqXG5cdCAqICAgICAvLyBDaGFpbmVkXG5cdCAqICAgICBhcGkucm93LmFkZCggey4uLn0gKS5kcmF3KCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBEYXRhVGFibGUuQXBpXG5cdCAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fHN0cmluZ3xqUXVlcnl9IGNvbnRleHQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIFRoaXMgaXNcblx0ICogICB1c2VkIHRvIGRlZmluZSB3aGljaCBEYXRhVGFibGVzIGVuaGFuY2VkIHRhYmxlcyB0aGlzIEFQSSB3aWxsIG9wZXJhdGUgb24uXG5cdCAqICAgQ2FuIGJlIG9uZSBvZjpcblx0ICpcblx0ICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXG5cdCAqICAgICB3aXRoIGJlIGZvdW5kIGFuZCB1c2VkLlxuXHQgKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG5cdCAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxuXHQgKiAgICogYG9iamVjdGAgLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiBAcGFyYW0ge2FycmF5fSBbZGF0YV0gRGF0YSB0byBpbml0aWFsaXNlIHRoZSBBcGkgaW5zdGFuY2Ugd2l0aC5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICAvLyBEaXJlY3QgaW5pdGlhbGlzYXRpb24gZHVyaW5nIERhdGFUYWJsZXMgY29uc3RydWN0aW9uXG5cdCAqICAgdmFyIGFwaSA9ICQoJyNleGFtcGxlJykuRGF0YVRhYmxlKCk7XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gSW5pdGlhbGlzYXRpb24gdXNpbmcgYSBEYXRhVGFibGVzIGpRdWVyeSBvYmplY3Rcblx0ICogICB2YXIgYXBpID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKS5hcGkoKTtcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICAvLyBJbml0aWFsaXNhdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG5cdCAqICAgdmFyIGFwaSA9IG5ldyAkLmZuLkRhdGFUYWJsZS5BcGkoICd0YWJsZS5kYXRhVGFibGUnICk7XG5cdCAqL1xuXHRfQXBpID0gZnVuY3Rpb24gKCBjb250ZXh0LCBkYXRhIClcblx0e1xuXHRcdGlmICggISAodGhpcyBpbnN0YW5jZW9mIF9BcGkpICkge1xuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCBjb250ZXh0LCBkYXRhICk7XG5cdFx0fVxuXHRcblx0XHR2YXIgc2V0dGluZ3MgPSBbXTtcblx0XHR2YXIgY3R4U2V0dGluZ3MgPSBmdW5jdGlvbiAoIG8gKSB7XG5cdFx0XHR2YXIgYSA9IF90b1NldHRpbmdzKCBvICk7XG5cdFx0XHRpZiAoIGEgKSB7XG5cdFx0XHRcdHNldHRpbmdzID0gc2V0dGluZ3MuY29uY2F0KCBhICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0aWYgKCAkLmlzQXJyYXkoIGNvbnRleHQgKSApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1jb250ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjdHhTZXR0aW5ncyggY29udGV4dFtpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGN0eFNldHRpbmdzKCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcblx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdHRoaXMuY29udGV4dCA9IF91bmlxdWUoIHNldHRpbmdzICk7XG5cdFxuXHRcdC8vIEluaXRpYWwgZGF0YVxuXHRcdGlmICggZGF0YSApIHtcblx0XHRcdCQubWVyZ2UoIHRoaXMsIGRhdGEgKTtcblx0XHR9XG5cdFxuXHRcdC8vIHNlbGVjdG9yXG5cdFx0dGhpcy5zZWxlY3RvciA9IHtcblx0XHRcdHJvd3M6IG51bGwsXG5cdFx0XHRjb2xzOiBudWxsLFxuXHRcdFx0b3B0czogbnVsbFxuXHRcdH07XG5cdFxuXHRcdF9BcGkuZXh0ZW5kKCB0aGlzLCB0aGlzLCBfX2FwaVN0cnVjdCApO1xuXHR9O1xuXHRcblx0RGF0YVRhYmxlLkFwaSA9IF9BcGk7XG5cdFxuXHQvLyBEb24ndCBkZXN0cm95IHRoZSBleGlzdGluZyBwcm90b3R5cGUsIGp1c3QgZXh0ZW5kIGl0LiBSZXF1aXJlZCBmb3IgalF1ZXJ5IDInc1xuXHQvLyBpc1BsYWluT2JqZWN0LlxuXHQkLmV4dGVuZCggX0FwaS5wcm90b3R5cGUsIHtcblx0XHRhbnk6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuY291bnQoKSAhPT0gMDtcblx0XHR9LFxuXHRcblx0XG5cdFx0Y29uY2F0OiAgX19hcnJheVByb3RvLmNvbmNhdCxcblx0XG5cdFxuXHRcdGNvbnRleHQ6IFtdLCAvLyBhcnJheSBvZiB0YWJsZSBzZXR0aW5ncyBvYmplY3RzXG5cdFxuXHRcblx0XHRjb3VudDogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGF0dGVuKCkubGVuZ3RoO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRlYWNoOiBmdW5jdGlvbiAoIGZuIClcblx0XHR7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbjsgaSsrICkge1xuXHRcdFx0XHRmbi5jYWxsKCB0aGlzLCB0aGlzW2ldLCBpLCB0aGlzICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGVxOiBmdW5jdGlvbiAoIGlkeCApXG5cdFx0e1xuXHRcdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA+IGlkeCA/XG5cdFx0XHRcdG5ldyBfQXBpKCBjdHhbaWR4XSwgdGhpc1tpZHhdICkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uICggZm4gKVxuXHRcdHtcblx0XHRcdHZhciBhID0gW107XG5cdFxuXHRcdFx0aWYgKCBfX2FycmF5UHJvdG8uZmlsdGVyICkge1xuXHRcdFx0XHRhID0gX19hcnJheVByb3RvLmZpbHRlci5jYWxsKCB0aGlzLCBmbiwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIENvbXBhdGliaWxpdHkgZm9yIGJyb3dzZXJzIHdpdGhvdXQgRU1DQS0yNTItNSAoSlMgMS42KVxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGZuLmNhbGwoIHRoaXMsIHRoaXNbaV0sIGksIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdGEucHVzaCggdGhpc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGZsYXR0ZW46IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0dmFyIGEgPSBbXTtcblx0XHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhLmNvbmNhdC5hcHBseSggYSwgdGhpcy50b0FycmF5KCkgKSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRqb2luOiAgICBfX2FycmF5UHJvdG8uam9pbixcblx0XG5cdFxuXHRcdGluZGV4T2Y6IF9fYXJyYXlQcm90by5pbmRleE9mIHx8IGZ1bmN0aW9uIChvYmosIHN0YXJ0KVxuXHRcdHtcblx0XHRcdGZvciAoIHZhciBpPShzdGFydCB8fCAwKSwgaWVuPXRoaXMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggdGhpc1tpXSA9PT0gb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fSxcblx0XG5cdFx0aXRlcmF0b3I6IGZ1bmN0aW9uICggZmxhdHRlbiwgdHlwZSwgZm4sIGFsd2F5c05ldyApIHtcblx0XHRcdHZhclxuXHRcdFx0XHRhID0gW10sIHJldCxcblx0XHRcdFx0aSwgaWVuLCBqLCBqZW4sXG5cdFx0XHRcdGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG5cdFx0XHRcdHJvd3MsIGl0ZW1zLCBpdGVtLFxuXHRcdFx0XHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cdFxuXHRcdFx0Ly8gQXJndW1lbnQgc2hpZnRpbmdcblx0XHRcdGlmICggdHlwZW9mIGZsYXR0ZW4gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRhbHdheXNOZXcgPSBmbjtcblx0XHRcdFx0Zm4gPSB0eXBlO1xuXHRcdFx0XHR0eXBlID0gZmxhdHRlbjtcblx0XHRcdFx0ZmxhdHRlbiA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPWNvbnRleHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHZhciBhcGlJbnN0ID0gbmV3IF9BcGkoIGNvbnRleHRbaV0gKTtcblx0XG5cdFx0XHRcdGlmICggdHlwZSA9PT0gJ3RhYmxlJyApIHtcblx0XHRcdFx0XHRyZXQgPSBmbi5jYWxsKCBhcGlJbnN0LCBjb250ZXh0W2ldLCBpICk7XG5cdFxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRhLnB1c2goIHJldCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2NvbHVtbnMnIHx8IHR5cGUgPT09ICdyb3dzJyApIHtcblx0XHRcdFx0XHQvLyB0aGlzIGhhcyBzYW1lIGxlbmd0aCBhcyBjb250ZXh0IC0gb25lIGVudHJ5IGZvciBlYWNoIHRhYmxlXG5cdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgdGhpc1tpXSwgaSApO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdjb2x1bW4nIHx8IHR5cGUgPT09ICdjb2x1bW4tcm93cycgfHwgdHlwZSA9PT0gJ3JvdycgfHwgdHlwZSA9PT0gJ2NlbGwnICkge1xuXHRcdFx0XHRcdC8vIGNvbHVtbnMgYW5kIHJvd3Mgc2hhcmUgdGhlIHNhbWUgc3RydWN0dXJlLlxuXHRcdFx0XHRcdC8vICd0aGlzJyBpcyBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyBmb3IgZWFjaCBjb250ZXh0XG5cdFx0XHRcdFx0aXRlbXMgPSB0aGlzW2ldO1xuXHRcblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdjb2x1bW4tcm93cycgKSB7XG5cdFx0XHRcdFx0XHRyb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBjb250ZXh0W2ldLCBzZWxlY3Rvci5vcHRzICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRmb3IgKCBqPTAsIGplbj1pdGVtcy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRcdGl0ZW0gPSBpdGVtc1tqXTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaXRlbS5yb3csIGl0ZW0uY29sdW1uLCBpLCBqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaXRlbSwgaSwgaiwgcm93cyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBhLmxlbmd0aCB8fCBhbHdheXNOZXcgKSB7XG5cdFx0XHRcdHZhciBhcGkgPSBuZXcgX0FwaSggY29udGV4dCwgZmxhdHRlbiA/IGEuY29uY2F0LmFwcGx5KCBbXSwgYSApIDogYSApO1xuXHRcdFx0XHR2YXIgYXBpU2VsZWN0b3IgPSBhcGkuc2VsZWN0b3I7XG5cdFx0XHRcdGFwaVNlbGVjdG9yLnJvd3MgPSBzZWxlY3Rvci5yb3dzO1xuXHRcdFx0XHRhcGlTZWxlY3Rvci5jb2xzID0gc2VsZWN0b3IuY29scztcblx0XHRcdFx0YXBpU2VsZWN0b3Iub3B0cyA9IHNlbGVjdG9yLm9wdHM7XG5cdFx0XHRcdHJldHVybiBhcGk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcblx0XG5cdFx0bGFzdEluZGV4T2Y6IF9fYXJyYXlQcm90by5sYXN0SW5kZXhPZiB8fCBmdW5jdGlvbiAob2JqLCBzdGFydClcblx0XHR7XG5cdFx0XHQvLyBCaXQgY2hlZWt5Li4uXG5cdFx0XHRyZXR1cm4gdGhpcy5pbmRleE9mLmFwcGx5KCB0aGlzLnRvQXJyYXkucmV2ZXJzZSgpLCBhcmd1bWVudHMgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0bGVuZ3RoOiAgMCxcblx0XG5cdFxuXHRcdG1hcDogZnVuY3Rpb24gKCBmbiApXG5cdFx0e1xuXHRcdFx0dmFyIGEgPSBbXTtcblx0XG5cdFx0XHRpZiAoIF9fYXJyYXlQcm90by5tYXAgKSB7XG5cdFx0XHRcdGEgPSBfX2FycmF5UHJvdG8ubWFwLmNhbGwoIHRoaXMsIGZuLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gQ29tcGF0aWJpbGl0eSBmb3IgYnJvd3NlcnMgd2l0aG91dCBFTUNBLTI1Mi01IChKUyAxLjYpXG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdGEucHVzaCggZm4uY2FsbCggdGhpcywgdGhpc1tpXSwgaSApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRwbHVjazogZnVuY3Rpb24gKCBwcm9wIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICggZWwgKSB7XG5cdFx0XHRcdHJldHVybiBlbFsgcHJvcCBdO1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cdFxuXHRcdHBvcDogICAgIF9fYXJyYXlQcm90by5wb3AsXG5cdFxuXHRcblx0XHRwdXNoOiAgICBfX2FycmF5UHJvdG8ucHVzaCxcblx0XG5cdFxuXHRcdC8vIERvZXMgbm90IHJldHVybiBhbiBBUEkgaW5zdGFuY2Vcblx0XHRyZWR1Y2U6IF9fYXJyYXlQcm90by5yZWR1Y2UgfHwgZnVuY3Rpb24gKCBmbiwgaW5pdCApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9mblJlZHVjZSggdGhpcywgZm4sIGluaXQsIDAsIHRoaXMubGVuZ3RoLCAxICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHJlZHVjZVJpZ2h0OiBfX2FycmF5UHJvdG8ucmVkdWNlUmlnaHQgfHwgZnVuY3Rpb24gKCBmbiwgaW5pdCApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9mblJlZHVjZSggdGhpcywgZm4sIGluaXQsIHRoaXMubGVuZ3RoLTEsIC0xLCAtMSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRyZXZlcnNlOiBfX2FycmF5UHJvdG8ucmV2ZXJzZSxcblx0XG5cdFxuXHRcdC8vIE9iamVjdCB3aXRoIHJvd3MsIGNvbHVtbnMgYW5kIG9wdHNcblx0XHRzZWxlY3RvcjogbnVsbCxcblx0XG5cdFxuXHRcdHNoaWZ0OiAgIF9fYXJyYXlQcm90by5zaGlmdCxcblx0XG5cdFxuXHRcdHNsaWNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgdGhpcyApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRzb3J0OiAgICBfX2FycmF5UHJvdG8uc29ydCwgLy8gPyBuYW1lIC0gb3JkZXI/XG5cdFxuXHRcblx0XHRzcGxpY2U6ICBfX2FycmF5UHJvdG8uc3BsaWNlLFxuXHRcblx0XG5cdFx0dG9BcnJheTogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX19hcnJheVByb3RvLnNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0dG8kOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiAkKCB0aGlzICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHRvSlF1ZXJ5OiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiAkKCB0aGlzICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHVuaXF1ZTogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgX3VuaXF1ZSh0aGlzKSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHR1bnNoaWZ0OiBfX2FycmF5UHJvdG8udW5zaGlmdFxuXHR9ICk7XG5cdFxuXHRcblx0X0FwaS5leHRlbmQgPSBmdW5jdGlvbiAoIHNjb3BlLCBvYmosIGV4dCApXG5cdHtcblx0XHQvLyBPbmx5IGV4dGVuZCBBUEkgaW5zdGFuY2VzIGFuZCBzdGF0aWMgcHJvcGVydGllcyBvZiB0aGUgQVBJXG5cdFx0aWYgKCAhIGV4dC5sZW5ndGggfHwgISBvYmogfHwgKCAhIChvYmogaW5zdGFuY2VvZiBfQXBpKSAmJiAhIG9iai5fX2R0X3dyYXBwZXIgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhclxuXHRcdFx0aSwgaWVuLFxuXHRcdFx0aiwgamVuLFxuXHRcdFx0c3RydWN0LCBpbm5lcixcblx0XHRcdG1ldGhvZFNjb3BpbmcgPSBmdW5jdGlvbiAoIHNjb3BlLCBmbiwgc3RydWMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHJldCA9IGZuLmFwcGx5KCBzY29wZSwgYXJndW1lbnRzICk7XG5cdFxuXHRcdFx0XHRcdC8vIE1ldGhvZCBleHRlbnNpb25cblx0XHRcdFx0XHRfQXBpLmV4dGVuZCggcmV0LCByZXQsIHN0cnVjLm1ldGhvZEV4dCApO1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1leHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzdHJ1Y3QgPSBleHRbaV07XG5cdFxuXHRcdFx0Ly8gVmFsdWVcblx0XHRcdG9ialsgc3RydWN0Lm5hbWUgXSA9IHR5cGVvZiBzdHJ1Y3QudmFsID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0bWV0aG9kU2NvcGluZyggc2NvcGUsIHN0cnVjdC52YWwsIHN0cnVjdCApIDpcblx0XHRcdFx0JC5pc1BsYWluT2JqZWN0KCBzdHJ1Y3QudmFsICkgP1xuXHRcdFx0XHRcdHt9IDpcblx0XHRcdFx0XHRzdHJ1Y3QudmFsO1xuXHRcblx0XHRcdG9ialsgc3RydWN0Lm5hbWUgXS5fX2R0X3dyYXBwZXIgPSB0cnVlO1xuXHRcblx0XHRcdC8vIFByb3BlcnR5IGV4dGVuc2lvblxuXHRcdFx0X0FwaS5leHRlbmQoIHNjb3BlLCBvYmpbIHN0cnVjdC5uYW1lIF0sIHN0cnVjdC5wcm9wRXh0ICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8vIEB0b2RvIC0gSXMgdGhlcmUgbmVlZCBmb3IgYW4gYXVnbWVudCBmdW5jdGlvbj9cblx0Ly8gX0FwaS5hdWdtZW50ID0gZnVuY3Rpb24gKCBpbnN0LCBuYW1lIClcblx0Ly8ge1xuXHQvLyBcdC8vIEZpbmQgc3JjIG9iamVjdCBpbiB0aGUgc3RydWN0dXJlIGZyb20gdGhlIG5hbWVcblx0Ly8gXHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFxuXHQvLyBcdF9BcGkuZXh0ZW5kKCBpbnN0LCBvYmogKTtcblx0Ly8gfTtcblx0XG5cdFxuXHQvLyAgICAgW1xuXHQvLyAgICAgICB7XG5cdC8vICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXG5cdC8vICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3Rcblx0Ly8gICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBtZXRob2QgcmVzdWx0XG5cdC8vICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcblx0Ly8gICAgICAgfSxcblx0Ly8gICAgICAge1xuXHQvLyAgICAgICAgIG5hbWU6ICAgICAncm93J1xuXHQvLyAgICAgICAgIHZhbDogICAgICAge30sXG5cdC8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuXHQvLyAgICAgICAgIHByb3BFeHQ6ICAgW1xuXHQvLyAgICAgICAgICAge1xuXHQvLyAgICAgICAgICAgICBuYW1lOiAgICAgICdkYXRhJ1xuXHQvLyAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxuXHQvLyAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG5cdC8vICAgICAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXVxuXHQvLyAgICAgICAgICAgfSxcblx0Ly8gICAgICAgICAgIC4uLlxuXHQvLyAgICAgICAgIF1cblx0Ly8gICAgICAgfVxuXHQvLyAgICAgXVxuXHRcblx0X0FwaS5yZWdpc3RlciA9IF9hcGlfcmVnaXN0ZXIgPSBmdW5jdGlvbiAoIG5hbWUsIHZhbCApXG5cdHtcblx0XHRpZiAoICQuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0Zm9yICggdmFyIGo9MCwgamVuPW5hbWUubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdF9BcGkucmVnaXN0ZXIoIG5hbWVbal0sIHZhbCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyXG5cdFx0XHRpLCBpZW4sXG5cdFx0XHRoZWlyID0gbmFtZS5zcGxpdCgnLicpLFxuXHRcdFx0c3RydWN0ID0gX19hcGlTdHJ1Y3QsXG5cdFx0XHRrZXksIG1ldGhvZDtcblx0XG5cdFx0dmFyIGZpbmQgPSBmdW5jdGlvbiAoIHNyYywgbmFtZSApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1zcmMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc3JjW2ldLm5hbWUgPT09IG5hbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNyY1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XG5cdFx0Zm9yICggaT0wLCBpZW49aGVpci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdG1ldGhvZCA9IGhlaXJbaV0uaW5kZXhPZignKCknKSAhPT0gLTE7XG5cdFx0XHRrZXkgPSBtZXRob2QgP1xuXHRcdFx0XHRoZWlyW2ldLnJlcGxhY2UoJygpJywgJycpIDpcblx0XHRcdFx0aGVpcltpXTtcblx0XG5cdFx0XHR2YXIgc3JjID0gZmluZCggc3RydWN0LCBrZXkgKTtcblx0XHRcdGlmICggISBzcmMgKSB7XG5cdFx0XHRcdHNyYyA9IHtcblx0XHRcdFx0XHRuYW1lOiAgICAgIGtleSxcblx0XHRcdFx0XHR2YWw6ICAgICAgIHt9LFxuXHRcdFx0XHRcdG1ldGhvZEV4dDogW10sXG5cdFx0XHRcdFx0cHJvcEV4dDogICBbXVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRzdHJ1Y3QucHVzaCggc3JjICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBpID09PSBpZW4tMSApIHtcblx0XHRcdFx0c3JjLnZhbCA9IHZhbDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzdHJ1Y3QgPSBtZXRob2QgP1xuXHRcdFx0XHRcdHNyYy5tZXRob2RFeHQgOlxuXHRcdFx0XHRcdHNyYy5wcm9wRXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdFxuXHRfQXBpLnJlZ2lzdGVyUGx1cmFsID0gX2FwaV9yZWdpc3RlclBsdXJhbCA9IGZ1bmN0aW9uICggcGx1cmFsTmFtZSwgc2luZ3VsYXJOYW1lLCB2YWwgKSB7XG5cdFx0X0FwaS5yZWdpc3RlciggcGx1cmFsTmFtZSwgdmFsICk7XG5cdFxuXHRcdF9BcGkucmVnaXN0ZXIoIHNpbmd1bGFyTmFtZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJldCA9IHZhbC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFxuXHRcdFx0aWYgKCByZXQgPT09IHRoaXMgKSB7XG5cdFx0XHRcdC8vIFJldHVybmVkIGl0ZW0gaXMgdGhlIEFQSSBpbnN0YW5jZSB0aGF0IHdhcyBwYXNzZWQgaW4sIHJldHVybiBpdFxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByZXQgaW5zdGFuY2VvZiBfQXBpICkge1xuXHRcdFx0XHQvLyBOZXcgQVBJIGluc3RhbmNlIHJldHVybmVkLCB3YW50IHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVtXG5cdFx0XHRcdC8vIGluIHRoZSByZXR1cm5lZCBhcnJheSBmb3IgdGhlIHNpbmd1bGFyIHJlc3VsdC5cblx0XHRcdFx0cmV0dXJuIHJldC5sZW5ndGggP1xuXHRcdFx0XHRcdCQuaXNBcnJheSggcmV0WzBdICkgP1xuXHRcdFx0XHRcdFx0bmV3IF9BcGkoIHJldC5jb250ZXh0LCByZXRbMF0gKSA6IC8vIEFycmF5IHJlc3VsdHMgYXJlICdlbmhhbmNlZCdcblx0XHRcdFx0XHRcdHJldFswXSA6XG5cdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIE5vbi1BUEkgcmV0dXJuIC0ganVzdCBmaXJlIGl0IGJhY2tcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSApO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBTZWxlY3RvciBmb3IgSFRNTCB0YWJsZXMuIEFwcGx5IHRoZSBnaXZlbiBzZWxlY3RvciB0byB0aGUgZ2l2ZSBhcnJheSBvZlxuXHQgKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0galF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBvciBpbnRlZ2VyXG5cdCAqIEBwYXJhbSAge2FycmF5fSBBcnJheSBvZiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMgdG8gYmUgZmlsdGVyZWRcblx0ICogQHJldHVybiB7YXJyYXl9XG5cdCAqIEBpZ25vcmVcblx0ICovXG5cdHZhciBfX3RhYmxlX3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZWxlY3RvciwgYSApXG5cdHtcblx0XHQvLyBJbnRlZ2VyIGlzIHVzZWQgdG8gcGljayBvdXQgYSB0YWJsZSBieSBpbmRleFxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSAnbnVtYmVyJyApIHtcblx0XHRcdHJldHVybiBbIGFbIHNlbGVjdG9yIF0gXTtcblx0XHR9XG5cdFxuXHRcdC8vIFBlcmZvcm0gYSBqUXVlcnkgc2VsZWN0b3Igb24gdGhlIHRhYmxlIG5vZGVzXG5cdFx0dmFyIG5vZGVzID0gJC5tYXAoIGEsIGZ1bmN0aW9uIChlbCwgaSkge1xuXHRcdFx0cmV0dXJuIGVsLm5UYWJsZTtcblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiAkKG5vZGVzKVxuXHRcdFx0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdFx0Lm1hcCggZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0Ly8gTmVlZCB0byB0cmFuc2xhdGUgYmFjayBmcm9tIHRoZSB0YWJsZSBub2RlIHRvIHRoZSBzZXR0aW5nc1xuXHRcdFx0XHR2YXIgaWR4ID0gJC5pbkFycmF5KCB0aGlzLCBub2RlcyApO1xuXHRcdFx0XHRyZXR1cm4gYVsgaWR4IF07XG5cdFx0XHR9IClcblx0XHRcdC50b0FycmF5KCk7XG5cdH07XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb250ZXh0IHNlbGVjdG9yIGZvciB0aGUgQVBJJ3MgY29udGV4dCAoaS5lLiB0aGUgdGFibGVzIHRoZSBBUEkgaW5zdGFuY2Vcblx0ICogcmVmZXJzIHRvLlxuXHQgKlxuXHQgKiBAbmFtZSAgICBEYXRhVGFibGUuQXBpI3RhYmxlc1xuXHQgKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbc2VsZWN0b3JdIFNlbGVjdG9yIHRvIHBpY2sgd2hpY2ggdGFibGVzIHRoZSBpdGVyYXRvclxuXHQgKiAgIHNob3VsZCBvcGVyYXRlIG9uLiBJZiBub3QgZ2l2ZW4sIGFsbCB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dCBhcmVcblx0ICogICB1c2VkLiBUaGlzIGNhbiBiZSBnaXZlbiBhcyBhIGpRdWVyeSBzZWxlY3RvciAoZm9yIGV4YW1wbGUgYCc6Z3QoMCknYCkgdG9cblx0ICogICBzZWxlY3QgbXVsdGlwbGUgdGFibGVzIG9yIGFzIGFuIGludGVnZXIgdG8gc2VsZWN0IGEgc2luZ2xlIHRhYmxlLlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlLkFwaX0gUmV0dXJucyBhIG5ldyBBUEkgaW5zdGFuY2UgaWYgYSBzZWxlY3RvciBpcyBnaXZlbi5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICd0YWJsZXMoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG5cdFx0Ly8gQSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBpZiB0aGVyZSB3YXMgYSBzZWxlY3RvciBzcGVjaWZpZWRcblx0XHRyZXR1cm4gc2VsZWN0b3IgP1xuXHRcdFx0bmV3IF9BcGkoIF9fdGFibGVfc2VsZWN0b3IoIHNlbGVjdG9yLCB0aGlzLmNvbnRleHQgKSApIDpcblx0XHRcdHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAndGFibGUoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHRhYmxlcyA9IHRoaXMudGFibGVzKCBzZWxlY3RvciApO1xuXHRcdHZhciBjdHggPSB0YWJsZXMuY29udGV4dDtcblx0XG5cdFx0Ly8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IG1hdGNoZWQgdGFibGVcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA/XG5cdFx0XHRuZXcgX0FwaSggY3R4WzBdICkgOlxuXHRcdFx0dGFibGVzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLm5vZGVzKCknLCAndGFibGUoKS5ub2RlKCknICwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdHJldHVybiBjdHgublRhYmxlO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5ib2R5KCknLCAndGFibGUoKS5ib2R5KCknICwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdHJldHVybiBjdHgublRCb2R5O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5oZWFkZXIoKScsICd0YWJsZSgpLmhlYWRlcigpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5USGVhZDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuZm9vdGVyKCknLCAndGFibGUoKS5mb290ZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0cmV0dXJuIGN0eC5uVEZvb3Q7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLmNvbnRhaW5lcnMoKScsICd0YWJsZSgpLmNvbnRhaW5lcigpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5UYWJsZVdyYXBwZXI7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIHRhYmxlcyBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2RyYXcoKScsIGZ1bmN0aW9uICggcGFnaW5nICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0aWYgKCBwYWdpbmcgPT09ICdwYWdlJyApIHtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBwYWdpbmcgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHBhZ2luZyA9IHBhZ2luZyA9PT0gJ2Z1bGwtaG9sZCcgP1xuXHRcdFx0XHRcdFx0ZmFsc2UgOlxuXHRcdFx0XHRcdFx0dHJ1ZTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgcGFnaW5nPT09ZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBwYWdlIGluZGV4LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtpbnRlZ2VyfSBDdXJyZW50IHBhZ2UgaW5kZXggKHplcm8gYmFzZWQpXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgcGFnZS5cblx0ICpcblx0ICogTm90ZSB0aGF0IGlmIHlvdSBhdHRlbXB0IHRvIHNob3cgYSBwYWdlIHdoaWNoIGRvZXMgbm90IGV4aXN0LCBEYXRhVGFibGVzIHdpbGxcblx0ICogbm90IHRocm93IGFuIGVycm9yLCBidXQgcmF0aGVyIHJlc2V0IHRoZSBwYWdpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7aW50ZWdlcnxzdHJpbmd9IGFjdGlvbiBUaGUgcGFnaW5nIGFjdGlvbiB0byB0YWtlLiBUaGlzIGNhbiBiZSBvbmUgb2Y6XG5cdCAqICAqIGBpbnRlZ2VyYCAtIFRoZSBwYWdlIGluZGV4IHRvIGp1bXAgdG9cblx0ICogICogYHN0cmluZ2AgLSBBbiBhY3Rpb24gdG8gdGFrZTpcblx0ICogICAgKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlLlxuXHQgKiAgICAqIGBuZXh0YCAtIEp1bXAgdG8gdGhlIG5leHQgcGFnZVxuXHQgKiAgICAqIGBwcmV2aW91c2AgLSBKdW1wIHRvIHByZXZpb3VzIHBhZ2Vcblx0ICogICAgKiBgbGFzdGAgLSBKdW1wIHRvIHRoZSBsYXN0IHBhZ2UuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3BhZ2UoKScsIGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRcdGlmICggYWN0aW9uID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYWdlLmluZm8oKS5wYWdlOyAvLyBub3QgYW4gZXhwZW5zaXZlIGNhbGxcblx0XHR9XG5cdFxuXHRcdC8vIGVsc2UsIGhhdmUgYW4gYWN0aW9uIHRvIHRha2Ugb24gYWxsIHRhYmxlc1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0X2ZuUGFnZUNoYW5nZSggc2V0dGluZ3MsIGFjdGlvbiApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBQYWdpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdCB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuXHQgKlxuXHQgKiBJZiB5b3UgcmVxdWlyZSBwYWdpbmcgaW5mb3JtYXRpb24gZm9yIGFub3RoZXIgdGFibGUsIHVzZSB0aGUgYHRhYmxlKClgIG1ldGhvZFxuXHQgKiB3aXRoIGEgc3VpdGFibGUgc2VsZWN0b3IuXG5cdCAqXG5cdCAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHNldDpcblx0ICogICogYHBhZ2VgIC0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkIC0gaS5lLiB0aGUgZmlyc3QgcGFnZSBpcyBgMGApXG5cdCAqICAqIGBwYWdlc2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXNcblx0ICogICogYHN0YXJ0YCAtIERpc3BsYXkgaW5kZXggZm9yIHRoZSBmaXJzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxuXHQgKiAgKiBgZW5kYCAtIERpc3BsYXkgaW5kZXggZm9yIHRoZSBsYXN0IHJlY29yZCBzaG93biBvbiB0aGUgY3VycmVudCBwYWdlXG5cdCAqICAqIGBsZW5ndGhgIC0gRGlzcGxheSBsZW5ndGggKG51bWJlciBvZiByZWNvcmRzKS4gTm90ZSB0aGF0IGdlbmVyYWxseSBgc3RhcnRcblx0ICogICAgKyBsZW5ndGggPSBlbmRgLCBidXQgdGhpcyBpcyBub3QgYWx3YXlzIHRydWUsIGZvciBleGFtcGxlIGlmIHRoZXJlIGFyZVxuXHQgKiAgICBvbmx5IDIgcmVjb3JkcyB0byBzaG93IG9uIHRoZSBmaW5hbCBwYWdlLCB3aXRoIGEgbGVuZ3RoIG9mIDEwLlxuXHQgKiAgKiBgcmVjb3Jkc1RvdGFsYCAtIEZ1bGwgZGF0YSBzZXQgbGVuZ3RoXG5cdCAqICAqIGByZWNvcmRzRGlzcGxheWAgLSBEYXRhIHNldCBsZW5ndGggb25jZSB0aGUgY3VycmVudCBmaWx0ZXJpbmcgY3JpdGVyaW9uXG5cdCAqICAgIGFyZSBhcHBsaWVkLlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3BhZ2UuaW5mbygpJywgZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cdFx0aWYgKCB0aGlzLmNvbnRleHQubGVuZ3RoID09PSAwICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdHZhclxuXHRcdFx0c2V0dGluZ3MgICA9IHRoaXMuY29udGV4dFswXSxcblx0XHRcdHN0YXJ0ICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5vRmVhdHVyZXMuYlBhZ2luYXRlID8gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDogLTEsXG5cdFx0XHR2aXNSZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdFx0YWxsICAgICAgICA9IGxlbiA9PT0gLTE7XG5cdFxuXHRcdHJldHVybiB7XG5cdFx0XHRcInBhZ2VcIjogICAgICAgICAgIGFsbCA/IDAgOiBNYXRoLmZsb29yKCBzdGFydCAvIGxlbiApLFxuXHRcdFx0XCJwYWdlc1wiOiAgICAgICAgICBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXNSZWNvcmRzIC8gbGVuICksXG5cdFx0XHRcInN0YXJ0XCI6ICAgICAgICAgIHN0YXJ0LFxuXHRcdFx0XCJlbmRcIjogICAgICAgICAgICBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcblx0XHRcdFwibGVuZ3RoXCI6ICAgICAgICAgbGVuLFxuXHRcdFx0XCJyZWNvcmRzVG90YWxcIjogICBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpLFxuXHRcdFx0XCJyZWNvcmRzRGlzcGxheVwiOiB2aXNSZWNvcmRzLFxuXHRcdFx0XCJzZXJ2ZXJTaWRlXCI6ICAgICBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09PSAnc3NwJ1xuXHRcdH07XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJyZW50IHBhZ2UgbGVuZ3RoLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtpbnRlZ2VyfSBDdXJyZW50IHBhZ2UgbGVuZ3RoLiBOb3RlIGAtMWAgaW5kaWNhdGVzIHRoYXQgYWxsIHJlY29yZHNcblx0ICogICBhcmUgdG8gYmUgc2hvd24uXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgcGFnZSBsZW5ndGguXG5cdCAqXG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gUGFnZSBsZW5ndGggdG8gc2V0LiBVc2UgYC0xYCB0byBzaG93IGFsbCByZWNvcmRzLlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdwYWdlLmxlbigpJywgZnVuY3Rpb24gKCBsZW4gKSB7XG5cdFx0Ly8gTm90ZSB0aGF0IHdlIGNhbid0IGNhbGwgdGhpcyBmdW5jdGlvbiAnbGVuZ3RoKCknIGJlY2F1c2UgYGxlbmd0aGBcblx0XHQvLyBpcyBhIEphdmFzY3JpcHQgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHdoaWNoIGRlZmluZXMgaG93IG1hbnkgYXJndW1lbnRzXG5cdFx0Ly8gdGhlIGZ1bmN0aW9uIGV4cGVjdHMuXG5cdFx0aWYgKCBsZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoICE9PSAwID9cblx0XHRcdFx0dGhpcy5jb250ZXh0WzBdLl9pRGlzcGxheUxlbmd0aCA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIGVsc2UsIHNldCB0aGUgcGFnZSBsZW5ndGhcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mbkxlbmd0aENoYW5nZSggc2V0dGluZ3MsIGxlbiApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHR2YXIgX19yZWxvYWQgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBob2xkUG9zaXRpb24sIGNhbGxiYWNrICkge1xuXHRcdC8vIFVzZSB0aGUgZHJhdyBldmVudCB0byB0cmlnZ2VyIGEgY2FsbGJhY2tcblx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIGFwaSA9IG5ldyBfQXBpKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdGFwaS5vbmUoICdkcmF3JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjYWxsYmFjayggYXBpLmFqYXguanNvbigpICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgPT0gJ3NzcCcgKSB7XG5cdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblx0XG5cdFx0XHQvLyBDYW5jZWwgYW4gZXhpc3RpbmcgcmVxdWVzdFxuXHRcdFx0dmFyIHhociA9IHNldHRpbmdzLmpxWEhSO1xuXHRcdFx0aWYgKCB4aHIgJiYgeGhyLnJlYWR5U3RhdGUgIT09IDQgKSB7XG5cdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFRyaWdnZXIgeGhyXG5cdFx0XHRfZm5CdWlsZEFqYXgoIHNldHRpbmdzLCBbXSwgZnVuY3Rpb24oIGpzb24gKSB7XG5cdFx0XHRcdF9mbkNsZWFyVGFibGUoIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0XHR2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgZGF0YVtpXSApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKTtcblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBKU09OIHJlc3BvbnNlIGZyb20gdGhlIGxhc3QgQWpheCByZXF1ZXN0IHRoYXQgRGF0YVRhYmxlcyBtYWRlIHRvIHRoZVxuXHQgKiBzZXJ2ZXIuIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgdGhlIEpTT04gZnJvbSB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnRcblx0ICogY29udGV4dC5cblx0ICpcblx0ICogQHJldHVybiB7b2JqZWN0fSBKU09OIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdhamF4Lmpzb24oKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggPiAwICkge1xuXHRcdFx0cmV0dXJuIGN0eFswXS5qc29uO1xuXHRcdH1cblx0XG5cdFx0Ly8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgZGF0YSBzdWJtaXR0ZWQgaW4gdGhlIGxhc3QgQWpheCByZXF1ZXN0XG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnYWpheC5wYXJhbXMoKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggPiAwICkge1xuXHRcdFx0cmV0dXJuIGN0eFswXS5vQWpheERhdGE7XG5cdFx0fVxuXHRcblx0XHQvLyBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogUmVsb2FkIHRhYmxlcyBmcm9tIHRoZSBBamF4IGRhdGEgc291cmNlLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsXG5cdCAqIGF1dG9tYXRpY2FsbHkgcmUtZHJhdyB0aGUgdGFibGUgd2hlbiB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD10cnVlXSBSZXNldCAoZGVmYXVsdCkgb3IgaG9sZCB0aGUgY3VycmVudCBwYWdpbmdcblx0ICogICBwb3NpdGlvbi4gQSBmdWxsIHJlLXNvcnQgYW5kIHJlLWZpbHRlciBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIG1ldGhvZCBpc1xuXHQgKiAgIGNhbGxlZCwgd2hpY2ggaXMgd2h5IHRoZSBwYWdpbmF0aW9uIHJlc2V0IGlzIHRoZSBkZWZhdWx0IGFjdGlvbi5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnYWpheC5yZWxvYWQoKScsIGZ1bmN0aW9uICggY2FsbGJhY2ssIHJlc2V0UGFnaW5nICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcblx0XHRcdF9fcmVsb2FkKCBzZXR0aW5ncywgcmVzZXRQYWdpbmc9PT1mYWxzZSwgY2FsbGJhY2sgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJyZW50IEFqYXggVVJMLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBVUkwgZnJvbSB0aGUgZmlyc3Rcblx0ICogdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cblx0ICpcblx0ICogQHJldHVybiB7c3RyaW5nfSBDdXJyZW50IEFqYXggc291cmNlIFVSTFxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBzZXQgdGhlIFVSTCBmb3IgYWxsIHRhYmxlcyBpbiB0aGVcblx0ICogY3VycmVudCBjb250ZXh0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgudXJsKCknLCBmdW5jdGlvbiAoIHVybCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gZ2V0XG5cdFx0XHRpZiAoIGN0eC5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRjdHggPSBjdHhbMF07XG5cdFxuXHRcdFx0cmV0dXJuIGN0eC5hamF4ID9cblx0XHRcdFx0JC5pc1BsYWluT2JqZWN0KCBjdHguYWpheCApID9cblx0XHRcdFx0XHRjdHguYWpheC51cmwgOlxuXHRcdFx0XHRcdGN0eC5hamF4IDpcblx0XHRcdFx0Y3R4LnNBamF4U291cmNlO1xuXHRcdH1cblx0XG5cdFx0Ly8gc2V0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggc2V0dGluZ3MuYWpheCApICkge1xuXHRcdFx0XHRzZXR0aW5ncy5hamF4LnVybCA9IHVybDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZXR0aW5ncy5hamF4ID0gdXJsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTm8gbmVlZCB0byBjb25zaWRlciBzQWpheFNvdXJjZSBoZXJlIHNpbmNlIERhdGFUYWJsZXMgZ2l2ZXMgcHJpb3JpdHlcblx0XHRcdC8vIHRvIGBhamF4YCBvdmVyIGBzQWpheFNvdXJjZWAuIFNvIHNldHRpbmcgYGFqYXhgIGhlcmUsIHJlbmRlcnMgYW55XG5cdFx0XHQvLyB2YWx1ZSBvZiBgc0FqYXhTb3VyY2VgIHJlZHVuZGFudC5cblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogTG9hZCBkYXRhIGZyb20gdGhlIG5ld2x5IHNldCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG9ubHlcblx0ICogYXZhaWxhYmxlIHdoZW4gYGFqYXgudXJsKClgIGlzIHVzZWQgdG8gc2V0IGEgVVJMLiBBZGRpdGlvbmFsbHksIHRoaXMgbWV0aG9kXG5cdCAqIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgY2FsbGluZyBgYWpheC5yZWxvYWQoKWAgYnV0IGlzIHByb3ZpZGVkIGZvclxuXHQgKiBjb252ZW5pZW5jZSB3aGVuIHNldHRpbmcgYSBuZXcgVVJMLiBMaWtlIGBhamF4LnJlbG9hZCgpYCBpdCB3aWxsXG5cdCAqIGF1dG9tYXRpY2FsbHkgcmVkcmF3IHRoZSB0YWJsZSBvbmNlIHRoZSByZW1vdGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgudXJsKCkubG9hZCgpJywgZnVuY3Rpb24gKCBjYWxsYmFjaywgcmVzZXRQYWdpbmcgKSB7XG5cdFx0Ly8gU2FtZSBhcyBhIHJlbG9hZCwgYnV0IG1ha2VzIHNlbnNlIHRvIHByZXNlbnQgaXQgZm9yIGVhc3kgYWNjZXNzIGFmdGVyIGFcblx0XHQvLyB1cmwgY2hhbmdlXG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0X19yZWxvYWQoIGN0eCwgcmVzZXRQYWdpbmc9PT1mYWxzZSwgY2FsbGJhY2sgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0XG5cdHZhciBfc2VsZWN0b3JfcnVuID0gZnVuY3Rpb24gKCB0eXBlLCBzZWxlY3Rvciwgc2VsZWN0Rm4sIHNldHRpbmdzLCBvcHRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0b3V0ID0gW10sIHJlcyxcblx0XHRcdGEsIGksIGllbiwgaiwgamVuLFxuXHRcdFx0c2VsZWN0b3JUeXBlID0gdHlwZW9mIHNlbGVjdG9yO1xuXHRcblx0XHQvLyBDYW4ndCBqdXN0IGNoZWNrIGZvciBpc0FycmF5IGhlcmUsIGFzIGFuIEFQSSBvciBqUXVlcnkgaW5zdGFuY2UgbWlnaHQgYmVcblx0XHQvLyBnaXZlbiB3aXRoIHRoZWlyIGFycmF5IGxpa2UgbG9va1xuXHRcdGlmICggISBzZWxlY3RvciB8fCBzZWxlY3RvclR5cGUgPT09ICdzdHJpbmcnIHx8IHNlbGVjdG9yVHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBzZWxlY3Rvci5sZW5ndGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNlbGVjdG9yID0gWyBzZWxlY3RvciBdO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wLCBpZW49c2VsZWN0b3IubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHQvLyBPbmx5IHNwbGl0IG9uIHNpbXBsZSBzdHJpbmdzIC0gY29tcGxleCBleHByZXNzaW9ucyB3aWxsIGJlIGpRdWVyeSBzZWxlY3RvcnNcblx0XHRcdGEgPSBzZWxlY3RvcltpXSAmJiBzZWxlY3RvcltpXS5zcGxpdCAmJiAhIHNlbGVjdG9yW2ldLm1hdGNoKC9bXFxbXFwoOl0vKSA/XG5cdFx0XHRcdHNlbGVjdG9yW2ldLnNwbGl0KCcsJykgOlxuXHRcdFx0XHRbIHNlbGVjdG9yW2ldIF07XG5cdFxuXHRcdFx0Zm9yICggaj0wLCBqZW49YS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0cmVzID0gc2VsZWN0Rm4oIHR5cGVvZiBhW2pdID09PSAnc3RyaW5nJyA/ICQudHJpbShhW2pdKSA6IGFbal0gKTtcblx0XG5cdFx0XHRcdGlmICggcmVzICYmIHJlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0b3V0ID0gb3V0LmNvbmNhdCggcmVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8vIHNlbGVjdG9yIGV4dGVuc2lvbnNcblx0XHR2YXIgZXh0ID0gX2V4dC5zZWxlY3RvclsgdHlwZSBdO1xuXHRcdGlmICggZXh0Lmxlbmd0aCApIHtcblx0XHRcdGZvciAoIGk9MCwgaWVuPWV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0b3V0ID0gZXh0W2ldKCBzZXR0aW5ncywgb3B0cywgb3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gX3VuaXF1ZSggb3V0ICk7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9zZWxlY3Rvcl9vcHRzID0gZnVuY3Rpb24gKCBvcHRzIClcblx0e1xuXHRcdGlmICggISBvcHRzICkge1xuXHRcdFx0b3B0cyA9IHt9O1xuXHRcdH1cblx0XG5cdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIDEuOS0gd2hpY2ggdXNlZCB0aGUgdGVybWlub2xvZ3kgZmlsdGVyIHJhdGhlclxuXHRcdC8vIHRoYW4gc2VhcmNoXG5cdFx0aWYgKCBvcHRzLmZpbHRlciAmJiBvcHRzLnNlYXJjaCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0b3B0cy5zZWFyY2ggPSBvcHRzLmZpbHRlcjtcblx0XHR9XG5cdFxuXHRcdHJldHVybiAkLmV4dGVuZCgge1xuXHRcdFx0c2VhcmNoOiAnbm9uZScsXG5cdFx0XHRvcmRlcjogJ2N1cnJlbnQnLFxuXHRcdFx0cGFnZTogJ2FsbCdcblx0XHR9LCBvcHRzICk7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9zZWxlY3Rvcl9maXJzdCA9IGZ1bmN0aW9uICggaW5zdCApXG5cdHtcblx0XHQvLyBSZWR1Y2UgdGhlIEFQSSBpbnN0YW5jZSB0byB0aGUgZmlyc3QgaXRlbSBmb3VuZFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1pbnN0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBpbnN0W2ldLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdC8vIEFzc2lnbiB0aGUgZmlyc3QgZWxlbWVudCB0byB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgaW5zdGFuY2Vcblx0XHRcdFx0Ly8gYW5kIHRydW5jYXRlIHRoZSBpbnN0YW5jZSBhbmQgY29udGV4dFxuXHRcdFx0XHRpbnN0WzBdID0gaW5zdFtpXTtcblx0XHRcdFx0aW5zdFswXS5sZW5ndGggPSAxO1xuXHRcdFx0XHRpbnN0Lmxlbmd0aCA9IDE7XG5cdFx0XHRcdGluc3QuY29udGV4dCA9IFsgaW5zdC5jb250ZXh0W2ldIF07XG5cdFxuXHRcdFx0XHRyZXR1cm4gaW5zdDtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8vIE5vdCBmb3VuZCAtIHJldHVybiBhbiBlbXB0eSBpbnN0YW5jZVxuXHRcdGluc3QubGVuZ3RoID0gMDtcblx0XHRyZXR1cm4gaW5zdDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3NlbGVjdG9yX3Jvd19pbmRleGVzID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGksIGllbiwgdG1wLCBhPVtdLFxuXHRcdFx0ZGlzcGxheUZpbHRlcmVkID0gc2V0dGluZ3MuYWlEaXNwbGF5LFxuXHRcdFx0ZGlzcGxheU1hc3RlciA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlcjtcblx0XG5cdFx0dmFyXG5cdFx0XHRzZWFyY2ggPSBvcHRzLnNlYXJjaCwgIC8vIG5vbmUsIGFwcGxpZWQsIHJlbW92ZWRcblx0XHRcdG9yZGVyICA9IG9wdHMub3JkZXIsICAgLy8gYXBwbGllZCwgY3VycmVudCwgaW5kZXggKG9yaWdpbmFsIC0gY29tcGF0aWJpbGl0eSB3aXRoIDEuOSlcblx0XHRcdHBhZ2UgICA9IG9wdHMucGFnZTsgICAgLy8gYWxsLCBjdXJyZW50XG5cdFxuXHRcdGlmICggX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PSAnc3NwJyApIHtcblx0XHRcdC8vIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgbW9kZSwgbW9zdCBvcHRpb25zIGFyZSBpcnJlbGV2YW50IHNpbmNlXG5cdFx0XHQvLyByb3dzIG5vdCBzaG93biBkb24ndCBleGlzdCBhbmQgdGhlIGluZGV4IG9yZGVyIGlzIHRoZSBhcHBsaWVkIG9yZGVyXG5cdFx0XHQvLyBSZW1vdmVkIGlzIGEgc3BlY2lhbCBjYXNlIC0gZm9yIGNvbnNpc3RlbmN5IGp1c3QgcmV0dXJuIGFuIGVtcHR5XG5cdFx0XHQvLyBhcnJheVxuXHRcdFx0cmV0dXJuIHNlYXJjaCA9PT0gJ3JlbW92ZWQnID9cblx0XHRcdFx0W10gOlxuXHRcdFx0XHRfcmFuZ2UoIDAsIGRpc3BsYXlNYXN0ZXIubGVuZ3RoICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBwYWdlID09ICdjdXJyZW50JyApIHtcblx0XHRcdC8vIEN1cnJlbnQgcGFnZSBpbXBsaWVzIHRoYXQgb3JkZXI9Y3VycmVudCBhbmQgZml0bGVyPWFwcGxpZWQsIHNpbmNlIGl0IGlzXG5cdFx0XHQvLyBmYWlybHkgc2Vuc2VsZXNzIG90aGVyd2lzZSwgcmVnYXJkbGVzcyBvZiB3aGF0IG9yZGVyIGFuZCBzZWFyY2ggYWN0dWFsbHlcblx0XHRcdC8vIGFyZVxuXHRcdFx0Zm9yICggaT1zZXR0aW5ncy5faURpc3BsYXlTdGFydCwgaWVuPXNldHRpbmdzLmZuRGlzcGxheUVuZCgpIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGEucHVzaCggZGlzcGxheUZpbHRlcmVkW2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBvcmRlciA9PSAnY3VycmVudCcgfHwgb3JkZXIgPT0gJ2FwcGxpZWQnICkge1xuXHRcdFx0YSA9IHNlYXJjaCA9PSAnbm9uZScgP1xuXHRcdFx0XHRkaXNwbGF5TWFzdGVyLnNsaWNlKCkgOiAgICAgICAgICAgICAgICAgICAgICAvLyBubyBzZWFyY2hcblx0XHRcdFx0c2VhcmNoID09ICdhcHBsaWVkJyA/XG5cdFx0XHRcdFx0ZGlzcGxheUZpbHRlcmVkLnNsaWNlKCkgOiAgICAgICAgICAgICAgICAvLyBhcHBsaWVkIHNlYXJjaFxuXHRcdFx0XHRcdCQubWFwKCBkaXNwbGF5TWFzdGVyLCBmdW5jdGlvbiAoZWwsIGkpIHsgLy8gcmVtb3ZlZCBzZWFyY2hcblx0XHRcdFx0XHRcdHJldHVybiAkLmluQXJyYXkoIGVsLCBkaXNwbGF5RmlsdGVyZWQgKSA9PT0gLTEgPyBlbCA6IG51bGw7XG5cdFx0XHRcdFx0fSApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggb3JkZXIgPT0gJ2luZGV4JyB8fCBvcmRlciA9PSAnb3JpZ2luYWwnICkge1xuXHRcdFx0Zm9yICggaT0wLCBpZW49c2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHNlYXJjaCA9PSAnbm9uZScgKSB7XG5cdFx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IC8vIGFwcGxpZWQgfCByZW1vdmVkXG5cdFx0XHRcdFx0dG1wID0gJC5pbkFycmF5KCBpLCBkaXNwbGF5RmlsdGVyZWQgKTtcblx0XG5cdFx0XHRcdFx0aWYgKCh0bXAgPT09IC0xICYmIHNlYXJjaCA9PSAncmVtb3ZlZCcpIHx8XG5cdFx0XHRcdFx0XHQodG1wID49IDAgICAmJiBzZWFyY2ggPT0gJ2FwcGxpZWQnKSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gYTtcblx0fTtcblx0XG5cdFxuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogUm93c1xuXHQgKlxuXHQgKiB7fSAgICAgICAgICAtIG5vIHNlbGVjdG9yIC0gdXNlIGFsbCBhdmFpbGFibGUgcm93c1xuXHQgKiB7aW50ZWdlcn0gICAtIHJvdyBhb0RhdGEgaW5kZXhcblx0ICoge25vZGV9ICAgICAgLSBUUiBub2RlXG5cdCAqIHtzdHJpbmd9ICAgIC0galF1ZXJ5IHNlbGVjdG9yIHRvIGFwcGx5IHRvIHRoZSBUUiBlbGVtZW50c1xuXHQgKiB7YXJyYXl9ICAgICAtIGpRdWVyeSBhcnJheSBvZiBub2Rlcywgb3Igc2ltcGx5IGFuIGFycmF5IG9mIFRSIG5vZGVzXG5cdCAqXG5cdCAqL1xuXHRcblx0XG5cdHZhciBfX3Jvd19zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcblx0e1xuXHRcdHZhciByb3dzO1xuXHRcdHZhciBydW4gPSBmdW5jdGlvbiAoIHNlbCApIHtcblx0XHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzZWwgKTtcblx0XHRcdHZhciBpLCBpZW47XG5cdFxuXHRcdFx0Ly8gU2hvcnQgY3V0IC0gc2VsZWN0b3IgaXMgYSBudW1iZXIgYW5kIG5vIG9wdGlvbnMgcHJvdmlkZWQgKGRlZmF1bHQgaXNcblx0XHRcdC8vIGFsbCByZWNvcmRzLCBzbyBubyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBpbmRleCBpcyBpbiB0aGVyZSwgc2luY2UgaXRcblx0XHRcdC8vIG11c3QgYmUgLSBkZXYgZXJyb3IgaWYgdGhlIGluZGV4IGRvZXNuJ3QgZXhpc3QpLlxuXHRcdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgJiYgISBvcHRzICkge1xuXHRcdFx0XHRyZXR1cm4gWyBzZWxJbnQgXTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoICEgcm93cyApIHtcblx0XHRcdFx0cm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHNlbEludCAhPT0gbnVsbCAmJiAkLmluQXJyYXkoIHNlbEludCwgcm93cyApICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBpbnRlZ2VyXG5cdFx0XHRcdHJldHVybiBbIHNlbEludCBdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbCA9PT0gbnVsbCB8fCBzZWwgPT09IHVuZGVmaW5lZCB8fCBzZWwgPT09ICcnICkge1xuXHRcdFx0XHQvLyBTZWxlY3RvciAtIG5vbmVcblx0XHRcdFx0cmV0dXJuIHJvd3M7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBmdW5jdGlvblxuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXR1cm4gJC5tYXAoIHJvd3MsIGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0XHR2YXIgcm93ID0gc2V0dGluZ3MuYW9EYXRhWyBpZHggXTtcblx0XHRcdFx0XHRyZXR1cm4gc2VsKCBpZHgsIHJvdy5fYURhdGEsIHJvdy5uVHIgKSA/IGlkeCA6IG51bGw7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBHZXQgbm9kZXMgaW4gdGhlIG9yZGVyIGZyb20gdGhlIGByb3dzYCBhcnJheSB3aXRoIG51bGwgdmFsdWVzIHJlbW92ZWRcblx0XHRcdHZhciBub2RlcyA9IF9yZW1vdmVFbXB0eShcblx0XHRcdFx0X3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICduVHInIClcblx0XHRcdCk7XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBub2RlXG5cdFx0XHRpZiAoIHNlbC5ub2RlTmFtZSApIHtcblx0XHRcdFx0aWYgKCBzZWwuX0RUX1Jvd0luZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFsgc2VsLl9EVF9Sb3dJbmRleCBdOyAvLyBQcm9wZXJ0eSBhZGRlZCBieSBEVCBmb3IgZmFzdCBsb29rdXBcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggc2VsLl9EVF9DZWxsSW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFsgc2VsLl9EVF9DZWxsSW5kZXgucm93IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGhvc3QgPSAkKHNlbCkuY2xvc2VzdCgnKltkYXRhLWR0LXJvd10nKTtcblx0XHRcdFx0XHRyZXR1cm4gaG9zdC5sZW5ndGggP1xuXHRcdFx0XHRcdFx0WyBob3N0LmRhdGEoJ2R0LXJvdycpIF0gOlxuXHRcdFx0XHRcdFx0W107XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBJRCBzZWxlY3Rvci4gV2FudCB0byBhbHdheXMgYmUgYWJsZSB0byBzZWxlY3Qgcm93cyBieSBpZCwgcmVnYXJkbGVzc1xuXHRcdFx0Ly8gb2YgaWYgdGhlIHRyIGVsZW1lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciBub3QsIHNvIGNhbid0IHJlbHkgdXBvblxuXHRcdFx0Ly8galF1ZXJ5IGhlcmUgLSBoZW5jZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi4gVGhpcyBkb2VzIG5vdCBtYXRjaFxuXHRcdFx0Ly8gU2l6emxlJ3MgZmFzdCBzZWxlY3RvciBvciBIVE1MNCAtIGluIEhUTUw1IHRoZSBJRCBjYW4gYmUgYW55dGhpbmcsXG5cdFx0XHQvLyBidXQgdG8gc2VsZWN0IGl0IHVzaW5nIGEgQ1NTIHNlbGVjdG9yIGVuZ2luZSAobGlrZSBTaXp6bGUgb3Jcblx0XHRcdC8vIHF1ZXJ5U2VsZWN0KSBpdCB3b3VsZCBuZWVkIHRvIG5lZWQgdG8gYmUgZXNjYXBlZCBmb3Igc29tZSBjaGFyYWN0ZXJzLlxuXHRcdFx0Ly8gRGF0YVRhYmxlcyBzaW1wbGlmaWVzIHRoaXMgZm9yIHJvdyBzZWxlY3RvcnMgc2luY2UgeW91IGNhbiBzZWxlY3Rcblx0XHRcdC8vIG9ubHkgYSByb3cuIEEgIyBpbmRpY2F0ZXMgYW4gaWQgYW55IGFueXRoaW5nIHRoYXQgZm9sbG93cyBpcyB0aGUgaWQgLVxuXHRcdFx0Ly8gdW5lc2NhcGVkLlxuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsID09PSAnc3RyaW5nJyAmJiBzZWwuY2hhckF0KDApID09PSAnIycgKSB7XG5cdFx0XHRcdC8vIGdldCByb3cgaW5kZXggZnJvbSBpZFxuXHRcdFx0XHR2YXIgcm93T2JqID0gc2V0dGluZ3MuYUlkc1sgc2VsLnJlcGxhY2UoIC9eIy8sICcnICkgXTtcblx0XHRcdFx0aWYgKCByb3dPYmogIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gWyByb3dPYmouaWR4IF07XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIG5lZWQgdG8gZmFsbCB0aHJvdWdoIHRvIGpRdWVyeSBpbiBjYXNlIHRoZXJlIGlzIERPTSBpZCB0aGF0XG5cdFx0XHRcdC8vIG1hdGNoZXNcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcsIGFycmF5IG9mIG5vZGVzIG9yIGpRdWVyeSBvYmplY3QvXG5cdFx0XHQvLyBBcyBqUXVlcnkncyAuZmlsdGVyKCkgYWxsb3dzIGpRdWVyeSBvYmplY3RzIHRvIGJlIHBhc3NlZCBpbiBmaWx0ZXIsXG5cdFx0XHQvLyBpdCBhbHNvIGFsbG93cyBhcnJheXMsIHNvIHRoaXMgd2lsbCBjb3BlIHdpdGggYWxsIHRocmVlIG9wdGlvbnNcblx0XHRcdHJldHVybiAkKG5vZGVzKVxuXHRcdFx0XHQuZmlsdGVyKCBzZWwgKVxuXHRcdFx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX0RUX1Jvd0luZGV4O1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcblx0XHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ3JvdycsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG5cdH07XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3Jvd3MoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0Ly8gYXJndW1lbnQgc2hpZnRpbmdcblx0XHRpZiAoIHNlbGVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZWxlY3RvciA9ICcnO1xuXHRcdH1cblx0XHRlbHNlIGlmICggJC5pc1BsYWluT2JqZWN0KCBzZWxlY3RvciApICkge1xuXHRcdFx0b3B0cyA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSAnJztcblx0XHR9XG5cdFxuXHRcdG9wdHMgPSBfc2VsZWN0b3Jfb3B0cyggb3B0cyApO1xuXHRcblx0XHR2YXIgaW5zdCA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRyZXR1cm4gX19yb3dfc2VsZWN0b3IoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApO1xuXHRcdH0sIDEgKTtcblx0XG5cdFx0Ly8gV2FudCBhcmd1bWVudCBzaGlmdGluZyBoZXJlIGFuZCBpbiBfX3Jvd19zZWxlY3Rvcj9cblx0XHRpbnN0LnNlbGVjdG9yLnJvd3MgPSBzZWxlY3Rvcjtcblx0XHRpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xuXHRcblx0XHRyZXR1cm4gaW5zdDtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlciggJ3Jvd3MoKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvRGF0YVsgcm93IF0ublRyIHx8IHVuZGVmaW5lZDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3dzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCB0cnVlLCAncm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvd3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICdfYURhdGEnICk7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLmNhY2hlKCknLCAncm93KCkuY2FjaGUoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHRcdHZhciByID0gc2V0dGluZ3MuYW9EYXRhWyByb3cgXTtcblx0XHRcdHJldHVybiB0eXBlID09PSAnc2VhcmNoJyA/IHIuX2FGaWx0ZXJEYXRhIDogci5fYVNvcnREYXRhO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pbnZhbGlkYXRlKCknLCAncm93KCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0XHRfZm5JbnZhbGlkYXRlKCBzZXR0aW5ncywgcm93LCBzcmMgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaW5kZXhlcygpJywgJ3JvdygpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0XHRyZXR1cm4gcm93O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pZHMoKScsICdyb3coKS5pZCgpJywgZnVuY3Rpb24gKCBoYXNoICkge1xuXHRcdHZhciBhID0gW107XG5cdFx0dmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdC8vIGBpdGVyYXRvcmAgd2lsbCBkcm9wIHVuZGVmaW5lZCB2YWx1ZXMsIGJ1dCBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0aGVtXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWNvbnRleHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaj0wLCBqZW49dGhpc1tpXS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0dmFyIGlkID0gY29udGV4dFtpXS5yb3dJZEZuKCBjb250ZXh0W2ldLmFvRGF0YVsgdGhpc1tpXVtqXSBdLl9hRGF0YSApO1xuXHRcdFx0XHRhLnB1c2goIChoYXNoID09PSB0cnVlID8gJyMnIDogJycgKSsgaWQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBuZXcgX0FwaSggY29udGV4dCwgYSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLnJlbW92ZSgpJywgJ3JvdygpLnJlbW92ZSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XG5cdFx0dGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgdGhhdElkeCApIHtcblx0XHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcdFx0dmFyIHJvd0RhdGEgPSBkYXRhWyByb3cgXTtcblx0XHRcdHZhciBpLCBpZW4sIGosIGplbjtcblx0XHRcdHZhciBsb29wUm93LCBsb29wQ2VsbHM7XG5cdFxuXHRcdFx0ZGF0YS5zcGxpY2UoIHJvdywgMSApO1xuXHRcblx0XHRcdC8vIFVwZGF0ZSB0aGUgY2FjaGVkIGluZGV4ZXNcblx0XHRcdGZvciAoIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGxvb3BSb3cgPSBkYXRhW2ldO1xuXHRcdFx0XHRsb29wQ2VsbHMgPSBsb29wUm93LmFuQ2VsbHM7XG5cdFxuXHRcdFx0XHQvLyBSb3dzXG5cdFx0XHRcdGlmICggbG9vcFJvdy5uVHIgIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0bG9vcFJvdy5uVHIuX0RUX1Jvd0luZGV4ID0gaTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gQ2VsbHNcblx0XHRcdFx0aWYgKCBsb29wQ2VsbHMgIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0Zm9yICggaj0wLCBqZW49bG9vcENlbGxzLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0bG9vcENlbGxzW2pdLl9EVF9DZWxsSW5kZXgucm93ID0gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBEZWxldGUgZnJvbSB0aGUgZGlzcGxheSBhcnJheXNcblx0XHRcdF9mbkRlbGV0ZUluZGV4KCBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIsIHJvdyApO1xuXHRcdFx0X2ZuRGVsZXRlSW5kZXgoIHNldHRpbmdzLmFpRGlzcGxheSwgcm93ICk7XG5cdFx0XHRfZm5EZWxldGVJbmRleCggdGhhdFsgdGhhdElkeCBdLCByb3csIGZhbHNlICk7IC8vIG1haW50YWluIGxvY2FsIGluZGV4ZXNcblx0XG5cdFx0XHQvLyBDaGVjayBmb3IgYW4gJ292ZXJmbG93JyB0aGV5IGNhc2UgZm9yIGRpc3BsYXlpbmcgdGhlIHRhYmxlXG5cdFx0XHRfZm5MZW5ndGhPdmVyZmxvdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0XHQvLyBSZW1vdmUgdGhlIHJvdydzIElEIHJlZmVyZW5jZSBpZiB0aGVyZSBpcyBvbmVcblx0XHRcdHZhciBpZCA9IHNldHRpbmdzLnJvd0lkRm4oIHJvd0RhdGEuX2FEYXRhICk7XG5cdFx0XHRpZiAoIGlkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGRlbGV0ZSBzZXR0aW5ncy5hSWRzWyBpZCBdO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHNldHRpbmdzLmFvRGF0YVtpXS5pZHggPSBpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93cy5hZGQoKScsIGZ1bmN0aW9uICggcm93cyApIHtcblx0XHR2YXIgbmV3Um93cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdHZhciByb3csIGksIGllbjtcblx0XHRcdFx0dmFyIG91dCA9IFtdO1xuXHRcblx0XHRcdFx0Zm9yICggaT0wLCBpZW49cm93cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRyb3cgPSByb3dzW2ldO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJyApIHtcblx0XHRcdFx0XHRcdG91dC5wdXNoKCBfZm5BZGRUciggc2V0dGluZ3MsIHJvdyApWzBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0b3V0LnB1c2goIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIG91dDtcblx0XHRcdH0sIDEgKTtcblx0XG5cdFx0Ly8gUmV0dXJuIGFuIEFwaS5yb3dzKCkgZXh0ZW5kZWQgaW5zdGFuY2UsIHNvIHJvd3MoKS5ub2RlcygpIGV0YyBjYW4gYmUgdXNlZFxuXHRcdHZhciBtb2RSb3dzID0gdGhpcy5yb3dzKCAtMSApO1xuXHRcdG1vZFJvd3MucG9wKCk7XG5cdFx0JC5tZXJnZSggbW9kUm93cywgbmV3Um93cyApO1xuXHRcblx0XHRyZXR1cm4gbW9kUm93cztcblx0fSApO1xuXHRcblx0XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3JvdygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLnJvd3MoIHNlbGVjdG9yLCBvcHRzICkgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3coKS5kYXRhKCknLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBHZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cblx0XHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9hRGF0YSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIFNldFxuXHRcdGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fYURhdGEgPSBkYXRhO1xuXHRcblx0XHQvLyBBdXRvbWF0aWNhbGx5IGludmFsaWRhdGVcblx0XHRfZm5JbnZhbGlkYXRlKCBjdHhbMF0sIHRoaXNbMF0sICdkYXRhJyApO1xuXHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3coKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xuXHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLm5UciB8fCBudWxsIDpcblx0XHRcdG51bGw7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93LmFkZCgpJywgZnVuY3Rpb24gKCByb3cgKSB7XG5cdFx0Ly8gQWxsb3cgYSBqUXVlcnkgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbiAtIG9ubHkgYSBzaW5nbGUgcm93IGlzIGFkZGVkIGZyb21cblx0XHQvLyBpdCB0aG91Z2ggLSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG5cdFx0aWYgKCByb3cgaW5zdGFuY2VvZiAkICYmIHJvdy5sZW5ndGggKSB7XG5cdFx0XHRyb3cgPSByb3dbMF07XG5cdFx0fVxuXHRcblx0XHR2YXIgcm93cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoIHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJyApIHtcblx0XHRcdFx0cmV0dXJuIF9mbkFkZFRyKCBzZXR0aW5ncywgcm93IClbMF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gX2ZuQWRkRGF0YSggc2V0dGluZ3MsIHJvdyApO1xuXHRcdH0gKTtcblx0XG5cdFx0Ly8gUmV0dXJuIGFuIEFwaS5yb3dzKCkgZXh0ZW5kZWQgaW5zdGFuY2UsIHdpdGggdGhlIG5ld2x5IGFkZGVkIHJvdyBzZWxlY3RlZFxuXHRcdHJldHVybiB0aGlzLnJvdyggcm93c1swXSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdHZhciBfX2RldGFpbHNfYWRkID0gZnVuY3Rpb24gKCBjdHgsIHJvdywgZGF0YSwga2xhc3MgKVxuXHR7XG5cdFx0Ly8gQ29udmVydCB0byBhcnJheSBvZiBUUiBlbGVtZW50c1xuXHRcdHZhciByb3dzID0gW107XG5cdFx0dmFyIGFkZFJvdyA9IGZ1bmN0aW9uICggciwgayApIHtcblx0XHRcdC8vIFJlY3Vyc2lvbiB0byBhbGxvdyBmb3IgYXJyYXlzIG9mIGpRdWVyeSBvYmplY3RzXG5cdFx0XHRpZiAoICQuaXNBcnJheSggciApIHx8IHIgaW5zdGFuY2VvZiAkICkge1xuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRhZGRSb3coIHJbaV0sIGsgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcblx0XHRcdC8vIHRvIGFkZCB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1ucyBldGNcblx0XHRcdGlmICggci5ub2RlTmFtZSAmJiByLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0cicgKSB7XG5cdFx0XHRcdHJvd3MucHVzaCggciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyd2lzZSBjcmVhdGUgYSByb3cgd2l0aCBhIHdyYXBwZXJcblx0XHRcdFx0dmFyIGNyZWF0ZWQgPSAkKCc8dHI+PHRkLz48L3RyPicpLmFkZENsYXNzKCBrICk7XG5cdFx0XHRcdCQoJ3RkJywgY3JlYXRlZClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIGsgKVxuXHRcdFx0XHRcdC5odG1sKCByIClcblx0XHRcdFx0XHRbMF0uY29sU3BhbiA9IF9mblZpc2JsZUNvbHVtbnMoIGN0eCApO1xuXHRcblx0XHRcdFx0cm93cy5wdXNoKCBjcmVhdGVkWzBdICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0YWRkUm93KCBkYXRhLCBrbGFzcyApO1xuXHRcblx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdHJvdy5fZGV0YWlscy5kZXRhY2goKTtcblx0XHR9XG5cdFxuXHRcdHJvdy5fZGV0YWlscyA9ICQocm93cyk7XG5cdFxuXHRcdC8vIElmIHRoZSBjaGlsZHJlbiB3ZXJlIGFscmVhZHkgc2hvd24sIHRoYXQgc3RhdGUgc2hvdWxkIGJlIHJldGFpbmVkXG5cdFx0aWYgKCByb3cuX2RldGFpbHNTaG93ICkge1xuXHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdHZhciBfX2RldGFpbHNfcmVtb3ZlID0gZnVuY3Rpb24gKCBhcGksIGlkeCApXG5cdHtcblx0XHR2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggY3R4Lmxlbmd0aCApIHtcblx0XHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyBpZHggIT09IHVuZGVmaW5lZCA/IGlkeCA6IGFwaVswXSBdO1xuXHRcblx0XHRcdGlmICggcm93ICYmIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdFx0cm93Ll9kZXRhaWxzLnJlbW92ZSgpO1xuXHRcblx0XHRcdFx0cm93Ll9kZXRhaWxzU2hvdyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cm93Ll9kZXRhaWxzID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdFxuXHR2YXIgX19kZXRhaWxzX2Rpc3BsYXkgPSBmdW5jdGlvbiAoIGFwaSwgc2hvdyApIHtcblx0XHR2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggY3R4Lmxlbmd0aCAmJiBhcGkubGVuZ3RoICkge1xuXHRcdFx0dmFyIHJvdyA9IGN0eFswXS5hb0RhdGFbIGFwaVswXSBdO1xuXHRcblx0XHRcdGlmICggcm93Ll9kZXRhaWxzICkge1xuXHRcdFx0XHRyb3cuX2RldGFpbHNTaG93ID0gc2hvdztcblx0XG5cdFx0XHRcdGlmICggc2hvdyApIHtcblx0XHRcdFx0XHRyb3cuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIoIHJvdy5uVHIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyb3cuX2RldGFpbHMuZGV0YWNoKCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdF9fZGV0YWlsc19ldmVudHMoIGN0eFswXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdFxuXHR2YXIgX19kZXRhaWxzX2V2ZW50cyA9IGZ1bmN0aW9uICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGFwaSA9IG5ldyBfQXBpKCBzZXR0aW5ncyApO1xuXHRcdHZhciBuYW1lc3BhY2UgPSAnLmR0LkRUX2RldGFpbHMnO1xuXHRcdHZhciBkcmF3RXZlbnQgPSAnZHJhdycrbmFtZXNwYWNlO1xuXHRcdHZhciBjb2x2aXNFdmVudCA9ICdjb2x1bW4tdmlzaWJpbGl0eScrbmFtZXNwYWNlO1xuXHRcdHZhciBkZXN0cm95RXZlbnQgPSAnZGVzdHJveScrbmFtZXNwYWNlO1xuXHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcblx0XHRhcGkub2ZmKCBkcmF3RXZlbnQgKycgJysgY29sdmlzRXZlbnQgKycgJysgZGVzdHJveUV2ZW50ICk7XG5cdFxuXHRcdGlmICggX3BsdWNrKCBkYXRhLCAnX2RldGFpbHMnICkubGVuZ3RoID4gMCApIHtcblx0XHRcdC8vIE9uIGVhY2ggZHJhdywgaW5zZXJ0IHRoZSByZXF1aXJlZCBlbGVtZW50cyBpbnRvIHRoZSBkb2N1bWVudFxuXHRcdFx0YXBpLm9uKCBkcmF3RXZlbnQsIGZ1bmN0aW9uICggZSwgY3R4ICkge1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRhcGkucm93cygge3BhZ2U6J2N1cnJlbnQnfSApLmVxKDApLmVhY2goIGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0XHQvLyBJbnRlcm5hbCBkYXRhIGdyYWJcblx0XHRcdFx0XHR2YXIgcm93ID0gZGF0YVsgaWR4IF07XG5cdFxuXHRcdFx0XHRcdGlmICggcm93Ll9kZXRhaWxzU2hvdyApIHtcblx0XHRcdFx0XHRcdHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlciggcm93Lm5UciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fSApO1xuXHRcblx0XHRcdC8vIENvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZSAtIHVwZGF0ZSB0aGUgY29sc3BhblxuXHRcdFx0YXBpLm9uKCBjb2x2aXNFdmVudCwgZnVuY3Rpb24gKCBlLCBjdHgsIGlkeCwgdmlzICkge1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIGNvbHNwYW4gZm9yIHRoZSBkZXRhaWxzIHJvd3MgKG5vdGUsIG9ubHkgaWYgaXQgYWxyZWFkeSBoYXNcblx0XHRcdFx0Ly8gYSBjb2xzcGFuKVxuXHRcdFx0XHR2YXIgcm93LCB2aXNpYmxlID0gX2ZuVmlzYmxlQ29sdW1ucyggY3R4ICk7XG5cdFxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRyb3cgPSBkYXRhW2ldO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdFx0XHRcdHJvdy5fZGV0YWlscy5jaGlsZHJlbigndGRbY29sc3Bhbl0nKS5hdHRyKCdjb2xzcGFuJywgdmlzaWJsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdC8vIFRhYmxlIGRlc3Ryb3llZCAtIG51a2UgYW55IGNoaWxkIHJvd3Ncblx0XHRcdGFwaS5vbiggZGVzdHJveUV2ZW50LCBmdW5jdGlvbiAoIGUsIGN0eCApIHtcblx0XHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhW2ldLl9kZXRhaWxzICkge1xuXHRcdFx0XHRcdFx0X19kZXRhaWxzX3JlbW92ZSggYXBpLCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0Ly8gU3RyaW5ncyBmb3IgdGhlIG1ldGhvZCBuYW1lcyB0byBoZWxwIG1pbmlmaWNhdGlvblxuXHR2YXIgX2VtcCA9ICcnO1xuXHR2YXIgX2NoaWxkX29iaiA9IF9lbXArJ3JvdygpLmNoaWxkJztcblx0dmFyIF9jaGlsZF9tdGggPSBfY2hpbGRfb2JqKycoKSc7XG5cdFxuXHQvLyBkYXRhIGNhbiBiZTpcblx0Ly8gIHRyXG5cdC8vICBzdHJpbmdcblx0Ly8gIGpRdWVyeSBvciBhcnJheSBvZiBhbnkgb2YgdGhlIGFib3ZlXG5cdF9hcGlfcmVnaXN0ZXIoIF9jaGlsZF9tdGgsIGZ1bmN0aW9uICggZGF0YSwga2xhc3MgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBnZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cblx0XHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9kZXRhaWxzIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XHRlbHNlIGlmICggZGF0YSA9PT0gdHJ1ZSApIHtcblx0XHRcdC8vIHNob3dcblx0XHRcdHRoaXMuY2hpbGQuc2hvdygpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggZGF0YSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyByZW1vdmVcblx0XHRcdF9fZGV0YWlsc19yZW1vdmUoIHRoaXMgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggKSB7XG5cdFx0XHQvLyBzZXRcblx0XHRcdF9fZGV0YWlsc19hZGQoIGN0eFswXSwgY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLCBkYXRhLCBrbGFzcyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCBbXG5cdFx0X2NoaWxkX29iaisnLnNob3coKScsXG5cdFx0X2NoaWxkX210aCsnLnNob3coKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuXHRdLCBmdW5jdGlvbiAoIHNob3cgKSB7ICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0XHRfX2RldGFpbHNfZGlzcGxheSggdGhpcywgdHJ1ZSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggW1xuXHRcdF9jaGlsZF9vYmorJy5oaWRlKCknLFxuXHRcdF9jaGlsZF9tdGgrJy5oaWRlKCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcblx0XSwgZnVuY3Rpb24gKCkgeyAgICAgICAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXG5cdFx0X19kZXRhaWxzX2Rpc3BsYXkoIHRoaXMsIGZhbHNlICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCBbXG5cdFx0X2NoaWxkX29iaisnLnJlbW92ZSgpJyxcblx0XHRfY2hpbGRfbXRoKycucmVtb3ZlKCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcblx0XSwgZnVuY3Rpb24gKCkgeyAgICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0XHRfX2RldGFpbHNfcmVtb3ZlKCB0aGlzICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCBfY2hpbGRfb2JqKycuaXNTaG93bigpJywgZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCApIHtcblx0XHRcdC8vIF9kZXRhaWxzU2hvd24gYXMgZmFsc2Ugb3IgdW5kZWZpbmVkIHdpbGwgZmFsbCB0aHJvdWdoIHRvIHJldHVybiBmYWxzZVxuXHRcdFx0cmV0dXJuIGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fZGV0YWlsc1Nob3cgfHwgZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogQ29sdW1uc1xuXHQgKlxuXHQgKiB7aW50ZWdlcn0gICAgICAgICAgIC0gY29sdW1uIGluZGV4ICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxuXHQgKiBcIntpbnRlZ2VyfTp2aXNJZHhcIiAgLSB2aXNpYmxlIGNvbHVtbiBpbmRleCAoaS5lLiB0cmFuc2xhdGUgdG8gY29sdW1uIGluZGV4KSAgKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXG5cdCAqIFwie2ludGVnZXJ9OnZpc2libGVcIiAtIGFsaWFzIGZvciB7aW50ZWdlcn06dmlzSWR4ICAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcblx0ICogXCJ7c3RyaW5nfTpuYW1lXCIgICAgIC0gY29sdW1uIG5hbWVcblx0ICogXCJ7c3RyaW5nfVwiICAgICAgICAgIC0galF1ZXJ5IHNlbGVjdG9yIG9uIGNvbHVtbiBoZWFkZXIgbm9kZXNcblx0ICpcblx0ICovXG5cdFxuXHQvLyBjYW4gYmUgYW4gYXJyYXkgb2YgdGhlc2UgaXRlbXMsIGNvbW1hIHNlcGFyYXRlZCBsaXN0LCBvciBhbiBhcnJheSBvZiBjb21tYVxuXHQvLyBzZXBhcmF0ZWQgbGlzdHNcblx0XG5cdHZhciBfX3JlX2NvbHVtbl9zZWxlY3RvciA9IC9eKFteOl0rKToobmFtZXx2aXNJZHh8dmlzaWJsZSkkLztcblx0XG5cdFxuXHQvLyByMSBhbmQgcjIgYXJlIHJlZHVuZGFudCAtIGJ1dCBpdCBtZWFucyB0aGF0IHRoZSBwYXJhbWV0ZXJzIG1hdGNoIGZvciB0aGVcblx0Ly8gaXRlcmF0b3IgY2FsbGJhY2sgaW4gY29sdW1ucygpLmRhdGEoKVxuXHR2YXIgX19jb2x1bW5EYXRhID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCByMSwgcjIsIHJvd3MgKSB7XG5cdFx0dmFyIGEgPSBbXTtcblx0XHRmb3IgKCB2YXIgcm93PTAsIGllbj1yb3dzLmxlbmd0aCA7IHJvdzxpZW4gOyByb3crKyApIHtcblx0XHRcdGEucHVzaCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dzW3Jvd10sIGNvbHVtbiApICk7XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfX2NvbHVtbl9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdG5hbWVzID0gX3BsdWNrKCBjb2x1bW5zLCAnc05hbWUnICksXG5cdFx0XHRub2RlcyA9IF9wbHVjayggY29sdW1ucywgJ25UaCcgKTtcblx0XG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzICk7XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBhbGxcblx0XHRcdGlmICggcyA9PT0gJycgKSB7XG5cdFx0XHRcdHJldHVybiBfcmFuZ2UoIGNvbHVtbnMubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBbIHNlbEludCA+PSAwID9cblx0XHRcdFx0XHRzZWxJbnQgOiAvLyBDb3VudCBmcm9tIGxlZnRcblx0XHRcdFx0XHRjb2x1bW5zLmxlbmd0aCArIHNlbEludCAvLyBDb3VudCBmcm9tIHJpZ2h0ICgrIGJlY2F1c2UgaXRzIGEgbmVnYXRpdmUgdmFsdWUpXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgPSBmdW5jdGlvblxuXHRcdFx0aWYgKCB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0dmFyIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoIHNldHRpbmdzLCBvcHRzICk7XG5cdFxuXHRcdFx0XHRyZXR1cm4gJC5tYXAoIGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGlkeCkge1xuXHRcdFx0XHRcdHJldHVybiBzKFxuXHRcdFx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0XHRcdF9fY29sdW1uRGF0YSggc2V0dGluZ3MsIGlkeCwgMCwgMCwgcm93cyApLFxuXHRcdFx0XHRcdFx0XHRub2Rlc1sgaWR4IF1cblx0XHRcdFx0XHRcdCkgPyBpZHggOiBudWxsO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8galF1ZXJ5IG9yIHN0cmluZyBzZWxlY3RvclxuXHRcdFx0dmFyIG1hdGNoID0gdHlwZW9mIHMgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0cy5tYXRjaCggX19yZV9jb2x1bW5fc2VsZWN0b3IgKSA6XG5cdFx0XHRcdCcnO1xuXHRcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdHN3aXRjaCggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0Y2FzZSAndmlzSWR4Jzpcblx0XHRcdFx0XHRjYXNlICd2aXNpYmxlJzpcblx0XHRcdFx0XHRcdHZhciBpZHggPSBwYXJzZUludCggbWF0Y2hbMV0sIDEwICk7XG5cdFx0XHRcdFx0XHQvLyBWaXNpYmxlIGluZGV4IGdpdmVuLCBjb252ZXJ0IHRvIGNvbHVtbiBpbmRleFxuXHRcdFx0XHRcdFx0aWYgKCBpZHggPCAwICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDb3VudGluZyBmcm9tIHRoZSByaWdodFxuXHRcdFx0XHRcdFx0XHR2YXIgdmlzQ29sdW1ucyA9ICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoY29sLGkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY29sLmJWaXNpYmxlID8gaSA6IG51bGw7XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgdmlzQ29sdW1uc1sgdmlzQ29sdW1ucy5sZW5ndGggKyBpZHggXSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gQ291bnRpbmcgZnJvbSB0aGUgbGVmdFxuXHRcdFx0XHRcdFx0cmV0dXJuIFsgX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIHNldHRpbmdzLCBpZHggKSBdO1xuXHRcblx0XHRcdFx0XHRjYXNlICduYW1lJzpcblx0XHRcdFx0XHRcdC8vIG1hdGNoIGJ5IG5hbWUuIGBuYW1lc2AgaXMgY29sdW1uIGluZGV4IGNvbXBsZXRlIGFuZCBpbiBvcmRlclxuXHRcdFx0XHRcdFx0cmV0dXJuICQubWFwKCBuYW1lcywgZnVuY3Rpb24gKG5hbWUsIGkpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5hbWUgPT09IG1hdGNoWzFdID8gaSA6IG51bGw7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBDZWxsIGluIHRoZSB0YWJsZSBib2R5XG5cdFx0XHRpZiAoIHMubm9kZU5hbWUgJiYgcy5fRFRfQ2VsbEluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gWyBzLl9EVF9DZWxsSW5kZXguY29sdW1uIF07XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8galF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSBUSCBlbGVtZW50cyBmb3IgdGhlIGNvbHVtbnNcblx0XHRcdHZhciBqcVJlc3VsdCA9ICQoIG5vZGVzIClcblx0XHRcdFx0LmZpbHRlciggcyApXG5cdFx0XHRcdC5tYXAoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5pbkFycmF5KCB0aGlzLCBub2RlcyApOyAvLyBgbm9kZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcblx0XHRcdFx0fSApXG5cdFx0XHRcdC50b0FycmF5KCk7XG5cdFxuXHRcdFx0aWYgKCBqcVJlc3VsdC5sZW5ndGggfHwgISBzLm5vZGVOYW1lICkge1xuXHRcdFx0XHRyZXR1cm4ganFSZXN1bHQ7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGEgbm9kZSB3aGljaCBtaWdodCBoYXZlIGEgYGR0LWNvbHVtbmAgZGF0YSBhdHRyaWJ1dGUsIG9yIGJlXG5cdFx0XHQvLyBhIGNoaWxkIG9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0dmFyIGhvc3QgPSAkKHMpLmNsb3Nlc3QoJypbZGF0YS1kdC1jb2x1bW5dJyk7XG5cdFx0XHRyZXR1cm4gaG9zdC5sZW5ndGggP1xuXHRcdFx0XHRbIGhvc3QuZGF0YSgnZHQtY29sdW1uJykgXSA6XG5cdFx0XHRcdFtdO1xuXHRcdH07XG5cdFxuXHRcdHJldHVybiBfc2VsZWN0b3JfcnVuKCAnY29sdW1uJywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMgKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX19zZXRDb2x1bW5WaXMgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIHZpcyApIHtcblx0XHR2YXJcblx0XHRcdGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRjb2wgID0gY29sc1sgY29sdW1uIF0sXG5cdFx0XHRkYXRhID0gc2V0dGluZ3MuYW9EYXRhLFxuXHRcdFx0cm93LCBjZWxscywgaSwgaWVuLCB0cjtcblx0XG5cdFx0Ly8gR2V0XG5cdFx0aWYgKCB2aXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBjb2wuYlZpc2libGU7XG5cdFx0fVxuXHRcblx0XHQvLyBTZXRcblx0XHQvLyBObyBjaGFuZ2Vcblx0XHRpZiAoIGNvbC5iVmlzaWJsZSA9PT0gdmlzICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCB2aXMgKSB7XG5cdFx0XHQvLyBJbnNlcnQgY29sdW1uXG5cdFx0XHQvLyBOZWVkIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgdXNlIGFwcGVuZENoaWxkIG9yIGluc2VydEJlZm9yZVxuXHRcdFx0dmFyIGluc2VydEJlZm9yZSA9ICQuaW5BcnJheSggdHJ1ZSwgX3BsdWNrKGNvbHMsICdiVmlzaWJsZScpLCBjb2x1bW4rMSApO1xuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHRyID0gZGF0YVtpXS5uVHI7XG5cdFx0XHRcdGNlbGxzID0gZGF0YVtpXS5hbkNlbGxzO1xuXHRcblx0XHRcdFx0aWYgKCB0ciApIHtcblx0XHRcdFx0XHQvLyBpbnNlcnRCZWZvcmUgY2FuIGFjdCBsaWtlIGFwcGVuZENoaWxkIGlmIDJuZCBhcmcgaXMgbnVsbFxuXHRcdFx0XHRcdHRyLmluc2VydEJlZm9yZSggY2VsbHNbIGNvbHVtbiBdLCBjZWxsc1sgaW5zZXJ0QmVmb3JlIF0gfHwgbnVsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVtb3ZlIGNvbHVtblxuXHRcdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sdW1uICkgKS5kZXRhY2goKTtcblx0XHR9XG5cdFxuXHRcdC8vIENvbW1vbiBhY3Rpb25zXG5cdFx0Y29sLmJWaXNpYmxlID0gdmlzO1xuXHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9IZWFkZXIgKTtcblx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvRm9vdGVyICk7XG5cdFxuXHRcdF9mblNhdmVTdGF0ZSggc2V0dGluZ3MgKTtcblx0fTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY29sdW1ucygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHQvLyBhcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNlbGVjdG9yID0gJyc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRvcHRzID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9ICcnO1xuXHRcdH1cblx0XG5cdFx0b3B0cyA9IF9zZWxlY3Rvcl9vcHRzKCBvcHRzICk7XG5cdFxuXHRcdHZhciBpbnN0ID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHJldHVybiBfX2NvbHVtbl9zZWxlY3Rvciggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzICk7XG5cdFx0fSwgMSApO1xuXHRcblx0XHQvLyBXYW50IGFyZ3VtZW50IHNoaWZ0aW5nIGhlcmUgYW5kIGluIF9yb3dfc2VsZWN0b3I/XG5cdFx0aW5zdC5zZWxlY3Rvci5jb2xzID0gc2VsZWN0b3I7XG5cdFx0aW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcblx0XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuaGVhZGVyKCknLCAnY29sdW1uKCkuaGVhZGVyKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm5UaDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZm9vdGVyKCknLCAnY29sdW1uKCkuZm9vdGVyKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm5UZjtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGF0YSgpJywgJ2NvbHVtbigpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbi1yb3dzJywgX19jb2x1bW5EYXRhLCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGF0YVNyYygpJywgJ2NvbHVtbigpLmRhdGFTcmMoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXS5tRGF0YTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuY2FjaGUoKScsICdjb2x1bW4oKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsXG5cdFx0XHRcdHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YScsIGNvbHVtblxuXHRcdFx0KTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkubm9kZXMoKScsICdjb2x1bW4oKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICdhbkNlbGxzJywgY29sdW1uICkgO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS52aXNpYmxlKCknLCAnY29sdW1uKCkudmlzaWJsZSgpJywgZnVuY3Rpb24gKCB2aXMsIGNhbGMgKSB7XG5cdFx0dmFyIHJldCA9IHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRpZiAoIHZpcyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2x1bW4gXS5iVmlzaWJsZTtcblx0XHRcdH0gLy8gZWxzZVxuXHRcdFx0X19zZXRDb2x1bW5WaXMoIHNldHRpbmdzLCBjb2x1bW4sIHZpcyApO1xuXHRcdH0gKTtcblx0XG5cdFx0Ly8gR3JvdXAgdGhlIGNvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZXNcblx0XHRpZiAoIHZpcyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gU2Vjb25kIGxvb3Agb25jZSB0aGUgZmlyc3QgaXMgZG9uZSBmb3IgZXZlbnRzXG5cdFx0XHR0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnY29sdW1uLXZpc2liaWxpdHknLCBbc2V0dGluZ3MsIGNvbHVtbiwgdmlzLCBjYWxjXSApO1xuXHRcdFx0fSApO1xuXHRcblx0XHRcdGlmICggY2FsYyA9PT0gdW5kZWZpbmVkIHx8IGNhbGMgKSB7XG5cdFx0XHRcdHRoaXMuY29sdW1ucy5hZGp1c3QoKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiByZXQ7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuaW5kZXhlcygpJywgJ2NvbHVtbigpLmluZGV4KCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gdHlwZSA9PT0gJ3Zpc2libGUnID9cblx0XHRcdFx0X2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoIHNldHRpbmdzLCBjb2x1bW4gKSA6XG5cdFx0XHRcdGNvbHVtbjtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjb2x1bW5zLmFkanVzdCgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0X2ZuQWRqdXN0Q29sdW1uU2l6aW5nKCBzZXR0aW5ncyApO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NvbHVtbi5pbmRleCgpJywgZnVuY3Rpb24gKCB0eXBlLCBpZHggKSB7XG5cdFx0aWYgKCB0aGlzLmNvbnRleHQubGVuZ3RoICE9PSAwICkge1xuXHRcdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcblx0XG5cdFx0XHRpZiAoIHR5cGUgPT09ICdmcm9tVmlzaWJsZScgfHwgdHlwZSA9PT0gJ3RvRGF0YScgKSB7XG5cdFx0XHRcdHJldHVybiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCggY3R4LCBpZHggKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlID09PSAnZnJvbURhdGEnIHx8IHR5cGUgPT09ICd0b1Zpc2libGUnICkge1xuXHRcdFx0XHRyZXR1cm4gX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoIGN0eCwgaWR4ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY29sdW1uKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdHJldHVybiBfc2VsZWN0b3JfZmlyc3QoIHRoaXMuY29sdW1ucyggc2VsZWN0b3IsIG9wdHMgKSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdHZhciBfX2NlbGxfc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG5cdHtcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblx0XHR2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblx0XHR2YXIgY2VsbHMgPSBfcmVtb3ZlRW1wdHkoIF9wbHVja19vcmRlciggZGF0YSwgcm93cywgJ2FuQ2VsbHMnICkgKTtcblx0XHR2YXIgYWxsQ2VsbHMgPSAkKCBbXS5jb25jYXQuYXBwbHkoW10sIGNlbGxzKSApO1xuXHRcdHZhciByb3c7XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHRcdHZhciBhLCBpLCBpZW4sIGosIG8sIGhvc3Q7XG5cdFxuXHRcdHZhciBydW4gPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0XHR2YXIgZm5TZWxlY3RvciA9IHR5cGVvZiBzID09PSAnZnVuY3Rpb24nO1xuXHRcblx0XHRcdGlmICggcyA9PT0gbnVsbCB8fCBzID09PSB1bmRlZmluZWQgfHwgZm5TZWxlY3RvciApIHtcblx0XHRcdFx0Ly8gQWxsIGNlbGxzIGFuZCBmdW5jdGlvbiBzZWxlY3RvcnNcblx0XHRcdFx0YSA9IFtdO1xuXHRcblx0XHRcdFx0Zm9yICggaT0wLCBpZW49cm93cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRyb3cgPSByb3dzW2ldO1xuXHRcblx0XHRcdFx0XHRmb3IgKCBqPTAgOyBqPGNvbHVtbnMgOyBqKysgKSB7XG5cdFx0XHRcdFx0XHRvID0ge1xuXHRcdFx0XHRcdFx0XHRyb3c6IHJvdyxcblx0XHRcdFx0XHRcdFx0Y29sdW1uOiBqXG5cdFx0XHRcdFx0XHR9O1xuXHRcblx0XHRcdFx0XHRcdGlmICggZm5TZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBmdW5jdGlvblxuXHRcdFx0XHRcdFx0XHRob3N0ID0gZGF0YVsgcm93IF07XG5cdFxuXHRcdFx0XHRcdFx0XHRpZiAoIHMoIG8sIF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3csIGopLCBob3N0LmFuQ2VsbHMgPyBob3N0LmFuQ2VsbHNbal0gOiBudWxsICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0YS5wdXNoKCBvICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBTZWxlY3RvciAtIGFsbFxuXHRcdFx0XHRcdFx0XHRhLnB1c2goIG8gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIGluZGV4XG5cdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggcyApICkge1xuXHRcdFx0XHRyZXR1cm4gW3NdO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlbGVjdG9yIC0galF1ZXJ5IGZpbHRlcmVkIGNlbGxzXG5cdFx0XHR2YXIganFSZXN1bHQgPSBhbGxDZWxsc1xuXHRcdFx0XHQuZmlsdGVyKCBzIClcblx0XHRcdFx0Lm1hcCggZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgLy8gdXNlIGEgbmV3IG9iamVjdCwgaW4gY2FzZSBzb21lb25lIGNoYW5nZXMgdGhlIHZhbHVlc1xuXHRcdFx0XHRcdFx0cm93OiAgICBlbC5fRFRfQ2VsbEluZGV4LnJvdyxcblx0XHRcdFx0XHRcdGNvbHVtbjogZWwuX0RUX0NlbGxJbmRleC5jb2x1bW5cblx0IFx0XHRcdFx0fTtcblx0XHRcdFx0fSApXG5cdFx0XHRcdC50b0FycmF5KCk7XG5cdFxuXHRcdFx0aWYgKCBqcVJlc3VsdC5sZW5ndGggfHwgISBzLm5vZGVOYW1lICkge1xuXHRcdFx0XHRyZXR1cm4ganFSZXN1bHQ7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBpcyBhIG5vZGUsIGFuZCB0aGVyZSBpcyBvbmUgbGFzdCBvcHRpb24gLSB0aGVcblx0XHRcdC8vIGVsZW1lbnQgbWlnaHQgYmUgYSBjaGlsZCBvZiBhbiBlbGVtZW50IHdoaWNoIGhhcyBkdC1yb3cgYW5kIGR0LWNvbHVtblxuXHRcdFx0Ly8gZGF0YSBhdHRyaWJ1dGVzXG5cdFx0XHRob3N0ID0gJChzKS5jbG9zZXN0KCcqW2RhdGEtZHQtcm93XScpO1xuXHRcdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFx0WyB7XG5cdFx0XHRcdFx0cm93OiBob3N0LmRhdGEoJ2R0LXJvdycpLFxuXHRcdFx0XHRcdGNvbHVtbjogaG9zdC5kYXRhKCdkdC1jb2x1bW4nKVxuXHRcdFx0XHR9IF0gOlxuXHRcdFx0XHRbXTtcblx0XHR9O1xuXHRcblx0XHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ2NlbGwnLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyApO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NlbGxzKCknLCBmdW5jdGlvbiAoIHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cyApIHtcblx0XHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCByb3dTZWxlY3RvciApICkge1xuXHRcdFx0Ly8gSW5kZXhlc1xuXHRcdFx0aWYgKCByb3dTZWxlY3Rvci5yb3cgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gU2VsZWN0b3Igb3B0aW9ucyBpbiBmaXJzdCBwYXJhbWV0ZXJcblx0XHRcdFx0b3B0cyA9IHJvd1NlbGVjdG9yO1xuXHRcdFx0XHRyb3dTZWxlY3RvciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gQ2VsbCBpbmRleCBvYmplY3RzIGluIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0XHRcdGNvbHVtblNlbGVjdG9yID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIGNvbHVtblNlbGVjdG9yICkgKSB7XG5cdFx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0XHRjb2x1bW5TZWxlY3RvciA9IG51bGw7XG5cdFx0fVxuXHRcblx0XHQvLyBDZWxsIHNlbGVjdG9yXG5cdFx0aWYgKCBjb2x1bW5TZWxlY3RvciA9PT0gbnVsbCB8fCBjb2x1bW5TZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdHJldHVybiBfX2NlbGxfc2VsZWN0b3IoIHNldHRpbmdzLCByb3dTZWxlY3RvciwgX3NlbGVjdG9yX29wdHMoIG9wdHMgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0Ly8gUm93ICsgY29sdW1uIHNlbGVjdG9yXG5cdFx0dmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoIGNvbHVtblNlbGVjdG9yLCBvcHRzICk7XG5cdFx0dmFyIHJvd3MgPSB0aGlzLnJvd3MoIHJvd1NlbGVjdG9yLCBvcHRzICk7XG5cdFx0dmFyIGEsIGksIGllbiwgaiwgamVuO1xuXHRcblx0XHR2YXIgY2VsbHMgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpZHggKSB7XG5cdFx0XHRhID0gW107XG5cdFxuXHRcdFx0Zm9yICggaT0wLCBpZW49cm93c1tpZHhdLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBqPTAsIGplbj1jb2x1bW5zW2lkeF0ubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0YS5wdXNoKCB7XG5cdFx0XHRcdFx0XHRyb3c6ICAgIHJvd3NbaWR4XVtpXSxcblx0XHRcdFx0XHRcdGNvbHVtbjogY29sdW1uc1tpZHhdW2pdXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fSwgMSApO1xuXHRcblx0XHQkLmV4dGVuZCggY2VsbHMuc2VsZWN0b3IsIHtcblx0XHRcdGNvbHM6IGNvbHVtblNlbGVjdG9yLFxuXHRcdFx0cm93czogcm93U2VsZWN0b3IsXG5cdFx0XHRvcHRzOiBvcHRzXG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gY2VsbHM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5ub2RlcygpJywgJ2NlbGwoKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cdFxuXHRcdFx0cmV0dXJuIGRhdGEgJiYgZGF0YS5hbkNlbGxzID9cblx0XHRcdFx0ZGF0YS5hbkNlbGxzWyBjb2x1bW4gXSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY2VsbHMoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3csIGNvbHVtbiApO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmNhY2hlKCknLCAnY2VsbCgpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YSc7XG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvRGF0YVsgcm93IF1bIHR5cGUgXVsgY29sdW1uIF07XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkucmVuZGVyKCknLCAnY2VsbCgpLnJlbmRlcigpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93LCBjb2x1bW4sIHR5cGUgKTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5pbmRleGVzKCknLCAnY2VsbCgpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyb3c6IHJvdyxcblx0XHRcdFx0Y29sdW1uOiBjb2x1bW4sXG5cdFx0XHRcdGNvbHVtblZpc2libGU6IF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uIClcblx0XHRcdH07XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuaW52YWxpZGF0ZSgpJywgJ2NlbGwoKS5pbnZhbGlkYXRlKCknLCBmdW5jdGlvbiAoIHNyYyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRcdF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3csIHNyYywgY29sdW1uICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjZWxsKCknLCBmdW5jdGlvbiAoIHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cyApIHtcblx0XHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLmNlbGxzKCByb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMgKSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NlbGwoKS5kYXRhKCknLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XHR2YXIgY2VsbCA9IHRoaXNbMF07XG5cdFxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gR2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiBjZWxsLmxlbmd0aCA/XG5cdFx0XHRcdF9mbkdldENlbGxEYXRhKCBjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbiApIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2V0XG5cdFx0X2ZuU2V0Q2VsbERhdGEoIGN0eFswXSwgY2VsbFswXS5yb3csIGNlbGxbMF0uY29sdW1uLCBkYXRhICk7XG5cdFx0X2ZuSW52YWxpZGF0ZSggY3R4WzBdLCBjZWxsWzBdLnJvdywgJ2RhdGEnLCBjZWxsWzBdLmNvbHVtbiApO1xuXHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IGN1cnJlbnQgb3JkZXJpbmcgKHNvcnRpbmcpIHRoYXQgaGFzIGJlZW4gYXBwbGllZCB0byB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHthcnJheX0gMkQgYXJyYXkgY29udGFpbmluZyB0aGUgc29ydGluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0XG5cdCAqICAgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC4gRWFjaCBlbGVtZW50IGluIHRoZSBwYXJlbnQgYXJyYXkgcmVwcmVzZW50c1xuXHQgKiAgIGEgY29sdW1uIGJlaW5nIHNvcnRlZCB1cG9uIChpLmUuIG11bHRpLXNvcnRpbmcgd2l0aCB0d28gY29sdW1ucyB3b3VsZCBoYXZlXG5cdCAqICAgMiBpbm5lciBhcnJheXMpLiBUaGUgaW5uZXIgYXJyYXlzIG1heSBoYXZlIDIgb3IgMyBlbGVtZW50cy4gVGhlIGZpcnN0IGlzXG5cdCAqICAgdGhlIGNvbHVtbiBpbmRleCB0aGF0IHRoZSBzb3J0aW5nIGNvbmRpdGlvbiBhcHBsaWVzIHRvLCB0aGUgc2Vjb25kIGlzIHRoZVxuXHQgKiAgIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAoYGRlc2NgIG9yIGBhc2NgKSBhbmQsIG9wdGlvbmFsbHksIHRoZSB0aGlyZCBpcyB0aGVcblx0ICogICBpbmRleCBvZiB0aGUgc29ydGluZyBvcmRlciBmcm9tIHRoZSBgY29sdW1uLnNvcnRpbmdgIGluaXRpYWxpc2F0aW9uIGFycmF5LlxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ9IG9yZGVyIENvbHVtbiBpbmRleCB0byBzb3J0IHVwb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gRGlyZWN0aW9uIG9mIHRoZSBzb3J0IHRvIGJlIGFwcGxpZWQgKGBhc2NgIG9yIGBkZXNjYClcblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7YXJyYXl9IG9yZGVyIDFEIGFycmF5IG9mIHNvcnRpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXBwbGllZC5cblx0ICogQHBhcmFtIHthcnJheX0gWy4uLl0gT3B0aW9uYWwgYWRkaXRpb25hbCBzb3J0aW5nIGNvbmRpdGlvbnNcblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7YXJyYXl9IG9yZGVyIDJEIGFycmF5IG9mIHNvcnRpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXBwbGllZC5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnb3JkZXIoKScsIGZ1bmN0aW9uICggb3JkZXIsIGRpciApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIG9yZGVyID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBnZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cblx0XHRcdFx0Y3R4WzBdLmFhU29ydGluZyA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIHNldFxuXHRcdGlmICggdHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJyApIHtcblx0XHRcdC8vIFNpbXBsZSBjb2x1bW4gLyBkaXJlY3Rpb24gcGFzc2VkIGluXG5cdFx0XHRvcmRlciA9IFsgWyBvcmRlciwgZGlyIF0gXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9yZGVyLmxlbmd0aCAmJiAhICQuaXNBcnJheSggb3JkZXJbMF0gKSApIHtcblx0XHRcdC8vIEFyZ3VtZW50cyBwYXNzZWQgaW4gKGxpc3Qgb2YgMUQgYXJyYXlzKVxuXHRcdFx0b3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0fVxuXHRcdC8vIG90aGVyd2lzZSBhIDJEIGFycmF5IHdhcyBwYXNzZWQgaW5cblx0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSBvcmRlci5zbGljZSgpO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gY29sdW1uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bm9kZXxqUXVlcnl8c3RyaW5nfSBub2RlIElkZW50aWZpZXIgZm9yIHRoZSBlbGVtZW50KHMpIHRvIGF0dGFjaCB0aGVcblx0ICogICBsaXN0ZW5lciB0by4gVGhpcyBjYW4gdGFrZSB0aGUgZm9ybSBvZiBhIHNpbmdsZSBET00gbm9kZSwgYSBqUXVlcnlcblx0ICogICBjb2xsZWN0aW9uIG9mIG5vZGVzIG9yIGEgalF1ZXJ5IHNlbGVjdG9yIHdoaWNoIHdpbGwgaWRlbnRpZnkgdGhlIG5vZGUocykuXG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gY29sdW1uIHRoZSBjb2x1bW4gdGhhdCBhIGNsaWNrIG9uIHRoaXMgbm9kZSB3aWxsIHNvcnQgb25cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ29yZGVyLmxpc3RlbmVyKCknLCBmdW5jdGlvbiAoIG5vZGUsIGNvbHVtbiwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5Tb3J0QXR0YWNoTGlzdGVuZXIoIHNldHRpbmdzLCBub2RlLCBjb2x1bW4sIGNhbGxiYWNrICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ29yZGVyLmZpeGVkKCknLCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRpZiAoICEgc2V0ICkge1xuXHRcdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XHRcdHZhciBmaXhlZCA9IGN0eC5sZW5ndGggP1xuXHRcdFx0XHRjdHhbMF0uYWFTb3J0aW5nRml4ZWQgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFxuXHRcdFx0cmV0dXJuICQuaXNBcnJheSggZml4ZWQgKSA/XG5cdFx0XHRcdHsgcHJlOiBmaXhlZCB9IDpcblx0XHRcdFx0Zml4ZWQ7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkID0gJC5leHRlbmQoIHRydWUsIHt9LCBzZXQgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvLyBPcmRlciBieSB0aGUgc2VsZWN0ZWQgY29sdW1uKHMpXG5cdF9hcGlfcmVnaXN0ZXIoIFtcblx0XHQnY29sdW1ucygpLm9yZGVyKCknLFxuXHRcdCdjb2x1bW4oKS5vcmRlcigpJ1xuXHRdLCBmdW5jdGlvbiAoIGRpciApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpICkge1xuXHRcdFx0dmFyIHNvcnQgPSBbXTtcblx0XG5cdFx0XHQkLmVhY2goIHRoYXRbaV0sIGZ1bmN0aW9uIChqLCBjb2wpIHtcblx0XHRcdFx0c29ydC5wdXNoKCBbIGNvbCwgZGlyIF0gKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSBzb3J0O1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc2VhcmNoKCknLCBmdW5jdGlvbiAoIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbiApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBnZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cblx0XHRcdFx0Y3R4WzBdLm9QcmV2aW91c1NlYXJjaC5zU2VhcmNoIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XG5cdFx0Ly8gc2V0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoICEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsICQuZXh0ZW5kKCB7fSwgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCB7XG5cdFx0XHRcdFwic1NlYXJjaFwiOiBpbnB1dCtcIlwiLFxuXHRcdFx0XHRcImJSZWdleFwiOiAgcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxuXHRcdFx0XHRcImJTbWFydFwiOiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxuXHRcdFx0fSApLCAxICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbChcblx0XHQnY29sdW1ucygpLnNlYXJjaCgpJyxcblx0XHQnY29sdW1uKCkuc2VhcmNoKCknLFxuXHRcdGZ1bmN0aW9uICggaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2VuICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRcdHZhciBwcmVTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cdFxuXHRcdFx0XHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0XG5cdFx0XHRcdFx0cmV0dXJuIHByZVNlYXJjaFsgY29sdW1uIF0uc1NlYXJjaDtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gc2V0XG5cdFx0XHRcdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdCQuZXh0ZW5kKCBwcmVTZWFyY2hbIGNvbHVtbiBdLCB7XG5cdFx0XHRcdFx0XCJzU2VhcmNoXCI6IGlucHV0K1wiXCIsXG5cdFx0XHRcdFx0XCJiUmVnZXhcIjogIHJlZ2V4ID09PSBudWxsID8gZmFsc2UgOiByZWdleCxcblx0XHRcdFx0XHRcImJTbWFydFwiOiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XHRcdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiBjYXNlSW5zZW4gPT09IG51bGwgPyB0cnVlIDogY2FzZUluc2VuXG5cdFx0XHRcdH0gKTtcblx0XG5cdFx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCAxICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHQpO1xuXHRcblx0Lypcblx0ICogU3RhdGUgQVBJIG1ldGhvZHNcblx0ICovXG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc3RhdGUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCA/XG5cdFx0XHR0aGlzLmNvbnRleHRbMF0ub1NhdmVkU3RhdGUgOlxuXHRcdFx0bnVsbDtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzdGF0ZS5jbGVhcigpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0Ly8gU2F2ZSBhbiBlbXB0eSBvYmplY3Rcblx0XHRcdHNldHRpbmdzLmZuU3RhdGVTYXZlQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywge30gKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc3RhdGUubG9hZGVkKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggP1xuXHRcdFx0dGhpcy5jb250ZXh0WzBdLm9Mb2FkZWRTdGF0ZSA6XG5cdFx0XHRudWxsO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3N0YXRlLnNhdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mblNhdmVTdGF0ZSggc2V0dGluZ3MgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nXG5cdCAqIHVzZWQsIGluIG9yZGVyIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gVmVyc2lvbiBzdHJpbmcgdG8gY2hlY2sgZm9yLCBpbiB0aGUgZm9ybWF0IFwiWC5ZLlpcIi5cblx0ICogICAgTm90ZSB0aGF0IHRoZSBmb3JtYXRzIFwiWFwiIGFuZCBcIlguWVwiIGFyZSBhbHNvIGFjY2VwdGFibGUuXG5cdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvXG5cdCAqICAgIHRoZSByZXF1aXJlZCB2ZXJzaW9uLCBvciBmYWxzZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhbGVzIGlzIG5vdFxuXHQgKiAgICBzdWl0YWJsZVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGR0b3B0IEFQSS1TdGF0aWNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIGFsZXJ0KCAkLmZuLmRhdGFUYWJsZS52ZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xuXHQgKi9cblx0RGF0YVRhYmxlLnZlcnNpb25DaGVjayA9IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayA9IGZ1bmN0aW9uKCB2ZXJzaW9uIClcblx0e1xuXHRcdHZhciBhVGhpcyA9IERhdGFUYWJsZS52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGFUaGF0ID0gdmVyc2lvbi5zcGxpdCgnLicpO1xuXHRcdHZhciBpVGhpcywgaVRoYXQ7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49YVRoYXQubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0aVRoaXMgPSBwYXJzZUludCggYVRoaXNbaV0sIDEwICkgfHwgMDtcblx0XHRcdGlUaGF0ID0gcGFyc2VJbnQoIGFUaGF0W2ldLCAxMCApIHx8IDA7XG5cdFxuXHRcdFx0Ly8gUGFydHMgYXJlIHRoZSBzYW1lLCBrZWVwIGNvbXBhcmluZ1xuXHRcdFx0aWYgKGlUaGlzID09PSBpVGhhdCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBQYXJ0cyBhcmUgZGlmZmVyZW50LCByZXR1cm4gaW1tZWRpYXRlbHlcblx0XHRcdHJldHVybiBpVGhpcyA+IGlUaGF0O1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIGEgYDx0YWJsZT5gIG5vZGUgaXMgYSBEYXRhVGFibGUgdGFibGUgYWxyZWFkeSBvciBub3QuXG5cdCAqXG5cdCAqICBAcGFyYW0ge25vZGV8anF1ZXJ5fHN0cmluZ30gdGFibGUgVGFibGUgbm9kZSwgalF1ZXJ5IG9iamVjdCBvciBqUXVlcnlcblx0ICogICAgICBzZWxlY3RvciBmb3IgdGhlIHRhYmxlIHRvIHRlc3QuIE5vdGUgdGhhdCBpZiBtb3JlIHRoYW4gbW9yZSB0aGFuIG9uZVxuXHQgKiAgICAgIHRhYmxlIGlzIHBhc3NlZCBvbiwgb25seSB0aGUgZmlyc3Qgd2lsbCBiZSBjaGVja2VkXG5cdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSB0aGUgdGFibGUgZ2l2ZW4gaXMgYSBEYXRhVGFibGUsIG9yIGZhbHNlIG90aGVyd2lzZVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGR0b3B0IEFQSS1TdGF0aWNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIGlmICggISAkLmZuLkRhdGFUYWJsZS5pc0RhdGFUYWJsZSggJyNleGFtcGxlJyApICkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqICAgIH1cblx0ICovXG5cdERhdGFUYWJsZS5pc0RhdGFUYWJsZSA9IERhdGFUYWJsZS5mbklzRGF0YVRhYmxlID0gZnVuY3Rpb24gKCB0YWJsZSApXG5cdHtcblx0XHR2YXIgdCA9ICQodGFibGUpLmdldCgwKTtcblx0XHR2YXIgaXMgPSBmYWxzZTtcblx0XG5cdFx0aWYgKCB0YWJsZSBpbnN0YW5jZW9mIERhdGFUYWJsZS5BcGkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdCQuZWFjaCggRGF0YVRhYmxlLnNldHRpbmdzLCBmdW5jdGlvbiAoaSwgbykge1xuXHRcdFx0dmFyIGhlYWQgPSBvLm5TY3JvbGxIZWFkID8gJCgndGFibGUnLCBvLm5TY3JvbGxIZWFkKVswXSA6IG51bGw7XG5cdFx0XHR2YXIgZm9vdCA9IG8ublNjcm9sbEZvb3QgPyAkKCd0YWJsZScsIG8ublNjcm9sbEZvb3QpWzBdIDogbnVsbDtcblx0XG5cdFx0XHRpZiAoIG8ublRhYmxlID09PSB0IHx8IGhlYWQgPT09IHQgfHwgZm9vdCA9PT0gdCApIHtcblx0XHRcdFx0aXMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGlzO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgYWxsIERhdGFUYWJsZSB0YWJsZXMgdGhhdCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQgLSBvcHRpb25hbGx5IHlvdSBjYW5cblx0ICogc2VsZWN0IHRvIGdldCBvbmx5IGN1cnJlbnRseSB2aXNpYmxlIHRhYmxlcy5cblx0ICpcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW3Zpc2libGU9ZmFsc2VdIEZsYWcgdG8gaW5kaWNhdGUgaWYgeW91IHdhbnQgYWxsIChkZWZhdWx0KVxuXHQgKiAgICBvciB2aXNpYmxlIHRhYmxlcyBvbmx5LlxuXHQgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBgdGFibGVgIG5vZGVzIChub3QgRGF0YVRhYmxlIGluc3RhbmNlcykgd2hpY2ggYXJlXG5cdCAqICAgIERhdGFUYWJsZXNcblx0ICogIEBzdGF0aWNcblx0ICogIEBkdG9wdCBBUEktU3RhdGljXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkLmVhY2goICQuZm4uZGF0YVRhYmxlLnRhYmxlcyh0cnVlKSwgZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQodGFibGUpLkRhdGFUYWJsZSgpLmNvbHVtbnMuYWRqdXN0KCk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdERhdGFUYWJsZS50YWJsZXMgPSBEYXRhVGFibGUuZm5UYWJsZXMgPSBmdW5jdGlvbiAoIHZpc2libGUgKVxuXHR7XG5cdFx0dmFyIGFwaSA9IGZhbHNlO1xuXHRcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmlzaWJsZSApICkge1xuXHRcdFx0YXBpID0gdmlzaWJsZS5hcGk7XG5cdFx0XHR2aXNpYmxlID0gdmlzaWJsZS52aXNpYmxlO1xuXHRcdH1cblx0XG5cdFx0dmFyIGEgPSAkLm1hcCggRGF0YVRhYmxlLnNldHRpbmdzLCBmdW5jdGlvbiAobykge1xuXHRcdFx0aWYgKCAhdmlzaWJsZSB8fCAodmlzaWJsZSAmJiAkKG8ublRhYmxlKS5pcygnOnZpc2libGUnKSkgKSB7XG5cdFx0XHRcdHJldHVybiBvLm5UYWJsZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiBhcGkgP1xuXHRcdFx0bmV3IF9BcGkoIGEgKSA6XG5cdFx0XHRhO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiBub3RhdGlvbi4gVGhpcyBpcyBtYWRlIHB1YmxpY1xuXHQgKiBmb3IgdGhlIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSB0aGUgc2FtZSBhYmlsaXR5IGFzIERhdGFUYWJsZXMgY29yZSB0byBhY2NlcHRcblx0ICogZWl0aGVyIHRoZSAxLjkgc3R5bGUgSHVuZ2FyaWFuIG5vdGF0aW9uLCBvciB0aGUgMS4xMCsgc3R5bGUgY2FtZWxDYXNlXG5cdCAqIHBhcmFtZXRlcnMuXG5cdCAqXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcblx0ICogICAgbWFwcGVkLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxuXHQgKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcblx0ICogICAgd29uJ3QgYmUuXG5cdCAqL1xuXHREYXRhVGFibGUuY2FtZWxUb0h1bmdhcmlhbiA9IF9mbkNhbWVsVG9IdW5nYXJpYW47XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJyQoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0dmFyXG5cdFx0XHRyb3dzICAgPSB0aGlzLnJvd3MoIG9wdHMgKS5ub2RlcygpLCAvLyBHZXQgYWxsIHJvd3Ncblx0XHRcdGpxUm93cyA9ICQocm93cyk7XG5cdFxuXHRcdHJldHVybiAkKCBbXS5jb25jYXQoXG5cdFx0XHRqcVJvd3MuZmlsdGVyKCBzZWxlY3RvciApLnRvQXJyYXkoKSxcblx0XHRcdGpxUm93cy5maW5kKCBzZWxlY3RvciApLnRvQXJyYXkoKVxuXHRcdCkgKTtcblx0fSApO1xuXHRcblx0XG5cdC8vIGpRdWVyeSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiB0aGUgdGFibGVzXG5cdCQuZWFjaCggWyAnb24nLCAnb25lJywgJ29mZicgXSwgZnVuY3Rpb24gKGksIGtleSkge1xuXHRcdF9hcGlfcmVnaXN0ZXIoIGtleSsnKCknLCBmdW5jdGlvbiAoIC8qIGV2ZW50LCBoYW5kbGVyICovICkge1xuXHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcblx0XHRcdC8vIEFkZCB0aGUgYGR0YCBuYW1lc3BhY2UgYXV0b21hdGljYWxseSBpZiBpdCBpc24ndCBhbHJlYWR5IHByZXNlbnRcblx0XHRcdGFyZ3NbMF0gPSAkLm1hcCggYXJnc1swXS5zcGxpdCggL1xccy8gKSwgZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0XHRyZXR1cm4gISBlLm1hdGNoKC9cXC5kdFxcYi8pID9cblx0XHRcdFx0XHRlKycuZHQnIDpcblx0XHRcdFx0XHRlO1xuXHRcdFx0XHR9ICkuam9pbiggJyAnICk7XG5cdFxuXHRcdFx0dmFyIGluc3QgPSAkKCB0aGlzLnRhYmxlcygpLm5vZGVzKCkgKTtcblx0XHRcdGluc3Rba2V5XS5hcHBseSggaW5zdCwgYXJncyApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NsZWFyKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzZXR0aW5ncygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCB0aGlzLmNvbnRleHQgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdpbml0KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA/IGN0eFswXS5vSW5pdCA6IG51bGw7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xuXHRcdH0gKS5mbGF0dGVuKCk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnZGVzdHJveSgpJywgZnVuY3Rpb24gKCByZW1vdmUgKSB7XG5cdFx0cmVtb3ZlID0gcmVtb3ZlIHx8IGZhbHNlO1xuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciBvcmlnICAgICAgPSBzZXR0aW5ncy5uVGFibGVXcmFwcGVyLnBhcmVudE5vZGU7XG5cdFx0XHR2YXIgY2xhc3NlcyAgID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0XHR2YXIgdGFibGUgICAgID0gc2V0dGluZ3MublRhYmxlO1xuXHRcdFx0dmFyIHRib2R5ICAgICA9IHNldHRpbmdzLm5UQm9keTtcblx0XHRcdHZhciB0aGVhZCAgICAgPSBzZXR0aW5ncy5uVEhlYWQ7XG5cdFx0XHR2YXIgdGZvb3QgICAgID0gc2V0dGluZ3MublRGb290O1xuXHRcdFx0dmFyIGpxVGFibGUgICA9ICQodGFibGUpO1xuXHRcdFx0dmFyIGpxVGJvZHkgICA9ICQodGJvZHkpO1xuXHRcdFx0dmFyIGpxV3JhcHBlciA9ICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcik7XG5cdFx0XHR2YXIgcm93cyAgICAgID0gJC5tYXAoIHNldHRpbmdzLmFvRGF0YSwgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIublRyOyB9ICk7XG5cdFx0XHR2YXIgaSwgaWVuO1xuXHRcblx0XHRcdC8vIEZsYWcgdG8gbm90ZSB0aGF0IHRoZSB0YWJsZSBpcyBjdXJyZW50bHkgYmVpbmcgZGVzdHJveWVkIC0gbm8gYWN0aW9uXG5cdFx0XHQvLyBzaG91bGQgYmUgdGFrZW5cblx0XHRcdHNldHRpbmdzLmJEZXN0cm95aW5nID0gdHJ1ZTtcblx0XG5cdFx0XHQvLyBGaXJlIG9mZiB0aGUgZGVzdHJveSBjYWxsYmFja3MgZm9yIHBsdWctaW5zIGV0Y1xuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgXCJhb0Rlc3Ryb3lDYWxsYmFja1wiLCBcImRlc3Ryb3lcIiwgW3NldHRpbmdzXSApO1xuXHRcblx0XHRcdC8vIElmIG5vdCBiZWluZyByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50LCBtYWtlIGFsbCBjb2x1bW5zIHZpc2libGVcblx0XHRcdGlmICggISByZW1vdmUgKSB7XG5cdFx0XHRcdG5ldyBfQXBpKCBzZXR0aW5ncyApLmNvbHVtbnMoKS52aXNpYmxlKCB0cnVlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQmxpdHogYWxsIGBEVGAgbmFtZXNwYWNlZCBldmVudHMgKHRoZXNlIGFyZSBpbnRlcm5hbCBldmVudHMsIHRoZVxuXHRcdFx0Ly8gbG93ZXJjYXNlLCBgZHRgIGV2ZW50cyBhcmUgdXNlciBzdWJzY3JpYmVkIGFuZCB0aGV5IGFyZSByZXNwb25zaWJsZVxuXHRcdFx0Ly8gZm9yIHJlbW92aW5nIHRoZW1cblx0XHRcdGpxV3JhcHBlci5vZmYoJy5EVCcpLmZpbmQoJzpub3QodGJvZHkgKiknKS5vZmYoJy5EVCcpO1xuXHRcdFx0JCh3aW5kb3cpLm9mZignLkRULScrc2V0dGluZ3Muc0luc3RhbmNlKTtcblx0XG5cdFx0XHQvLyBXaGVuIHNjcm9sbGluZyB3ZSBoYWQgdG8gYnJlYWsgdGhlIHRhYmxlIHVwIC0gcmVzdG9yZSBpdFxuXHRcdFx0aWYgKCB0YWJsZSAhPSB0aGVhZC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRqcVRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpLmRldGFjaCgpO1xuXHRcdFx0XHRqcVRhYmxlLmFwcGVuZCggdGhlYWQgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHRmb290ICYmIHRhYmxlICE9IHRmb290LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGpxVGFibGUuY2hpbGRyZW4oJ3Rmb290JykuZGV0YWNoKCk7XG5cdFx0XHRcdGpxVGFibGUuYXBwZW5kKCB0Zm9vdCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQgPSBbXTtcblx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdCQoIHJvd3MgKS5yZW1vdmVDbGFzcyggc2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzLmpvaW4oJyAnKSApO1xuXHRcblx0XHRcdCQoJ3RoLCB0ZCcsIHRoZWFkKS5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zU29ydGFibGUrJyAnK1xuXHRcdFx0XHRjbGFzc2VzLnNTb3J0YWJsZUFzYysnICcrY2xhc3Nlcy5zU29ydGFibGVEZXNjKycgJytjbGFzc2VzLnNTb3J0YWJsZU5vbmVcblx0XHRcdCk7XG5cdFxuXHRcdFx0aWYgKCBzZXR0aW5ncy5iSlVJICkge1xuXHRcdFx0XHQkKCd0aCBzcGFuLicrY2xhc3Nlcy5zU29ydEljb24rICcsIHRkIHNwYW4uJytjbGFzc2VzLnNTb3J0SWNvbiwgdGhlYWQpLmRldGFjaCgpO1xuXHRcdFx0XHQkKCd0aCwgdGQnLCB0aGVhZCkuZWFjaCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciB3cmFwcGVyID0gJCgnZGl2LicrY2xhc3Nlcy5zU29ydEpVSVdyYXBwZXIsIHRoaXMpO1xuXHRcdFx0XHRcdCQodGhpcykuYXBwZW5kKCB3cmFwcGVyLmNvbnRlbnRzKCkgKTtcblx0XHRcdFx0XHR3cmFwcGVyLmRldGFjaCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQWRkIHRoZSBUUiBlbGVtZW50cyBiYWNrIGludG8gdGhlIHRhYmxlIGluIHRoZWlyIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRqcVRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdFx0XHRqcVRib2R5LmFwcGVuZCggcm93cyApO1xuXHRcblx0XHRcdC8vIFJlbW92ZSB0aGUgRGF0YVRhYmxlcyBnZW5lcmF0ZWQgbm9kZXMsIGV2ZW50cyBhbmQgY2xhc3Nlc1xuXHRcdFx0dmFyIHJlbW92ZWRNZXRob2QgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdkZXRhY2gnO1xuXHRcdFx0anFUYWJsZVsgcmVtb3ZlZE1ldGhvZCBdKCk7XG5cdFx0XHRqcVdyYXBwZXJbIHJlbW92ZWRNZXRob2QgXSgpO1xuXHRcblx0XHRcdC8vIElmIHdlIG5lZWQgdG8gcmVhdHRhY2ggdGhlIHRhYmxlIHRvIHRoZSBkb2N1bWVudFxuXHRcdFx0aWYgKCAhIHJlbW92ZSAmJiBvcmlnICkge1xuXHRcdFx0XHQvLyBpbnNlcnRCZWZvcmUgYWN0cyBsaWtlIGFwcGVuZENoaWxkIGlmICFhcmdbMV1cblx0XHRcdFx0b3JpZy5pbnNlcnRCZWZvcmUoIHRhYmxlLCBzZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSApO1xuXHRcblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIHRhYmxlIC0gd2FzIHJlYWQgZnJvbSB0aGUgc3R5bGUgcHJvcGVydHksXG5cdFx0XHRcdC8vIHNvIHdlIGNhbiByZXN0b3JlIGRpcmVjdGx5IHRvIHRoYXRcblx0XHRcdFx0anFUYWJsZVxuXHRcdFx0XHRcdC5jc3MoICd3aWR0aCcsIHNldHRpbmdzLnNEZXN0cm95V2lkdGggKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zVGFibGUgKTtcblx0XG5cdFx0XHRcdC8vIElmIHRoZSB3ZXJlIG9yaWdpbmFsbHkgc3RyaXBlIGNsYXNzZXMgLSB0aGVuIHdlIGFkZCB0aGVtIGJhY2sgaGVyZS5cblx0XHRcdFx0Ly8gTm90ZSB0aGlzIGlzIG5vdCBmb29sIHByb29mIChmb3IgZXhhbXBsZSBpZiBub3QgYWxsIHJvd3MgaGFkIHN0cmlwZVxuXHRcdFx0XHQvLyBjbGFzc2VzIC0gYnV0IGl0J3MgYSBnb29kIGVmZm9ydCB3aXRob3V0IGdldHRpbmcgY2FycmllZCBhd2F5XG5cdFx0XHRcdGllbiA9IHNldHRpbmdzLmFzRGVzdHJveVN0cmlwZXMubGVuZ3RoO1xuXHRcblx0XHRcdFx0aWYgKCBpZW4gKSB7XG5cdFx0XHRcdFx0anFUYm9keS5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKCBzZXR0aW5ncy5hc0Rlc3Ryb3lTdHJpcGVzW2kgJSBpZW5dICk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogUmVtb3ZlIHRoZSBzZXR0aW5ncyBvYmplY3QgZnJvbSB0aGUgc2V0dGluZ3MgYXJyYXkgKi9cblx0XHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHNldHRpbmdzLCBEYXRhVGFibGUuc2V0dGluZ3MgKTtcblx0XHRcdGlmICggaWR4ICE9PSAtMSApIHtcblx0XHRcdFx0RGF0YVRhYmxlLnNldHRpbmdzLnNwbGljZSggaWR4LCAxICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0Ly8gQWRkIHRoZSBgZXZlcnkoKWAgbWV0aG9kIGZvciByb3dzLCBjb2x1bW5zIGFuZCBjZWxscyBpbiBhIGNvbXBhY3QgZm9ybVxuXHQkLmVhY2goIFsgJ2NvbHVtbicsICdyb3cnLCAnY2VsbCcgXSwgZnVuY3Rpb24gKCBpLCB0eXBlICkge1xuXHRcdF9hcGlfcmVnaXN0ZXIoIHR5cGUrJ3MoKS5ldmVyeSgpJywgZnVuY3Rpb24gKCBmbiApIHtcblx0XHRcdHZhciBvcHRzID0gdGhpcy5zZWxlY3Rvci5vcHRzO1xuXHRcdFx0dmFyIGFwaSA9IHRoaXM7XG5cdFxuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoIHR5cGUsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQgKSB7XG5cdFx0XHRcdC8vIFJvd3MgYW5kIGNvbHVtbnM6XG5cdFx0XHRcdC8vICBhcmcxIC0gaW5kZXhcblx0XHRcdFx0Ly8gIGFyZzIgLSB0YWJsZSBjb3VudGVyXG5cdFx0XHRcdC8vICBhcmczIC0gbG9vcCBjb3VudGVyXG5cdFx0XHRcdC8vICBhcmc0IC0gdW5kZWZpbmVkXG5cdFx0XHRcdC8vIENlbGxzOlxuXHRcdFx0XHQvLyAgYXJnMSAtIHJvdyBpbmRleFxuXHRcdFx0XHQvLyAgYXJnMiAtIGNvbHVtbiBpbmRleFxuXHRcdFx0XHQvLyAgYXJnMyAtIHRhYmxlIGNvdW50ZXJcblx0XHRcdFx0Ly8gIGFyZzQgLSBsb29wIGNvdW50ZXJcblx0XHRcdFx0Zm4uY2FsbChcblx0XHRcdFx0XHRhcGlbIHR5cGUgXShcblx0XHRcdFx0XHRcdGFyZzEsXG5cdFx0XHRcdFx0XHR0eXBlPT09J2NlbGwnID8gYXJnMiA6IG9wdHMsXG5cdFx0XHRcdFx0XHR0eXBlPT09J2NlbGwnID8gb3B0cyA6IHVuZGVmaW5lZFxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0YXJnMSwgYXJnMiwgYXJnMywgYXJnNFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8vIGkxOG4gbWV0aG9kIGZvciBleHRlbnNpb25zIHRvIGJlIGFibGUgdG8gdXNlIHRoZSBsYW5ndWFnZSBvYmplY3QgZnJvbSB0aGVcblx0Ly8gRGF0YVRhYmxlXG5cdF9hcGlfcmVnaXN0ZXIoICdpMThuKCknLCBmdW5jdGlvbiAoIHRva2VuLCBkZWYsIHBsdXJhbCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXHRcdHZhciByZXNvbHZlZCA9IF9mbkdldE9iamVjdERhdGFGbiggdG9rZW4gKSggY3R4Lm9MYW5ndWFnZSApO1xuXHRcblx0XHRpZiAoIHJlc29sdmVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXNvbHZlZCA9IGRlZjtcblx0XHR9XG5cdFxuXHRcdGlmICggcGx1cmFsICE9PSB1bmRlZmluZWQgJiYgJC5pc1BsYWluT2JqZWN0KCByZXNvbHZlZCApICkge1xuXHRcdFx0cmVzb2x2ZWQgPSByZXNvbHZlZFsgcGx1cmFsIF0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJlc29sdmVkWyBwbHVyYWwgXSA6XG5cdFx0XHRcdHJlc29sdmVkLl87XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gcmVzb2x2ZWQucmVwbGFjZSggJyVkJywgcGx1cmFsICk7IC8vIG5iOiBwbHVyYWwgbWlnaHQgYmUgdW5kZWZpbmVkLFxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIFZlcnNpb24gc3RyaW5nIGZvciBwbHVnLWlucyB0byBjaGVjayBjb21wYXRpYmlsaXR5LiBBbGxvd2VkIGZvcm1hdCBpc1xuXHQgKiBgYS5iLmMtZGAgd2hlcmU6IGE6aW50LCBiOmludCwgYzppbnQsIGQ6c3RyaW5nKGRldnxiZXRhfGFscGhhKS4gYGRgIGlzIHVzZWRcblx0ICogb25seSBmb3Igbm9uLXJlbGVhc2UgYnVpbGRzLiBTZWUgaHR0cDovL3NlbXZlci5vcmcvIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiAgQG1lbWJlclxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBWZXJzaW9uIG51bWJlclxuXHQgKi9cblx0RGF0YVRhYmxlLnZlcnNpb24gPSBcIjEuMTAuMTVcIjtcblxuXHQvKipcblx0ICogUHJpdmF0ZSBkYXRhIHN0b3JlLCBjb250YWluaW5nIGFsbCBvZiB0aGUgc2V0dGluZ3Mgb2JqZWN0cyB0aGF0IGFyZVxuXHQgKiBjcmVhdGVkIGZvciB0aGUgdGFibGVzIG9uIGEgZ2l2ZW4gcGFnZS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBgRGF0YVRhYmxlLnNldHRpbmdzYCBvYmplY3QgaXMgYWxpYXNlZCB0b1xuXHQgKiBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgdGhyb3VnaCB3aGljaCBpdCBtYXkgYmUgYWNjZXNzZWQgYW5kXG5cdCAqIG1hbmlwdWxhdGVkLCBvciBgalF1ZXJ5LmZuLmRhdGFUYWJsZS5zZXR0aW5nc2AuXG5cdCAqICBAbWVtYmVyXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHREYXRhVGFibGUuc2V0dGluZ3MgPSBbXTtcblxuXHQvKipcblx0ICogT2JqZWN0IG1vZGVscyBjb250YWluZXIsIGZvciB0aGUgdmFyaW91cyBtb2RlbHMgdGhhdCBEYXRhVGFibGVzIGhhc1xuXHQgKiBhdmFpbGFibGUgdG8gaXQuIFRoZXNlIG1vZGVscyBkZWZpbmUgdGhlIG9iamVjdHMgdGhhdCBhcmUgdXNlZCB0byBob2xkXG5cdCAqIHRoZSBhY3RpdmUgc3RhdGUgYW5kIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHRhYmxlLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLm1vZGVscyA9IHt9O1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcblx0ICogc2VhcmNoIGluZm9ybWF0aW9uIGZvciB0aGUgZ2xvYmFsIGZpbHRlciBhbmQgaW5kaXZpZHVhbCBjb2x1bW4gZmlsdGVycy5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCA9IHtcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBmaWx0ZXJpbmcgc2hvdWxkIGJlIGNhc2UgaW5zZW5zaXRpdmUgb3Igbm90XG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiB0cnVlLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcHBsaWVkIHNlYXJjaCB0ZXJtXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0ICovXG5cdFx0XCJzU2VhcmNoXCI6IFwiXCIsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIHNlYXJjaCB0ZXJtIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhXG5cdFx0ICogcmVndWxhciBleHByZXNzaW9uICh0cnVlKSBvciBub3QgKGZhbHNlKSBhbmQgdGhlcmVmb3JlIGFuZCBzcGVjaWFsXG5cdFx0ICogcmVnZXggY2hhcmFjdGVycyBlc2NhcGVkLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0XCJiUmVnZXhcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgRGF0YVRhYmxlcyBpcyB0byB1c2UgaXRzIHNtYXJ0IGZpbHRlcmluZyBvciBub3QuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdFwiYlNtYXJ0XCI6IHRydWVcblx0fTtcblx0XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSB3YXkgaW4gd2hpY2ggRGF0YVRhYmxlcyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dFxuXHQgKiBlYWNoIGluZGl2aWR1YWwgcm93LiBUaGlzIGlzIHRoZSBvYmplY3QgZm9ybWF0IHVzZWQgZm9yIHRoZSBzZXR0aW5nc1xuXHQgKiBhb0RhdGEgYXJyYXkuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzLm9Sb3cgPSB7XG5cdFx0LyoqXG5cdFx0ICogVFIgZWxlbWVudCBmb3IgdGhlIHJvd1xuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UclwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSBvZiBURCBlbGVtZW50cyBmb3IgZWFjaCByb3cuIFRoaXMgaXMgbnVsbCB1bnRpbCB0aGUgcm93IGhhcyBiZWVuXG5cdFx0ICogY3JlYXRlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXkgbm9kZXNcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFuQ2VsbHNcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YSBvYmplY3QgZnJvbSB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cuIFRoaXMgaXMgZWl0aGVyXG5cdFx0ICogYW4gYXJyYXkgaWYgdXNpbmcgdGhlIHRyYWRpdGlvbmFsIGZvcm0gb2YgRGF0YVRhYmxlcywgb3IgYW4gb2JqZWN0IGlmXG5cdFx0ICogdXNpbmcgbURhdGEgb3B0aW9ucy4gVGhlIGV4YWN0IHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIHBhc3NlZCBpblxuXHRcdCAqIGRhdGEgZnJvbSB0aGUgZGF0YSBzb3VyY2UsIG9yIHdpbGwgYmUgYW4gYXJyYXkgaWYgdXNpbmcgRE9NIGEgZGF0YVxuXHRcdCAqIHNvdXJjZS5cblx0XHQgKiAgQHR5cGUgYXJyYXl8b2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJfYURhdGFcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNvcnRpbmcgZGF0YSBjYWNoZSAtIHRoaXMgYXJyYXkgaXMgb3N0ZW5zaWJseSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlXG5cdFx0ICogbnVtYmVyIG9mIGNvbHVtbnMgKGFsdGhvdWdoIGVhY2ggaW5kZXggaXMgZ2VuZXJhdGVkIG9ubHkgYXMgaXQgaXNcblx0XHQgKiBuZWVkZWQpLCBhbmQgaG9sZHMgdGhlIGRhdGEgdGhhdCBpcyB1c2VkIGZvciBzb3J0aW5nIGVhY2ggY29sdW1uIGluIHRoZVxuXHRcdCAqIHJvdy4gV2UgZG8gdGhpcyBjYWNoZSBnZW5lcmF0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgc29ydCBpbiBvcmRlciB0aGF0XG5cdFx0ICogdGhlIGZvcm1hdHRpbmcgb2YgdGhlIHNvcnQgZGF0YSBuZWVkIGJlIGRvbmUgb25seSBvbmNlIGZvciBlYWNoIGNlbGxcblx0XHQgKiBwZXIgc29ydC4gVGhpcyBhcnJheSBzaG91bGQgbm90IGJlIHJlYWQgZnJvbSBvciB3cml0dGVuIHRvIGJ5IGFueXRoaW5nXG5cdFx0ICogb3RoZXIgdGhhbiB0aGUgbWFzdGVyIHNvcnRpbmcgbWV0aG9kcy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX2FTb3J0RGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQZXIgY2VsbCBmaWx0ZXJpbmcgZGF0YSBjYWNoZS4gQXMgcGVyIHRoZSBzb3J0IGRhdGEgY2FjaGUsIHVzZWQgdG9cblx0XHQgKiBpbmNyZWFzZSB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIGZpbHRlcmluZyBpbiBEYXRhVGFibGVzXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9hRmlsdGVyRGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGaWx0ZXJpbmcgZGF0YSBjYWNoZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgY2VsbCBmaWx0ZXJpbmcgY2FjaGUsIGJ1dFxuXHRcdCAqIGluIHRoaXMgY2FzZSBhIHN0cmluZyByYXRoZXIgdGhhbiBhbiBhcnJheS4gVGhpcyBpcyBlYXNpbHkgY29tcHV0ZWQgd2l0aFxuXHRcdCAqIGEgam9pbiBvbiBgX2FGaWx0ZXJEYXRhYCwgYnV0IGlzIHByb3ZpZGVkIGFzIGEgY2FjaGUgc28gdGhlIGpvaW4gaXNuJ3Rcblx0XHQgKiBuZWVkZWQgb24gZXZlcnkgc2VhcmNoIChtZW1vcnkgdHJhZGVkIGZvciBwZXJmb3JtYW5jZSlcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX3NGaWx0ZXJSb3dcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FjaGUgb2YgdGhlIGNsYXNzIG5hbWUgdGhhdCBEYXRhVGFibGVzIGhhcyBhcHBsaWVkIHRvIHRoZSByb3csIHNvIHdlXG5cdFx0ICogY2FuIHF1aWNrbHkgbG9vayBhdCB0aGlzIHZhcmlhYmxlIHJhdGhlciB0aGFuIG5lZWRpbmcgdG8gZG8gYSBET00gY2hlY2tcblx0XHQgKiBvbiBjbGFzc05hbWUgZm9yIHRoZSBuVHIgcHJvcGVydHkuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfc1Jvd1N0cmlwZVwiOiBcIlwiLFxuXHRcblx0XHQvKipcblx0XHQgKiBEZW5vdGUgaWYgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIHdhcyBmcm9tIHRoZSBET00sIG9yIHRoZSBkYXRhIHNvdXJjZVxuXHRcdCAqIG9iamVjdC4gVGhpcyBpcyB1c2VkIGZvciBpbnZhbGlkYXRpbmcgZGF0YSwgc28gRGF0YVRhYmxlcyBjYW5cblx0XHQgKiBhdXRvbWF0aWNhbGx5IHJlYWQgZGF0YSBmcm9tIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHVubGVzcyB1bmluc3RydWN0ZWRcblx0XHQgKiBvdGhlcndpc2UuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJzcmNcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kZXggaW4gdGhlIGFvRGF0YSBhcnJheS4gVGhpcyBzYXZlcyBhbiBpbmRleE9mIGxvb2t1cCB3aGVuIHdlIGhhdmUgdGhlXG5cdFx0ICogb2JqZWN0LCBidXQgd2FudCB0byBrbm93IHRoZSBpbmRleFxuXHRcdCAqICBAdHlwZSBpbnRlZ2VyXG5cdFx0ICogIEBkZWZhdWx0IC0xXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJpZHhcIjogLTFcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgY29sdW1uIGluZm9ybWF0aW9uIG9iamVjdCBpbiBEYXRhVGFibGVzLiBUaGlzIG9iamVjdFxuXHQgKiBpcyBoZWxkIGluIHRoZSBzZXR0aW5ncyBhb0NvbHVtbnMgYXJyYXkgYW5kIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gdGhhdFxuXHQgKiBEYXRhVGFibGVzIG5lZWRzIGFib3V0IGVhY2ggaW5kaXZpZHVhbCBjb2x1bW4uXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBpcyByZWxhdGVkIHRvIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufVxuXHQgKiBidXQgdGhpcyBvbmUgaXMgdGhlIGludGVybmFsIGRhdGEgc3RvcmUgZm9yIERhdGFUYWJsZXMncyBjYWNoZSBvZiBjb2x1bW5zLlxuXHQgKiBJdCBzaG91bGQgTk9UIGJlIG1hbmlwdWxhdGVkIG91dHNpZGUgb2YgRGF0YVRhYmxlcy4gQW55IGNvbmZpZ3VyYXRpb24gc2hvdWxkXG5cdCAqIGJlIGRvbmUgdGhyb3VnaCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucy5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5tb2RlbHMub0NvbHVtbiA9IHtcblx0XHQvKipcblx0XHQgKiBDb2x1bW4gaW5kZXguIFRoaXMgY291bGQgYmUgd29ya2VkIG91dCBvbi10aGUtZmx5IHdpdGggJC5pbkFycmF5LCBidXQgaXRcblx0XHQgKiBpcyBmYXN0ZXIgdG8ganVzdCBob2xkIGl0IGFzIGEgdmFyaWFibGVcblx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJpZHhcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQSBsaXN0IG9mIHRoZSBjb2x1bW5zIHRoYXQgc29ydGluZyBzaG91bGQgb2NjdXIgb24gd2hlbiB0aGlzIGNvbHVtblxuXHRcdCAqIGlzIHNvcnRlZC4gVGhhdCB0aGlzIHByb3BlcnR5IGlzIGFuIGFycmF5IGFsbG93cyBtdWx0aS1jb2x1bW4gc29ydGluZ1xuXHRcdCAqIHRvIGJlIGRlZmluZWQgZm9yIGEgY29sdW1uIChmb3IgZXhhbXBsZSBmaXJzdCBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnNcblx0XHQgKiB3b3VsZCBiZW5lZml0IGZyb20gdGhpcykuIFRoZSB2YWx1ZXMgYXJlIGludGVnZXJzIHBvaW50aW5nIHRvIHRoZVxuXHRcdCAqIGNvbHVtbnMgdG8gYmUgc29ydGVkIG9uICh0eXBpY2FsbHkgaXQgd2lsbCBiZSBhIHNpbmdsZSBpbnRlZ2VyIHBvaW50aW5nXG5cdFx0ICogYXQgaXRzZWxmLCBidXQgdGhhdCBkb2Vzbid0IG5lZWQgdG8gYmUgdGhlIGNhc2UpLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqL1xuXHRcdFwiYURhdGFTb3J0XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERlZmluZSB0aGUgc29ydGluZyBkaXJlY3Rpb25zIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGNvbHVtbiwgaW4gc2VxdWVuY2Vcblx0XHQgKiBhcyB0aGUgY29sdW1uIGlzIHJlcGVhdGVkbHkgc29ydGVkIHVwb24gLSBpLmUuIHRoZSBmaXJzdCB2YWx1ZSBpcyB1c2VkXG5cdFx0ICogYXMgdGhlIHNvcnRpbmcgZGlyZWN0aW9uIHdoZW4gdGhlIGNvbHVtbiBpZiBmaXJzdCBzb3J0ZWQgKGNsaWNrZWQgb24pLlxuXHRcdCAqIFNvcnQgaXQgYWdhaW4gKGNsaWNrIGFnYWluKSBhbmQgaXQgd2lsbCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGluZGV4LlxuXHRcdCAqIFJlcGVhdCB1bnRpbCBsb29wLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqL1xuXHRcdFwiYXNTb3J0aW5nXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzZWFyY2hhYmxlLCBhbmQgdGh1cyBzaG91bGQgYmUgaW5jbHVkZWRcblx0XHQgKiBpbiB0aGUgZmlsdGVyaW5nIG9yIG5vdC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYlNlYXJjaGFibGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIHNvcnRhYmxlIG9yIG5vdC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYlNvcnRhYmxlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJWaXNpYmxlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlIGZvciBtYW51YWwgdHlwZSBhc3NpZ25tZW50IHVzaW5nIHRoZSBgY29sdW1uLnR5cGVgIG9wdGlvbi4gVGhpc1xuXHRcdCAqIGlzIGhlbGQgaW4gc3RvcmUgc28gd2UgY2FuIG1hbmlwdWxhdGUgdGhlIGNvbHVtbidzIGBzVHlwZWAgcHJvcGVydHkuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfc01hbnVhbFR5cGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBIVE1MNSBkYXRhIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGRhdGFcblx0XHQgKiBzb3VyY2UgZm9yIGZpbHRlcmluZyBvciBzb3J0aW5nLiBUcnVlIGlzIGVpdGhlciBhcmUuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9iQXR0clNyY1wiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGV2ZWxvcGVyIGRlZmluYWJsZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBhIGNlbGwgaXMgY3JlYXRlZCAoQWpheCBzb3VyY2UsXG5cdFx0ICogZXRjKSBvciBwcm9jZXNzZWQgZm9yIGlucHV0IChET00gc291cmNlKS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGNvbXBsaW1lbnQgdG8gbVJlbmRlclxuXHRcdCAqIGFsbG93aW5nIHlvdSB0byBtb2RpZnkgdGhlIERPTSBlbGVtZW50IChhZGQgYmFja2dyb3VuZCBjb2xvdXIgZm9yIGV4YW1wbGUpIHdoZW4gdGhlXG5cdFx0ICogZWxlbWVudCBpcyBhdmFpbGFibGUuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7ZWxlbWVudH0gblRkIFRoZSBURCBub2RlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZFxuXHRcdCAqICBAcGFyYW0geyp9IHNEYXRhIFRoZSBEYXRhIGZvciB0aGUgY2VsbFxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgZm9yIHRoZSB3aG9sZSByb3dcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGlSb3cgVGhlIHJvdyBpbmRleCBmb3IgdGhlIGFvRGF0YSBkYXRhIHN0b3JlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcImZuQ3JlYXRlZENlbGxcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb24gdG8gZ2V0IGRhdGEgZnJvbSBhIGNlbGwgaW4gYSBjb2x1bW4uIFlvdSBzaG91bGQgPGI+bmV2ZXI8L2I+XG5cdFx0ICogYWNjZXNzIGRhdGEgZGlyZWN0bHkgdGhyb3VnaCBfYURhdGEgaW50ZXJuYWxseSBpbiBEYXRhVGFibGVzIC0gYWx3YXlzIHVzZVxuXHRcdCAqIHRoZSBtZXRob2QgYXR0YWNoZWQgdG8gdGhpcyBwcm9wZXJ0eS4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzXG5cdFx0ICogcmVxdWlyZWQuIFRoaXMgZnVuY3Rpb24gaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uXG5cdFx0ICogaW5pdGlhbGlzYXRpb24gbWV0aG9kXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvRGF0YSBUaGUgZGF0YSBhcnJheS9vYmplY3QgZm9yIHRoZSBhcnJheVxuXHRcdCAqICAgIChpLmUuIGFvRGF0YVtdLl9hRGF0YSlcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNTcGVjaWZpYyBUaGUgc3BlY2lmaWMgZGF0YSB0eXBlIHlvdSB3YW50IHRvIGdldCAtXG5cdFx0ICogICAgJ2Rpc3BsYXknLCAndHlwZScgJ2ZpbHRlcicgJ3NvcnQnXG5cdFx0ICogIEByZXR1cm5zIHsqfSBUaGUgZGF0YSBmb3IgdGhlIGNlbGwgZnJvbSB0aGUgZ2l2ZW4gcm93J3MgZGF0YVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJmbkdldERhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb24gdG8gc2V0IGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBZb3Ugc2hvdWxkIDxiPm5ldmVyPC9iPlxuXHRcdCAqIHNldCB0aGUgZGF0YSBkaXJlY3RseSB0byBfYURhdGEgaW50ZXJuYWxseSBpbiBEYXRhVGFibGVzIC0gYWx3YXlzIHVzZVxuXHRcdCAqIHRoaXMgbWV0aG9kLiBJdCBhbGxvd3MgbURhdGEgdG8gZnVuY3Rpb24gYXMgcmVxdWlyZWQuIFRoaXMgZnVuY3Rpb25cblx0XHQgKiBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIGJ5IHRoZSBjb2x1bW4gaW5pdGlhbGlzYXRpb24gbWV0aG9kXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvRGF0YSBUaGUgZGF0YSBhcnJheS9vYmplY3QgZm9yIHRoZSBhcnJheVxuXHRcdCAqICAgIChpLmUuIGFvRGF0YVtdLl9hRGF0YSlcblx0XHQgKiAgQHBhcmFtIHsqfSBzVmFsdWUgVmFsdWUgdG8gc2V0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcImZuU2V0RGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSB0byByZWFkIHRoZSB2YWx1ZSBmb3IgdGhlIGNlbGxzIGluIHRoZSBjb2x1bW4gZnJvbSB0aGUgZGF0YVxuXHRcdCAqIHNvdXJjZSBhcnJheSAvIG9iamVjdC4gSWYgbnVsbCwgdGhlbiB0aGUgZGVmYXVsdCBjb250ZW50IGlzIHVzZWQsIGlmIGFcblx0XHQgKiBmdW5jdGlvbiBpcyBnaXZlbiB0aGVuIHRoZSByZXR1cm4gZnJvbSB0aGUgZnVuY3Rpb24gaXMgdXNlZC5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb258aW50fHN0cmluZ3xudWxsXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm1EYXRhXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBhcnRuZXIgcHJvcGVydHkgdG8gbURhdGEgd2hpY2ggaXMgdXNlZCAob25seSB3aGVuIGRlZmluZWQpIHRvIGdldFxuXHRcdCAqIHRoZSBkYXRhIC0gaS5lLiBpdCBpcyBiYXNpY2FsbHkgdGhlIHNhbWUgYXMgbURhdGEsIGJ1dCB3aXRob3V0IHRoZVxuXHRcdCAqICdzZXQnIG9wdGlvbiwgYW5kIGFsc28gdGhlIGRhdGEgZmVkIHRvIGl0IGlzIHRoZSByZXN1bHQgZnJvbSBtRGF0YS5cblx0XHQgKiBUaGlzIGlzIHRoZSByZW5kZXJpbmcgbWV0aG9kIHRvIG1hdGNoIHRoZSBkYXRhIG1ldGhvZCBvZiBtRGF0YS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb258aW50fHN0cmluZ3xudWxsXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm1SZW5kZXJcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogVW5pcXVlIGhlYWRlciBUSC9URCBlbGVtZW50IGZvciB0aGlzIGNvbHVtbiAtIHRoaXMgaXMgd2hhdCB0aGUgc29ydGluZ1xuXHRcdCAqIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHRvIChpZiBzb3J0aW5nIGlzIGVuYWJsZWQuKVxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UaFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBVbmlxdWUgZm9vdGVyIFRIL1REIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uIChpZiB0aGVyZSBpcyBvbmUpLiBOb3QgdXNlZFxuXHRcdCAqIGluIERhdGFUYWJsZXMgYXMgc3VjaCwgYnV0IGNhbiBiZSB1c2VkIGZvciBwbHVnLWlucyB0byByZWZlcmVuY2UgdGhlXG5cdFx0ICogZm9vdGVyIGZvciBlYWNoIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVGZcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNsYXNzIHRvIGFwcGx5IHRvIGFsbCBURCBlbGVtZW50cyBpbiB0aGUgdGFibGUncyBUQk9EWSBmb3IgdGhlIGNvbHVtblxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic0NsYXNzXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gRGF0YVRhYmxlcyBjYWxjdWxhdGVzIHRoZSBjb2x1bW4gd2lkdGhzIHRvIGFzc2lnbiB0byBlYWNoIGNvbHVtbixcblx0XHQgKiBpdCBmaW5kcyB0aGUgbG9uZ2VzdCBzdHJpbmcgaW4gZWFjaCBjb2x1bW4gYW5kIHRoZW4gY29uc3RydWN0cyBhXG5cdFx0ICogdGVtcG9yYXJ5IHRhYmxlIGFuZCByZWFkcyB0aGUgd2lkdGhzIGZyb20gdGhhdC4gVGhlIHByb2JsZW0gd2l0aCB0aGlzXG5cdFx0ICogaXMgdGhhdCBcIm1tbVwiIGlzIG11Y2ggd2lkZXIgdGhlbiBcImlpaWlcIiwgYnV0IHRoZSBsYXR0ZXIgaXMgYSBsb25nZXJcblx0XHQgKiBzdHJpbmcgLSB0aHVzIHRoZSBjYWxjdWxhdGlvbiBjYW4gZ28gd3JvbmcgKGRvaW5nIGl0IHByb3Blcmx5IGFuZCBwdXR0aW5nXG5cdFx0ICogaXQgaW50byBhbiBET00gb2JqZWN0IGFuZCBtZWFzdXJpbmcgdGhhdCBpcyBob3JyaWJseSghKSBzbG93KS4gVGh1cyBhc1xuXHRcdCAqIGEgXCJ3b3JrIGFyb3VuZFwiIHdlIHByb3ZpZGUgdGhpcyBvcHRpb24uIEl0IHdpbGwgYXBwZW5kIGl0cyB2YWx1ZSB0byB0aGVcblx0XHQgKiB0ZXh0IHRoYXQgaXMgZm91bmQgdG8gYmUgdGhlIGxvbmdlc3Qgc3RyaW5nIGZvciB0aGUgY29sdW1uIC0gaS5lLiBwYWRkaW5nLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNDb250ZW50UGFkZGluZ1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBBbGxvd3MgYSBkZWZhdWx0IHZhbHVlIHRvIGJlIGdpdmVuIGZvciBhIGNvbHVtbidzIGRhdGEsIGFuZCB3aWxsIGJlIHVzZWRcblx0XHQgKiB3aGVuZXZlciBhIG51bGwgZGF0YSBzb3VyY2UgaXMgZW5jb3VudGVyZWQgKHRoaXMgY2FuIGJlIGJlY2F1c2UgbURhdGFcblx0XHQgKiBpcyBzZXQgdG8gbnVsbCwgb3IgYmVjYXVzZSB0aGUgZGF0YSBzb3VyY2UgaXRzZWxmIGlzIG51bGwpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic0RlZmF1bHRDb250ZW50XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIE5hbWUgZm9yIHRoZSBjb2x1bW4sIGFsbG93aW5nIHJlZmVyZW5jZSB0byB0aGUgY29sdW1uIGJ5IG5hbWUgYXMgd2VsbCBhc1xuXHRcdCAqIGJ5IGluZGV4IChuZWVkcyBhIGxvb2t1cCB0byB3b3JrIGJ5IG5hbWUpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNOYW1lXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEN1c3RvbSBzb3J0aW5nIGRhdGEgdHlwZSAtIGRlZmluZXMgd2hpY2ggb2YgdGhlIGF2YWlsYWJsZSBwbHVnLWlucyBpblxuXHRcdCAqIGFmblNvcnREYXRhIHRoZSBjdXN0b20gc29ydGluZyB3aWxsIHVzZSAtIGlmIGFueSBpcyBkZWZpbmVkLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgc3RkXG5cdFx0ICovXG5cdFx0XCJzU29ydERhdGFUeXBlXCI6ICdzdGQnLFxuXHRcblx0XHQvKipcblx0XHQgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBoZWFkZXIgZWxlbWVudCB3aGVuIHNvcnRpbmcgb24gdGhpcyBjb2x1bW5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNTb3J0aW5nQ2xhc3NcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgaGVhZGVyIGVsZW1lbnQgd2hlbiBzb3J0aW5nIG9uIHRoaXMgY29sdW1uIC1cblx0XHQgKiB3aGVuIGpRdWVyeSBVSSB0aGVtaW5nIGlzIHVzZWQuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzU29ydGluZ0NsYXNzSlVJXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRpdGxlIG9mIHRoZSBjb2x1bW4gLSB3aGF0IGlzIHNlZW4gaW4gdGhlIFRIIGVsZW1lbnQgKG5UaCkuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdFwic1RpdGxlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENvbHVtbiBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcgdHlwZVxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1R5cGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogV2lkdGggb2YgdGhlIGNvbHVtblxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1dpZHRoXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdpZHRoIG9mIHRoZSBjb2x1bW4gd2hlbiBpdCB3YXMgZmlyc3QgXCJlbmNvdW50ZXJlZFwiXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzV2lkdGhPcmlnXCI6IG51bGxcblx0fTtcblx0XG5cdFxuXHQvKlxuXHQgKiBEZXZlbG9wZXIgbm90ZTogVGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBiZWxvdyBhcmUgZ2l2ZW4gaW4gSHVuZ2FyaWFuXG5cdCAqIG5vdGF0aW9uLCB0aGF0IHdhcyB1c2VkIGFzIHRoZSBpbnRlcmZhY2UgZm9yIERhdGFUYWJsZXMgcHJpb3IgdG8gdjEuMTAsIGhvd2V2ZXJcblx0ICogZnJvbSB2MS4xMCBvbndhcmRzIHRoZSBwcmltYXJ5IGludGVyZmFjZSBpcyBjYW1lbCBjYXNlLiBJbiBvcmRlciB0byBhdm9pZFxuXHQgKiBicmVha2luZyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB1dHRlcmx5IHdpdGggdGhpcyBjaGFuZ2UsIHRoZSBIdW5nYXJpYW5cblx0ICogdmVyc2lvbiBpcyBzdGlsbCwgaW50ZXJuYWxseSB0aGUgcHJpbWFyeSBpbnRlcmZhY2UsIGJ1dCBpcyBpcyBub3QgZG9jdW1lbnRlZFxuXHQgKiAtIGhlbmNlIHRoZSBAbmFtZSB0YWdzIGluIGVhY2ggZG9jIGNvbW1lbnQuIFRoaXMgYWxsb3dzIGEgSmF2YXNjcmlwdCBmdW5jdGlvblxuXHQgKiB0byBjcmVhdGUgYSBtYXAgZnJvbSBIdW5nYXJpYW4gbm90YXRpb24gdG8gY2FtZWwgY2FzZSAoZ29pbmcgdGhlIG90aGVyIGRpcmVjdGlvblxuXHQgKiB3b3VsZCByZXF1aXJlIGVhY2ggcHJvcGVydHkgdG8gYmUgbGlzdGVkLCB3aGljaCB3b3VsZCBhdCBhcm91bmQgM0sgdG8gdGhlIHNpemVcblx0ICogb2YgRGF0YVRhYmxlcywgd2hpbGUgdGhpcyBtZXRob2QgaXMgYWJvdXQgYSAwLjVLIGhpdC5cblx0ICpcblx0ICogVWx0aW1hdGVseSB0aGlzIGRvZXMgcGF2ZSB0aGUgd2F5IGZvciBIdW5nYXJpYW4gbm90YXRpb24gdG8gYmUgZHJvcHBlZFxuXHQgKiBjb21wbGV0ZWx5LCBidXQgdGhhdCBpcyBhIG1hc3NpdmUgYW1vdW50IG9mIHdvcmsgYW5kIHdpbGwgYnJlYWsgY3VycmVudFxuXHQgKiBpbnN0YWxscyAodGhlcmVmb3JlIGlzIG9uLWhvbGQgdW50aWwgdjIpLlxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBJbml0aWFsaXNhdGlvbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb25cblx0ICogdGltZS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5kZWZhdWx0cyA9IHtcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBkYXRhIHRvIHVzZSBmb3IgdGhlIHRhYmxlLCBwYXNzZWQgaW4gYXQgaW5pdGlhbGlzYXRpb24gd2hpY2hcblx0XHQgKiB3aWxsIGJlIHVzZWQgaW4gcHJlZmVyZW5jZSB0byBhbnkgZGF0YSB3aGljaCBpcyBhbHJlYWR5IGluIHRoZSBET00uIFRoaXMgaXNcblx0XHQgKiBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBjb25zdHJ1Y3RpbmcgdGFibGVzIHB1cmVseSBpbiBKYXZhc2NyaXB0LCBmb3Jcblx0XHQgKiBleGFtcGxlIHdpdGggYSBjdXN0b20gQWpheCBjYWxsLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGF0YVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYSAyRCBhcnJheSBkYXRhIHNvdXJjZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRhdGFcIjogW1xuXHRcdCAqICAgICAgICAgIFsnVHJpZGVudCcsICdJbnRlcm5ldCBFeHBsb3JlciA0LjAnLCAnV2luIDk1KycsIDQsICdYJ10sXG5cdFx0ICogICAgICAgICAgWydUcmlkZW50JywgJ0ludGVybmV0IEV4cGxvcmVyIDUuMCcsICdXaW4gOTUrJywgNSwgJ0MnXSxcblx0XHQgKiAgICAgICAgXSxcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJFbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlBsYXRmb3JtXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJWZXJzaW9uXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJHcmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYXMgYSBkYXRhIHNvdXJjZSAoYGRhdGFgKVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRhdGFcIjogW1xuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZW5naW5lXCI6ICAgXCJUcmlkZW50XCIsXG5cdFx0ICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNC4wXCIsXG5cdFx0ICogICAgICAgICAgICBcInBsYXRmb3JtXCI6IFwiV2luIDk1K1wiLFxuXHRcdCAqICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6ICA0LFxuXHRcdCAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIlhcIlxuXHRcdCAqICAgICAgICAgIH0sXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJlbmdpbmVcIjogICBcIlRyaWRlbnRcIixcblx0XHQgKiAgICAgICAgICAgIFwiYnJvd3NlclwiOiAgXCJJbnRlcm5ldCBFeHBsb3JlciA1LjBcIixcblx0XHQgKiAgICAgICAgICAgIFwicGxhdGZvcm1cIjogXCJXaW4gOTUrXCIsXG5cdFx0ICogICAgICAgICAgICBcInZlcnNpb25cIjogIDUsXG5cdFx0ICogICAgICAgICAgICBcImdyYWRlXCI6ICAgIFwiQ1wiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkVuZ2luZVwiLCAgIFwiZGF0YVwiOiBcImVuZ2luZVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiQnJvd3NlclwiLCAgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiUGxhdGZvcm1cIiwgXCJkYXRhXCI6IFwicGxhdGZvcm1cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlZlcnNpb25cIiwgIFwiZGF0YVwiOiBcInZlcnNpb25cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkdyYWRlXCIsICAgIFwiZGF0YVwiOiBcImdyYWRlXCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYWFEYXRhXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBJZiBvcmRlcmluZyBpcyBlbmFibGVkLCB0aGVuIERhdGFUYWJsZXMgd2lsbCBwZXJmb3JtIGEgZmlyc3QgcGFzcyBzb3J0IG9uXG5cdFx0ICogaW5pdGlhbGlzYXRpb24uIFlvdSBjYW4gZGVmaW5lIHdoaWNoIGNvbHVtbihzKSB0aGUgc29ydCBpcyBwZXJmb3JtZWRcblx0XHQgKiB1cG9uLCBhbmQgdGhlIHNvcnRpbmcgZGlyZWN0aW9uLCB3aXRoIHRoaXMgdmFyaWFibGUuIFRoZSBgc29ydGluZ2AgYXJyYXlcblx0XHQgKiBzaG91bGQgY29udGFpbiBhbiBhcnJheSBmb3IgZWFjaCBjb2x1bW4gdG8gYmUgc29ydGVkIGluaXRpYWxseSBjb250YWluaW5nXG5cdFx0ICogdGhlIGNvbHVtbidzIGluZGV4IGFuZCBhIGRpcmVjdGlvbiBzdHJpbmcgKCdhc2MnIG9yICdkZXNjJykuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtbMCwnYXNjJ11dXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNvcnQgYnkgM3JkIGNvbHVtbiBmaXJzdCwgYW5kIHRoZW4gNHRoIGNvbHVtblxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJcIjogW1syLCdhc2MnXSwgWzMsJ2Rlc2MnXV1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAvLyBObyBpbml0aWFsIHNvcnRpbmdcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyXCI6IFtdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYWFTb3J0aW5nXCI6IFtbMCwnYXNjJ11dLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgaXMgYmFzaWNhbGx5IGlkZW50aWNhbCB0byB0aGUgYHNvcnRpbmdgIHBhcmFtZXRlciwgYnV0XG5cdFx0ICogY2Fubm90IGJlIG92ZXJyaWRkZW4gYnkgdXNlciBpbnRlcmFjdGlvbiB3aXRoIHRoZSB0YWJsZS4gV2hhdCB0aGlzIG1lYW5zXG5cdFx0ICogaXMgdGhhdCB5b3UgY291bGQgaGF2ZSBhIGNvbHVtbiAodmlzaWJsZSBvciBoaWRkZW4pIHdoaWNoIHRoZSBzb3J0aW5nXG5cdFx0ICogd2lsbCBhbHdheXMgYmUgZm9yY2VkIG9uIGZpcnN0IC0gYW55IHNvcnRpbmcgYWZ0ZXIgdGhhdCAoZnJvbSB0aGUgdXNlcilcblx0XHQgKiB3aWxsIHRoZW4gYmUgcGVyZm9ybWVkIGFzIHJlcXVpcmVkLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGdyb3VwaW5nIHJvd3Ncblx0XHQgKiB0b2dldGhlci5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyRml4ZWRcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJGaXhlZFwiOiBbWzAsJ2FzYyddXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEYXRhVGFibGVzIGNhbiBiZSBpbnN0cnVjdGVkIHRvIGxvYWQgZGF0YSB0byBkaXNwbGF5IGluIHRoZSB0YWJsZSBmcm9tIGFcblx0XHQgKiBBamF4IHNvdXJjZS4gVGhpcyBvcHRpb24gZGVmaW5lcyBob3cgdGhhdCBBamF4IGNhbGwgaXMgbWFkZSBhbmQgd2hlcmUgdG8uXG5cdFx0ICpcblx0XHQgKiBUaGUgYGFqYXhgIHByb3BlcnR5IGhhcyB0aHJlZSBkaWZmZXJlbnQgbW9kZXMgb2Ygb3BlcmF0aW9uLCBkZXBlbmRpbmcgb25cblx0XHQgKiBob3cgaXQgaXMgZGVmaW5lZC4gVGhlc2UgYXJlOlxuXHRcdCAqXG5cdFx0ICogKiBgc3RyaW5nYCAtIFNldCB0aGUgVVJMIGZyb20gd2hlcmUgdGhlIGRhdGEgc2hvdWxkIGJlIGxvYWRlZCBmcm9tLlxuXHRcdCAqICogYG9iamVjdGAgLSBEZWZpbmUgcHJvcGVydGllcyBmb3IgYGpRdWVyeS5hamF4YC5cblx0XHQgKiAqIGBmdW5jdGlvbmAgLSBDdXN0b20gZGF0YSBnZXQgZnVuY3Rpb25cblx0XHQgKlxuXHRcdCAqIGBzdHJpbmdgXG5cdFx0ICogLS0tLS0tLS1cblx0XHQgKlxuXHRcdCAqIEFzIGEgc3RyaW5nLCB0aGUgYGFqYXhgIHByb3BlcnR5IHNpbXBseSBkZWZpbmVzIHRoZSBVUkwgZnJvbSB3aGljaFxuXHRcdCAqIERhdGFUYWJsZXMgd2lsbCBsb2FkIGRhdGEuXG5cdFx0ICpcblx0XHQgKiBgb2JqZWN0YFxuXHRcdCAqIC0tLS0tLS0tXG5cdFx0ICpcblx0XHQgKiBBcyBhbiBvYmplY3QsIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSBvYmplY3QgYXJlIHBhc3NlZCB0b1xuXHRcdCAqIFtqUXVlcnkuYWpheF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5hamF4LykgYWxsb3dpbmcgZmluZSBjb250cm9sXG5cdFx0ICogb2YgdGhlIEFqYXggcmVxdWVzdC4gRGF0YVRhYmxlcyBoYXMgYSBudW1iZXIgb2YgZGVmYXVsdCBwYXJhbWV0ZXJzIHdoaWNoXG5cdFx0ICogeW91IGNhbiBvdmVycmlkZSB1c2luZyB0aGlzIG9wdGlvbi4gUGxlYXNlIHJlZmVyIHRvIHRoZSBqUXVlcnlcblx0XHQgKiBkb2N1bWVudGF0aW9uIGZvciBhIGZ1bGwgZGVzY3JpcHRpb24gb2YgdGhlIG9wdGlvbnMgYXZhaWxhYmxlLCBhbHRob3VnaFxuXHRcdCAqIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVycyBwcm92aWRlIGFkZGl0aW9uYWwgb3B0aW9ucyBpbiBEYXRhVGFibGVzIG9yXG5cdFx0ICogcmVxdWlyZSBzcGVjaWFsIGNvbnNpZGVyYXRpb246XG5cdFx0ICpcblx0XHQgKiAqIGBkYXRhYCAtIEFzIHdpdGggalF1ZXJ5LCBgZGF0YWAgY2FuIGJlIHByb3ZpZGVkIGFzIGFuIG9iamVjdCwgYnV0IGl0XG5cdFx0ICogICBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBEYXRhVGFibGVzIHNlbmRzXG5cdFx0ICogICB0byB0aGUgc2VydmVyLiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzaW5nbGUgcGFyYW1ldGVyLCBhbiBvYmplY3Qgb2Zcblx0XHQgKiAgIHBhcmFtZXRlcnMgd2l0aCB0aGUgdmFsdWVzIHRoYXQgRGF0YVRhYmxlcyBoYXMgcmVhZGllZCBmb3Igc2VuZGluZy4gQW5cblx0XHQgKiAgIG9iamVjdCBtYXkgYmUgcmV0dXJuZWQgd2hpY2ggd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgRGF0YVRhYmxlc1xuXHRcdCAqICAgZGVmYXVsdHMsIG9yIHlvdSBjYW4gYWRkIHRoZSBpdGVtcyB0byB0aGUgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBpbiBhbmRcblx0XHQgKiAgIG5vdCByZXR1cm4gYW55dGhpbmcgZnJvbSB0aGUgZnVuY3Rpb24uIFRoaXMgc3VwZXJzZWRlcyBgZm5TZXJ2ZXJQYXJhbXNgXG5cdFx0ICogICBmcm9tIERhdGFUYWJsZXMgMS45LS5cblx0XHQgKlxuXHRcdCAqICogYGRhdGFTcmNgIC0gQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9vayBmb3IgdGhlIHByb3BlcnR5IGBkYXRhYCAob3Jcblx0XHQgKiAgIGBhYURhdGFgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhXG5cdFx0ICogICBmcm9tIGFuIEFqYXggc291cmNlIG9yIGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gdGhpcyBwYXJhbWV0ZXJcblx0XHQgKiAgIGFsbG93cyB0aGF0IHByb3BlcnR5IHRvIGJlIGNoYW5nZWQuIFlvdSBjYW4gdXNlIEphdmFzY3JpcHQgZG90dGVkXG5cdFx0ICogICBvYmplY3Qgbm90YXRpb24gdG8gZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLCBvclxuXHRcdCAqICAgaXQgbXkgYmUgdXNlZCBhcyBhIGZ1bmN0aW9uLiBBcyBhIGZ1bmN0aW9uIGl0IHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlcixcblx0XHQgKiAgIHRoZSBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciwgd2hpY2ggY2FuIGJlIG1hbmlwdWxhdGVkIGFzXG5cdFx0ICogICByZXF1aXJlZCwgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWUgYmVpbmcgdGhhdCB1c2VkIGJ5IERhdGFUYWJsZXMgYXMgdGhlXG5cdFx0ICogICBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIHN1cGVyc2VkZXMgYHNBamF4RGF0YVByb3BgIGZyb21cblx0XHQgKiAgIERhdGFUYWJsZXMgMS45LS5cblx0XHQgKlxuXHRcdCAqICogYHN1Y2Nlc3NgIC0gU2hvdWxkIG5vdCBiZSBvdmVycmlkZGVuIGl0IGlzIHVzZWQgaW50ZXJuYWxseSBpblxuXHRcdCAqICAgRGF0YVRhYmxlcy4gVG8gbWFuaXB1bGF0ZSAvIHRyYW5zZm9ybSB0aGUgZGF0YSByZXR1cm5lZCBieSB0aGUgc2VydmVyXG5cdFx0ICogICB1c2UgYGFqYXguZGF0YVNyY2AsIG9yIHVzZSBgYWpheGAgYXMgYSBmdW5jdGlvbiAoc2VlIGJlbG93KS5cblx0XHQgKlxuXHRcdCAqIGBmdW5jdGlvbmBcblx0XHQgKiAtLS0tLS0tLS0tXG5cdFx0ICpcblx0XHQgKiBBcyBhIGZ1bmN0aW9uLCBtYWtpbmcgdGhlIEFqYXggY2FsbCBpcyBsZWZ0IHVwIHRvIHlvdXJzZWxmIGFsbG93aW5nXG5cdFx0ICogY29tcGxldGUgY29udHJvbCBvZiB0aGUgQWpheCByZXF1ZXN0LiBJbmRlZWQsIGlmIGRlc2lyZWQsIGEgbWV0aG9kIG90aGVyXG5cdFx0ICogdGhhbiBBamF4IGNvdWxkIGJlIHVzZWQgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhLCBzdWNoIGFzIFdlYiBzdG9yYWdlXG5cdFx0ICogb3IgYW4gQUlSIGRhdGFiYXNlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9uIGlzIGdpdmVuIGZvdXIgcGFyYW1ldGVycyBhbmQgbm8gcmV0dXJuIGlzIHJlcXVpcmVkLiBUaGVcblx0XHQgKiBwYXJhbWV0ZXJzIGFyZTpcblx0XHQgKlxuXHRcdCAqIDEuIF9vYmplY3RfIC0gRGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcblx0XHQgKiAyLiBfZnVuY3Rpb25fIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBtdXN0IGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHJlcXVpcmVkXG5cdFx0ICogICAgZGF0YSBoYXMgYmVlbiBvYnRhaW5lZC4gVGhhdCBkYXRhIHNob3VsZCBiZSBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tcblx0XHQgKiAgICBhcyB0aGUgb25seSBwYXJhbWV0ZXJcblx0XHQgKiAzLiBfb2JqZWN0XyAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgdGFibGVcblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHN1cGVyc2VkZXMgYGZuU2VydmVyRGF0YWAgZnJvbSBEYXRhVGFibGVzIDEuOS0uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfG9iamVjdHxmdW5jdGlvblxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheFxuXHRcdCAqICBAc2luY2UgMS4xMC4wXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gR2V0IEpTT04gZGF0YSBmcm9tIGEgZmlsZSB2aWEgQWpheC5cblx0XHQgKiAgIC8vIE5vdGUgRGF0YVRhYmxlcyBleHBlY3RzIGRhdGEgaW4gdGhlIGZvcm0gYHsgZGF0YTogWyAuLi5kYXRhLi4uIF0gfWAgYnkgZGVmYXVsdCkuXG5cdFx0ICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICBcImFqYXhcIjogXCJkYXRhLmpzb25cIlxuXHRcdCAqICAgfSApO1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXgsIHVzaW5nIGBkYXRhU3JjYCB0byBjaGFuZ2Vcblx0XHQgKiAgIC8vIGBkYXRhYCB0byBgdGFibGVEYXRhYCAoaS5lLiBgeyB0YWJsZURhdGE6IFsgLi4uZGF0YS4uLiBdIH1gKVxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVNyY1wiOiBcInRhYmxlRGF0YVwiXG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LCB1c2luZyBgZGF0YVNyY2AgdG8gcmVhZCBkYXRhXG5cdFx0ICogICAvLyBmcm9tIGEgcGxhaW4gYXJyYXkgcmF0aGVyIHRoYW4gYW4gYXJyYXkgaW4gYW4gb2JqZWN0XG5cdFx0ICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICBcImFqYXhcIjoge1xuXHRcdCAqICAgICAgIFwidXJsXCI6IFwiZGF0YS5qc29uXCIsXG5cdFx0ICogICAgICAgXCJkYXRhU3JjXCI6IFwiXCJcblx0XHQgKiAgICAgfVxuXHRcdCAqICAgfSApO1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIE1hbmlwdWxhdGUgdGhlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIC0gYWRkIGEgbGluayB0byBkYXRhXG5cdFx0ICogICAvLyAobm90ZSB0aGlzIGNhbiwgc2hvdWxkLCBiZSBkb25lIHVzaW5nIGByZW5kZXJgIGZvciB0aGUgY29sdW1uIC0gdGhpc1xuXHRcdCAqICAgLy8gaXMganVzdCBhIHNpbXBsZSBleGFtcGxlIG9mIGhvdyB0aGUgZGF0YSBjYW4gYmUgbWFuaXB1bGF0ZWQpLlxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVNyY1wiOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cdFx0ICogICAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHQgKiAgICAgICAgICAganNvbltpXVswXSA9ICc8YSBocmVmPVwiL21lc3NhZ2UvJytqc29uW2ldWzBdKyc+VmlldyBtZXNzYWdlPC9hPic7XG5cdFx0ICogICAgICAgICB9XG5cdFx0ICogICAgICAgICByZXR1cm4ganNvbjtcblx0XHQgKiAgICAgICB9XG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBBZGQgZGF0YSB0byB0aGUgcmVxdWVzdFxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0ICogICAgICAgICByZXR1cm4ge1xuXHRcdCAqICAgICAgICAgICBcImV4dHJhX3NlYXJjaFwiOiAkKCcjZXh0cmEnKS52YWwoKVxuXHRcdCAqICAgICAgICAgfTtcblx0XHQgKiAgICAgICB9XG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBTZW5kIHJlcXVlc3QgYXMgUE9TVFxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwidHlwZVwiOiBcIlBPU1RcIlxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gR2V0IHRoZSBkYXRhIGZyb20gbG9jYWxTdG9yYWdlIChjb3VsZCBpbnRlcmZhY2Ugd2l0aCBhIGZvcm0gZm9yXG5cdFx0ICogICAvLyBhZGRpbmcsIGVkaXRpbmcgYW5kIHJlbW92aW5nIHJvd3MpLlxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaywgc2V0dGluZ3MpIHtcblx0XHQgKiAgICAgICBjYWxsYmFjayhcblx0XHQgKiAgICAgICAgIEpTT04ucGFyc2UoIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkYXRhVGFibGVzRGF0YScpIClcblx0XHQgKiAgICAgICApO1xuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICovXG5cdFx0XCJhamF4XCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIHJlYWRpbHkgc3BlY2lmeSB0aGUgZW50cmllcyBpbiB0aGUgbGVuZ3RoIGRyb3Bcblx0XHQgKiBkb3duIG1lbnUgdGhhdCBEYXRhVGFibGVzIHNob3dzIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLiBJdCBjYW4gYmVcblx0XHQgKiBlaXRoZXIgYSAxRCBhcnJheSBvZiBvcHRpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgYm90aCB0aGUgZGlzcGxheWVkXG5cdFx0ICogb3B0aW9uIGFuZCB0aGUgdmFsdWUsIG9yIGEgMkQgYXJyYXkgd2hpY2ggd2lsbCB1c2UgdGhlIGFycmF5IGluIHRoZSBmaXJzdFxuXHRcdCAqIHBvc2l0aW9uIGFzIHRoZSB2YWx1ZSwgYW5kIHRoZSBhcnJheSBpbiB0aGUgc2Vjb25kIHBvc2l0aW9uIGFzIHRoZVxuXHRcdCAqIGRpc3BsYXllZCBvcHRpb25zICh1c2VmdWwgZm9yIGxhbmd1YWdlIHN0cmluZ3Mgc3VjaCBhcyAnQWxsJykuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgdGhlIGBwYWdlTGVuZ3RoYCBwcm9wZXJ0eSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZVxuXHRcdCAqIGZpcnN0IHZhbHVlIGdpdmVuIGluIHRoaXMgYXJyYXksIHVubGVzcyBgcGFnZUxlbmd0aGAgaXMgYWxzbyBwcm92aWRlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgWyAxMCwgMjUsIDUwLCAxMDAgXVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxlbmd0aE1lbnVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwibGVuZ3RoTWVudVwiOiBbWzEwLCAyNSwgNTAsIC0xXSwgWzEwLCAyNSwgNTAsIFwiQWxsXCJdXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFMZW5ndGhNZW51XCI6IFsgMTAsIDI1LCA1MCwgMTAwIF0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgYGNvbHVtbnNgIG9wdGlvbiBpbiB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gZGVmaW5lXG5cdFx0ICogZGV0YWlscyBhYm91dCB0aGUgd2F5IGluZGl2aWR1YWwgY29sdW1ucyBiZWhhdmUuIEZvciBhIGZ1bGwgbGlzdCBvZlxuXHRcdCAqIGNvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCwgcGxlYXNlIHNlZVxuXHRcdCAqIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufS4gTm90ZSB0aGF0IGlmIHlvdSB1c2UgYGNvbHVtbnNgIHRvXG5cdFx0ICogZGVmaW5lIHlvdXIgY29sdW1ucywgeW91IG11c3QgaGF2ZSBhbiBlbnRyeSBpbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IHNpbmdsZVxuXHRcdCAqIGNvbHVtbiB0aGF0IHlvdSBoYXZlIGluIHlvdXIgdGFibGUgKHRoZXNlIGNhbiBiZSBudWxsIGlmIHlvdSBkb24ndCB3aGljaFxuXHRcdCAqIHRvIHNwZWNpZnkgYW55IG9wdGlvbnMpLlxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtblxuXHRcdCAqL1xuXHRcdFwiYW9Db2x1bW5zXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFZlcnkgc2ltaWxhciB0byBgY29sdW1uc2AsIGBjb2x1bW5EZWZzYCBhbGxvd3MgeW91IHRvIHRhcmdldCBhIHNwZWNpZmljXG5cdFx0ICogY29sdW1uLCBtdWx0aXBsZSBjb2x1bW5zLCBvciBhbGwgY29sdW1ucywgdXNpbmcgdGhlIGB0YXJnZXRzYCBwcm9wZXJ0eSBvZlxuXHRcdCAqIGVhY2ggb2JqZWN0IGluIHRoZSBhcnJheS4gVGhpcyBhbGxvd3MgZ3JlYXQgZmxleGliaWxpdHkgd2hlbiBjcmVhdGluZ1xuXHRcdCAqIHRhYmxlcywgYXMgdGhlIGBjb2x1bW5EZWZzYCBhcnJheXMgY2FuIGJlIG9mIGFueSBsZW5ndGgsIHRhcmdldGluZyB0aGVcblx0XHQgKiBjb2x1bW5zIHlvdSBzcGVjaWZpY2FsbHkgd2FudC4gYGNvbHVtbkRlZnNgIG1heSB1c2UgYW55IG9mIHRoZSBjb2x1bW5cblx0XHQgKiBvcHRpb25zIGF2YWlsYWJsZToge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59LCBidXQgaXQgX211c3RfXG5cdFx0ICogaGF2ZSBgdGFyZ2V0c2AgZGVmaW5lZCBpbiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFZhbHVlcyBpbiB0aGUgYHRhcmdldHNgXG5cdFx0ICogYXJyYXkgbWF5IGJlOlxuXHRcdCAqICAgPHVsPlxuXHRcdCAqICAgICA8bGk+YSBzdHJpbmcgLSBjbGFzcyBuYW1lIHdpbGwgYmUgbWF0Y2hlZCBvbiB0aGUgVEggZm9yIHRoZSBjb2x1bW48L2xpPlxuXHRcdCAqICAgICA8bGk+MCBvciBhIHBvc2l0aXZlIGludGVnZXIgLSBjb2x1bW4gaW5kZXggY291bnRpbmcgZnJvbSB0aGUgbGVmdDwvbGk+XG5cdFx0ICogICAgIDxsaT5hIG5lZ2F0aXZlIGludGVnZXIgLSBjb2x1bW4gaW5kZXggY291bnRpbmcgZnJvbSB0aGUgcmlnaHQ8L2xpPlxuXHRcdCAqICAgICA8bGk+dGhlIHN0cmluZyBcIl9hbGxcIiAtIGFsbCBjb2x1bW5zIChpLmUuIGFzc2lnbiBhIGRlZmF1bHQpPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEBtZW1iZXJcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uRGVmc1xuXHRcdCAqL1xuXHRcdFwiYW9Db2x1bW5EZWZzXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgYHNlYXJjaGAsIHRoaXMgcGFyYW1ldGVyIGRlZmluZXMgdGhlIGluZGl2aWR1YWwgY29sdW1uXG5cdFx0ICogZmlsdGVyaW5nIHN0YXRlIGF0IGluaXRpYWxpc2F0aW9uIHRpbWUuIFRoZSBhcnJheSBtdXN0IGJlIG9mIHRoZSBzYW1lIHNpemVcblx0XHQgKiBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMsIGFuZCBlYWNoIGVsZW1lbnQgYmUgYW4gb2JqZWN0IHdpdGggdGhlIHBhcmFtZXRlcnNcblx0XHQgKiBgc2VhcmNoYCBhbmQgYGVzY2FwZVJlZ2V4YCAodGhlIGxhdHRlciBpcyBvcHRpb25hbCkuICdudWxsJyBpcyBhbHNvXG5cdFx0ICogYWNjZXB0ZWQgYW5kIHRoZSBkZWZhdWx0IHdpbGwgYmUgdXNlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hDb2xzXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlYXJjaENvbHNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIk15IGZpbHRlclwiIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7IFwic2VhcmNoXCI6IFwiXlswLTldXCIsIFwiZXNjYXBlUmVnZXhcIjogZmFsc2UgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJhb1NlYXJjaENvbHNcIjogW10sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBDU1MgY2xhc3NlcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGRpc3BsYXllZCByb3dzLiBUaGlzXG5cdFx0ICogYXJyYXkgbWF5IGJlIG9mIGFueSBsZW5ndGgsIGFuZCBEYXRhVGFibGVzIHdpbGwgYXBwbHkgZWFjaCBjbGFzc1xuXHRcdCAqIHNlcXVlbnRpYWxseSwgbG9vcGluZyB3aGVuIHJlcXVpcmVkLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPldpbGwgdGFrZSB0aGUgdmFsdWVzIGRldGVybWluZWQgYnkgdGhlIGBvQ2xhc3Nlcy5zdHJpcGUqYFxuXHRcdCAqICAgIG9wdGlvbnM8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RyaXBlQ2xhc3Nlc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdHJpcGVDbGFzc2VzXCI6IFsgJ3N0cmlwMScsICdzdHJpcDInLCAnc3RyaXAzJyBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJhc1N0cmlwZUNsYXNzZXNcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIGF1dG9tYXRpYyBjb2x1bW4gd2lkdGggY2FsY3VsYXRpb24uIFRoaXMgY2FuIGJlIGRpc2FibGVkXG5cdFx0ICogYXMgYW4gb3B0aW1pc2F0aW9uIChpdCB0YWtlcyBzb21lIHRpbWUgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aHMpIGlmIHRoZVxuXHRcdCAqIHRhYmxlcyB3aWR0aHMgYXJlIHBhc3NlZCBpbiB1c2luZyBgY29sdW1uc2AuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYXV0b1dpZHRoXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhdXRvV2lkdGhcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiQXV0b1dpZHRoXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZlcnJlZCByZW5kZXJpbmcgY2FuIHByb3ZpZGUgRGF0YVRhYmxlcyB3aXRoIGEgaHVnZSBzcGVlZCBib29zdCB3aGVuIHlvdVxuXHRcdCAqIGFyZSB1c2luZyBhbiBBamF4IG9yIEpTIGRhdGEgc291cmNlIGZvciB0aGUgdGFibGUuIFRoaXMgb3B0aW9uLCB3aGVuIHNldCB0b1xuXHRcdCAqIHRydWUsIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBkZWZlciB0aGUgY3JlYXRpb24gb2YgdGhlIHRhYmxlIGVsZW1lbnRzIGZvclxuXHRcdCAqIGVhY2ggcm93IHVudGlsIHRoZXkgYXJlIG5lZWRlZCBmb3IgYSBkcmF3IC0gc2F2aW5nIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mXG5cdFx0ICogdGltZS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGVmZXJSZW5kZXJcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiYWpheFwiOiBcInNvdXJjZXMvYXJyYXlzLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImRlZmVyUmVuZGVyXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiRGVmZXJSZW5kZXJcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXBsYWNlIGEgRGF0YVRhYmxlIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIHNlbGVjdG9yIGFuZCByZXBsYWNlIGl0IHdpdGhcblx0XHQgKiBvbmUgd2hpY2ggaGFzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBuZXcgaW5pdGlhbGlzYXRpb24gb2JqZWN0IHBhc3NlZC4gSWYgbm9cblx0XHQgKiB0YWJsZSBtYXRjaGVzIHRoZSBzZWxlY3RvciwgdGhlbiB0aGUgbmV3IERhdGFUYWJsZSB3aWxsIGJlIGNvbnN0cnVjdGVkIGFzXG5cdFx0ICogcGVyIG5vcm1hbC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kZXN0cm95XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNyb2xsWVwiOiBcIjIwMHB4XCIsXG5cdFx0ICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gU29tZSB0aW1lIGxhdGVyLi4uLlxuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJmaWx0ZXJcIjogZmFsc2UsXG5cdFx0ICogICAgICAgIFwiZGVzdHJveVwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkRlc3Ryb3lcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb2YgZGF0YS4gRmlsdGVyaW5nIGluIERhdGFUYWJsZXMgaXMgXCJzbWFydFwiIGluXG5cdFx0ICogdGhhdCBpdCBhbGxvd3MgdGhlIGVuZCB1c2VyIHRvIGlucHV0IG11bHRpcGxlIHdvcmRzIChzcGFjZSBzZXBhcmF0ZWQpIGFuZFxuXHRcdCAqIHdpbGwgbWF0Y2ggYSByb3cgY29udGFpbmluZyB0aG9zZSB3b3JkcywgZXZlbiBpZiBub3QgaW4gdGhlIG9yZGVyIHRoYXQgd2FzXG5cdFx0ICogc3BlY2lmaWVkICh0aGlzIGFsbG93IG1hdGNoaW5nIGFjcm9zcyBtdWx0aXBsZSBjb2x1bW5zKS4gTm90ZSB0aGF0IGlmIHlvdVxuXHRcdCAqIHdpc2ggdG8gdXNlIGZpbHRlcmluZyBpbiBEYXRhVGFibGVzIHRoaXMgbXVzdCByZW1haW4gJ3RydWUnIC0gdG8gcmVtb3ZlIHRoZVxuXHRcdCAqIGRlZmF1bHQgZmlsdGVyaW5nIGlucHV0IGJveCBhbmQgcmV0YWluIGZpbHRlcmluZyBhYmlsaXRpZXMsIHBsZWFzZSB1c2Vcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbX0uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZWFyY2hpbmdcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiRmlsdGVyXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgdGFibGUgaW5mb3JtYXRpb24gZGlzcGxheS4gVGhpcyBzaG93cyBpbmZvcm1hdGlvblxuXHRcdCAqIGFib3V0IHRoZSBkYXRhIHRoYXQgaXMgY3VycmVudGx5IHZpc2libGUgb24gdGhlIHBhZ2UsIGluY2x1ZGluZyBpbmZvcm1hdGlvblxuXHRcdCAqIGFib3V0IGZpbHRlcmVkIGRhdGEgaWYgdGhhdCBhY3Rpb24gaXMgYmVpbmcgcGVyZm9ybWVkLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluZm9cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImluZm9cIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiSW5mb1wiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIGpRdWVyeSBVSSBUaGVtZVJvbGxlciBzdXBwb3J0IChyZXF1aXJlZCBhcyBUaGVtZVJvbGxlciByZXF1aXJlcyBzb21lXG5cdFx0ICogc2xpZ2h0bHkgZGlmZmVyZW50IGFuZCBhZGRpdGlvbmFsIG1hcmstdXAgZnJvbSB3aGF0IERhdGFUYWJsZXMgaGFzXG5cdFx0ICogdHJhZGl0aW9uYWxseSB1c2VkKS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMualF1ZXJ5VUlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwialF1ZXJ5VUlcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJKUXVlcnlVSVwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyB0aGUgZW5kIHVzZXIgdG8gc2VsZWN0IHRoZSBzaXplIG9mIGEgZm9ybWF0dGVkIHBhZ2UgZnJvbSBhIHNlbGVjdFxuXHRcdCAqIG1lbnUgKHNpemVzIGFyZSAxMCwgMjUsIDUwIGFuZCAxMDApLiBSZXF1aXJlcyBwYWdpbmF0aW9uIChgcGFnaW5hdGVgKS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sZW5ndGhDaGFuZ2Vcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxlbmd0aENoYW5nZVwiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJMZW5ndGhDaGFuZ2VcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHBhZ2luYXRpb24uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwYWdpbmdcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiUGFnaW5hdGVcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBkaXNwbGF5IG9mIGEgJ3Byb2Nlc3NpbmcnIGluZGljYXRvciB3aGVuIHRoZSB0YWJsZSBpc1xuXHRcdCAqIGJlaW5nIHByb2Nlc3NlZCAoZS5nLiBhIHNvcnQpLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHRhYmxlcyB3aXRoXG5cdFx0ICogbGFyZ2UgYW1vdW50cyBvZiBkYXRhIHdoZXJlIGl0IGNhbiB0YWtlIGEgbm90aWNlYWJsZSBhbW91bnQgb2YgdGltZSB0byBzb3J0XG5cdFx0ICogdGhlIGVudHJpZXMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnByb2Nlc3Npbmdcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInByb2Nlc3NpbmdcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJQcm9jZXNzaW5nXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUmV0cmlldmUgdGhlIERhdGFUYWJsZXMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3IuIE5vdGUgdGhhdCBpZiB0aGVcblx0XHQgKiB0YWJsZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpc2VkLCB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlIERhdGFUYWJsZXNcblx0XHQgKiB0byBzaW1wbHkgcmV0dXJuIHRoZSBvYmplY3QgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNldCB1cCAtIGl0IHdpbGwgbm90IHRha2Vcblx0XHQgKiBhY2NvdW50IG9mIGFueSBjaGFuZ2VzIHlvdSBtaWdodCBoYXZlIG1hZGUgdG8gdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdFxuXHRcdCAqIHBhc3NlZCB0byBEYXRhVGFibGVzIChzZXR0aW5nIHRoaXMgcGFyYW1ldGVyIHRvIHRydWUgaXMgYW4gYWNrbm93bGVkZ2VtZW50XG5cdFx0ICogdGhhdCB5b3UgdW5kZXJzdGFuZCB0aGlzKS4gYGRlc3Ryb3lgIGNhbiBiZSB1c2VkIHRvIHJlaW5pdGlhbGlzZSBhIHRhYmxlIGlmXG5cdFx0ICogeW91IG5lZWQuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmV0cmlldmVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIGluaXRUYWJsZSgpO1xuXHRcdCAqICAgICAgdGFibGVBY3Rpb25zKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgZnVuY3Rpb24gaW5pdFRhYmxlICgpXG5cdFx0ICogICAge1xuXHRcdCAqICAgICAgcmV0dXJuICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMHB4XCIsXG5cdFx0ICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2UsXG5cdFx0ICogICAgICAgIFwicmV0cmlldmVcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH1cblx0XHQgKlxuXHRcdCAqICAgIGZ1bmN0aW9uIHRhYmxlQWN0aW9ucyAoKVxuXHRcdCAqICAgIHtcblx0XHQgKiAgICAgIHZhciB0YWJsZSA9IGluaXRUYWJsZSgpO1xuXHRcdCAqICAgICAgLy8gcGVyZm9ybSBBUEkgb3BlcmF0aW9ucyB3aXRoIG9UYWJsZVxuXHRcdCAqICAgIH1cblx0XHQgKi9cblx0XHRcImJSZXRyaWV2ZVwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gdmVydGljYWwgKHkpIHNjcm9sbGluZyBpcyBlbmFibGVkLCBEYXRhVGFibGVzIHdpbGwgZm9yY2UgdGhlIGhlaWdodCBvZlxuXHRcdCAqIHRoZSB0YWJsZSdzIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBoZWlnaHQgYXQgYWxsIHRpbWVzICh1c2VmdWwgZm9yIGxheW91dCkuXG5cdFx0ICogSG93ZXZlciwgdGhpcyBjYW4gbG9vayBvZGQgd2hlbiBmaWx0ZXJpbmcgZGF0YSBkb3duIHRvIGEgc21hbGwgZGF0YSBzZXQsXG5cdFx0ICogYW5kIHRoZSBmb290ZXIgaXMgbGVmdCBcImZsb2F0aW5nXCIgZnVydGhlciBkb3duLiBUaGlzIHBhcmFtZXRlciAod2hlblxuXHRcdCAqIGVuYWJsZWQpIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBjb2xsYXBzZSB0aGUgdGFibGUncyB2aWV3cG9ydCBkb3duIHdoZW5cblx0XHQgKiB0aGUgcmVzdWx0IHNldCB3aWxsIGZpdCB3aXRoaW4gdGhlIGdpdmVuIFkgaGVpZ2h0LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbENvbGxhcHNlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBcIixcblx0XHQgKiAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNjcm9sbENvbGxhcHNlXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ29uZmlndXJlIERhdGFUYWJsZXMgdG8gdXNlIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuIE5vdGUgdGhhdCB0aGVcblx0XHQgKiBgYWpheGAgcGFyYW1ldGVyIG11c3QgYWxzbyBiZSBnaXZlbiBpbiBvcmRlciB0byBnaXZlIERhdGFUYWJsZXMgYVxuXHRcdCAqIHNvdXJjZSB0byBvYnRhaW4gdGhlIHJlcXVpcmVkIGRhdGEgZm9yIGVhY2ggZHJhdy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlclNpZGVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJhamF4XCI6IFwieGhyLnBocFwiXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNlcnZlclNpZGVcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBzb3J0aW5nIG9mIGNvbHVtbnMuIFNvcnRpbmcgb2YgaW5kaXZpZHVhbCBjb2x1bW5zIGNhbiBiZVxuXHRcdCAqIGRpc2FibGVkIGJ5IHRoZSBgc29ydGFibGVgIG9wdGlvbiBmb3IgZWFjaCBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJpbmdcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyaW5nXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNwbGF5IERhdGFUYWJsZXMnIGFiaWxpdHkgdG8gc29ydCBtdWx0aXBsZSBjb2x1bW5zIGF0IHRoZVxuXHRcdCAqIHNhbWUgdGltZSAoYWN0aXZhdGVkIGJ5IHNoaWZ0LWNsaWNrIGJ5IHRoZSB1c2VyKS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyTXVsdGlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIERpc2FibGUgbXVsdGlwbGUgY29sdW1uIHNvcnRpbmcgYWJpbGl0eVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyTXVsdGlcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU29ydE11bHRpXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbGxvd3MgY29udHJvbCBvdmVyIHdoZXRoZXIgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRoZSB0b3AgKHRydWUpIHVuaXF1ZVxuXHRcdCAqIGNlbGwgdGhhdCBpcyBmb3VuZCBmb3IgYSBzaW5nbGUgY29sdW1uLCBvciB0aGUgYm90dG9tIChmYWxzZSAtIGRlZmF1bHQpLlxuXHRcdCAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgY29tcGxleCBoZWFkZXJzLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyQ2VsbHNUb3Bcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJDZWxsc1RvcFwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRDZWxsc1RvcFwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBhZGRpdGlvbiBvZiB0aGUgY2xhc3NlcyBgc29ydGluZ1xcXzFgLCBgc29ydGluZ1xcXzJgIGFuZFxuXHRcdCAqIGBzb3J0aW5nXFxfM2AgdG8gdGhlIGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBiZWluZyBzb3J0ZWQgb24uIFRoaXMgaXNcblx0XHQgKiBwcmVzZW50ZWQgYXMgYSBmZWF0dXJlIHN3aXRjaCBhcyBpdCBjYW4gaW5jcmVhc2UgcHJvY2Vzc2luZyB0aW1lICh3aGlsZVxuXHRcdCAqIGNsYXNzZXMgYXJlIHJlbW92ZWQgYW5kIGFkZGVkKSBzbyBmb3IgbGFyZ2UgZGF0YSBzZXRzIHlvdSBtaWdodCB3YW50IHRvXG5cdFx0ICogdHVybiB0aGlzIG9mZi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckNsYXNzZXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyQ2xhc3Nlc1wiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTb3J0Q2xhc3Nlc1wiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgc3RhdGUgc2F2aW5nLiBXaGVuIGVuYWJsZWQgSFRNTDUgYGxvY2FsU3RvcmFnZWAgd2lsbCBiZVxuXHRcdCAqIHVzZWQgdG8gc2F2ZSB0YWJsZSBkaXNwbGF5IGluZm9ybWF0aW9uIHN1Y2ggYXMgcGFnaW5hdGlvbiBpbmZvcm1hdGlvbixcblx0XHQgKiBkaXNwbGF5IGxlbmd0aCwgZmlsdGVyaW5nIGFuZCBzb3J0aW5nLiBBcyBzdWNoIHdoZW4gdGhlIGVuZCB1c2VyIHJlbG9hZHNcblx0XHQgKiB0aGUgcGFnZSB0aGUgZGlzcGxheSBkaXNwbGF5IHdpbGwgbWF0Y2ggd2hhdCB0aHkgaGFkIHByZXZpb3VzbHkgc2V0IHVwLlxuXHRcdCAqXG5cdFx0ICogRHVlIHRvIHRoZSB1c2Ugb2YgYGxvY2FsU3RvcmFnZWAgdGhlIGRlZmF1bHQgc3RhdGUgc2F2aW5nIGlzIG5vdCBzdXBwb3J0ZWRcblx0XHQgKiBpbiBJRTYgb3IgNy4gSWYgc3RhdGUgc2F2aW5nIGlzIHJlcXVpcmVkIGluIHRob3NlIGJyb3dzZXJzLCB1c2Vcblx0XHQgKiBgc3RhdGVTYXZlQ2FsbGJhY2tgIHRvIHByb3ZpZGUgYSBzdG9yYWdlIHNvbHV0aW9uIHN1Y2ggYXMgY29va2llcy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVTYXZlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTdGF0ZVNhdmVcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgVFIgZWxlbWVudCBpcyBjcmVhdGVkIChhbmQgYWxsIFREIGNoaWxkXG5cdFx0ICogZWxlbWVudHMgaGF2ZSBiZWVuIGluc2VydGVkKSwgb3IgcmVnaXN0ZXJlZCBpZiB1c2luZyBhIERPTSBzb3VyY2UsIGFsbG93aW5nXG5cdFx0ICogbWFuaXB1bGF0aW9uIG9mIHRoZSBUUiBlbGVtZW50IChhZGRpbmcgY2xhc3NlcyBldGMpLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IHJvdyBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgcm93XG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgUmF3IGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSBkYXRhSW5kZXggVGhlIGluZGV4IG9mIHRoaXMgcm93IGluIHRoZSBpbnRlcm5hbCBhb0RhdGEgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jcmVhdGVkUm93XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNyZWF0ZWRSb3dcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGF0YUluZGV4ICkge1xuXHRcdCAqICAgICAgICAgIC8vIEJvbGQgdGhlIGdyYWRlIGZvciBhbGwgJ0EnIGdyYWRlIGJyb3dzZXJzXG5cdFx0ICogICAgICAgICAgaWYgKCBkYXRhWzRdID09IFwiQVwiIClcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICAkKCd0ZDplcSg0KScsIHJvdykuaHRtbCggJzxiPkE8L2I+JyApO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuQ3JlYXRlZFJvd1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xuXHRcdCAqIGR5bmFtaWNhbGx5IG1vZGlmeSBhbnkgYXNwZWN0IHlvdSB3YW50IGFib3V0IHRoZSBjcmVhdGVkIERPTS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZHJhd0NhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRyYXdDYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0ICogICAgICAgICAgYWxlcnQoICdEYXRhVGFibGVzIGhhcyByZWRyYXduIHRoZSB0YWJsZScgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuRHJhd0NhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBJZGVudGljYWwgdG8gZm5IZWFkZXJDYWxsYmFjaygpIGJ1dCBmb3IgdGhlIHRhYmxlIGZvb3RlciB0aGlzIGZ1bmN0aW9uXG5cdFx0ICogYWxsb3dzIHlvdSB0byBtb2RpZnkgdGhlIHRhYmxlIGZvb3RlciBvbiBldmVyeSAnZHJhdycgZXZlbnQuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gZm9vdCBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGZvb3RlclxuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEZ1bGwgdGFibGUgZGF0YSAoYXMgZGVyaXZlZCBmcm9tIHRoZSBvcmlnaW5hbCBIVE1MKVxuXHRcdCAqICBAcGFyYW0ge2ludH0gc3RhcnQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgc3RhcnRpbmcgcG9pbnQgaW4gdGhlXG5cdFx0ICogICAgZGlzcGxheSBhcnJheVxuXHRcdCAqICBAcGFyYW0ge2ludH0gZW5kIEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IGVuZGluZyBwb2ludCBpbiB0aGVcblx0XHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdFx0ICogIEBwYXJhbSB7YXJyYXkgaW50fSBkaXNwbGF5IEluZGV4IGFycmF5IHRvIHRyYW5zbGF0ZSB0aGUgdmlzdWFsIHBvc2l0aW9uXG5cdFx0ICogICAgdG8gdGhlIGZ1bGwgZGF0YSBhcnJheVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvb3RlckNhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImZvb3RlckNhbGxiYWNrXCI6IGZ1bmN0aW9uKCB0Zm9vdCwgZGF0YSwgc3RhcnQsIGVuZCwgZGlzcGxheSApIHtcblx0XHQgKiAgICAgICAgICB0Zm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGgnKVswXS5pbm5lckhUTUwgPSBcIlN0YXJ0aW5nIGluZGV4IGlzIFwiK3N0YXJ0O1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJmbkZvb3RlckNhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIHJlbmRlcmluZyBsYXJnZSBudW1iZXJzIGluIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGZvciB0aGUgdGFibGVcblx0XHQgKiAoaS5lLiBcIlNob3dpbmcgMSB0byAxMCBvZiA1NyBlbnRyaWVzXCIpIERhdGFUYWJsZXMgd2lsbCByZW5kZXIgbGFyZ2UgbnVtYmVyc1xuXHRcdCAqIHRvIGhhdmUgYSBjb21tYSBzZXBhcmF0b3IgZm9yIHRoZSAndGhvdXNhbmRzJyB1bml0cyAoZS5nLiAxIG1pbGxpb24gaXNcblx0XHQgKiByZW5kZXJlZCBhcyBcIjEsMDAwLDAwMFwiKSB0byBoZWxwIHJlYWRhYmlsaXR5IGZvciB0aGUgZW5kIHVzZXIuIFRoaXNcblx0XHQgKiBmdW5jdGlvbiB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1ldGhvZCBEYXRhVGFibGVzIHVzZXMuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBtZW1iZXJcblx0XHQgKiAgQHBhcmFtIHtpbnR9IHRvRm9ybWF0IG51bWJlciB0byBiZSBmb3JtYXR0ZWRcblx0XHQgKiAgQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHN0cmluZyBmb3IgRGF0YVRhYmxlcyB0byBzaG93IHRoZSBudW1iZXJcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5mb3JtYXROdW1iZXJcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIEZvcm1hdCBhIG51bWJlciB1c2luZyBhIHNpbmdsZSBxdW90ZSBmb3IgdGhlIHNlcGFyYXRvciAobm90ZSB0aGF0XG5cdFx0ICogICAgLy8gdGhpcyBjYW4gYWxzbyBiZSBkb25lIHdpdGggdGhlIGxhbmd1YWdlLnRob3VzYW5kcyBvcHRpb24pXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJmb3JtYXROdW1iZXJcIjogZnVuY3Rpb24gKCB0b0Zvcm1hdCApIHtcblx0XHQgKiAgICAgICAgICByZXR1cm4gdG9Gb3JtYXQudG9TdHJpbmcoKS5yZXBsYWNlKFxuXHRcdCAqICAgICAgICAgICAgL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiJ1wiXG5cdFx0ICogICAgICAgICAgKTtcblx0XHQgKiAgICAgICAgfTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkZvcm1hdE51bWJlclwiOiBmdW5jdGlvbiAoIHRvRm9ybWF0ICkge1xuXHRcdFx0cmV0dXJuIHRvRm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShcblx0XHRcdFx0L1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csXG5cdFx0XHRcdHRoaXMub0xhbmd1YWdlLnNUaG91c2FuZHNcblx0XHRcdCk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5ICdkcmF3JyBldmVudCwgYW5kIGFsbG93cyB5b3UgdG9cblx0XHQgKiBkeW5hbWljYWxseSBtb2RpZnkgdGhlIGhlYWRlciByb3cuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGFuZFxuXHRcdCAqIGRpc3BsYXkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBoZWFkIFwiVFJcIiBlbGVtZW50IGZvciB0aGUgaGVhZGVyXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRnVsbCB0YWJsZSBkYXRhIChhcyBkZXJpdmVkIGZyb20gdGhlIG9yaWdpbmFsIEhUTUwpXG5cdFx0ICogIEBwYXJhbSB7aW50fSBzdGFydCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBzdGFydGluZyBwb2ludCBpbiB0aGVcblx0XHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdFx0ICogIEBwYXJhbSB7aW50fSBlbmQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgZW5kaW5nIHBvaW50IGluIHRoZVxuXHRcdCAqICAgIGRpc3BsYXkgYXJyYXlcblx0XHQgKiAgQHBhcmFtIHthcnJheSBpbnR9IGRpc3BsYXkgSW5kZXggYXJyYXkgdG8gdHJhbnNsYXRlIHRoZSB2aXN1YWwgcG9zaXRpb25cblx0XHQgKiAgICB0byB0aGUgZnVsbCBkYXRhIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaGVhZGVyQ2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZmhlYWRlckNhbGxiYWNrXCI6IGZ1bmN0aW9uKCBoZWFkLCBkYXRhLCBzdGFydCwgZW5kLCBkaXNwbGF5ICkge1xuXHRcdCAqICAgICAgICAgIGhlYWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RoJylbMF0uaW5uZXJIVE1MID0gXCJEaXNwbGF5aW5nIFwiKyhlbmQtc3RhcnQpK1wiIHJlY29yZHNcIjtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiZm5IZWFkZXJDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gY29udmV5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50XG5cdFx0ICogc3RhdGUgb2YgdGhlIHRhYmxlLiBBbHRob3VnaCB0aGUgaW50ZXJuYXRpb25hbGlzYXRpb24gb3B0aW9ucyBwcmVzZW50ZWQgYnlcblx0XHQgKiBEYXRhVGFibGVzIGFyZSBxdWl0ZSBjYXBhYmxlIG9mIGRlYWxpbmcgd2l0aCBtb3N0IGN1c3RvbWlzYXRpb25zLCB0aGVyZSBtYXlcblx0XHQgKiBiZSB0aW1lcyB3aGVyZSB5b3Ugd2lzaCB0byBjdXN0b21pc2UgdGhlIHN0cmluZyBmdXJ0aGVyLiBUaGlzIGNhbGxiYWNrXG5cdFx0ICogYWxsb3dzIHlvdSB0byBkbyBleGFjdGx5IHRoYXQuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtpbnR9IHN0YXJ0IFN0YXJ0aW5nIHBvc2l0aW9uIGluIGRhdGEgZm9yIHRoZSBkcmF3XG5cdFx0ICogIEBwYXJhbSB7aW50fSBlbmQgRW5kIHBvc2l0aW9uIGluIGRhdGEgZm9yIHRoZSBkcmF3XG5cdFx0ICogIEBwYXJhbSB7aW50fSBtYXggVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRhYmxlIChyZWdhcmRsZXNzIG9mXG5cdFx0ICogICAgZmlsdGVyaW5nKVxuXHRcdCAqICBAcGFyYW0ge2ludH0gdG90YWwgVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGRhdGEgc2V0LCBhZnRlciBmaWx0ZXJpbmdcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHByZSBUaGUgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBoYXMgZm9ybWF0dGVkIHVzaW5nIGl0J3Ncblx0XHQgKiAgICBvd24gcnVsZXNcblx0XHQgKiAgQHJldHVybnMge3N0cmluZ30gVGhlIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5mb0NhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgXCJpbmZvQ2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzLCBzdGFydCwgZW5kLCBtYXgsIHRvdGFsLCBwcmUgKSB7XG5cdFx0ICogICAgICAgIHJldHVybiBzdGFydCArXCIgdG8gXCIrIGVuZDtcblx0XHQgKiAgICAgIH1cblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkluZm9DYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGVkIHdoZW4gdGhlIHRhYmxlIGhhcyBiZWVuIGluaXRpYWxpc2VkLiBOb3JtYWxseSBEYXRhVGFibGVzIHdpbGxcblx0XHQgKiBpbml0aWFsaXNlIHNlcXVlbnRpYWxseSBhbmQgdGhlcmUgd2lsbCBiZSBubyBuZWVkIGZvciB0aGlzIGZ1bmN0aW9uLFxuXHRcdCAqIGhvd2V2ZXIsIHRoaXMgZG9lcyBub3QgaG9sZCB0cnVlIHdoZW4gdXNpbmcgZXh0ZXJuYWwgbGFuZ3VhZ2UgaW5mb3JtYXRpb25cblx0XHQgKiBzaW5jZSB0aGF0IGlzIG9idGFpbmVkIHVzaW5nIGFuIGFzeW5jIFhIUiBjYWxsLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIEpTT04gb2JqZWN0IHJlcXVlc3QgZnJvbSB0aGUgc2VydmVyIC0gb25seVxuXHRcdCAqICAgIHByZXNlbnQgaWYgY2xpZW50LXNpZGUgQWpheCBzb3VyY2VkIGRhdGEgaXMgdXNlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluaXRDb21wbGV0ZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJpbml0Q29tcGxldGVcIjogZnVuY3Rpb24oc2V0dGluZ3MsIGpzb24pIHtcblx0XHQgKiAgICAgICAgICBhbGVydCggJ0RhdGFUYWJsZXMgaGFzIGZpbmlzaGVkIGl0cyBpbml0aWFsaXNhdGlvbi4nICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImZuSW5pdENvbXBsZXRlXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsZWQgYXQgdGhlIHZlcnkgc3RhcnQgb2YgZWFjaCB0YWJsZSBkcmF3IGFuZCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlXG5cdFx0ICogZHJhdyBieSByZXR1cm5pbmcgZmFsc2UsIGFueSBvdGhlciByZXR1cm4gKGluY2x1ZGluZyB1bmRlZmluZWQpIHJlc3VsdHMgaW5cblx0XHQgKiB0aGUgZnVsbCBkcmF3IG9jY3VycmluZykuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gRmFsc2Ugd2lsbCBjYW5jZWwgdGhlIGRyYXcsIGFueXRoaW5nIGVsc2UgKGluY2x1ZGluZyBub1xuXHRcdCAqICAgIHJldHVybikgd2lsbCBhbGxvdyBpdCB0byBjb21wbGV0ZS5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wcmVEcmF3Q2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwicHJlRHJhd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgICBpZiAoICQoJyN0ZXN0JykudmFsKCkgPT0gMSApIHtcblx0XHQgKiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblByZURyYXdDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvICdwb3N0IHByb2Nlc3MnIGVhY2ggcm93IGFmdGVyIGl0IGhhdmUgYmVlblxuXHRcdCAqIGdlbmVyYXRlZCBmb3IgZWFjaCB0YWJsZSBkcmF3LCBidXQgYmVmb3JlIGl0IGlzIHJlbmRlcmVkIG9uIHNjcmVlbi4gVGhpc1xuXHRcdCAqIGZ1bmN0aW9uIG1pZ2h0IGJlIHVzZWQgZm9yIHNldHRpbmcgdGhlIHJvdyBjbGFzcyBuYW1lIGV0Yy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtub2RlfSByb3cgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBjdXJyZW50IHJvd1xuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIFJhdyBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gZGlzcGxheUluZGV4IFRoZSBkaXNwbGF5IGluZGV4IGZvciB0aGUgY3VycmVudCB0YWJsZSBkcmF3XG5cdFx0ICogIEBwYXJhbSB7aW50fSBkaXNwbGF5SW5kZXhGdWxsIFRoZSBpbmRleCBvZiB0aGUgZGF0YSBpbiB0aGUgZnVsbCBsaXN0IG9mXG5cdFx0ICogICAgcm93cyAoYWZ0ZXIgZmlsdGVyaW5nKVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJvd0NhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInJvd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCByb3csIGRhdGEsIGRpc3BsYXlJbmRleCwgZGlzcGxheUluZGV4RnVsbCApIHtcblx0XHQgKiAgICAgICAgICAvLyBCb2xkIHRoZSBncmFkZSBmb3IgYWxsICdBJyBncmFkZSBicm93c2Vyc1xuXHRcdCAqICAgICAgICAgIGlmICggZGF0YVs0XSA9PSBcIkFcIiApIHtcblx0XHQgKiAgICAgICAgICAgICQoJ3RkOmVxKDQpJywgcm93KS5odG1sKCAnPGI+QTwvYj4nICk7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5Sb3dDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBmdW5jdGlvbiB3aGljaCBvYnRhaW5zXG5cdFx0ICogdGhlIGRhdGEgZnJvbSB0aGUgc2VydmVyIHNvIHNvbWV0aGluZyBtb3JlIHN1aXRhYmxlIGZvciB5b3VyIGFwcGxpY2F0aW9uLlxuXHRcdCAqIEZvciBleGFtcGxlIHlvdSBjb3VsZCB1c2UgUE9TVCBkYXRhLCBvciBwdWxsIGluZm9ybWF0aW9uIGZyb20gYSBHZWFycyBvclxuXHRcdCAqIEFJUiBkYXRhYmFzZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gc291cmNlIEhUVFAgc291cmNlIHRvIG9idGFpbiB0aGUgZGF0YSBmcm9tIChgYWpheGApXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgQSBrZXkvdmFsdWUgcGFpciBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSB0byBzZW5kXG5cdFx0ICogICAgdG8gdGhlIHNlcnZlclxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gY29tcGxldGlvbiBvZiB0aGUgZGF0YSBnZXRcblx0XHQgKiAgICBwcm9jZXNzIHRoYXQgd2lsbCBkcmF3IHRoZSBkYXRhIG9uIHRoZSBwYWdlLlxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyRGF0YVxuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwiZm5TZXJ2ZXJEYXRhXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0XHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiAgSXQgaXMgb2Z0ZW4gdXNlZnVsIHRvIHNlbmQgZXh0cmEgZGF0YSB0byB0aGUgc2VydmVyIHdoZW4gbWFraW5nIGFuIEFqYXhcblx0XHQgKiByZXF1ZXN0IC0gZm9yIGV4YW1wbGUgY3VzdG9tIGZpbHRlcmluZyBpbmZvcm1hdGlvbiwgYW5kIHRoaXMgY2FsbGJhY2tcblx0XHQgKiBmdW5jdGlvbiBtYWtlcyBpdCB0cml2aWFsIHRvIHNlbmQgZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIHNlcnZlci4gVGhlXG5cdFx0ICogcGFzc2VkIGluIHBhcmFtZXRlciBpcyB0aGUgZGF0YSBzZXQgdGhhdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBieVxuXHRcdCAqIERhdGFUYWJsZXMsIGFuZCB5b3UgY2FuIGFkZCB0byB0aGlzIG9yIG1vZGlmeSBpdCBhcyB5b3UgcmVxdWlyZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBEYXRhIGFycmF5IChhcnJheSBvZiBvYmplY3RzIHdoaWNoIGFyZSBuYW1lL3ZhbHVlXG5cdFx0ICogICAgcGFpcnMpIHRoYXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgYnkgRGF0YVRhYmxlcyBhbmQgd2lsbCBiZSBzZW50IHRvIHRoZVxuXHRcdCAqICAgIHNlcnZlci4gSW4gdGhlIGNhc2Ugb2YgQWpheCBzb3VyY2VkIGRhdGEgd2l0aCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0ICogICAgdGhpcyB3aWxsIGJlIGFuIGVtcHR5IGFycmF5LCBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0aGVyZSB3aWxsIGJlIGFcblx0XHQgKiAgICBzaWduaWZpY2FudCBudW1iZXIgb2YgcGFyYW1ldGVycyFcblx0XHQgKiAgQHJldHVybnMge3VuZGVmaW5lZH0gRW5zdXJlIHRoYXQgeW91IG1vZGlmeSB0aGUgZGF0YSBhcnJheSBwYXNzZWQgaW4sXG5cdFx0ICogICAgYXMgdGhpcyBpcyBwYXNzZWQgYnkgcmVmZXJlbmNlLlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJQYXJhbXNcblx0XHQgKlxuXHRcdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0XHQgKi9cblx0XHRcImZuU2VydmVyUGFyYW1zXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBMb2FkIHRoZSB0YWJsZSBzdGF0ZS4gV2l0aCB0aGlzIGZ1bmN0aW9uIHlvdSBjYW4gZGVmaW5lIGZyb20gd2hlcmUsIGFuZCBob3csIHRoZVxuXHRcdCAqIHN0YXRlIG9mIGEgdGFibGUgaXMgbG9hZGVkLiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb2FkIGZyb20gYGxvY2FsU3RvcmFnZWBcblx0XHQgKiBidXQgeW91IG1pZ2h0IHdpc2ggdG8gdXNlIGEgc2VydmVyLXNpZGUgZGF0YWJhc2Ugb3IgY29va2llcy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgY2FuIGJlIGV4ZWN1dGVkIHdoZW4gZG9uZS4gSXRcblx0XHQgKiAgICBzaG91bGQgYmUgcGFzc2VkIHRoZSBsb2FkZWQgc3RhdGUgb2JqZWN0LlxuXHRcdCAqICBAcmV0dXJuIHtvYmplY3R9IFRoZSBEYXRhVGFibGVzIHN0YXRlIG9iamVjdCB0byBiZSBsb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZUxvYWRDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGNhbGxiYWNrKSB7XG5cdFx0ICogICAgICAgICAgJC5hamF4KCB7XG5cdFx0ICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9sb2FkXCIsXG5cdFx0ICogICAgICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxuXHRcdCAqICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZ1bmN0aW9uIChqc29uKSB7XG5cdFx0ICogICAgICAgICAgICAgIGNhbGxiYWNrKCBqc29uICk7XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgfSApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZUxvYWRDYWxsYmFja1wiOiBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoXG5cdFx0XHRcdFx0KHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uID09PSAtMSA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKS5nZXRJdGVtKFxuXHRcdFx0XHRcdFx0J0RhdGFUYWJsZXNfJytzZXR0aW5ncy5zSW5zdGFuY2UrJ18nK2xvY2F0aW9uLnBhdGhuYW1lXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgd2hpY2ggYWxsb3dzIG1vZGlmaWNhdGlvbiBvZiB0aGUgc2F2ZWQgc3RhdGUgcHJpb3IgdG8gbG9hZGluZyB0aGF0IHN0YXRlLlxuXHRcdCAqIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRhYmxlIGlzIGxvYWRpbmcgc3RhdGUgZnJvbSB0aGUgc3RvcmVkIGRhdGEsIGJ1dFxuXHRcdCAqIHByaW9yIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgYmVpbmcgbW9kaWZpZWQgYnkgdGhlIHNhdmVkIHN0YXRlLiBOb3RlIHRoYXQgZm9yXG5cdFx0ICogcGx1Zy1pbiBhdXRob3JzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYHN0YXRlTG9hZFBhcmFtc2AgZXZlbnQgdG8gbG9hZCBwYXJhbWV0ZXJzIGZvclxuXHRcdCAqIGEgcGx1Zy1pbi5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdGhhdCBpcyB0byBiZSBsb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRQYXJhbXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFJlbW92ZSBhIHNhdmVkIGZpbHRlciwgc28gZmlsdGVyaW5nIGlzIG5ldmVyIGxvYWRlZFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic3RhdGVMb2FkUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIGRhdGEub1NlYXJjaC5zU2VhcmNoID0gXCJcIjtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIERpc2FsbG93IHN0YXRlIGxvYWRpbmcgYnkgcmV0dXJuaW5nIGZhbHNlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZUxvYWRQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZUxvYWRQYXJhbXNcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZCBmcm9tIHRoZSBzdGF0ZSBzYXZpbmcgbWV0aG9kXG5cdFx0ICogYW5kIHRoZSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBtb2RpZmllZCBhcyBhIHJlc3VsdCBvZiB0aGUgbG9hZGVkIHN0YXRlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0aGF0IHdhcyBsb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRlZFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gU2hvdyBhbiBhbGVydCB3aXRoIHRoZSBmaWx0ZXJpbmcgdmFsdWUgdGhhdCB3YXMgc2F2ZWRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlTG9hZGVkXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIGFsZXJ0KCAnU2F2ZWQgZmlsdGVyIHdhczogJytkYXRhLm9TZWFyY2guc1NlYXJjaCApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZUxvYWRlZFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogU2F2ZSB0aGUgdGFibGUgc3RhdGUuIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBkZWZpbmUgd2hlcmUgYW5kIGhvdyB0aGUgc3RhdGVcblx0XHQgKiBpbmZvcm1hdGlvbiBmb3IgdGhlIHRhYmxlIGlzIHN0b3JlZCBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCB1c2UgYGxvY2FsU3RvcmFnZWBcblx0XHQgKiBidXQgeW91IG1pZ2h0IHdpc2ggdG8gdXNlIGEgc2VydmVyLXNpZGUgZGF0YWJhc2Ugb3IgY29va2llcy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZUNhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZUNhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIC8vIFNlbmQgYW4gQWpheCByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgd2l0aCB0aGUgc3RhdGUgb2JqZWN0XG5cdFx0ICogICAgICAgICAgJC5hamF4KCB7XG5cdFx0ICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9zYXZlXCIsXG5cdFx0ICogICAgICAgICAgICBcImRhdGFcIjogZGF0YSxcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXG5cdFx0ICogICAgICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIlxuXHRcdCAqICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZ1bmN0aW9uICgpIHt9XG5cdFx0ICogICAgICAgICAgfSApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiOiBmdW5jdGlvbiAoIHNldHRpbmdzLCBkYXRhICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0KHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uID09PSAtMSA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKS5zZXRJdGVtKFxuXHRcdFx0XHRcdCdEYXRhVGFibGVzXycrc2V0dGluZ3Muc0luc3RhbmNlKydfJytsb2NhdGlvbi5wYXRobmFtZSxcblx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeSggZGF0YSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSB0byBiZSBzYXZlZC4gQ2FsbGVkIHdoZW4gdGhlIHRhYmxlXG5cdFx0ICogaGFzIGNoYW5nZWQgc3RhdGUgYSBuZXcgc3RhdGUgc2F2ZSBpcyByZXF1aXJlZC4gVGhpcyBtZXRob2QgYWxsb3dzIG1vZGlmaWNhdGlvbiBvZlxuXHRcdCAqIHRoZSBzdGF0ZSBzYXZpbmcgb2JqZWN0IHByaW9yIHRvIGFjdHVhbGx5IGRvaW5nIHRoZSBzYXZlLCBpbmNsdWRpbmcgYWRkaXRpb24gb3Jcblx0XHQgKiBvdGhlciBzdGF0ZSBwcm9wZXJ0aWVzIG9yIG1vZGlmaWNhdGlvbi4gTm90ZSB0aGF0IGZvciBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGRcblx0XHQgKiB1c2UgdGhlIGBzdGF0ZVNhdmVQYXJhbXNgIGV2ZW50IHRvIHNhdmUgcGFyYW1ldGVycyBmb3IgYSBwbHVnLWluLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZVBhcmFtc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUmVtb3ZlIGEgc2F2ZWQgZmlsdGVyLCBzbyBmaWx0ZXJpbmcgaXMgbmV2ZXIgc2F2ZWRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVBhcmFtc1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0XHQgKiAgICAgICAgICBkYXRhLm9TZWFyY2guc1NlYXJjaCA9IFwiXCI7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblN0YXRlU2F2ZVBhcmFtc1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRHVyYXRpb24gZm9yIHdoaWNoIHRoZSBzYXZlZCBzdGF0ZSBpbmZvcm1hdGlvbiBpcyBjb25zaWRlcmVkIHZhbGlkLiBBZnRlciB0aGlzIHBlcmlvZFxuXHRcdCAqIGhhcyBlbGFwc2VkIHRoZSBzdGF0ZSB3aWxsIGJlIHJldHVybmVkIHRvIHRoZSBkZWZhdWx0LlxuXHRcdCAqIFZhbHVlIGlzIGdpdmVuIGluIHNlY29uZHMuXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCA3MjAwIDxpPigyIGhvdXJzKTwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVEdXJhdGlvblxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZUR1cmF0aW9uXCI6IDYwKjYwKjI0OyAvLyAxIGRheVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiaVN0YXRlRHVyYXRpb25cIjogNzIwMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gZW5hYmxlZCBEYXRhVGFibGVzIHdpbGwgbm90IG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgZm9yIHRoZSBmaXJzdFxuXHRcdCAqIHBhZ2UgZHJhdyAtIHJhdGhlciBpdCB3aWxsIHVzZSB0aGUgZGF0YSBhbHJlYWR5IG9uIHRoZSBwYWdlIChubyBzb3J0aW5nIGV0Y1xuXHRcdCAqIHdpbGwgYmUgYXBwbGllZCB0byBpdCksIHRodXMgc2F2aW5nIG9uIGFuIFhIUiBhdCBsb2FkIHRpbWUuIGBkZWZlckxvYWRpbmdgXG5cdFx0ICogaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IGRlZmVycmVkIGxvYWRpbmcgaXMgcmVxdWlyZWQsIGJ1dCBpdCBpcyBhbHNvIHVzZWRcblx0XHQgKiB0byB0ZWxsIERhdGFUYWJsZXMgaG93IG1hbnkgcmVjb3JkcyB0aGVyZSBhcmUgaW4gdGhlIGZ1bGwgdGFibGUgKGFsbG93aW5nXG5cdFx0ICogdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgYW5kIHBhZ2luYXRpb24gdG8gYmUgZGlzcGxheWVkIGNvcnJlY3RseSkuIEluIHRoZSBjYXNlXG5cdFx0ICogd2hlcmUgYSBmaWx0ZXJpbmcgaXMgYXBwbGllZCB0byB0aGUgdGFibGUgb24gaW5pdGlhbCBsb2FkLCB0aGlzIGNhbiBiZVxuXHRcdCAqIGluZGljYXRlZCBieSBnaXZpbmcgdGhlIHBhcmFtZXRlciBhcyBhbiBhcnJheSwgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXNcblx0XHQgKiB0aGUgbnVtYmVyIG9mIHJlY29yZHMgYXZhaWxhYmxlIGFmdGVyIGZpbHRlcmluZyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZVxuXHRcdCAqIG51bWJlciBvZiByZWNvcmRzIHdpdGhvdXQgZmlsdGVyaW5nIChhbGxvd2luZyB0aGUgdGFibGUgaW5mb3JtYXRpb24gZWxlbWVudFxuXHRcdCAqIHRvIGJlIHNob3duIGNvcnJlY3RseSkuXG5cdFx0ICogIEB0eXBlIGludCB8IGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGVmZXJMb2FkaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyA1NyByZWNvcmRzIGF2YWlsYWJsZSBpbiB0aGUgdGFibGUsIG5vIGZpbHRlcmluZyBhcHBsaWVkXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwiYWpheFwiOiBcInNjcmlwdHMvc2VydmVyX3Byb2Nlc3NpbmcucGhwXCIsXG5cdFx0ICogICAgICAgIFwiZGVmZXJMb2FkaW5nXCI6IDU3XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gNTcgcmVjb3JkcyBhZnRlciBmaWx0ZXJpbmcsIDEwMCB3aXRob3V0IGZpbHRlcmluZyAoYW4gaW5pdGlhbCBmaWx0ZXIgYXBwbGllZClcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJhamF4XCI6IFwic2NyaXB0cy9zZXJ2ZXJfcHJvY2Vzc2luZy5waHBcIixcblx0XHQgKiAgICAgICAgXCJkZWZlckxvYWRpbmdcIjogWyA1NywgMTAwIF0sXG5cdFx0ICogICAgICAgIFwic2VhcmNoXCI6IHtcblx0XHQgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIm15X2ZpbHRlclwiXG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJpRGVmZXJMb2FkaW5nXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IG9uIGEgc2luZ2xlIHBhZ2Ugd2hlbiB1c2luZyBwYWdpbmF0aW9uLiBJZlxuXHRcdCAqIGZlYXR1cmUgZW5hYmxlZCAoYGxlbmd0aENoYW5nZWApIHRoZW4gdGhlIGVuZCB1c2VyIHdpbGwgYmUgYWJsZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoaXMgdG8gYSBjdXN0b20gc2V0dGluZyB1c2luZyBhIHBvcC11cCBtZW51LlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMTBcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnZUxlbmd0aFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwYWdlTGVuZ3RoXCI6IDUwXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJpRGlzcGxheUxlbmd0aFwiOiAxMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERlZmluZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIGRhdGEgZGlzcGxheSB3aGVuIHVzaW5nIERhdGFUYWJsZXMgd2l0aFxuXHRcdCAqIHBhZ2luYXRpb24uIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJhdGhlciB0aGFuXG5cdFx0ICogdGhlIHBhZ2UgbnVtYmVyLCBzbyBpZiB5b3UgaGF2ZSAxMCByZWNvcmRzIHBlciBwYWdlIGFuZCB3YW50IHRvIHN0YXJ0IG9uXG5cdFx0ICogdGhlIHRoaXJkIHBhZ2UsIGl0IHNob3VsZCBiZSBcIjIwXCIuXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRpc3BsYXlTdGFydFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkaXNwbGF5U3RhcnRcIjogMjBcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImlEaXNwbGF5U3RhcnRcIjogMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyBhbGxvd3Mga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgKHNvcnRpbmcsIHBhZ2luZyxcblx0XHQgKiBhbmQgZmlsdGVyaW5nKSBieSBhZGRpbmcgYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSB0byB0aGUgcmVxdWlyZWQgZWxlbWVudHMuIFRoaXNcblx0XHQgKiBhbGxvd3MgeW91IHRvIHRhYiB0aHJvdWdoIHRoZSBjb250cm9scyBhbmQgcHJlc3MgdGhlIGVudGVyIGtleSB0byBhY3RpdmF0ZSB0aGVtLlxuXHRcdCAqIFRoZSB0YWJpbmRleCBpcyBkZWZhdWx0IDAsIG1lYW5pbmcgdGhhdCB0aGUgdGFiIGZvbGxvd3MgdGhlIGZsb3cgb2YgdGhlIGRvY3VtZW50LlxuXHRcdCAqIFlvdSBjYW4gb3ZlcnJ1bGUgdGhpcyB1c2luZyB0aGlzIHBhcmFtZXRlciBpZiB5b3Ugd2lzaC4gVXNlIGEgdmFsdWUgb2YgLTEgdG9cblx0XHQgKiBkaXNhYmxlIGJ1aWx0LWluIGtleWJvYXJkIG5hdmlnYXRpb24uXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnRhYkluZGV4XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInRhYkluZGV4XCI6IDFcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJpVGFiSW5kZXhcIjogMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzZXMgdGhhdCBEYXRhVGFibGVzIGFzc2lnbnMgdG8gdGhlIHZhcmlvdXMgY29tcG9uZW50cyBhbmQgZmVhdHVyZXNcblx0XHQgKiB0aGF0IGl0IGFkZHMgdG8gdGhlIEhUTUwgdGFibGUuIFRoaXMgYWxsb3dzIGNsYXNzZXMgdG8gYmUgY29uZmlndXJlZFxuXHRcdCAqIGR1cmluZyBpbml0aWFsaXNhdGlvbiBpbiBhZGRpdGlvbiB0byB0aHJvdWdoIHRoZSBzdGF0aWNcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmV4dC5vU3RkQ2xhc3Nlc30gb2JqZWN0KS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY2xhc3Nlc1xuXHRcdCAqL1xuXHRcdFwib0NsYXNzZXNcIjoge30sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbGwgc3RyaW5ncyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbiB0aGUgdXNlciBpbnRlcmZhY2UgdGhhdCBpdCBjcmVhdGVzXG5cdFx0ICogYXJlIGRlZmluZWQgaW4gdGhpcyBvYmplY3QsIGFsbG93aW5nIHlvdSB0byBtb2RpZmllZCB0aGVtIGluZGl2aWR1YWxseSBvclxuXHRcdCAqIGNvbXBsZXRlbHkgcmVwbGFjZSB0aGVtIGFsbCBhcyByZXF1aXJlZC5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2Vcblx0XHQgKi9cblx0XHRcIm9MYW5ndWFnZVwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0cmluZ3MgdGhhdCBhcmUgdXNlZCBmb3IgV0FJLUFSSUEgbGFiZWxzIGFuZCBjb250cm9scyBvbmx5ICh0aGVzZSBhcmUgbm90XG5cdFx0XHQgKiBhY3R1YWxseSB2aXNpYmxlIG9uIHRoZSBwYWdlLCBidXQgd2lsbCBiZSByZWFkIGJ5IHNjcmVlbnJlYWRlcnMsIGFuZCB0aHVzXG5cdFx0XHQgKiBtdXN0IGJlIGludGVybmF0aW9uYWxpc2VkIGFzIHdlbGwpLlxuXHRcdFx0ICogIEBuYW1lc3BhY2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYVxuXHRcdFx0ICovXG5cdFx0XHRcIm9BcmlhXCI6IHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gbWF5IGJlXG5cdFx0XHRcdCAqIHNvcnRlZCBhc2NlbmRpbmcgYnkgYWN0aXZpbmcgdGhlIGNvbHVtbiAoY2xpY2sgb3IgcmV0dXJuIHdoZW4gZm9jdXNlZCkuXG5cdFx0XHRcdCAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBpcyBwcmVmaXhlZCB0byB0aGlzIHN0cmluZy5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWEuc29ydEFzY2VuZGluZ1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJhcmlhXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcInNvcnRBc2NlbmRpbmdcIjogXCIgLSBjbGljay9yZXR1cm4gdG8gc29ydCBhc2NlbmRpbmdcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNTb3J0QXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcIixcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBUklBIGxhYmVsIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRhYmxlIGhlYWRlcnMgd2hlbiB0aGUgY29sdW1uIG1heSBiZVxuXHRcdFx0XHQgKiBzb3J0ZWQgZGVzY2VuZGluZyBieSBhY3RpdmluZyB0aGUgY29sdW1uIChjbGljayBvciByZXR1cm4gd2hlbiBmb2N1c2VkKS5cblx0XHRcdFx0ICogTm90ZSB0aGF0IHRoZSBjb2x1bW4gaGVhZGVyIGlzIHByZWZpeGVkIHRvIHRoaXMgc3RyaW5nLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCA6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGFzY2VuZGluZ1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYS5zb3J0RGVzY2VuZGluZ1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJhcmlhXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcInNvcnREZXNjZW5kaW5nXCI6IFwiIC0gY2xpY2svcmV0dXJuIHRvIHNvcnQgZGVzY2VuZGluZ1wiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic1NvcnREZXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBkZXNjZW5kaW5nXCJcblx0XHRcdH0sXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQYWdpbmF0aW9uIHN0cmluZyB1c2VkIGJ5IERhdGFUYWJsZXMgZm9yIHRoZSBidWlsdC1pbiBwYWdpbmF0aW9uXG5cdFx0XHQgKiBjb250cm9sIHR5cGVzLlxuXHRcdFx0ICogIEBuYW1lc3BhY2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGVcblx0XHRcdCAqL1xuXHRcdFx0XCJvUGFnaW5hdGVcIjoge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVGV4dCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ2Z1bGxfbnVtYmVycycgdHlwZSBvZiBwYWdpbmF0aW9uIGZvciB0aGVcblx0XHRcdFx0ICogYnV0dG9uIHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlIGZpcnN0IHBhZ2UuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IEZpcnN0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5maXJzdFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJmaXJzdFwiOiBcIkZpcnN0IHBhZ2VcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNGaXJzdFwiOiBcIkZpcnN0XCIsXG5cdFxuXHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFRleHQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdmdWxsX251bWJlcnMnIHR5cGUgb2YgcGFnaW5hdGlvbiBmb3IgdGhlXG5cdFx0XHRcdCAqIGJ1dHRvbiB0byB0YWtlIHRoZSB1c2VyIHRvIHRoZSBsYXN0IHBhZ2UuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IExhc3Rcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLmxhc3Rcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwibGFzdFwiOiBcIkxhc3QgcGFnZVwiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic0xhc3RcIjogXCJMYXN0XCIsXG5cdFxuXHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFRleHQgdG8gdXNlIGZvciB0aGUgJ25leHQnIHBhZ2luYXRpb24gYnV0dG9uICh0byB0YWtlIHRoZSB1c2VyIHRvIHRoZVxuXHRcdFx0XHQgKiBuZXh0IHBhZ2UpLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCBOZXh0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5uZXh0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcIm5leHRcIjogXCJOZXh0IHBhZ2VcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNOZXh0XCI6IFwiTmV4dFwiLFxuXHRcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBUZXh0IHRvIHVzZSBmb3IgdGhlICdwcmV2aW91cycgcGFnaW5hdGlvbiBidXR0b24gKHRvIHRha2UgdGhlIHVzZXIgdG9cblx0XHRcdFx0ICogdGhlIHByZXZpb3VzIHBhZ2UpLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCBQcmV2aW91c1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUucHJldmlvdXNcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwicHJldmlvdXNcIjogXCJQcmV2aW91cyBwYWdlXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzUHJldmlvdXNcIjogXCJQcmV2aW91c1wiXG5cdFx0XHR9LFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBzdHJpbmcgaXMgc2hvd24gaW4gcHJlZmVyZW5jZSB0byBgemVyb1JlY29yZHNgIHdoZW4gdGhlIHRhYmxlIGlzXG5cdFx0XHQgKiBlbXB0eSBvZiBkYXRhIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuIE5vdGUgdGhhdCB0aGlzIGlzIGFuIG9wdGlvbmFsXG5cdFx0XHQgKiBwYXJhbWV0ZXIgLSBpZiBpdCBpcyBub3QgZ2l2ZW4sIHRoZSB2YWx1ZSBvZiBgemVyb1JlY29yZHNgIHdpbGwgYmUgdXNlZFxuXHRcdFx0ICogaW5zdGVhZCAoZWl0aGVyIHRoZSBkZWZhdWx0IG9yIGdpdmVuIHZhbHVlKS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuZW1wdHlUYWJsZVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJlbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNFbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGlzIHN0cmluZyBnaXZlcyBpbmZvcm1hdGlvbiB0byB0aGUgZW5kIHVzZXIgYWJvdXQgdGhlIGluZm9ybWF0aW9uXG5cdFx0XHQgKiB0aGF0IGlzIGN1cnJlbnQgb24gZGlzcGxheSBvbiB0aGUgcGFnZS4gVGhlIGZvbGxvd2luZyB0b2tlbnMgY2FuIGJlXG5cdFx0XHQgKiB1c2VkIGluIHRoZSBzdHJpbmcgYW5kIHdpbGwgYmUgZHluYW1pY2FsbHkgcmVwbGFjZWQgYXMgdGhlIHRhYmxlXG5cdFx0XHQgKiBkaXNwbGF5IHVwZGF0ZXMuIFRoaXMgdG9rZW5zIGNhbiBiZSBwbGFjZWQgYW55d2hlcmUgaW4gdGhlIHN0cmluZywgb3Jcblx0XHRcdCAqIHJlbW92ZWQgYXMgbmVlZGVkIGJ5IHRoZSBsYW5ndWFnZSByZXF1aXJlczpcblx0XHRcdCAqXG5cdFx0XHQgKiAqIGBcXF9TVEFSVFxcX2AgLSBEaXNwbGF5IGluZGV4IG9mIHRoZSBmaXJzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRcdFx0ICogKiBgXFxfRU5EXFxfYCAtIERpc3BsYXkgaW5kZXggb2YgdGhlIGxhc3QgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHRcdCAqICogYFxcX1RPVEFMXFxfYCAtIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSB0YWJsZSBhZnRlciBmaWx0ZXJpbmdcblx0XHRcdCAqICogYFxcX01BWFxcX2AgLSBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgdGFibGUgd2l0aG91dCBmaWx0ZXJpbmdcblx0XHRcdCAqICogYFxcX1BBR0VcXF9gIC0gQ3VycmVudCBwYWdlIG51bWJlclxuXHRcdFx0ICogKiBgXFxfUEFHRVNcXF9gIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzIG9mIGRhdGEgaW4gdGhlIHRhYmxlXG5cdFx0XHQgKlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIGVudHJpZXNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiaW5mb1wiOiBcIlNob3dpbmcgcGFnZSBfUEFHRV8gb2YgX1BBR0VTX1wiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0luZm9cIjogXCJTaG93aW5nIF9TVEFSVF8gdG8gX0VORF8gb2YgX1RPVEFMXyBlbnRyaWVzXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGlzcGxheSBpbmZvcm1hdGlvbiBzdHJpbmcgZm9yIHdoZW4gdGhlIHRhYmxlIGlzIGVtcHR5LiBUeXBpY2FsbHkgdGhlXG5cdFx0XHQgKiBmb3JtYXQgb2YgdGhpcyBzdHJpbmcgc2hvdWxkIG1hdGNoIGBpbmZvYC5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBTaG93aW5nIDAgdG8gMCBvZiAwIGVudHJpZXNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9FbXB0eVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJpbmZvRW1wdHlcIjogXCJObyBlbnRyaWVzIHRvIHNob3dcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNJbmZvRW1wdHlcIjogXCJTaG93aW5nIDAgdG8gMCBvZiAwIGVudHJpZXNcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGVuIGEgdXNlciBmaWx0ZXJzIHRoZSBpbmZvcm1hdGlvbiBpbiBhIHRhYmxlLCB0aGlzIHN0cmluZyBpcyBhcHBlbmRlZFxuXHRcdFx0ICogdG8gdGhlIGluZm9ybWF0aW9uIChgaW5mb2ApIHRvIGdpdmUgYW4gaWRlYSBvZiBob3cgc3Ryb25nIHRoZSBmaWx0ZXJpbmdcblx0XHRcdCAqIGlzLiBUaGUgdmFyaWFibGUgX01BWF8gaXMgZHluYW1pY2FsbHkgdXBkYXRlZC5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCAoZmlsdGVyZWQgZnJvbSBfTUFYXyB0b3RhbCBlbnRyaWVzKVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb0ZpbHRlcmVkXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImluZm9GaWx0ZXJlZFwiOiBcIiAtIGZpbHRlcmluZyBmcm9tIF9NQVhfIHJlY29yZHNcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNJbmZvRmlsdGVyZWRcIjogXCIoZmlsdGVyZWQgZnJvbSBfTUFYXyB0b3RhbCBlbnRyaWVzKVwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIElmIGNhbiBiZSB1c2VmdWwgdG8gYXBwZW5kIGV4dHJhIGluZm9ybWF0aW9uIHRvIHRoZSBpbmZvIHN0cmluZyBhdCB0aW1lcyxcblx0XHRcdCAqIGFuZCB0aGlzIHZhcmlhYmxlIGRvZXMgZXhhY3RseSB0aGF0LiBUaGlzIGluZm9ybWF0aW9uIHdpbGwgYmUgYXBwZW5kZWQgdG9cblx0XHRcdCAqIHRoZSBgaW5mb2AgKGBpbmZvRW1wdHlgIGFuZCBgaW5mb0ZpbHRlcmVkYCBpbiB3aGF0ZXZlciBjb21iaW5hdGlvbiB0aGV5IGFyZVxuXHRcdFx0ICogYmVpbmcgdXNlZCkgYXQgYWxsIHRpbWVzLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9Qb3N0Rml4XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImluZm9Qb3N0Rml4XCI6IFwiQWxsIHJlY29yZHMgc2hvd24gYXJlIGRlcml2ZWQgZnJvbSByZWFsIGluZm9ybWF0aW9uLlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0luZm9Qb3N0Rml4XCI6IFwiXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBkZWNpbWFsIHBsYWNlIG9wZXJhdG9yIGlzIGEgbGl0dGxlIGRpZmZlcmVudCBmcm9tIHRoZSBvdGhlclxuXHRcdFx0ICogbGFuZ3VhZ2Ugb3B0aW9ucyBzaW5jZSBEYXRhVGFibGVzIGRvZXNuJ3Qgb3V0cHV0IGZsb2F0aW5nIHBvaW50XG5cdFx0XHQgKiBudW1iZXJzLCBzbyBpdCB3b24ndCBldmVyIHVzZSB0aGlzIGZvciBkaXNwbGF5IG9mIGEgbnVtYmVyLiBSYXRoZXIsXG5cdFx0XHQgKiB3aGF0IHRoaXMgcGFyYW1ldGVyIGRvZXMgaXMgbW9kaWZ5IHRoZSBzb3J0IG1ldGhvZHMgb2YgdGhlIHRhYmxlIHNvXG5cdFx0XHQgKiB0aGF0IG51bWJlcnMgd2hpY2ggYXJlIGluIGEgZm9ybWF0IHdoaWNoIGhhcyBhIGNoYXJhY3RlciBvdGhlciB0aGFuXG5cdFx0XHQgKiBhIHBlcmlvZCAoYC5gKSBhcyBhIGRlY2ltYWwgcGxhY2Ugd2lsbCBiZSBzb3J0ZWQgbnVtZXJpY2FsbHkuXG5cdFx0XHQgKlxuXHRcdFx0ICogTm90ZSB0aGF0IG51bWJlcnMgd2l0aCBkaWZmZXJlbnQgZGVjaW1hbCBwbGFjZXMgY2Fubm90IGJlIHNob3duIGluXG5cdFx0XHQgKiB0aGUgc2FtZSB0YWJsZSBhbmQgc3RpbGwgYmUgc29ydGFibGUsIHRoZSB0YWJsZSBtdXN0IGJlIGNvbnNpc3RlbnQuXG5cdFx0XHQgKiBIb3dldmVyLCBtdWx0aXBsZSBkaWZmZXJlbnQgdGFibGVzIG9uIHRoZSBwYWdlIGNhbiB1c2UgZGlmZmVyZW50XG5cdFx0XHQgKiBkZWNpbWFsIHBsYWNlIGNoYXJhY3RlcnMuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5kZWNpbWFsXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImRlY2ltYWxcIjogXCIsXCJcblx0XHRcdCAqICAgICAgICAgIFwidGhvdXNhbmRzXCI6IFwiLlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0RlY2ltYWxcIjogXCJcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEYXRhVGFibGVzIGhhcyBhIGJ1aWxkIGluIG51bWJlciBmb3JtYXR0ZXIgKGBmb3JtYXROdW1iZXJgKSB3aGljaCBpc1xuXHRcdFx0ICogdXNlZCB0byBmb3JtYXQgbGFyZ2UgbnVtYmVycyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0YWJsZSBpbmZvcm1hdGlvbi5cblx0XHRcdCAqIEJ5IGRlZmF1bHQgYSBjb21tYSBpcyB1c2VkLCBidXQgdGhpcyBjYW4gYmUgdHJpdmlhbGx5IGNoYW5nZWQgdG8gYW55XG5cdFx0XHQgKiBjaGFyYWN0ZXIgeW91IHdpc2ggd2l0aCB0aGlzIHBhcmFtZXRlci5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCAsXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS50aG91c2FuZHNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwidGhvdXNhbmRzXCI6IFwiJ1wiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1Rob3VzYW5kc1wiOiBcIixcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZXRhaWwgdGhlIGFjdGlvbiB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgZHJvcCBkb3duIG1lbnUgZm9yIHRoZVxuXHRcdFx0ICogcGFnaW5hdGlvbiBsZW5ndGggb3B0aW9uIGlzIGNoYW5nZWQuIFRoZSAnX01FTlVfJyB2YXJpYWJsZSBpcyByZXBsYWNlZFxuXHRcdFx0ICogd2l0aCBhIGRlZmF1bHQgc2VsZWN0IGxpc3Qgb2YgMTAsIDI1LCA1MCBhbmQgMTAwLCBhbmQgY2FuIGJlIHJlcGxhY2VkXG5cdFx0XHQgKiB3aXRoIGEgY3VzdG9tIHNlbGVjdCBib3ggaWYgcmVxdWlyZWQuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgU2hvdyBfTUVOVV8gZW50cmllc1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UubGVuZ3RoTWVudVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTGFuZ3VhZ2UgY2hhbmdlIG9ubHlcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwibGVuZ3RoTWVudVwiOiBcIkRpc3BsYXkgX01FTlVfIHJlY29yZHNcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTGFuZ3VhZ2UgYW5kIG9wdGlvbnMgY2hhbmdlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImxlbmd0aE1lbnVcIjogJ0Rpc3BsYXkgPHNlbGVjdD4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjEwXCI+MTA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjIwXCI+MjA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjMwXCI+MzA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjQwXCI+NDA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjUwXCI+NTA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIi0xXCI+QWxsPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzwvc2VsZWN0PiByZWNvcmRzJ1xuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNMZW5ndGhNZW51XCI6IFwiU2hvdyBfTUVOVV8gZW50cmllc1wiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFdoZW4gdXNpbmcgQWpheCBzb3VyY2VkIGRhdGEgYW5kIGR1cmluZyB0aGUgZmlyc3QgZHJhdyB3aGVuIERhdGFUYWJsZXMgaXNcblx0XHRcdCAqIGdhdGhlcmluZyB0aGUgZGF0YSwgdGhpcyBtZXNzYWdlIGlzIHNob3duIGluIGFuIGVtcHR5IHJvdyBpbiB0aGUgdGFibGUgdG9cblx0XHRcdCAqIGluZGljYXRlIHRvIHRoZSBlbmQgdXNlciB0aGUgdGhlIGRhdGEgaXMgYmVpbmcgbG9hZGVkLiBOb3RlIHRoYXQgdGhpc1xuXHRcdFx0ICogcGFyYW1ldGVyIGlzIG5vdCB1c2VkIHdoZW4gbG9hZGluZyBkYXRhIGJ5IHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIGp1c3Rcblx0XHRcdCAqIEFqYXggc291cmNlZCBkYXRhIHdpdGggY2xpZW50LXNpZGUgcHJvY2Vzc2luZy5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBMb2FkaW5nLi4uXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5sb2FkaW5nUmVjb3Jkc1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJsb2FkaW5nUmVjb3Jkc1wiOiBcIlBsZWFzZSB3YWl0IC0gbG9hZGluZy4uLlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0xvYWRpbmdSZWNvcmRzXCI6IFwiTG9hZGluZy4uLlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRleHQgd2hpY2ggaXMgZGlzcGxheWVkIHdoZW4gdGhlIHRhYmxlIGlzIHByb2Nlc3NpbmcgYSB1c2VyIGFjdGlvblxuXHRcdFx0ICogKHVzdWFsbHkgYSBzb3J0IGNvbW1hbmQgb3Igc2ltaWxhcikuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgUHJvY2Vzc2luZy4uLlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucHJvY2Vzc2luZ1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJwcm9jZXNzaW5nXCI6IFwiRGF0YVRhYmxlcyBpcyBjdXJyZW50bHkgYnVzeVwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1Byb2Nlc3NpbmdcIjogXCJQcm9jZXNzaW5nLi4uXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGV0YWlscyB0aGUgYWN0aW9ucyB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgdXNlciB0eXBlcyBpbnRvIHRoZVxuXHRcdFx0ICogZmlsdGVyaW5nIGlucHV0IHRleHQgYm94LiBUaGUgdmFyaWFibGUgXCJfSU5QVVRfXCIsIGlmIHVzZWQgaW4gdGhlIHN0cmluZyxcblx0XHRcdCAqIGlzIHJlcGxhY2VkIHdpdGggdGhlIEhUTUwgdGV4dCBib3ggZm9yIHRoZSBmaWx0ZXJpbmcgaW5wdXQgYWxsb3dpbmdcblx0XHRcdCAqIGNvbnRyb2wgb3ZlciB3aGVyZSBpdCBhcHBlYXJzIGluIHRoZSBzdHJpbmcuIElmIFwiX0lOUFVUX1wiIGlzIG5vdCBnaXZlblxuXHRcdFx0ICogdGhlbiB0aGUgaW5wdXQgYm94IGlzIGFwcGVuZGVkIHRvIHRoZSBzdHJpbmcgYXV0b21hdGljYWxseS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBTZWFyY2g6XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5zZWFyY2hcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIElucHV0IHRleHQgYm94IHdpbGwgYmUgYXBwZW5kZWQgYXQgdGhlIGVuZCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIkZpbHRlciByZWNvcmRzOlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBTcGVjaWZ5IHdoZXJlIHRoZSBmaWx0ZXIgc2hvdWxkIGFwcGVhclxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJzZWFyY2hcIjogXCJBcHBseSBmaWx0ZXIgX0lOUFVUXyB0byB0YWJsZVwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1NlYXJjaFwiOiBcIlNlYXJjaDpcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBc3NpZ24gYSBgcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSB0byB0aGUgc2VhcmNoIGBpbnB1dGAgZWxlbWVudFxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2Uuc2VhcmNoUGxhY2Vob2xkZXJcblx0XHRcdCAqL1xuXHRcdFx0XCJzU2VhcmNoUGxhY2Vob2xkZXJcIjogXCJcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbGwgb2YgdGhlIGxhbmd1YWdlIGluZm9ybWF0aW9uIGNhbiBiZSBzdG9yZWQgaW4gYSBmaWxlIG9uIHRoZVxuXHRcdFx0ICogc2VydmVyLXNpZGUsIHdoaWNoIERhdGFUYWJsZXMgd2lsbCBsb29rIHVwIGlmIHRoaXMgcGFyYW1ldGVyIGlzIHBhc3NlZC5cblx0XHRcdCAqIEl0IG11c3Qgc3RvcmUgdGhlIFVSTCBvZiB0aGUgbGFuZ3VhZ2UgZmlsZSwgd2hpY2ggaXMgaW4gYSBKU09OIGZvcm1hdCxcblx0XHRcdCAqIGFuZCB0aGUgb2JqZWN0IGhhcyB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBvTGFuZ3VhZ2Ugb2JqZWN0IGluIHRoZVxuXHRcdFx0ICogaW5pdGlhbGlzZXIgb2JqZWN0IChpLmUuIHRoZSBhYm92ZSBwYXJhbWV0ZXJzKS4gUGxlYXNlIHJlZmVyIHRvIG9uZSBvZlxuXHRcdFx0ICogdGhlIGV4YW1wbGUgbGFuZ3VhZ2UgZmlsZXMgdG8gc2VlIGhvdyB0aGlzIHdvcmtzIGluIGFjdGlvbi5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UudXJsXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInVybFwiOiBcImh0dHA6Ly93d3cuc3ByeW1lZGlhLmNvLnVrL2RhdGFUYWJsZXMvbGFuZy50eHRcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNVcmxcIjogXCJcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUZXh0IHNob3duIGluc2lkZSB0aGUgdGFibGUgcmVjb3JkcyB3aGVuIHRoZSBpcyBubyBpbmZvcm1hdGlvbiB0byBiZVxuXHRcdFx0ICogZGlzcGxheWVkIGFmdGVyIGZpbHRlcmluZy4gYGVtcHR5VGFibGVgIGlzIHNob3duIHdoZW4gdGhlcmUgaXMgc2ltcGx5IG5vXG5cdFx0XHQgKiBpbmZvcm1hdGlvbiBpbiB0aGUgdGFibGUgYXQgYWxsIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuemVyb1JlY29yZHNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiemVyb1JlY29yZHNcIjogXCJObyByZWNvcmRzIHRvIGRpc3BsYXlcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNaZXJvUmVjb3Jkc1wiOiBcIk5vIG1hdGNoaW5nIHJlY29yZHMgZm91bmRcIlxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIGhhdmUgZGVmaW5lIHRoZSBnbG9iYWwgZmlsdGVyaW5nIHN0YXRlIGF0XG5cdFx0ICogaW5pdGlhbGlzYXRpb24gdGltZS4gQXMgYW4gb2JqZWN0IHRoZSBgc2VhcmNoYCBwYXJhbWV0ZXIgbXVzdCBiZVxuXHRcdCAqIGRlZmluZWQsIGJ1dCBhbGwgb3RoZXIgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIFdoZW4gYHJlZ2V4YCBpcyB0cnVlLFxuXHRcdCAqIHRoZSBzZWFyY2ggc3RyaW5nIHdpbGwgYmUgdHJlYXRlZCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgd2hlbiBmYWxzZVxuXHRcdCAqIChkZWZhdWx0KSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzdHJhaWdodCBzdHJpbmcuIFdoZW4gYHNtYXJ0YFxuXHRcdCAqIERhdGFUYWJsZXMgd2lsbCB1c2UgaXQncyBzbWFydCBmaWx0ZXJpbmcgbWV0aG9kcyAodG8gd29yZCBtYXRjaCBhdFxuXHRcdCAqIGFueSBwb2ludCBpbiB0aGUgZGF0YSksIHdoZW4gZmFsc2UgdGhpcyB3aWxsIG5vdCBiZSBkb25lLlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VhcmNoXCI6IHtcInNlYXJjaFwiOiBcIkluaXRpYWwgc2VhcmNoXCJ9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJvU2VhcmNoXCI6ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoICksXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0XHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb29rIGZvciB0aGUgcHJvcGVydHkgYGRhdGFgIChvciBgYWFEYXRhYCBmb3Jcblx0XHQgKiBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhIGZyb20gYW4gQWpheFxuXHRcdCAqIHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyIGFsbG93cyB0aGF0XG5cdFx0ICogcHJvcGVydHkgdG8gYmUgY2hhbmdlZC4gWW91IGNhbiB1c2UgSmF2YXNjcmlwdCBkb3R0ZWQgb2JqZWN0IG5vdGF0aW9uIHRvXG5cdFx0ICogZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgZGF0YVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheERhdGFQcm9wXG5cdFx0ICpcblx0XHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdFx0ICovXG5cdFx0XCJzQWpheERhdGFQcm9wXCI6IFwiZGF0YVwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogWW91IGNhbiBpbnN0cnVjdCBEYXRhVGFibGVzIHRvIGxvYWQgZGF0YSBmcm9tIGFuIGV4dGVybmFsXG5cdFx0ICogc291cmNlIHVzaW5nIHRoaXMgcGFyYW1ldGVyICh1c2UgYURhdGEgaWYgeW91IHdhbnQgdG8gcGFzcyBkYXRhIGluIHlvdVxuXHRcdCAqIGFscmVhZHkgaGF2ZSkuIFNpbXBseSBwcm92aWRlIGEgdXJsIGEgSlNPTiBvYmplY3QgY2FuIGJlIG9idGFpbmVkIGZyb20uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5hamF4U291cmNlXG5cdFx0ICpcblx0XHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdFx0ICovXG5cdFx0XCJzQWpheFNvdXJjZVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBpbml0aWFsaXNhdGlvbiB2YXJpYWJsZSBhbGxvd3MgeW91IHRvIHNwZWNpZnkgZXhhY3RseSB3aGVyZSBpbiB0aGVcblx0XHQgKiBET00geW91IHdhbnQgRGF0YVRhYmxlcyB0byBpbmplY3QgdGhlIHZhcmlvdXMgY29udHJvbHMgaXQgYWRkcyB0byB0aGUgcGFnZVxuXHRcdCAqIChmb3IgZXhhbXBsZSB5b3UgbWlnaHQgd2FudCB0aGUgcGFnaW5hdGlvbiBjb250cm9scyBhdCB0aGUgdG9wIG9mIHRoZVxuXHRcdCAqIHRhYmxlKS4gRElWIGVsZW1lbnRzICh3aXRoIG9yIHdpdGhvdXQgYSBjdXN0b20gY2xhc3MpIGNhbiBhbHNvIGJlIGFkZGVkIHRvXG5cdFx0ICogYWlkIHN0eWxpbmcuIFRoZSBmb2xsb3cgc3ludGF4IGlzIHVzZWQ6XG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT5UaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGFsbG93ZWQ6XG5cdFx0ICogICAgICAgPHVsPlxuXHRcdCAqICAgICAgICAgPGxpPidsJyAtIExlbmd0aCBjaGFuZ2luZzwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J2YnIC0gRmlsdGVyaW5nIGlucHV0PC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4ndCcgLSBUaGUgdGFibGUhPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4naScgLSBJbmZvcm1hdGlvbjwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J3AnIC0gUGFnaW5hdGlvbjwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J3InIC0gcFJvY2Vzc2luZzwvbGk+XG5cdFx0ICogICAgICAgPC91bD5cblx0XHQgKiAgICAgPC9saT5cblx0XHQgKiAgICAgPGxpPlRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSBhbGxvd2VkOlxuXHRcdCAqICAgICAgIDx1bD5cblx0XHQgKiAgICAgICAgIDxsaT4nSCcgLSBqUXVlcnlVSSB0aGVtZSBcImhlYWRlclwiIGNsYXNzZXMgKCdmZy10b29sYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLXRsIHVpLWNvcm5lci10ciB1aS1oZWxwZXItY2xlYXJmaXgnKTwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J0YnIC0galF1ZXJ5VUkgdGhlbWUgXCJmb290ZXJcIiBjbGFzc2VzICgnZmctdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1ibCB1aS1jb3JuZXItYnIgdWktaGVscGVyLWNsZWFyZml4Jyk8L2xpPlxuXHRcdCAqICAgICAgIDwvdWw+XG5cdFx0ICogICAgIDwvbGk+XG5cdFx0ICogICAgIDxsaT5UaGUgZm9sbG93aW5nIHN5bnRheCBpcyBleHBlY3RlZDpcblx0XHQgKiAgICAgICA8dWw+XG5cdFx0ICogICAgICAgICA8bGk+JyZsdDsnIGFuZCAnJmd0OycgLSBkaXYgZWxlbWVudHM8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPicmbHQ7XCJjbGFzc1wiIGFuZCAnJmd0OycgLSBkaXYgd2l0aCBhIGNsYXNzPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0O1wiI2lkXCIgYW5kICcmZ3Q7JyAtIGRpdiB3aXRoIGFuIElEPC9saT5cblx0XHQgKiAgICAgICA8L3VsPlxuXHRcdCAqICAgICA8L2xpPlxuXHRcdCAqICAgICA8bGk+RXhhbXBsZXM6XG5cdFx0ICogICAgICAgPHVsPlxuXHRcdCAqICAgICAgICAgPGxpPicmbHQ7XCJ3cmFwcGVyXCJmbGlwdCZndDsnPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0O2xmJmx0O3QmZ3Q7aXAmZ3Q7JzwvbGk+XG5cdFx0ICogICAgICAgPC91bD5cblx0XHQgKiAgICAgPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBsZnJ0aXAgPGk+KHdoZW4gYGpRdWVyeVVJYCBpcyBmYWxzZSk8L2k+IDxiPm9yPC9iPlxuXHRcdCAqICAgIDxcIkhcImxmcj50PFwiRlwiaXA+IDxpPih3aGVuIGBqUXVlcnlVSWAgaXMgdHJ1ZSk8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkb21cIjogJyZsdDtcInRvcFwiaSZndDtydCZsdDtcImJvdHRvbVwiZmxwJmd0OyZsdDtcImNsZWFyXCImZ3Q7J1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNEb21cIjogXCJsZnJ0aXBcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlYXJjaCBkZWxheSBvcHRpb24uIFRoaXMgd2lsbCB0aHJvdHRsZSBmdWxsIHRhYmxlIHNlYXJjaGVzIHRoYXQgdXNlIHRoZVxuXHRcdCAqIERhdGFUYWJsZXMgcHJvdmlkZWQgc2VhcmNoIGlucHV0IGVsZW1lbnQgKGl0IGRvZXMgbm90IGVmZmVjdCBjYWxscyB0b1xuXHRcdCAqIGBkdC1hcGkgc2VhcmNoKClgLCBwcm92aWRpbmcgYSBkZWxheSBiZWZvcmUgdGhlIHNlYXJjaCBpcyBtYWRlLlxuXHRcdCAqICBAdHlwZSBpbnRlZ2VyXG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoRGVsYXlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VhcmNoRGVsYXlcIjogMjAwXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJzZWFyY2hEZWxheVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBmZWF0dXJlcyBzaXggZGlmZmVyZW50IGJ1aWx0LWluIG9wdGlvbnMgZm9yIHRoZSBidXR0b25zIHRvXG5cdFx0ICogZGlzcGxheSBmb3IgcGFnaW5hdGlvbiBjb250cm9sOlxuXHRcdCAqXG5cdFx0ICogKiBgbnVtYmVyc2AgLSBQYWdlIG51bWJlciBidXR0b25zIG9ubHlcblx0XHQgKiAqIGBzaW1wbGVgIC0gJ1ByZXZpb3VzJyBhbmQgJ05leHQnIGJ1dHRvbnMgb25seVxuXHRcdCAqICogJ3NpbXBsZV9udW1iZXJzYCAtICdQcmV2aW91cycgYW5kICdOZXh0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuXHRcdCAqICogYGZ1bGxgIC0gJ0ZpcnN0JywgJ1ByZXZpb3VzJywgJ05leHQnIGFuZCAnTGFzdCcgYnV0dG9uc1xuXHRcdCAqICogYGZ1bGxfbnVtYmVyc2AgLSAnRmlyc3QnLCAnUHJldmlvdXMnLCAnTmV4dCcgYW5kICdMYXN0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuXHRcdCAqICogYGZpcnN0X2xhc3RfbnVtYmVyc2AgLSAnRmlyc3QnIGFuZCAnTGFzdCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0XHQgKiAgXG5cdFx0ICogRnVydGhlciBtZXRob2RzIGNhbiBiZSBhZGRlZCB1c2luZyB7QGxpbmsgRGF0YVRhYmxlLmV4dC5vUGFnaW5hdGlvbn0uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBzaW1wbGVfbnVtYmVyc1xuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wYWdpbmdUeXBlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInBhZ2luZ1R5cGVcIjogXCJmdWxsX251bWJlcnNcIlxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwic1BhZ2luYXRpb25UeXBlXCI6IFwic2ltcGxlX251bWJlcnNcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBob3Jpem9udGFsIHNjcm9sbGluZy4gV2hlbiBhIHRhYmxlIGlzIHRvbyB3aWRlIHRvIGZpdCBpbnRvIGFcblx0XHQgKiBjZXJ0YWluIGxheW91dCwgb3IgeW91IGhhdmUgYSBsYXJnZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGFibGUsIHlvdVxuXHRcdCAqIGNhbiBlbmFibGUgeC1zY3JvbGxpbmcgdG8gc2hvdyB0aGUgdGFibGUgaW4gYSB2aWV3cG9ydCwgd2hpY2ggY2FuIGJlXG5cdFx0ICogc2Nyb2xsZWQuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGB0cnVlYCB3aGljaCB3aWxsIGFsbG93IHRoZSB0YWJsZSB0b1xuXHRcdCAqIHNjcm9sbCBob3Jpem9udGFsbHkgd2hlbiBuZWVkZWQsIG9yIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXIgKGluIHdoaWNoXG5cdFx0ICogY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbCBtZWFzdXJlbWVudCkuIFNldHRpbmcgYXMgc2ltcGx5IGB0cnVlYFxuXHRcdCAqIGlzIHJlY29tbWVuZGVkLlxuXHRcdCAqICBAdHlwZSBib29sZWFufHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzY3JvbGxYXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic2Nyb2xsQ29sbGFwc2VcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNTY3JvbGxYXCI6IFwiXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGZvcmNlIGEgRGF0YVRhYmxlIHRvIHVzZSBtb3JlIHdpZHRoIHRoYW4gaXRcblx0XHQgKiBtaWdodCBvdGhlcndpc2UgZG8gd2hlbiB4LXNjcm9sbGluZyBpcyBlbmFibGVkLiBGb3IgZXhhbXBsZSBpZiB5b3UgaGF2ZSBhXG5cdFx0ICogdGFibGUgd2hpY2ggcmVxdWlyZXMgdG8gYmUgd2VsbCBzcGFjZWQsIHRoaXMgcGFyYW1ldGVyIGlzIHVzZWZ1bCBmb3Jcblx0XHQgKiBcIm92ZXItc2l6aW5nXCIgdGhlIHRhYmxlLCBhbmQgdGh1cyBmb3JjaW5nIHNjcm9sbGluZy4gVGhpcyBwcm9wZXJ0eSBjYW4gYnlcblx0XHQgKiBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyIChpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHBpeGVsXG5cdFx0ICogbWVhc3VyZW1lbnQpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+Ymxhbmsgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWElubmVyXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNjcm9sbFhcIjogXCIxMDAlXCIsXG5cdFx0ICogICAgICAgIFwic2Nyb2xsWElubmVyXCI6IFwiMTEwJVwiXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1Njcm9sbFhJbm5lclwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIHdpbGwgY29uc3RyYWluIHRoZSBEYXRhVGFibGVcblx0XHQgKiB0byB0aGUgZ2l2ZW4gaGVpZ2h0LCBhbmQgZW5hYmxlIHNjcm9sbGluZyBmb3IgYW55IGRhdGEgd2hpY2ggb3ZlcmZsb3dzIHRoZVxuXHRcdCAqIGN1cnJlbnQgdmlld3BvcnQuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gcGFnaW5nIHRvIGRpc3BsYXlcblx0XHQgKiBhIGxvdCBvZiBkYXRhIGluIGEgc21hbGwgYXJlYSAoYWx0aG91Z2ggcGFnaW5nIGFuZCBzY3JvbGxpbmcgY2FuIGJvdGggYmVcblx0XHQgKiBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUpLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyXG5cdFx0ICogKGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+Ymxhbmsgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMHB4XCIsXG5cdFx0ICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzU2Nyb2xsWVwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogU2V0IHRoZSBIVFRQIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gbWFrZSB0aGUgQWpheCBjYWxsIGZvciBzZXJ2ZXItc2lkZVxuXHRcdCAqIHByb2Nlc3Npbmcgb3IgQWpheCBzb3VyY2VkIGRhdGEuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBHRVRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlck1ldGhvZFxuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwic1NlcnZlck1ldGhvZFwiOiBcIkdFVFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBtYWtlcyB1c2Ugb2YgcmVuZGVyZXJzIHdoZW4gZGlzcGxheWluZyBIVE1MIGVsZW1lbnRzIGZvclxuXHRcdCAqIGEgdGFibGUuIFRoZXNlIHJlbmRlcmVycyBjYW4gYmUgYWRkZWQgb3IgbW9kaWZpZWQgYnkgcGx1Zy1pbnMgdG9cblx0XHQgKiBnZW5lcmF0ZSBzdWl0YWJsZSBtYXJrLXVwIGZvciBhIHNpdGUuIEZvciBleGFtcGxlIHRoZSBCb290c3RyYXBcblx0XHQgKiBpbnRlZ3JhdGlvbiBwbHVnLWluIGZvciBEYXRhVGFibGVzIHVzZXMgYSBwYWdpbmcgYnV0dG9uIHJlbmRlcmVyIHRvXG5cdFx0ICogZGlzcGxheSBwYWdpbmF0aW9uIGJ1dHRvbnMgaW4gdGhlIG1hcmstdXAgcmVxdWlyZWQgYnkgQm9vdHN0cmFwLlxuXHRcdCAqXG5cdFx0ICogRm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVycyBhdmFpbGFibGUgc2VlXG5cdFx0ICogRGF0YVRhYmxlLmV4dC5yZW5kZXJlclxuXHRcdCAqICBAdHlwZSBzdHJpbmd8b2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmVuZGVyZXJcblx0XHQgKlxuXHRcdCAqL1xuXHRcdFwicmVuZGVyZXJcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgZGF0YSBwcm9wZXJ0eSBuYW1lIHRoYXQgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRvIGdldCBhIHJvdydzIGlkXG5cdFx0ICogdG8gc2V0IGFzIHRoZSBgaWRgIHByb3BlcnR5IGluIHRoZSBub2RlLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgRFRfUm93SWRcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucm93SWRcblx0XHQgKi9cblx0XHRcInJvd0lkXCI6IFwiRFRfUm93SWRcIlxuXHR9O1xuXHRcblx0X2ZuSHVuZ2FyaWFuTWFwKCBEYXRhVGFibGUuZGVmYXVsdHMgKTtcblx0XG5cdFxuXHRcblx0Lypcblx0ICogRGV2ZWxvcGVyIG5vdGUgLSBTZWUgbm90ZSBpbiBtb2RlbC5kZWZhdWx0cy5qcyBhYm91dCB0aGUgdXNlIG9mIEh1bmdhcmlhblxuXHQgKiBub3RhdGlvbiBhbmQgY2FtZWwgY2FzZS5cblx0ICovXG5cdFxuXHQvKipcblx0ICogQ29sdW1uIG9wdGlvbnMgdGhhdCBjYW4gYmUgZ2l2ZW4gdG8gRGF0YVRhYmxlcyBhdCBpbml0aWFsaXNhdGlvbiB0aW1lLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbiA9IHtcblx0XHQvKipcblx0XHQgKiBEZWZpbmUgd2hpY2ggY29sdW1uKHMpIGFuIG9yZGVyIHdpbGwgb2NjdXIgb24gZm9yIHRoaXMgY29sdW1uLiBUaGlzXG5cdFx0ICogYWxsb3dzIGEgY29sdW1uJ3Mgb3JkZXJpbmcgdG8gdGFrZSBtdWx0aXBsZSBjb2x1bW5zIGludG8gYWNjb3VudCB3aGVuXG5cdFx0ICogZG9pbmcgYSBzb3J0IG9yIHVzZSB0aGUgZGF0YSBmcm9tIGEgZGlmZmVyZW50IGNvbHVtbi4gRm9yIGV4YW1wbGUgZmlyc3Rcblx0XHQgKiBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnMgbWFrZSBzZW5zZSB0byBkbyBhIG11bHRpLWNvbHVtbiBzb3J0IG92ZXIgdGhlXG5cdFx0ICogdHdvIGNvbHVtbnMuXG5cdFx0ICogIEB0eXBlIGFycmF5fGludFxuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPlRha2VzIHRoZSB2YWx1ZSBvZiB0aGUgY29sdW1uIGluZGV4IGF1dG9tYXRpY2FsbHk8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlckRhdGFcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDAsIDEgXSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDEsIDAgXSwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiAyLCBcInRhcmdldHNcIjogWyAyIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IFsgMCwgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDEsIDAgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogMiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYURhdGFTb3J0XCI6IG51bGwsXG5cdFx0XCJpRGF0YVNvcnRcIjogLTEsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBZb3UgY2FuIGNvbnRyb2wgdGhlIGRlZmF1bHQgb3JkZXJpbmcgZGlyZWN0aW9uLCBhbmQgZXZlbiBhbHRlciB0aGVcblx0XHQgKiBiZWhhdmlvdXIgb2YgdGhlIHNvcnQgaGFuZGxlciAoaS5lLiBvbmx5IGFsbG93IGFzY2VuZGluZyBvcmRlcmluZyBldGMpXG5cdFx0ICogdXNpbmcgdGhpcyBwYXJhbWV0ZXIuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFsgJ2FzYycsICdkZXNjJyBdXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlclNlcXVlbmNlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAxIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiLCBcImFzY1wiLCBcImFzY1wiIF0sIFwidGFyZ2V0c1wiOiBbIDIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMyBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiYXNjXCIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIsIFwiYXNjXCIsIFwiYXNjXCIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSB9LFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFzU29ydGluZ1wiOiBbICdhc2MnLCAnZGVzYycgXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIGZpbHRlcmluZyBvbiB0aGUgZGF0YSBpbiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5zZWFyY2hhYmxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJzZWFyY2hhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJzZWFyY2hhYmxlXCI6IGZhbHNlIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU2VhcmNoYWJsZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgb3JkZXJpbmcgb24gdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJhYmxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlcmFibGVcIjogZmFsc2UsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdFx0ICogICAgICAgIF0gfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyYWJsZVwiOiBmYWxzZSB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRhYmxlXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZGlzcGxheSBvZiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi52aXNpYmxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ2aXNpYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ2aXNpYmxlXCI6IGZhbHNlIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiVmlzaWJsZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGV2ZWxvcGVyIGRlZmluYWJsZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBhIGNlbGwgaXMgY3JlYXRlZCAoQWpheCBzb3VyY2UsXG5cdFx0ICogZXRjKSBvciBwcm9jZXNzZWQgZm9yIGlucHV0IChET00gc291cmNlKS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGNvbXBsaW1lbnQgdG8gbVJlbmRlclxuXHRcdCAqIGFsbG93aW5nIHlvdSB0byBtb2RpZnkgdGhlIERPTSBlbGVtZW50IChhZGQgYmFja2dyb3VuZCBjb2xvdXIgZm9yIGV4YW1wbGUpIHdoZW4gdGhlXG5cdFx0ICogZWxlbWVudCBpcyBhdmFpbGFibGUuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7ZWxlbWVudH0gdGQgVGhlIFREIG5vZGUgdGhhdCBoYXMgYmVlbiBjcmVhdGVkXG5cdFx0ICogIEBwYXJhbSB7Kn0gY2VsbERhdGEgVGhlIERhdGEgZm9yIHRoZSBjZWxsXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSByb3dEYXRhIFRoZSBkYXRhIGZvciB0aGUgd2hvbGUgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSByb3cgVGhlIHJvdyBpbmRleCBmb3IgdGhlIGFvRGF0YSBkYXRhIHN0b3JlXG5cdFx0ICogIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBpbmRleCBmb3IgYW9Db2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jcmVhdGVkQ2VsbFxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbM10sXG5cdFx0ICogICAgICAgICAgXCJjcmVhdGVkQ2VsbFwiOiBmdW5jdGlvbiAodGQsIGNlbGxEYXRhLCByb3dEYXRhLCByb3csIGNvbCkge1xuXHRcdCAqICAgICAgICAgICAgaWYgKCBjZWxsRGF0YSA9PSBcIjEuN1wiICkge1xuXHRcdCAqICAgICAgICAgICAgICAkKHRkKS5jc3MoJ2NvbG9yJywgJ2JsdWUnKVxuXHRcdCAqICAgICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9KTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBoYXMgYmVlbiByZXBsYWNlZCBieSBgZGF0YWAgaW4gRGF0YVRhYmxlcyB0byBlbnN1cmUgbmFtaW5nXG5cdFx0ICogY29uc2lzdGVuY3kuIGBkYXRhUHJvcGAgY2FuIHN0aWxsIGJlIHVzZWQsIGFzIHRoZXJlIGlzIGJhY2t3YXJkc1xuXHRcdCAqIGNvbXBhdGliaWxpdHkgaW4gRGF0YVRhYmxlcyBmb3IgdGhpcyBvcHRpb24sIGJ1dCBpdCBpcyBzdHJvbmdseVxuXHRcdCAqIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSBgZGF0YWAgaW4gcHJlZmVyZW5jZSB0byBgZGF0YVByb3BgLlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRhdGFQcm9wXG5cdFx0ICovXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIHJlYWQgZGF0YSBmcm9tIGFueSBkYXRhIHNvdXJjZSBwcm9wZXJ0eSxcblx0XHQgKiBpbmNsdWRpbmcgZGVlcGx5IG5lc3RlZCBvYmplY3RzIC8gcHJvcGVydGllcy4gYGRhdGFgIGNhbiBiZSBnaXZlbiBpbiBhXG5cdFx0ICogbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHdoaWNoIGVmZmVjdCBpdHMgYmVoYXZpb3VyOlxuXHRcdCAqXG5cdFx0ICogKiBgaW50ZWdlcmAgLSB0cmVhdGVkIGFzIGFuIGFycmF5IGluZGV4IGZvciB0aGUgZGF0YSBzb3VyY2UuIFRoaXMgaXMgdGhlXG5cdFx0ICogICBkZWZhdWx0IHRoYXQgRGF0YVRhYmxlcyB1c2VzIChpbmNyZW1lbnRhbGx5IGluY3JlYXNlZCBmb3IgZWFjaCBjb2x1bW4pLlxuXHRcdCAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXG5cdFx0ICogICB0aHJlZSAnc3BlY2lhbCcgb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzdHJpbmcgdG8gYWx0ZXIgaG93XG5cdFx0ICogICBEYXRhVGFibGVzIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3Q6XG5cdFx0ICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXG5cdFx0ICogICAgICBKYXZhc2NyaXB0IHRvIHJlYWQgZnJvbSBuZXN0ZWQgb2JqZWN0cywgc28gdG8gY2FuIHRoZSBvcHRpb25zXG5cdFx0ICogICAgICBzcGVjaWZpZWQgaW4gYGRhdGFgLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIudmVyc2lvbmAgb3Jcblx0XHQgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXG5cdFx0ICogICAgICBgXFxcXGAgdG8gZXNjYXBlIGl0IC0gaS5lLiBgZmlyc3RcXFxcLm5hbWVgLlxuXHRcdCAqICAgICogYFtdYCAtIEFycmF5IG5vdGF0aW9uLiBEYXRhVGFibGVzIGNhbiBhdXRvbWF0aWNhbGx5IGNvbWJpbmUgZGF0YVxuXHRcdCAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcblx0XHQgKiAgICAgIGJldHdlZW4gdGhlIHR3byBicmFja2V0cy4gRm9yIGV4YW1wbGU6IGBuYW1lWywgXWAgd291bGQgcHJvdmlkZSBhXG5cdFx0ICogICAgICBjb21tYS1zcGFjZSBzZXBhcmF0ZWQgbGlzdCBmcm9tIHRoZSBzb3VyY2UgYXJyYXkuIElmIG5vIGNoYXJhY3RlcnNcblx0XHQgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xuXHRcdCAqICAgICAgcmV0dXJuZWQuXG5cdFx0ICogICAgKiBgKClgIC0gRnVuY3Rpb24gbm90YXRpb24uIEFkZGluZyBgKClgIHRvIHRoZSBlbmQgb2YgYSBwYXJhbWV0ZXIgd2lsbFxuXHRcdCAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcblx0XHQgKiAgICAgIHNpbXBsZSBmdW5jdGlvbiBvbiB0aGUgZGF0YSBzb3VyY2UsIGBicm93c2VyLnZlcnNpb24oKWAgZm9yIGFcblx0XHQgKiAgICAgIGZ1bmN0aW9uIGluIGEgbmVzdGVkIHByb3BlcnR5IG9yIGV2ZW4gYGJyb3dzZXIoKS52ZXJzaW9uYCB0byBnZXQgYW5cblx0XHQgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LiBOb3RlIHRoYXRcblx0XHQgKiAgICAgIGZ1bmN0aW9uIG5vdGF0aW9uIGlzIHJlY29tbWVuZGVkIGZvciB1c2UgaW4gYHJlbmRlcmAgcmF0aGVyIHRoYW5cblx0XHQgKiAgICAgIGBkYXRhYCBhcyBpdCBpcyBtdWNoIHNpbXBsZXIgdG8gdXNlIGFzIGEgcmVuZGVyZXIuXG5cdFx0ICogKiBgbnVsbGAgLSB1c2UgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93IHJhdGhlciB0aGFuIHBsdWNraW5nXG5cdFx0ICogICBkYXRhIGRpcmVjdGx5IGZyb20gaXQuIFRoaXMgYWN0aW9uIGhhcyBlZmZlY3RzIG9uIHR3byBvdGhlclxuXHRcdCAqICAgaW5pdGlhbGlzYXRpb24gb3B0aW9uczpcblx0XHQgKiAgICAqIGBkZWZhdWx0Q29udGVudGAgLSBXaGVuIG51bGwgaXMgZ2l2ZW4gYXMgdGhlIGBkYXRhYCBvcHRpb24gYW5kXG5cdFx0ICogICAgICBgZGVmYXVsdENvbnRlbnRgIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbHVtbiwgdGhlIHZhbHVlIGRlZmluZWQgYnlcblx0XHQgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgd2lsbCBiZSB1c2VkIGZvciB0aGUgY2VsbC5cblx0XHQgKiAgICAqIGByZW5kZXJgIC0gV2hlbiBudWxsIGlzIHVzZWQgZm9yIHRoZSBgZGF0YWAgb3B0aW9uIGFuZCB0aGUgYHJlbmRlcmBcblx0XHQgKiAgICAgIG9wdGlvbiBpcyBzcGVjaWZpZWQgZm9yIHRoZSBjb2x1bW4sIHRoZSB3aG9sZSBkYXRhIHNvdXJjZSBmb3IgdGhlXG5cdFx0ICogICAgICByb3cgaXMgdXNlZCBmb3IgdGhlIHJlbmRlcmVyLlxuXHRcdCAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcblx0XHQgKiAgIG5lZWRzIHRvIHNldCBvciBnZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBUaGUgZnVuY3Rpb25cblx0XHQgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XG5cdFx0ICogICAgKiBQYXJhbWV0ZXJzOlxuXHRcdCAqICAgICAgKiBge2FycmF5fG9iamVjdH1gIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvd1xuXHRcdCAqICAgICAgKiBge3N0cmluZ31gIFRoZSB0eXBlIGNhbGwgZGF0YSByZXF1ZXN0ZWQgLSB0aGlzIHdpbGwgYmUgJ3NldCcgd2hlblxuXHRcdCAqICAgICAgICBzZXR0aW5nIGRhdGEgb3IgJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnLCAnc29ydCcgb3IgdW5kZWZpbmVkXG5cdFx0ICogICAgICAgIHdoZW4gZ2F0aGVyaW5nIGRhdGEuIE5vdGUgdGhhdCB3aGVuIGB1bmRlZmluZWRgIGlzIGdpdmVuIGZvciB0aGVcblx0XHQgKiAgICAgICAgdHlwZSBEYXRhVGFibGVzIGV4cGVjdHMgdG8gZ2V0IHRoZSByYXcgZGF0YSBmb3IgdGhlIG9iamVjdCBiYWNrPFxuXHRcdCAqICAgICAgKiBgeyp9YCBEYXRhIHRvIHNldCB3aGVuIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzICdzZXQnLlxuXHRcdCAqICAgICogUmV0dXJuOlxuXHRcdCAqICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uIGlzIG5vdCByZXF1aXJlZCB3aGVuICdzZXQnIGlzXG5cdFx0ICogICAgICAgIHRoZSB0eXBlIG9mIGNhbGwsIGJ1dCBvdGhlcndpc2UgdGhlIHJldHVybiBpcyB3aGF0IHdpbGwgYmUgdXNlZFxuXHRcdCAqICAgICAgICBmb3IgdGhlIGRhdGEgcmVxdWVzdGVkLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IGBkYXRhYCBpcyBhIGdldHRlciBhbmQgc2V0dGVyIG9wdGlvbi4gSWYgeW91IGp1c3QgcmVxdWlyZVxuXHRcdCAqIGZvcm1hdHRpbmcgb2YgZGF0YSBmb3Igb3V0cHV0LCB5b3Ugd2lsbCBsaWtlbHkgd2FudCB0byB1c2UgYHJlbmRlcmAgd2hpY2hcblx0XHQgKiBpcyBzaW1wbHkgYSBnZXR0ZXIgYW5kIHRodXMgc2ltcGxlciB0byB1c2UuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgcHJpb3IgdG8gRGF0YVRhYmxlcyAxLjkuMiBgZGF0YWAgd2FzIGNhbGxlZCBgbURhdGFQcm9wYC4gVGhlXG5cdFx0ICogbmFtZSBjaGFuZ2UgcmVmbGVjdHMgdGhlIGZsZXhpYmlsaXR5IG9mIHRoaXMgcHJvcGVydHkgYW5kIGlzIGNvbnNpc3RlbnRcblx0XHQgKiB3aXRoIHRoZSBuYW1pbmcgb2YgbVJlbmRlci4gSWYgJ21EYXRhUHJvcCcgaXMgZ2l2ZW4sIHRoZW4gaXQgd2lsbCBzdGlsbFxuXHRcdCAqIGJlIHVzZWQgYnkgRGF0YVRhYmxlcywgYXMgaXQgYXV0b21hdGljYWxseSBtYXBzIHRoZSBvbGQgbmFtZSB0byB0aGUgbmV3XG5cdFx0ICogaWYgcmVxdWlyZWQuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfGludHxmdW5jdGlvbnxudWxsXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgPGk+VXNlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBjb2x1bW4gaW5kZXg8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kYXRhXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBSZWFkIHRhYmxlIGRhdGEgZnJvbSBvYmplY3RzXG5cdFx0ICogICAgLy8gSlNPTiBzdHJ1Y3R1cmUgZm9yIGVhY2ggcm93OlxuXHRcdCAqICAgIC8vICAge1xuXHRcdCAqICAgIC8vICAgICAgXCJlbmdpbmVcIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwiYnJvd3NlclwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJwbGF0Zm9ybVwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJ2ZXJzaW9uXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcImdyYWRlXCI6IHt2YWx1ZX1cblx0XHQgKiAgICAvLyAgIH1cblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL29iamVjdHMudHh0XCIsXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJ2ZXJzaW9uXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImdyYWRlXCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUmVhZCBpbmZvcm1hdGlvbiBmcm9tIGRlZXBseSBuZXN0ZWQgb2JqZWN0c1xuXHRcdCAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcblx0XHQgKiAgICAvLyAgIHtcblx0XHQgKiAgICAvLyAgICAgIFwiZW5naW5lXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwicGxhdGZvcm1cIjoge1xuXHRcdCAqICAgIC8vICAgICAgICAgXCJpbm5lclwiOiB7dmFsdWV9XG5cdFx0ICogICAgLy8gICAgICB9LFxuXHRcdCAqICAgIC8vICAgICAgXCJkZXRhaWxzXCI6IFtcblx0XHQgKiAgICAvLyAgICAgICAgIHt2YWx1ZX0sIHt2YWx1ZX1cblx0XHQgKiAgICAvLyAgICAgIF1cblx0XHQgKiAgICAvLyAgIH1cblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL2RlZXAudHh0XCIsXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybS5pbm5lclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybS5kZXRhaWxzLjBcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm0uZGV0YWlscy4xXCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGRhdGFgIGFzIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBkaWZmZXJlbnQgaW5mb3JtYXRpb24gZm9yXG5cdFx0ICogICAgLy8gc29ydGluZywgZmlsdGVyaW5nIGFuZCBkaXNwbGF5LiBJbiB0aGlzIGNhc2UsIGN1cnJlbmN5IChwcmljZSlcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBmdW5jdGlvbiAoIHNvdXJjZSwgdHlwZSwgdmFsICkge1xuXHRcdCAqICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzZXQnKSB7XG5cdFx0ICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZSA9IHZhbDtcblx0XHQgKiAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNvbXB1dGVkIGRpc2xheSBhbmQgZmlsdGVyIHZhbHVlcyBmb3IgZWZmaWNpZW5jeVxuXHRcdCAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2VfZGlzcGxheSA9IHZhbD09XCJcIiA/IFwiXCIgOiBcIiRcIitudW1iZXJGb3JtYXQodmFsKTtcblx0XHQgKiAgICAgICAgICAgICAgc291cmNlLnByaWNlX2ZpbHRlciAgPSB2YWw9PVwiXCIgPyBcIlwiIDogXCIkXCIrbnVtYmVyRm9ybWF0KHZhbCkrXCIgXCIrdmFsO1xuXHRcdCAqICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnZGlzcGxheScpIHtcblx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZV9kaXNwbGF5O1xuXHRcdCAqICAgICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2ZpbHRlcicpIHtcblx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZV9maWx0ZXI7XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgICAvLyAnc29ydCcsICd0eXBlJyBhbmQgdW5kZWZpbmVkIGFsbCBqdXN0IHVzZSB0aGUgaW50ZWdlclxuXHRcdCAqICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGRlZmF1bHQgY29udGVudFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG5cdFx0ICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG5cdFx0ICogICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkNsaWNrIHRvIGVkaXRcIlxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBhcnJheSBub3RhdGlvbiAtIG91dHB1dHRpbmcgYSBsaXN0IGZyb20gYW4gYXJyYXlcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBcIm5hbWVbLCBdXCJcblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICovXG5cdFx0XCJtRGF0YVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBpcyB0aGUgcmVuZGVyaW5nIHBhcnRuZXIgdG8gYGRhdGFgIGFuZCBpdCBpcyBzdWdnZXN0ZWQgdGhhdFxuXHRcdCAqIHdoZW4geW91IHdhbnQgdG8gbWFuaXB1bGF0ZSBkYXRhIGZvciBkaXNwbGF5IChpbmNsdWRpbmcgZmlsdGVyaW5nLFxuXHRcdCAqIHNvcnRpbmcgZXRjKSB3aXRob3V0IGFsdGVyaW5nIHRoZSB1bmRlcmx5aW5nIGRhdGEgZm9yIHRoZSB0YWJsZSwgdXNlIHRoaXNcblx0XHQgKiBwcm9wZXJ0eS4gYHJlbmRlcmAgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIHRoZSByZWFkIG9ubHkgY29tcGFuaW9uIHRvXG5cdFx0ICogYGRhdGFgIHdoaWNoIGlzIHJlYWQgLyB3cml0ZSAodGhlbiBhcyBzdWNoIG1vcmUgY29tcGxleCkuIExpa2UgYGRhdGFgXG5cdFx0ICogdGhpcyBvcHRpb24gY2FuIGJlIGdpdmVuIGluIGEgbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHRvIGVmZmVjdCBpdHNcblx0XHQgKiBiZWhhdmlvdXI6XG5cdFx0ICpcblx0XHQgKiAqIGBpbnRlZ2VyYCAtIHRyZWF0ZWQgYXMgYW4gYXJyYXkgaW5kZXggZm9yIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyB0aGVcblx0XHQgKiAgIGRlZmF1bHQgdGhhdCBEYXRhVGFibGVzIHVzZXMgKGluY3JlbWVudGFsbHkgaW5jcmVhc2VkIGZvciBlYWNoIGNvbHVtbikuXG5cdFx0ICogKiBgc3RyaW5nYCAtIHJlYWQgYW4gb2JqZWN0IHByb3BlcnR5IGZyb20gdGhlIGRhdGEgc291cmNlLiBUaGVyZSBhcmVcblx0XHQgKiAgIHRocmVlICdzcGVjaWFsJyBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHN0cmluZyB0byBhbHRlciBob3dcblx0XHQgKiAgIERhdGFUYWJsZXMgcmVhZHMgdGhlIGRhdGEgZnJvbSB0aGUgc291cmNlIG9iamVjdDpcblx0XHQgKiAgICAqIGAuYCAtIERvdHRlZCBKYXZhc2NyaXB0IG5vdGF0aW9uLiBKdXN0IGFzIHlvdSB1c2UgYSBgLmAgaW5cblx0XHQgKiAgICAgIEphdmFzY3JpcHQgdG8gcmVhZCBmcm9tIG5lc3RlZCBvYmplY3RzLCBzbyB0byBjYW4gdGhlIG9wdGlvbnNcblx0XHQgKiAgICAgIHNwZWNpZmllZCBpbiBgZGF0YWAuIEZvciBleGFtcGxlOiBgYnJvd3Nlci52ZXJzaW9uYCBvclxuXHRcdCAqICAgICAgYGJyb3dzZXIubmFtZWAuIElmIHlvdXIgb2JqZWN0IHBhcmFtZXRlciBuYW1lIGNvbnRhaW5zIGEgcGVyaW9kLCB1c2Vcblx0XHQgKiAgICAgIGBcXFxcYCB0byBlc2NhcGUgaXQgLSBpLmUuIGBmaXJzdFxcXFwubmFtZWAuXG5cdFx0ICogICAgKiBgW11gIC0gQXJyYXkgbm90YXRpb24uIERhdGFUYWJsZXMgY2FuIGF1dG9tYXRpY2FsbHkgY29tYmluZSBkYXRhXG5cdFx0ICogICAgICBmcm9tIGFuZCBhcnJheSBzb3VyY2UsIGpvaW5pbmcgdGhlIGRhdGEgd2l0aCB0aGUgY2hhcmFjdGVycyBwcm92aWRlZFxuXHRcdCAqICAgICAgYmV0d2VlbiB0aGUgdHdvIGJyYWNrZXRzLiBGb3IgZXhhbXBsZTogYG5hbWVbLCBdYCB3b3VsZCBwcm92aWRlIGFcblx0XHQgKiAgICAgIGNvbW1hLXNwYWNlIHNlcGFyYXRlZCBsaXN0IGZyb20gdGhlIHNvdXJjZSBhcnJheS4gSWYgbm8gY2hhcmFjdGVyc1xuXHRcdCAqICAgICAgYXJlIHByb3ZpZGVkIGJldHdlZW4gdGhlIGJyYWNrZXRzLCB0aGUgb3JpZ2luYWwgYXJyYXkgc291cmNlIGlzXG5cdFx0ICogICAgICByZXR1cm5lZC5cblx0XHQgKiAgICAqIGAoKWAgLSBGdW5jdGlvbiBub3RhdGlvbi4gQWRkaW5nIGAoKWAgdG8gdGhlIGVuZCBvZiBhIHBhcmFtZXRlciB3aWxsXG5cdFx0ICogICAgICBleGVjdXRlIGEgZnVuY3Rpb24gb2YgdGhlIG5hbWUgZ2l2ZW4uIEZvciBleGFtcGxlOiBgYnJvd3NlcigpYCBmb3IgYVxuXHRcdCAqICAgICAgc2ltcGxlIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHNvdXJjZSwgYGJyb3dzZXIudmVyc2lvbigpYCBmb3IgYVxuXHRcdCAqICAgICAgZnVuY3Rpb24gaW4gYSBuZXN0ZWQgcHJvcGVydHkgb3IgZXZlbiBgYnJvd3NlcigpLnZlcnNpb25gIHRvIGdldCBhblxuXHRcdCAqICAgICAgb2JqZWN0IHByb3BlcnR5IGlmIHRoZSBmdW5jdGlvbiBjYWxsZWQgcmV0dXJucyBhbiBvYmplY3QuXG5cdFx0ICogKiBgb2JqZWN0YCAtIHVzZSBkaWZmZXJlbnQgZGF0YSBmb3IgdGhlIGRpZmZlcmVudCBkYXRhIHR5cGVzIHJlcXVlc3RlZCBieVxuXHRcdCAqICAgRGF0YVRhYmxlcyAoJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0JykuIFRoZSBwcm9wZXJ0eSBuYW1lc1xuXHRcdCAqICAgb2YgdGhlIG9iamVjdCBpcyB0aGUgZGF0YSB0eXBlIHRoZSBwcm9wZXJ0eSByZWZlcnMgdG8gYW5kIHRoZSB2YWx1ZSBjYW5cblx0XHQgKiAgIGRlZmluZWQgdXNpbmcgYW4gaW50ZWdlciwgc3RyaW5nIG9yIGZ1bmN0aW9uIHVzaW5nIHRoZSBzYW1lIHJ1bGVzIGFzXG5cdFx0ICogICBgcmVuZGVyYCBub3JtYWxseSBkb2VzLiBOb3RlIHRoYXQgYW4gYF9gIG9wdGlvbiBfbXVzdF8gYmUgc3BlY2lmaWVkLlxuXHRcdCAqICAgVGhpcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgeW91IGhhdmVuJ3Qgc3BlY2lmaWVkIGEgdmFsdWUgZm9yXG5cdFx0ICogICB0aGUgZGF0YSB0eXBlIHJlcXVlc3RlZCBieSBEYXRhVGFibGVzLlxuXHRcdCAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcblx0XHQgKiAgIG5lZWRzIHRvIHNldCBvciBnZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBUaGUgZnVuY3Rpb25cblx0XHQgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XG5cdFx0ICogICAgKiBQYXJhbWV0ZXJzOlxuXHRcdCAqICAgICAgKiB7YXJyYXl8b2JqZWN0fSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKGJhc2VkIG9uIGBkYXRhYClcblx0XHQgKiAgICAgICoge3N0cmluZ30gVGhlIHR5cGUgY2FsbCBkYXRhIHJlcXVlc3RlZCAtIHRoaXMgd2lsbCBiZSAnZmlsdGVyJyxcblx0XHQgKiAgICAgICAgJ2Rpc3BsYXknLCAndHlwZScgb3IgJ3NvcnQnLlxuXHRcdCAqICAgICAgKiB7YXJyYXl8b2JqZWN0fSBUaGUgZnVsbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyAobm90IGJhc2VkIG9uXG5cdFx0ICogICAgICAgIGBkYXRhYClcblx0XHQgKiAgICAqIFJldHVybjpcblx0XHQgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyB3aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlXG5cdFx0ICogICAgICAgIGRhdGEgcmVxdWVzdGVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIHN0cmluZ3xpbnR8ZnVuY3Rpb258b2JqZWN0fG51bGxcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCBVc2UgdGhlIGRhdGEgc291cmNlIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ucmVuZGVyXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBDcmVhdGUgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHNcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL2RlZXAudHh0XCIsXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IFwicGxhdGZvcm1cIixcblx0XHQgKiAgICAgICAgICAgIFwicmVuZGVyXCI6IFwiWywgXS5uYW1lXCJcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBFeGVjdXRlIGEgZnVuY3Rpb24gdG8gb2J0YWluIGRhdGFcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBudWxsLCAvLyBVc2UgdGhlIGZ1bGwgZGF0YSBzb3VyY2Ugb2JqZWN0IGZvciB0aGUgcmVuZGVyZXIncyBzb3VyY2Vcblx0XHQgKiAgICAgICAgICBcInJlbmRlclwiOiBcImJyb3dzZXJOYW1lKClcIlxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBBcyBhbiBvYmplY3QsIGV4dHJhY3RpbmcgZGlmZmVyZW50IGRhdGEgZm9yIHRoZSBkaWZmZXJlbnQgdHlwZXNcblx0XHQgKiAgICAvLyBUaGlzIHdvdWxkIGJlIHVzZWQgd2l0aCBhIGRhdGEgc291cmNlIHN1Y2ggYXM6XG5cdFx0ICogICAgLy8gICB7IFwicGhvbmVcIjogNTU1MjM2OCwgXCJwaG9uZV9maWx0ZXJcIjogXCI1NTUyMzY4IDU1NS0yMzY4XCIsIFwicGhvbmVfZGlzcGxheVwiOiBcIjU1NS0yMzY4XCIgfVxuXHRcdCAqICAgIC8vIEhlcmUgdGhlIGBwaG9uZWAgaW50ZWdlciBpcyB1c2VkIGZvciBzb3J0aW5nIGFuZCB0eXBlIGRldGVjdGlvbiwgd2hpbGUgYHBob25lX2ZpbHRlcmBcblx0XHQgKiAgICAvLyAod2hpY2ggaGFzIGJvdGggZm9ybXMpIGlzIHVzZWQgZm9yIGZpbHRlcmluZyBmb3IgaWYgYSB1c2VyIGlucHV0cyBlaXRoZXIgZm9ybWF0LCB3aGlsZVxuXHRcdCAqICAgIC8vIHRoZSBmb3JtYXR0ZWQgcGhvbmUgbnVtYmVyIGlzIHRoZSBvbmUgdGhhdCBpcyBzaG93biBpbiB0aGUgdGFibGUuXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogbnVsbCwgLy8gVXNlIHRoZSBmdWxsIGRhdGEgc291cmNlIG9iamVjdCBmb3IgdGhlIHJlbmRlcmVyJ3Mgc291cmNlXG5cdFx0ICogICAgICAgICAgXCJyZW5kZXJcIjoge1xuXHRcdCAqICAgICAgICAgICAgXCJfXCI6IFwicGhvbmVcIixcblx0XHQgKiAgICAgICAgICAgIFwiZmlsdGVyXCI6IFwicGhvbmVfZmlsdGVyXCIsXG5cdFx0ICogICAgICAgICAgICBcImRpc3BsYXlcIjogXCJwaG9uZV9kaXNwbGF5XCJcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzZSBhcyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGxpbmsgZnJvbSB0aGUgZGF0YSBzb3VyY2Vcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBcImRvd25sb2FkX2xpbmtcIixcblx0XHQgKiAgICAgICAgICBcInJlbmRlclwiOiBmdW5jdGlvbiAoIGRhdGEsIHR5cGUsIGZ1bGwgKSB7XG5cdFx0ICogICAgICAgICAgICByZXR1cm4gJzxhIGhyZWY9XCInK2RhdGErJ1wiPkRvd25sb2FkPC9hPic7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJtUmVuZGVyXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDaGFuZ2UgdGhlIGNlbGwgdHlwZSBjcmVhdGVkIGZvciB0aGUgY29sdW1uIC0gZWl0aGVyIFREIGNlbGxzIG9yIFRIIGNlbGxzLiBUaGlzXG5cdFx0ICogY2FuIGJlIHVzZWZ1bCBhcyBUSCBjZWxscyBoYXZlIHNlbWFudGljIG1lYW5pbmcgaW4gdGhlIHRhYmxlIGJvZHksIGFsbG93aW5nIHRoZW1cblx0XHQgKiB0byBhY3QgYXMgYSBoZWFkZXIgZm9yIGEgcm93ICh5b3UgbWF5IHdpc2ggdG8gYWRkIHNjb3BlPSdyb3cnIHRvIHRoZSBUSCBlbGVtZW50cykuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCB0ZFxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY2VsbFR5cGVcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIE1ha2UgdGhlIGZpcnN0IGNvbHVtbiB1c2UgVEggY2VsbHNcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiY2VsbFR5cGVcIjogXCJ0aFwiXG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNDZWxsVHlwZVwiOiBcInRkXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDbGFzcyB0byBnaXZlIHRvIGVhY2ggY2VsbCBpbiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNsYXNzXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJjbGFzc1wiOiBcIm15X2NsYXNzXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJjbGFzc1wiOiBcIm15X2NsYXNzXCIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzQ2xhc3NcIjogXCJcIixcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hlbiBEYXRhVGFibGVzIGNhbGN1bGF0ZXMgdGhlIGNvbHVtbiB3aWR0aHMgdG8gYXNzaWduIHRvIGVhY2ggY29sdW1uLFxuXHRcdCAqIGl0IGZpbmRzIHRoZSBsb25nZXN0IHN0cmluZyBpbiBlYWNoIGNvbHVtbiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGFcblx0XHQgKiB0ZW1wb3JhcnkgdGFibGUgYW5kIHJlYWRzIHRoZSB3aWR0aHMgZnJvbSB0aGF0LiBUaGUgcHJvYmxlbSB3aXRoIHRoaXNcblx0XHQgKiBpcyB0aGF0IFwibW1tXCIgaXMgbXVjaCB3aWRlciB0aGVuIFwiaWlpaVwiLCBidXQgdGhlIGxhdHRlciBpcyBhIGxvbmdlclxuXHRcdCAqIHN0cmluZyAtIHRodXMgdGhlIGNhbGN1bGF0aW9uIGNhbiBnbyB3cm9uZyAoZG9pbmcgaXQgcHJvcGVybHkgYW5kIHB1dHRpbmdcblx0XHQgKiBpdCBpbnRvIGFuIERPTSBvYmplY3QgYW5kIG1lYXN1cmluZyB0aGF0IGlzIGhvcnJpYmx5KCEpIHNsb3cpLiBUaHVzIGFzXG5cdFx0ICogYSBcIndvcmsgYXJvdW5kXCIgd2UgcHJvdmlkZSB0aGlzIG9wdGlvbi4gSXQgd2lsbCBhcHBlbmQgaXRzIHZhbHVlIHRvIHRoZVxuXHRcdCAqIHRleHQgdGhhdCBpcyBmb3VuZCB0byBiZSB0aGUgbG9uZ2VzdCBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gLSBpLmUuIHBhZGRpbmcuXG5cdFx0ICogR2VuZXJhbGx5IHlvdSBzaG91bGRuJ3QgbmVlZCB0aGlzIVxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPGk+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jb250ZW50UGFkZGluZ1xuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICBcImNvbnRlbnRQYWRkaW5nXCI6IFwibW1tXCJcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzQ29udGVudFBhZGRpbmdcIjogXCJcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgZ2l2ZW4gZm9yIGEgY29sdW1uJ3MgZGF0YSwgYW5kIHdpbGwgYmUgdXNlZFxuXHRcdCAqIHdoZW5ldmVyIGEgbnVsbCBkYXRhIHNvdXJjZSBpcyBlbmNvdW50ZXJlZCAodGhpcyBjYW4gYmUgYmVjYXVzZSBgZGF0YWBcblx0XHQgKiBpcyBzZXQgdG8gbnVsbCwgb3IgYmVjYXVzZSB0aGUgZGF0YSBzb3VyY2UgaXRzZWxmIGlzIG51bGwpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uZGVmYXVsdENvbnRlbnRcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG5cdFx0ICogICAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiRWRpdFwiLFxuXHRcdCAqICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgLTEgXVxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG5cdFx0ICogICAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiRWRpdFwiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0RlZmF1bHRDb250ZW50XCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHVzZWQgaW4gRGF0YVRhYmxlcycgc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gSXQgY2FuXG5cdFx0ICogYmUgZXhjZXB0aW9uYWxseSB1c2VmdWwgdG8ga25vdyB3aGF0IGNvbHVtbnMgYXJlIGJlaW5nIGRpc3BsYXllZCBvbiB0aGVcblx0XHQgKiBjbGllbnQgc2lkZSwgYW5kIHRvIG1hcCB0aGVzZSB0byBkYXRhYmFzZSBmaWVsZHMuIFdoZW4gZGVmaW5lZCwgdGhlIG5hbWVzXG5cdFx0ICogYWxzbyBhbGxvdyBEYXRhVGFibGVzIHRvIHJlb3JkZXIgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmVyIGlmIGl0IGNvbWVzXG5cdFx0ICogYmFjayBpbiBhbiB1bmV4cGVjdGVkIG9yZGVyIChpLmUuIGlmIHlvdSBzd2l0Y2ggeW91ciBjb2x1bW5zIGFyb3VuZCBvbiB0aGVcblx0XHQgKiBjbGllbnQtc2lkZSwgeW91ciBzZXJ2ZXItc2lkZSBjb2RlIGRvZXMgbm90IGFsc28gbmVlZCB1cGRhdGluZykuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5uYW1lXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW5naW5lXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYnJvd3NlclwiLCBcInRhcmdldHNcIjogWyAxIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInBsYXRmb3JtXCIsIFwidGFyZ2V0c1wiOiBbIDIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwidmVyc2lvblwiLCBcInRhcmdldHNcIjogWyAzIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImdyYWRlXCIsIFwidGFyZ2V0c1wiOiBbIDQgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwicGxhdGZvcm1cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwidmVyc2lvblwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJncmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNOYW1lXCI6IFwiXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGEgZGF0YSBzb3VyY2UgdHlwZSBmb3IgdGhlIG9yZGVyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlYWRcblx0XHQgKiByZWFsLXRpbWUgaW5mb3JtYXRpb24gZnJvbSB0aGUgdGFibGUgKHVwZGF0aW5nIHRoZSBpbnRlcm5hbGx5IGNhY2hlZFxuXHRcdCAqIHZlcnNpb24pIHByaW9yIHRvIG9yZGVyaW5nLiBUaGlzIGFsbG93cyBvcmRlcmluZyB0byBvY2N1ciBvbiB1c2VyXG5cdFx0ICogZWRpdGFibGUgZWxlbWVudHMgc3VjaCBhcyBmb3JtIGlucHV0cy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHN0ZFxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJEYXRhVHlwZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIsIFwidGFyZ2V0c1wiOiBbIDIsIDMgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwibnVtZXJpY1wiLCBcInRhcmdldHNcIjogWyAzIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1zZWxlY3RcIiwgXCJ0YXJnZXRzXCI6IFsgNCBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tY2hlY2tib3hcIiwgXCJ0YXJnZXRzXCI6IFsgNSBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiwgXCJ0eXBlXCI6IFwibnVtZXJpY1wiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tc2VsZWN0XCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1jaGVja2JveFwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNTb3J0RGF0YVR5cGVcIjogXCJzdGRcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0aXRsZSBvZiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgPGk+RGVyaXZlZCBmcm9tIHRoZSAnVEgnIHZhbHVlIGZvciB0aGlzIGNvbHVtbiBpbiB0aGVcblx0XHQgKiAgICBvcmlnaW5hbCBIVE1MIHRhYmxlLjwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnRpdGxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIk15IGNvbHVtbiB0aXRsZVwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJNeSBjb2x1bW4gdGl0bGVcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNUaXRsZVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGhvdyB0aGUgZGF0YSBmb3IgdGhpcyBjb2x1bW4gd2lsbCBiZVxuXHRcdCAqIG9yZGVyZWQuIEZvdXIgdHlwZXMgKHN0cmluZywgbnVtZXJpYywgZGF0ZSBhbmQgaHRtbCAod2hpY2ggd2lsbCBzdHJpcFxuXHRcdCAqIEhUTUwgdGFncyBiZWZvcmUgb3JkZXJpbmcpKSBhcmUgY3VycmVudGx5IGF2YWlsYWJsZS4gTm90ZSB0aGF0IG9ubHkgZGF0ZVxuXHRcdCAqIGZvcm1hdHMgdW5kZXJzdG9vZCBieSBKYXZhc2NyaXB0J3MgRGF0ZSgpIG9iamVjdCB3aWxsIGJlIGFjY2VwdGVkIGFzIHR5cGVcblx0XHQgKiBkYXRlLiBGb3IgZXhhbXBsZTogXCJNYXIgMjYsIDIwMDggNTowMyBQTVwiLiBNYXkgdGFrZSB0aGUgdmFsdWVzOiAnc3RyaW5nJyxcblx0XHQgKiAnbnVtZXJpYycsICdkYXRlJyBvciAnaHRtbCcgKGJ5IGRlZmF1bHQpLiBGdXJ0aGVyIHR5cGVzIGNhbiBiZSBhZGRpbmdcblx0XHQgKiB0aHJvdWdoIHBsdWctaW5zLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5BdXRvLWRldGVjdGVkIGZyb20gcmF3IGRhdGE8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi50eXBlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwiaHRtbFwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidHlwZVwiOiBcImh0bWxcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNUeXBlXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmluZyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbiwgdGhpcyBwYXJhbWV0ZXIgbWF5IHRha2UgYW55IENTUyB2YWx1ZVxuXHRcdCAqICgzZW0sIDIwcHggZXRjKS4gRGF0YVRhYmxlcyBhcHBsaWVzICdzbWFydCcgd2lkdGhzIHRvIGNvbHVtbnMgd2hpY2ggaGF2ZSBub3Rcblx0XHQgKiBiZWVuIGdpdmVuIGEgc3BlY2lmaWMgd2lkdGggdGhyb3VnaCB0aGlzIGludGVyZmFjZSBlbnN1cmluZyB0aGF0IHRoZSB0YWJsZVxuXHRcdCAqIHJlbWFpbnMgcmVhZGFibGUuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPkF1dG9tYXRpYzwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLndpZHRoXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ3aWR0aFwiOiBcIjIwJVwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwid2lkdGhcIjogXCIyMCVcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNXaWR0aFwiOiBudWxsXG5cdH07XG5cdFxuXHRfZm5IdW5nYXJpYW5NYXAoIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IC0gdGhpcyBob2xkcyBhbGwgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgYVxuXHQgKiBnaXZlbiB0YWJsZSwgaW5jbHVkaW5nIGNvbmZpZ3VyYXRpb24sIGRhdGEgYW5kIGN1cnJlbnQgYXBwbGljYXRpb24gb2YgdGhlXG5cdCAqIHRhYmxlIG9wdGlvbnMuIERhdGFUYWJsZXMgZG9lcyBub3QgaGF2ZSBhIHNpbmdsZSBpbnN0YW5jZSBmb3IgZWFjaCBEYXRhVGFibGVcblx0ICogd2l0aCB0aGUgc2V0dGluZ3MgYXR0YWNoZWQgdG8gdGhhdCBpbnN0YW5jZSwgYnV0IHJhdGhlciBpbnN0YW5jZXMgb2YgdGhlXG5cdCAqIERhdGFUYWJsZSBcImNsYXNzXCIgYXJlIGNyZWF0ZWQgb24tdGhlLWZseSBhcyBuZWVkZWQgKHR5cGljYWxseSBieSBhXG5cdCAqICQoKS5kYXRhVGFibGUoKSBjYWxsKSBhbmQgdGhlIHNldHRpbmdzIG9iamVjdCBpcyB0aGVuIGFwcGxpZWQgdG8gdGhhdFxuXHQgKiBpbnN0YW5jZS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoaXMgb2JqZWN0IGlzIHJlbGF0ZWQgdG8ge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30gYnV0IHRoaXNcblx0ICogb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy4gSXQgc2hvdWxkXG5cdCAqIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZCBiZSBkb25lXG5cdCAqIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqICBAdG9kbyBSZWFsbHkgc2hvdWxkIGF0dGFjaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IHRvIGluZGl2aWR1YWwgaW5zdGFuY2VzIHNvIHdlXG5cdCAqICAgIGRvbid0IG5lZWQgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb24gZWFjaCAkKCkuZGF0YVRhYmxlKCkgY2FsbCAoaWYgdGhlXG5cdCAqICAgIHRhYmxlIGFscmVhZHkgZXhpc3RzKS4gSXQgd291bGQgYWxzbyBzYXZlIHBhc3Npbmcgb1NldHRpbmdzIGFyb3VuZCBhbmRcblx0ICogICAgaW50byBldmVyeSBzaW5nbGUgZnVuY3Rpb24uIEhvd2V2ZXIsIHRoaXMgaXMgYSB2ZXJ5IHNpZ25pZmljYW50XG5cdCAqICAgIGFyY2hpdGVjdHVyZSBjaGFuZ2UgZm9yIERhdGFUYWJsZXMgYW5kIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBicmVha1xuXHQgKiAgICBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGluc3RhbGxhdGlvbnMuIFRoaXMgaXMgc29tZXRoaW5nIHRoYXRcblx0ICogICAgd2lsbCBiZSBkb25lIGluIDIuMC5cblx0ICovXG5cdERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzID0ge1xuXHRcdC8qKlxuXHRcdCAqIFByaW1hcnkgZmVhdHVyZXMgb2YgRGF0YVRhYmxlcyBhbmQgdGhlaXIgZW5hYmxlbWVudCBzdGF0ZS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdFwib0ZlYXR1cmVzXCI6IHtcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEZsYWcgdG8gc2F5IGlmIERhdGFUYWJsZXMgc2hvdWxkIGF1dG9tYXRpY2FsbHkgdHJ5IHRvIGNhbGN1bGF0ZSB0aGVcblx0XHRcdCAqIG9wdGltdW0gdGFibGUgYW5kIGNvbHVtbnMgd2lkdGhzICh0cnVlKSBvciBub3QgKGZhbHNlKS5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiQXV0b1dpZHRoXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZWxheSB0aGUgY3JlYXRpb24gb2YgVFIgYW5kIFREIGVsZW1lbnRzIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5XG5cdFx0XHQgKiBuZWVkZWQgYnkgYSBkcml2ZW4gcGFnZSBkcmF3LiBUaGlzIGNhbiBnaXZlIGEgc2lnbmlmaWNhbnQgc3BlZWRcblx0XHRcdCAqIGluY3JlYXNlIGZvciBBamF4IHNvdXJjZSBhbmQgSmF2YXNjcmlwdCBzb3VyY2UgZGF0YSwgYnV0IG1ha2VzIG5vXG5cdFx0XHQgKiBkaWZmZXJlbmNlIGF0IGFsbCBmcm8gRE9NIGFuZCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRhYmxlcy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiRGVmZXJSZW5kZXJcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZSBmaWx0ZXJpbmcgb24gdGhlIHRhYmxlIG9yIG5vdC4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgZGlzYWJsZWRcblx0XHRcdCAqIHRoZW4gdGhlcmUgaXMgbm8gZmlsdGVyaW5nIGF0IGFsbCBvbiB0aGUgdGFibGUsIGluY2x1ZGluZyBmbkZpbHRlci5cblx0XHRcdCAqIFRvIGp1c3QgcmVtb3ZlIHRoZSBmaWx0ZXJpbmcgaW5wdXQgdXNlIHNEb20gYW5kIHJlbW92ZSB0aGUgJ2YnIG9wdGlvbi5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiRmlsdGVyXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUYWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50ICh0aGUgJ1Nob3dpbmcgeCBvZiB5IHJlY29yZHMnIGRpdikgZW5hYmxlXG5cdFx0XHQgKiBmbGFnLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJJbmZvXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQcmVzZW50IGEgdXNlciBjb250cm9sIGFsbG93aW5nIHRoZSBlbmQgdXNlciB0byBjaGFuZ2UgdGhlIHBhZ2Ugc2l6ZVxuXHRcdFx0ICogd2hlbiBwYWdpbmF0aW9uIGlzIGVuYWJsZWQuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkxlbmd0aENoYW5nZVwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUGFnaW5hdGlvbiBlbmFibGVkIG9yIG5vdC4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgZGlzYWJsZWQgdGhlbiBsZW5ndGhcblx0XHRcdCAqIGNoYW5naW5nIG11c3QgYWxzbyBiZSBkaXNhYmxlZC5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiUGFnaW5hdGVcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFByb2Nlc3NpbmcgaW5kaWNhdG9yIGVuYWJsZSBmbGFnIHdoZW5ldmVyIERhdGFUYWJsZXMgaXMgZW5hY3RpbmcgYVxuXHRcdFx0ICogdXNlciByZXF1ZXN0IC0gdHlwaWNhbGx5IGFuIEFqYXggcmVxdWVzdCBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiUHJvY2Vzc2luZ1wiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBlbmFibGVkIGZsYWcgLSB3aGVuIGVuYWJsZWQgRGF0YVRhYmxlcyB3aWxsXG5cdFx0XHQgKiBnZXQgYWxsIGRhdGEgZnJvbSB0aGUgc2VydmVyIGZvciBldmVyeSBkcmF3IC0gdGhlcmUgaXMgbm8gZmlsdGVyaW5nLFxuXHRcdFx0ICogc29ydGluZyBvciBwYWdpbmcgZG9uZSBvbiB0aGUgY2xpZW50LXNpZGUuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlNlcnZlclNpZGVcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFNvcnRpbmcgZW5hYmxlbWVudCBmbGFnLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTb3J0XCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNdWx0aS1jb2x1bW4gc29ydGluZ1xuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTb3J0TXVsdGlcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEFwcGx5IGEgY2xhc3MgdG8gdGhlIGNvbHVtbnMgd2hpY2ggYXJlIGJlaW5nIHNvcnRlZCB0byBwcm92aWRlIGFcblx0XHRcdCAqIHZpc3VhbCBoaWdobGlnaHQgb3Igbm90LiBUaGlzIGNhbiBzbG93IHRoaW5ncyBkb3duIHdoZW4gZW5hYmxlZCBzaW5jZVxuXHRcdFx0ICogdGhlcmUgaXMgYSBsb3Qgb2YgRE9NIGludGVyYWN0aW9uLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTb3J0Q2xhc3Nlc1wiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RhdGUgc2F2aW5nIGVuYWJsZW1lbnQgZmxhZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiU3RhdGVTYXZlXCI6IG51bGxcblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogU2Nyb2xsaW5nIHNldHRpbmdzIGZvciBhIHRhYmxlLlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICovXG5cdFx0XCJvU2Nyb2xsXCI6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogV2hlbiB0aGUgdGFibGUgaXMgc2hvcnRlciBpbiBoZWlnaHQgdGhhbiBzU2Nyb2xsWSwgY29sbGFwc2UgdGhlXG5cdFx0XHQgKiB0YWJsZSBjb250YWluZXIgZG93biB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWJsZSAod2hlbiB0cnVlKS5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiQ29sbGFwc2VcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFdpZHRoIG9mIHRoZSBzY3JvbGxiYXIgZm9yIHRoZSB3ZWItYnJvd3NlcidzIHBsYXRmb3JtLiBDYWxjdWxhdGVkXG5cdFx0XHQgKiBkdXJpbmcgdGFibGUgaW5pdGlhbGlzYXRpb24uXG5cdFx0XHQgKiAgQHR5cGUgaW50XG5cdFx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdFx0ICovXG5cdFx0XHRcImlCYXJXaWR0aFwiOiAwLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVmlld3BvcnQgd2lkdGggZm9yIGhvcml6b250YWwgc2Nyb2xsaW5nLiBIb3Jpem9udGFsIHNjcm9sbGluZyBpc1xuXHRcdFx0ICogZGlzYWJsZWQgaWYgYW4gZW1wdHkgc3RyaW5nLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdFwic1hcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFdpZHRoIHRvIGV4cGFuZCB0aGUgdGFibGUgdG8gd2hlbiB1c2luZyB4LXNjcm9sbGluZy4gVHlwaWNhbGx5IHlvdVxuXHRcdFx0ICogc2hvdWxkIG5vdCBuZWVkIHRvIHVzZSB0aGlzLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHRcdCAqL1xuXHRcdFx0XCJzWElubmVyXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBWaWV3cG9ydCBoZWlnaHQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIGlzIGRpc2FibGVkXG5cdFx0XHQgKiBpZiBhbiBlbXB0eSBzdHJpbmcuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0XCJzWVwiOiBudWxsXG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogTGFuZ3VhZ2UgaW5mb3JtYXRpb24gZm9yIHRoZSB0YWJsZS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAZXh0ZW5kcyBEYXRhVGFibGUuZGVmYXVsdHMub0xhbmd1YWdlXG5cdFx0ICovXG5cdFx0XCJvTGFuZ3VhZ2VcIjoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBJbmZvcm1hdGlvbiBjYWxsYmFjayBmdW5jdGlvbi4gU2VlXG5cdFx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmZuSW5mb0NhbGxiYWNrfVxuXHRcdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICovXG5cdFx0XHRcImZuSW5mb0NhbGxiYWNrXCI6IG51bGxcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBCcm93c2VyIHN1cHBvcnQgcGFyYW1ldGVyc1xuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICovXG5cdFx0XCJvQnJvd3NlclwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEluZGljYXRlIGlmIHRoZSBicm93c2VyIGluY29ycmVjdGx5IGNhbGN1bGF0ZXMgd2lkdGg6MTAwJSBpbnNpZGUgYVxuXHRcdFx0ICogc2Nyb2xsaW5nIGVsZW1lbnQgKElFNi83KVxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRcImJTY3JvbGxPdmVyc2l6ZVwiOiBmYWxzZSxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERldGVybWluZSBpZiB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIGlzIG9uIHRoZSByaWdodCBvciBsZWZ0IG9mIHRoZVxuXHRcdFx0ICogc2Nyb2xsaW5nIGNvbnRhaW5lciAtIG5lZWRlZCBmb3IgcnRsIGxhbmd1YWdlIGxheW91dCwgYWx0aG91Z2ggbm90XG5cdFx0XHQgKiBhbGwgYnJvd3NlcnMgbW92ZSB0aGUgc2Nyb2xsYmFyIChTYWZhcmkpLlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRcImJTY3JvbGxiYXJMZWZ0XCI6IGZhbHNlLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRmxhZyBmb3IgaWYgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgaXMgZnVsbHkgc3VwcG9ydGVkIG9yIG5vdFxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRcImJCb3VuZGluZ1wiOiBmYWxzZSxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEJyb3dzZXIgc2Nyb2xsYmFyIHdpZHRoXG5cdFx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdFx0ICogIEBkZWZhdWx0IDBcblx0XHRcdCAqL1xuXHRcdFx0XCJiYXJXaWR0aFwiOiAwXG5cdFx0fSxcblx0XG5cdFxuXHRcdFwiYWpheFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgcmVmZXJlbmNpbmcgdGhlIG5vZGVzIHdoaWNoIGFyZSB1c2VkIGZvciB0aGUgZmVhdHVyZXMuIFRoZVxuXHRcdCAqIHBhcmFtZXRlcnMgb2YgdGhpcyBvYmplY3QgbWF0Y2ggd2hhdCBpcyBhbGxvd2VkIGJ5IHNEb20gLSBpLmUuXG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT4nbCcgLSBMZW5ndGggY2hhbmdpbmc8L2xpPlxuXHRcdCAqICAgICA8bGk+J2YnIC0gRmlsdGVyaW5nIGlucHV0PC9saT5cblx0XHQgKiAgICAgPGxpPid0JyAtIFRoZSB0YWJsZSE8L2xpPlxuXHRcdCAqICAgICA8bGk+J2knIC0gSW5mb3JtYXRpb248L2xpPlxuXHRcdCAqICAgICA8bGk+J3AnIC0gUGFnaW5hdGlvbjwvbGk+XG5cdFx0ICogICAgIDxsaT4ncicgLSBwUm9jZXNzaW5nPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhYW5GZWF0dXJlc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgZGF0YSBpbmZvcm1hdGlvbiAtIHNlZSB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vUm93fSBmb3IgZGV0YWlsZWRcblx0XHQgKiBpbmZvcm1hdGlvbi5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRGF0YVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgaW5kZXhlcyB3aGljaCBhcmUgaW4gdGhlIGN1cnJlbnQgZGlzcGxheSAoYWZ0ZXIgZmlsdGVyaW5nIGV0Yylcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFpRGlzcGxheVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgaW5kZXhlcyBmb3IgZGlzcGxheSAtIG5vIGZpbHRlcmluZ1xuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYWlEaXNwbGF5TWFzdGVyXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBNYXAgb2Ygcm93IGlkcyB0byBkYXRhIGluZGV4ZXNcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0XCJhSWRzXCI6IHt9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIGNvbHVtbiB0aGF0IGlzIGluIHVzZVxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Db2x1bW5zXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBoZWFkZXJcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvSGVhZGVyXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBmb290ZXJcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRm9vdGVyXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSB0aGUgYXBwbGllZCBnbG9iYWwgc2VhcmNoIGluZm9ybWF0aW9uIGluIGNhc2Ugd2Ugd2FudCB0byBmb3JjZSBhXG5cdFx0ICogcmVzZWFyY2ggb3IgY29tcGFyZSB0aGUgb2xkIHNlYXJjaCB0byBhIG5ldyBvbmUuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaFxuXHRcdCAqL1xuXHRcdFwib1ByZXZpb3VzU2VhcmNoXCI6IHt9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSB0aGUgYXBwbGllZCBzZWFyY2ggZm9yIGVhY2ggY29sdW1uIC0gc2VlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaH0gZm9yIHRoZSBmb3JtYXQgdGhhdCBpcyB1c2VkIGZvciB0aGVcblx0XHQgKiBmaWx0ZXJpbmcgaW5mb3JtYXRpb24gZm9yIGVhY2ggY29sdW1uLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9QcmVTZWFyY2hDb2xzXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3J0aW5nIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgdGFibGUuIE5vdGUgdGhhdCB0aGUgaW5uZXIgYXJyYXlzIGFyZVxuXHRcdCAqIHVzZWQgaW4gdGhlIGZvbGxvd2luZyBtYW5uZXI6XG5cdFx0ICogPHVsPlxuXHRcdCAqICAgPGxpPkluZGV4IDAgLSBjb2x1bW4gbnVtYmVyPC9saT5cblx0XHQgKiAgIDxsaT5JbmRleCAxIC0gY3VycmVudCBzb3J0aW5nIGRpcmVjdGlvbjwvbGk+XG5cdFx0ICogPC91bD5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEB0b2RvIFRoZXNlIGlubmVyIGFycmF5cyBzaG91bGQgcmVhbGx5IGJlIG9iamVjdHNcblx0XHQgKi9cblx0XHRcImFhU29ydGluZ1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3J0aW5nIHRoYXQgaXMgYWx3YXlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlIChpLmUuIHByZWZpeGVkIGluIGZyb250IG9mXG5cdFx0ICogYWFTb3J0aW5nKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhYVNvcnRpbmdGaXhlZFwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3NlcyB0byB1c2UgZm9yIHRoZSBzdHJpcGluZyBvZiBhIHRhYmxlLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFzU3RyaXBlQ2xhc3Nlc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyBzdHJpcGluZyBjbGFzc2VzIGFzIHdlbGxcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFzRGVzdHJveVN0cmlwZXNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHJlc3RvcmluZyBhIHRhYmxlIC0gd2Ugc2hvdWxkIHJlc3RvcmUgaXRzIHdpZHRoXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJzRGVzdHJveVdpZHRoXCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBhcnJheSBmb3IgZXZlcnkgdGltZSBhIHJvdyBpcyBpbnNlcnRlZCAoaS5lLiBvbiBhIGRyYXcpLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Sb3dDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgaGVhZGVyIG9uIGVhY2ggZHJhdy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvSGVhZGVyQ2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgZm9vdGVyIG9uIGVhY2ggZHJhdy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRm9vdGVyQ2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgZHJhdyBjYWxsYmFjayBmdW5jdGlvbnNcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRHJhd0NhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHJvdyBjcmVhdGVkIGZ1bmN0aW9uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1Jvd0NyZWF0ZWRDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciBqdXN0IGJlZm9yZSB0aGUgdGFibGUgaXMgcmVkcmF3bi4gQSByZXR1cm4gb2Zcblx0XHQgKiBmYWxzZSB3aWxsIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9QcmVEcmF3Q2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igd2hlbiB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0luaXRDb21wbGV0ZVwiOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0byBiZSBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZywgcHJpb3IgdG9cblx0XHQgKiBzYXZpbmcgc3RhdGUuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlU2F2ZVBhcmFtc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2tzIGZvciBtb2RpZnlpbmcgdGhlIHNldHRpbmdzIHRoYXQgaGF2ZSBiZWVuIHN0b3JlZCBmb3Igc3RhdGUgc2F2aW5nXG5cdFx0ICogcHJpb3IgdG8gdXNpbmcgdGhlIHN0b3JlZCB2YWx1ZXMgdG8gcmVzdG9yZSB0aGUgc3RhdGUuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlTG9hZFBhcmFtc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2tzIGZvciBvcGVyYXRpbmcgb24gdGhlIHNldHRpbmdzIG9iamVjdCBvbmNlIHRoZSBzYXZlZCBzdGF0ZSBoYXMgYmVlblxuXHRcdCAqIGxvYWRlZFxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZUxvYWRlZFwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FjaGUgdGhlIHRhYmxlIElEIGZvciBxdWljayBhY2Nlc3Ncblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKi9cblx0XHRcInNUYWJsZUlkXCI6IFwiXCIsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBUQUJMRSBub2RlIGZvciB0aGUgbWFpbiB0YWJsZVxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UYWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0aGVhZCBlbGVtZW50XG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRIZWFkXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRmb290IGVsZW1lbnQgLSBpZiBpdCBleGlzdHNcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVEZvb3RcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGJvZHkgZWxlbWVudFxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UQm9keVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWNoZSB0aGUgd3JhcHBlciBub2RlIChjb250YWlucyBhbGwgRGF0YVRhYmxlcyBjb250cm9sbGVkIGVsZW1lbnRzKVxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UYWJsZVdyYXBwZXJcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGUgaWYgd2hlbiB1c2luZyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRoZSBsb2FkaW5nIG9mIGRhdGFcblx0XHQgKiBzaG91bGQgYmUgZGVmZXJyZWQgdW50aWwgdGhlIHNlY29uZCBkcmF3LlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdFwiYkRlZmVyTG9hZGluZ1wiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGUgaWYgYWxsIHJlcXVpcmVkIGluZm9ybWF0aW9uIGhhcyBiZWVuIHJlYWQgaW5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdFwiYkluaXRpYWxpc2VkXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmZvcm1hdGlvbiBhYm91dCBvcGVuIHJvd3MuIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheSBoYXMgdGhlIHBhcmFtZXRlcnNcblx0XHQgKiAnblRyJyBhbmQgJ25QYXJlbnQnXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb09wZW5Sb3dzXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBEaWN0YXRlIHRoZSBwb3NpdGlvbmluZyBvZiBEYXRhVGFibGVzJyBjb250cm9sIGVsZW1lbnRzIC0gc2VlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbC5vSW5pdC5zRG9tfS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzRG9tXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlYXJjaCBkZWxheSAoaW4gbVMpXG5cdFx0ICogIEB0eXBlIGludGVnZXJcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic2VhcmNoRGVsYXlcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hpY2ggdHlwZSBvZiBwYWdpbmF0aW9uIHNob3VsZCBiZSB1c2VkLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHR3b19idXR0b25cblx0XHQgKi9cblx0XHRcInNQYWdpbmF0aW9uVHlwZVwiOiBcInR3b19idXR0b25cIixcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHN0YXRlIGR1cmF0aW9uIChmb3IgYHN0YXRlU2F2ZWApIGluIHNlY29uZHMuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdFwiaVN0YXRlRHVyYXRpb25cIjogMCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBzdGF0ZSBzYXZpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxuXHRcdCAqIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcblx0XHQgKiAgIDx1bD5cblx0XHQgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xuXHRcdCAqICAgICAgIGFuZCB0aGUgSlNPTiBzdHJpbmcgdG8gc2F2ZSB0aGF0IGhhcyBiZWVuIHRodXMgZmFyIGNyZWF0ZWQuIFJldHVybnNcblx0XHQgKiAgICAgICBhIEpTT04gc3RyaW5nIHRvIGJlIGluc2VydGVkIGludG8gYSBqc29uIG9iamVjdFxuXHRcdCAqICAgICAgIChpLmUuICdcInBhcmFtXCI6IFsgMCwgMSwgMl0nKTwvbGk+XG5cdFx0ICogICAgIDxsaT5zdHJpbmc6c05hbWUgLSBuYW1lIG9mIGNhbGxiYWNrPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlU2F2ZVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBzdGF0ZSBsb2FkaW5nLiBFYWNoIGFycmF5IGVsZW1lbnQgaXMgYW5cblx0XHQgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT5mdW5jdGlvbjpmbiAtIGZ1bmN0aW9uIHRvIGNhbGwuIFRha2VzIHR3byBwYXJhbWV0ZXJzLCBvU2V0dGluZ3Ncblx0XHQgKiAgICAgICBhbmQgdGhlIG9iamVjdCBzdG9yZWQuIE1heSByZXR1cm4gZmFsc2UgdG8gY2FuY2VsIHN0YXRlIGxvYWRpbmc8L2xpPlxuXHRcdCAqICAgICA8bGk+c3RyaW5nOnNOYW1lIC0gbmFtZSBvZiBjYWxsYmFjazwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZUxvYWRcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0YXRlIHRoYXQgd2FzIHNhdmVkLiBVc2VmdWwgZm9yIGJhY2sgcmVmZXJlbmNlXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJvU2F2ZWRTdGF0ZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdGF0ZSB0aGF0IHdhcyBsb2FkZWQuIFVzZWZ1bCBmb3IgYmFjayByZWZlcmVuY2Vcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm9Mb2FkZWRTdGF0ZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3VyY2UgdXJsIGZvciBBSkFYIGRhdGEgZm9yIHRoZSB0YWJsZS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzQWpheFNvdXJjZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSBmcm9tIGEgZ2l2ZW4gb2JqZWN0IGZyb20gd2hpY2ggdG8gcmVhZCB0aGUgdGFibGUgZGF0YSBmcm9tLiBUaGlzXG5cdFx0ICogY2FuIGJlIGFuIGVtcHR5IHN0cmluZyAod2hlbiBub3Qgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyksIGluIHdoaWNoIGNhc2Vcblx0XHQgKiBpdCBpcyAgYXNzdW1lZCBhbiBhbiBhcnJheSBpcyBnaXZlbiBkaXJlY3RseS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdFwic0FqYXhEYXRhUHJvcFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBOb3RlIGlmIGRyYXcgc2hvdWxkIGJlIGJsb2NrZWQgd2hpbGUgZ2V0dGluZyBkYXRhXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdFwiYkFqYXhEYXRhR2V0XCI6IHRydWUsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYXN0IGpRdWVyeSBYSFIgb2JqZWN0IHRoYXQgd2FzIHVzZWQgZm9yIHNlcnZlci1zaWRlIGRhdGEgZ2F0aGVyaW5nLlxuXHRcdCAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHdvcmtpbmcgd2l0aCB0aGUgWEhSIGluZm9ybWF0aW9uIGluIG9uZSBvZiB0aGVcblx0XHQgKiBjYWxsYmFja3Ncblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcImpxWEhSXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0XCJqc29uXCI6IHVuZGVmaW5lZCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YSBzdWJtaXR0ZWQgYXMgcGFydCBvZiB0aGUgbGFzdCBBamF4IHJlcXVlc3Rcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdFwib0FqYXhEYXRhXCI6IHVuZGVmaW5lZCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb24gdG8gZ2V0IHRoZSBzZXJ2ZXItc2lkZSBkYXRhLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRcImZuU2VydmVyRGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGdW5jdGlvbnMgd2hpY2ggYXJlIGNhbGxlZCBwcmlvciB0byBzZW5kaW5nIGFuIEFqYXggcmVxdWVzdCBzbyBleHRyYVxuXHRcdCAqIHBhcmFtZXRlcnMgY2FuIGVhc2lseSBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU2VydmVyUGFyYW1zXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTZW5kIHRoZSBYSFIgSFRUUCBtZXRob2QgLSBHRVQgb3IgUE9TVCAoY291bGQgYmUgUFVUIG9yIERFTEVURSBpZlxuXHRcdCAqIHJlcXVpcmVkKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdFwic1NlcnZlck1ldGhvZFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGb3JtYXQgbnVtYmVycyBmb3IgZGlzcGxheS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmbkZvcm1hdE51bWJlclwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBMaXN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIHVzZXIgc2VsZWN0YWJsZSBsZW5ndGggbWVudS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhTGVuZ3RoTWVudVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDb3VudGVyIGZvciB0aGUgZHJhd3MgdGhhdCB0aGUgdGFibGUgZG9lcy4gQWxzbyB1c2VkIGFzIGEgdHJhY2tlciBmb3Jcblx0XHQgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJpRHJhd1wiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZSBpZiBhIHJlZHJhdyBpcyBiZWluZyBkb25lIC0gdXNlZnVsIGZvciBBamF4XG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcImJEcmF3aW5nXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBEcmF3IGluZGV4IChpRHJhdykgb2YgdGhlIGxhc3QgZXJyb3Igd2hlbiBwYXJzaW5nIHRoZSByZXR1cm5lZCBkYXRhXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAtMVxuXHRcdCAqL1xuXHRcdFwiaURyYXdFcnJvclwiOiAtMSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGFnaW5nIGRpc3BsYXkgbGVuZ3RoXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAxMFxuXHRcdCAqL1xuXHRcdFwiX2lEaXNwbGF5TGVuZ3RoXCI6IDEwLFxuXHRcblx0XHQvKipcblx0XHQgKiBQYWdpbmcgc3RhcnQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHRcIl9pRGlzcGxheVN0YXJ0XCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgcmVzdWx0IHNldFxuXHRcdCAqIChpLmUuIGJlZm9yZSBmaWx0ZXJpbmcpLCBVc2UgZm5SZWNvcmRzVG90YWwgcmF0aGVyIHRoYW5cblx0XHQgKiB0aGlzIHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiByZWNvcmRzLCByZWdhcmRsZXNzIG9mXG5cdFx0ICogdGhlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgc2V0dGluZy5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9pUmVjb3Jkc1RvdGFsXCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCBkaXNwbGF5IHNldFxuXHRcdCAqIChpLmUuIGFmdGVyIGZpbHRlcmluZykuIFVzZSBmblJlY29yZHNEaXNwbGF5IHJhdGhlciB0aGFuXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmVnYXJkbGVzcyBvZlxuXHRcdCAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX2lSZWNvcmRzRGlzcGxheVwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIGpRdWVyeSBVSSBtYXJraW5nIGFuZCBjbGFzc2VzIHNob3VsZCBiZSB1c2VkLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYkpVSVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY2xhc3NlcyB0byB1c2UgZm9yIHRoZSB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKi9cblx0XHRcIm9DbGFzc2VzXCI6IHt9LFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHRcdCAqIGNhbGxiYWNrIGlmIGZpbHRlcmluZyBoYXMgYmVlbiBkb25lIGluIHRoZSBkcmF3LiBEZXByZWNhdGVkIGluIGZhdm91ciBvZlxuXHRcdCAqIGV2ZW50cy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqICBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdFwiYkZpbHRlcmVkXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHRcdCAqIGNhbGxiYWNrIGlmIHNvcnRpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Zcblx0XHQgKiBldmVudHMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRcImJTb3J0ZWRcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlIHRoYXQgaWYgbXVsdGlwbGUgcm93cyBhcmUgaW4gdGhlIGhlYWRlciBhbmQgdGhlcmUgaXMgbW9yZSB0aGFuXG5cdFx0ICogb25lIHVuaXF1ZSBjZWxsIHBlciBjb2x1bW4sIGlmIHRoZSB0b3Agb25lICh0cnVlKSBvciBib3R0b20gb25lIChmYWxzZSlcblx0XHQgKiBzaG91bGQgYmUgdXNlZCBmb3Igc29ydGluZyAvIHRpdGxlIGJ5IERhdGFUYWJsZXMuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiU29ydENlbGxzVG9wXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpc2F0aW9uIG9iamVjdCB0aGF0IGlzIHVzZWQgZm9yIHRoZSB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib0luaXRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSBjYWxsYmFjayBmdW5jdGlvbnMgLSBmb3IgcGx1Zy1pbnMgdG8gYXR0YWNoIHRoZW1zZWx2ZXMgdG8gdGhlXG5cdFx0ICogZGVzdHJveSBzbyB0aGV5IGNhbiBjbGVhbiB1cCBtYXJrdXAgYW5kIGV2ZW50cy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRGVzdHJveUNhbGxiYWNrXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBiZWZvcmUgZmlsdGVyaW5nXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmblJlY29yZHNUb3RhbFwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5EYXRhU291cmNlKCB0aGlzICkgPT0gJ3NzcCcgP1xuXHRcdFx0XHR0aGlzLl9pUmVjb3Jkc1RvdGFsICogMSA6XG5cdFx0XHRcdHRoaXMuYWlEaXNwbGF5TWFzdGVyLmxlbmd0aDtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IHJlY29yZCBzZXQsIGFmdGVyIGZpbHRlcmluZ1xuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdFwiZm5SZWNvcmRzRGlzcGxheVwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5EYXRhU291cmNlKCB0aGlzICkgPT0gJ3NzcCcgP1xuXHRcdFx0XHR0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKiAxIDpcblx0XHRcdFx0dGhpcy5haURpc3BsYXkubGVuZ3RoO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgZGlzcGxheSBlbmQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRcImZuRGlzcGxheUVuZFwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHZhclxuXHRcdFx0XHRsZW4gICAgICA9IHRoaXMuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0XHRzdGFydCAgICA9IHRoaXMuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRcdGNhbGMgICAgID0gc3RhcnQgKyBsZW4sXG5cdFx0XHRcdHJlY29yZHMgID0gdGhpcy5haURpc3BsYXkubGVuZ3RoLFxuXHRcdFx0XHRmZWF0dXJlcyA9IHRoaXMub0ZlYXR1cmVzLFxuXHRcdFx0XHRwYWdpbmF0ZSA9IGZlYXR1cmVzLmJQYWdpbmF0ZTtcblx0XG5cdFx0XHRpZiAoIGZlYXR1cmVzLmJTZXJ2ZXJTaWRlICkge1xuXHRcdFx0XHRyZXR1cm4gcGFnaW5hdGUgPT09IGZhbHNlIHx8IGxlbiA9PT0gLTEgP1xuXHRcdFx0XHRcdHN0YXJ0ICsgcmVjb3JkcyA6XG5cdFx0XHRcdFx0TWF0aC5taW4oIHN0YXJ0K2xlbiwgdGhpcy5faVJlY29yZHNEaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuICEgcGFnaW5hdGUgfHwgY2FsYz5yZWNvcmRzIHx8IGxlbj09PS0xID9cblx0XHRcdFx0XHRyZWNvcmRzIDpcblx0XHRcdFx0XHRjYWxjO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhpcyB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib0luc3RhbmNlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciBlYWNoIGluc3RhbmNlIG9mIHRoZSBEYXRhVGFibGVzIG9iamVjdC4gSWYgdGhlcmVcblx0XHQgKiBpcyBhbiBJRCBvbiB0aGUgdGFibGUgbm9kZSwgdGhlbiBpdCB0YWtlcyB0aGF0IHZhbHVlLCBvdGhlcndpc2UgYW5cblx0XHQgKiBpbmNyZW1lbnRpbmcgaW50ZXJuYWwgY291bnRlciBpcyB1c2VkLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic0luc3RhbmNlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIHRhYmluZGV4IGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIGFkZGVkIHRvIERhdGFUYWJsZXMgY29udHJvbCBlbGVtZW50cywgYWxsb3dpbmdcblx0XHQgKiBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSB0YWJsZSBhbmQgaXRzIGNvbnRyb2xzLlxuXHRcdCAqL1xuXHRcdFwiaVRhYkluZGV4XCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xuXHRcdCAqL1xuXHRcdFwiblNjcm9sbEhlYWRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRElWIGNvbnRhaW5lciBmb3IgdGhlIGZvb3RlciBzY3JvbGxpbmcgdGFibGUgaWYgc2Nyb2xsaW5nXG5cdFx0ICovXG5cdFx0XCJuU2Nyb2xsRm9vdFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBMYXN0IGFwcGxpZWQgc29ydFxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYUxhc3RTb3J0XCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZWQgcGx1Zy1pbiBpbnN0YW5jZXNcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0XCJvUGx1Z2luc1wiOiB7fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb24gdXNlZCB0byBnZXQgYSByb3cncyBpZCBmcm9tIHRoZSByb3cncyBkYXRhXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInJvd0lkRm5cIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSBhIHJvdydzIGlkXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJyb3dJZFwiOiBudWxsXG5cdH07XG5cblx0LyoqXG5cdCAqIEV4dGVuc2lvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMgdGhhdCBpcyB1c2VkIHRvIHByb3ZpZGUgYWxsIGV4dGVuc2lvblxuXHQgKiBvcHRpb25zLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuZXh0YCBvYmplY3QgaXMgYXZhaWxhYmxlIHRocm91Z2hcblx0ICogYGpRdWVyeS5mbi5kYXRhVGFibGUuZXh0YCB3aGVyZSBpdCBtYXkgYmUgYWNjZXNzZWQgYW5kIG1hbmlwdWxhdGVkLiBJdCBpc1xuXHQgKiBhbHNvIGFsaWFzZWQgdG8gYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIGZvciBoaXN0b3JpYyByZWFzb25zLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLm1vZGVscy5leHRcblx0ICovXG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgZXh0ZW5zaW9uc1xuXHQgKiBcblx0ICogVGhpcyBuYW1lc3BhY2UgYWN0cyBhcyBhIGNvbGxlY3Rpb24gYXJlYSBmb3IgcGx1Zy1pbnMgdGhhdCBjYW4gYmUgdXNlZCB0b1xuXHQgKiBleHRlbmQgRGF0YVRhYmxlcyBjYXBhYmlsaXRpZXMuIEluZGVlZCBtYW55IG9mIHRoZSBidWlsZCBpbiBtZXRob2RzXG5cdCAqIHVzZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIHRoZWlyIG93biBjYXBhYmlsaXRpZXMgKHNvcnRpbmcgbWV0aG9kcyBmb3Jcblx0ICogZXhhbXBsZSkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIG5hbWVzcGFjZSBpcyBhbGlhc2VkIHRvIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCBmb3IgbGVnYWN5XG5cdCAqIHJlYXNvbnNcblx0ICpcblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5leHQgPSBfZXh0ID0ge1xuXHRcdC8qKlxuXHRcdCAqIEJ1dHRvbnMuIEZvciB1c2Ugd2l0aCB0aGUgQnV0dG9ucyBleHRlbnNpb24gZm9yIERhdGFUYWJsZXMuIFRoaXMgaXNcblx0XHQgKiBkZWZpbmVkIGhlcmUgc28gb3RoZXIgZXh0ZW5zaW9ucyBjYW4gZGVmaW5lIGJ1dHRvbnMgcmVnYXJkbGVzcyBvZiBsb2FkXG5cdFx0ICogb3JkZXIuIEl0IGlzIF9ub3RfIHVzZWQgYnkgRGF0YVRhYmxlcyBjb3JlLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdGJ1dHRvbnM6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRWxlbWVudCBjbGFzcyBuYW1lc1xuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdGNsYXNzZXM6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBidWlsZCB0eXBlIChleHBhbmRlZCBieSB0aGUgZG93bmxvYWQgYnVpbGRlcilcblx0XHQgKlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRidWlsZGVyOiBcIi1zb3VyY2UtXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFcnJvciByZXBvcnRpbmcuXG5cdFx0ICogXG5cdFx0ICogSG93IHNob3VsZCBEYXRhVGFibGVzIHJlcG9ydCBhbiBlcnJvci4gQ2FuIHRha2UgdGhlIHZhbHVlICdhbGVydCcsXG5cdFx0ICogJ3Rocm93JywgJ25vbmUnIG9yIGEgZnVuY3Rpb24uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfGZ1bmN0aW9uXG5cdFx0ICogIEBkZWZhdWx0IGFsZXJ0XG5cdFx0ICovXG5cdFx0ZXJyTW9kZTogXCJhbGVydFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRmVhdHVyZSBwbHVnLWlucy5cblx0XHQgKiBcblx0XHQgKiBUaGlzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2hpY2ggZGVzY3JpYmUgdGhlIGZlYXR1cmUgcGx1Zy1pbnMgdGhhdCBhcmVcblx0XHQgKiBhdmFpbGFibGUgdG8gRGF0YVRhYmxlcy4gVGhlc2UgZmVhdHVyZSBwbHVnLWlucyBhcmUgdGhlbiBhdmFpbGFibGUgZm9yXG5cdFx0ICogdXNlIHRocm91Z2ggdGhlIGBkb21gIGluaXRpYWxpc2F0aW9uIG9wdGlvbi5cblx0XHQgKiBcblx0XHQgKiBFYWNoIGZlYXR1cmUgcGx1Zy1pbiBpcyBkZXNjcmliZWQgYnkgYW4gb2JqZWN0IHdoaWNoIG11c3QgaGF2ZSB0aGVcblx0XHQgKiBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHQgKiBcblx0XHQgKiAqIGBmbkluaXRgIC0gZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGluaXRpYWxpc2UgdGhlIHBsdWctaW4sXG5cdFx0ICogKiBgY0ZlYXR1cmVgIC0gYSBjaGFyYWN0ZXIgc28gdGhlIGZlYXR1cmUgY2FuIGJlIGVuYWJsZWQgYnkgdGhlIGBkb21gXG5cdFx0ICogICBpbnN0aWxsYXRpb24gb3B0aW9uLiBUaGlzIGlzIGNhc2Ugc2Vuc2l0aXZlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGBmbkluaXRgIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICpcblx0XHQgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XG5cdFx0ICogXG5cdFx0ICogKiB7bm9kZXxudWxsfSBUaGUgZWxlbWVudCB3aGljaCBjb250YWlucyB5b3VyIGZlYXR1cmUuIE5vdGUgdGhhdCB0aGVcblx0XHQgKiAgIHJldHVybiBtYXkgYWxzbyBiZSB2b2lkIGlmIHlvdXIgcGx1Zy1pbiBkb2VzIG5vdCByZXF1aXJlIHRvIGluamVjdCBhbnlcblx0XHQgKiAgIERPTSBlbGVtZW50cyBpbnRvIERhdGFUYWJsZXMgY29udHJvbCAoYGRvbWApIC0gZm9yIGV4YW1wbGUgdGhpcyBtaWdodFxuXHRcdCAqICAgYmUgdXNlZnVsIHdoZW4gZGV2ZWxvcGluZyBhIHBsdWctaW4gd2hpY2ggYWxsb3dzIHRhYmxlIGNvbnRyb2wgdmlhXG5cdFx0ICogICBrZXlib2FyZCBlbnRyeVxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQuZmVhdHVyZXMucHVzaCgge1xuXHRcdCAqICAgICAgXCJmbkluaXRcIjogZnVuY3Rpb24oIG9TZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZVRvb2xzKCB7IFwib0RUU2V0dGluZ3NcIjogb1NldHRpbmdzIH0gKTtcblx0XHQgKiAgICAgIH0sXG5cdFx0ICogICAgICBcImNGZWF0dXJlXCI6IFwiVFwiXG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdGZlYXR1cmU6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUm93IHNlYXJjaGluZy5cblx0XHQgKiBcblx0XHQgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXG5cdFx0ICogc2VhcmNoaW5nLCBhbmQgYSBsb3QgbW9yZSBjb21wcmVoZW5zaXZlIGFzIGl0IGFsbG93cyB5b3UgY29tcGxldGUgY29udHJvbFxuXHRcdCAqIG92ZXIgdGhlIHNlYXJjaGluZyBsb2dpYy4gRWFjaCBlbGVtZW50IGluIHRoaXMgYXJyYXkgaXMgYSBmdW5jdGlvblxuXHRcdCAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXG5cdFx0ICogYW5kIHlvdXIgbG9naWMgZGVjaWRlcyBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHNlYXJjaGluZyBkYXRhIHNldFxuXHRcdCAqIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIFNlYXJjaGluZyBmdW5jdGlvbnMgaGF2ZSB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICogMi4gYHthcnJheXxvYmplY3R9YCBEYXRhIGZvciB0aGUgcm93IHRvIGJlIHByb2Nlc3NlZCAoc2FtZSBhcyB0aGVcblx0XHQgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcblx0XHQgKiAgICBmcm9tIGEgRE9NIGRhdGEgc291cmNlXG5cdFx0ICogMy4gYHtpbnR9YCBSb3cgaW5kZXggKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncy5hb0RhdGF9KSwgd2hpY2hcblx0XHQgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQW5kIHRoZSBmb2xsb3dpbmcgcmV0dXJuIGlzIGV4cGVjdGVkOlxuXHRcdCAqXG5cdFx0ICogKiB7Ym9vbGVhbn0gSW5jbHVkZSB0aGUgcm93IGluIHRoZSBzZWFyY2hlZCByZXN1bHQgc2V0ICh0cnVlKSBvciBub3Rcblx0XHQgKiAgIChmYWxzZSlcblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBhcyB3aXRoIHRoZSBtYWluIHNlYXJjaCBhYmlsaXR5IGluIERhdGFUYWJsZXMsIHRlY2huaWNhbGx5IHRoaXNcblx0XHQgKiBpcyBcImZpbHRlcmluZ1wiLCBzaW5jZSBpdCBpcyBzdWJ0cmFjdGl2ZS4gSG93ZXZlciwgZm9yIGNvbnNpc3RlbmN5IGluXG5cdFx0ICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXG5cdFx0ICogICAgLy8gZm91cnRoIGNvbHVtbiAoaS5lLiB0aGUgZGF0YVszXSBpbmRleCkgYmFzZWQgb24gdHdvIGlucHV0IHZhbHVlc1xuXHRcdCAqICAgIC8vIGZyb20gdGhlIGVuZC11c2VyLCBtYXRjaGluZyB0aGUgZGF0YSBpbiBhIGNlcnRhaW4gcmFuZ2UuXG5cdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxuXHRcdCAqICAgICAgZnVuY3Rpb24oIHNldHRpbmdzLCBkYXRhLCBkYXRhSW5kZXggKSB7XG5cdFx0ICogICAgICAgIHZhciBtaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWluJykudmFsdWUgKiAxO1xuXHRcdCAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcblx0XHQgKiAgICAgICAgdmFyIHZlcnNpb24gPSBkYXRhWzNdID09IFwiLVwiID8gMCA6IGRhdGFbM10qMTtcblx0XHQgKlxuXHRcdCAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgICk7XG5cdFx0ICovXG5cdFx0c2VhcmNoOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlbGVjdG9yIGV4dGVuc2lvbnNcblx0XHQgKlxuXHRcdCAqIFRoZSBgc2VsZWN0b3JgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBleHRlbmQgdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGVcblx0XHQgKiBzZWxlY3RvciBtb2RpZmllciBvcHRpb25zIChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCBkYXRhIHR5cGUpIHRoYXRcblx0XHQgKiBlYWNoIG9mIHRoZSB0aHJlZSBidWlsdCBpbiBzZWxlY3RvciB0eXBlcyBvZmZlciAocm93LCBjb2x1bW4gYW5kIGNlbGwgK1xuXHRcdCAqIHRoZWlyIHBsdXJhbCBjb3VudGVycGFydHMpLiBGb3IgZXhhbXBsZSB0aGUgU2VsZWN0IGV4dGVuc2lvbiB1c2VzIHRoaXNcblx0XHQgKiBtZWNoYW5pc20gdG8gcHJvdmlkZSBhbiBvcHRpb24gdG8gc2VsZWN0IG9ubHkgcm93cywgY29sdW1ucyBhbmQgY2VsbHNcblx0XHQgKiB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgc2VsZWN0ZWQgYnkgdGhlIGVuZCB1c2VyIChge3NlbGVjdGVkOiB0cnVlfWApLFxuXHRcdCAqIHdoaWNoIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGV4aXN0aW5nIGJ1aWx0IGluIHNlbGVjdG9yXG5cdFx0ICogb3B0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEVhY2ggcHJvcGVydHkgaXMgYW4gYXJyYXkgdG8gd2hpY2ggZnVuY3Rpb25zIGNhbiBiZSBwdXNoZWQuIFRoZSBmdW5jdGlvbnNcblx0XHQgKiB0YWtlIHRocmVlIGF0dHJpYnV0ZXM6XG5cdFx0ICpcblx0XHQgKiAqIFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGhvc3QgdGFibGVcblx0XHQgKiAqIE9wdGlvbnMgb2JqZWN0IChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCB0eXBlKVxuXHRcdCAqICogQXJyYXkgb2Ygc2VsZWN0ZWQgaXRlbSBpbmRleGVzXG5cdFx0ICpcblx0XHQgKiBUaGUgcmV0dXJuIGlzIGFuIGFycmF5IG9mIHRoZSByZXN1bHRpbmcgaXRlbSBpbmRleGVzIGFmdGVyIHRoZSBjdXN0b21cblx0XHQgKiBzZWxlY3RvciBoYXMgYmVlbiBhcHBsaWVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqL1xuXHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRjZWxsOiBbXSxcblx0XHRcdGNvbHVtbjogW10sXG5cdFx0XHRyb3c6IFtdXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEludGVybmFsIGZ1bmN0aW9ucywgZXhwb3NlZCBmb3IgdXNlZCBpbiBwbHVnLWlucy5cblx0XHQgKiBcblx0XHQgKiBQbGVhc2Ugbm90ZSB0aGF0IHlvdSBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoZSBpbnRlcm5hbCBtZXRob2RzIGZvclxuXHRcdCAqIGFueXRoaW5nIG90aGVyIHRoYW4gYSBwbHVnLWluIChhbmQgZXZlbiB0aGVuLCB0cnkgdG8gYXZvaWQgaWYgcG9zc2libGUpLlxuXHRcdCAqIFRoZSBpbnRlcm5hbCBmdW5jdGlvbiBtYXkgY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0aW50ZXJuYWw6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogTGVnYWN5IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gRW5hYmxlIGFuZCBkaXNhYmxlIGxlZ2FjeSBvcHRpb25zIHRoYXRcblx0XHQgKiBhcmUgYXZhaWxhYmxlIGluIERhdGFUYWJsZXMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICovXG5cdFx0bGVnYWN5OiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZSAvIGRpc2FibGUgRGF0YVRhYmxlcyAxLjkgY29tcGF0aWJsZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0XHQgKiByZXF1ZXN0c1xuXHRcdFx0ICpcblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICovXG5cdFx0XHRhamF4OiBudWxsXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBhZ2luYXRpb24gcGx1Zy1pbiBtZXRob2RzLlxuXHRcdCAqIFxuXHRcdCAqIEVhY2ggZW50cnkgaW4gdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgZGVmaW5lcyB3aGljaCBidXR0b25zIHNob3VsZFxuXHRcdCAqIGJlIHNob3duIGJ5IHRoZSBwYWdpbmF0aW9uIHJlbmRlcmluZyBtZXRob2QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGU6XG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5leHQucmVuZGVyZXIucGFnZUJ1dHRvbn0uIFRoZSByZW5kZXJlciBhZGRyZXNzZXMgaG93IHRoZVxuXHRcdCAqIGJ1dHRvbnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgZG9jdW1lbnQsIHdoaWxlIHRoZSBmdW5jdGlvbnMgaGVyZSB0ZWxsIGl0XG5cdFx0ICogd2hhdCBidXR0b25zIHRvIGRpc3BsYXkuIFRoaXMgaXMgZG9uZSBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYnV0dG9uXG5cdFx0ICogZGVzY3JpcHRpb25zICh3aGF0IGVhY2ggYnV0dG9uIHdpbGwgZG8pLlxuXHRcdCAqXG5cdFx0ICogUGFnaW5hdGlvbiB0eXBlcyAodGhlIGZvdXIgYnVpbHQgaW4gb3B0aW9ucyBhbmQgYW55IGFkZGl0aW9uYWwgcGx1Zy1pblxuXHRcdCAqIG9wdGlvbnMgZGVmaW5lZCBoZXJlKSBjYW4gYmUgdXNlZCB0aHJvdWdoIHRoZSBgcGFnaW5hdGlvblR5cGVgXG5cdFx0ICogaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge2ludH0gcGFnZWAgVGhlIGN1cnJlbnQgcGFnZSBpbmRleFxuXHRcdCAqIDIuIGB7aW50fSBwYWdlc2AgVGhlIG51bWJlciBvZiBwYWdlcyBpbiB0aGUgdGFibGVcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5IHdoZXJlIGVhY2ggZWxlbWVudCBvZiB0aGVcblx0XHQgKiBhcnJheSBjYW4gYmUgb25lIG9mOlxuXHRcdCAqXG5cdFx0ICogKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdFx0ICogKiBgbGFzdGAgLSBKdW1wIHRvIGxhc3QgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYHByZXZpb3VzYCAtIFNob3cgcHJldmlvdXMgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYG5leHRgIC0gU2hvdyBuZXh0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcblx0XHQgKiAqIGB7aW50fWAgLSBTaG93IHBhZ2Ugb2YgdGhlIGluZGV4IGdpdmVuXG5cdFx0ICogKiBge2FycmF5fWAgLSBBIG5lc3RlZCBhcnJheSBjb250YWluaW5nIHRoZSBhYm92ZSBlbGVtZW50cyB0byBhZGQgYVxuXHRcdCAqICAgY29udGFpbmluZyAnRElWJyBlbGVtZW50IChtaWdodCBiZSB1c2VmdWwgZm9yIHN0eWxpbmcpLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IERhdGFUYWJsZXMgdjEuOS0gdXNlZCB0aGlzIG9iamVjdCBzbGlnaHRseSBkaWZmZXJlbnRseSB3aGVyZWJ5XG5cdFx0ICogYW4gb2JqZWN0IHdpdGggdHdvIGZ1bmN0aW9ucyB3b3VsZCBiZSBkZWZpbmVkIGZvciBlYWNoIHBsdWctaW4uIFRoYXRcblx0XHQgKiBhYmlsaXR5IGlzIHN0aWxsIHN1cHBvcnRlZCBieSBEYXRhVGFibGVzIDEuMTArIHRvIHByb3ZpZGUgYmFja3dhcmRzXG5cdFx0ICogY29tcGF0aWJpbGl0eSwgYnV0IHRoaXMgb3B0aW9uIG9mIHVzZSBpcyBub3cgZGVjcmVtZW50ZWQgYW5kIG5vIGxvbmdlclxuXHRcdCAqIGRvY3VtZW50ZWQgaW4gRGF0YVRhYmxlcyAxLjEwKy5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNob3cgcHJldmlvdXMsIG5leHQgYW5kIGN1cnJlbnQgcGFnZSBidXR0b25zIG9ubHlcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZUV4dC5vUGFnaW5hdGlvbi5jdXJyZW50ID0gZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHQgKiAgICAgIHJldHVybiBbICdwcmV2aW91cycsIHBhZ2UsICduZXh0JyBdO1xuXHRcdCAqICAgIH07XG5cdFx0ICovXG5cdFx0cGFnZXI6IHt9LFxuXHRcblx0XG5cdFx0cmVuZGVyZXI6IHtcblx0XHRcdHBhZ2VCdXR0b246IHt9LFxuXHRcdFx0aGVhZGVyOiB7fVxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBPcmRlcmluZyBwbHVnLWlucyAtIGN1c3RvbSBkYXRhIHNvdXJjZVxuXHRcdCAqIFxuXHRcdCAqIFRoZSBleHRlbnNpb24gb3B0aW9ucyBmb3Igb3JkZXJpbmcgb2YgZGF0YSBhdmFpbGFibGUgaGVyZSBpcyBjb21wbGltZW50YXJ5XG5cdFx0ICogdG8gdGhlIGRlZmF1bHQgdHlwZSBiYXNlZCBvcmRlcmluZyB0aGF0IERhdGFUYWJsZXMgdHlwaWNhbGx5IHVzZXMuIEl0XG5cdFx0ICogYWxsb3dzIG11Y2ggZ3JlYXRlciBjb250cm9sIG92ZXIgdGhlIHRoZSBkYXRhIHRoYXQgaXMgYmVpbmcgdXNlZCB0b1xuXHRcdCAqIG9yZGVyIGEgY29sdW1uLCBidXQgaXMgbmVjZXNzYXJpbHkgdGhlcmVmb3JlIG1vcmUgY29tcGxleC5cblx0XHQgKiBcblx0XHQgKiBUaGlzIHR5cGUgb2Ygb3JkZXJpbmcgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGRvIG9yZGVyaW5nIGJhc2VkIG9uIGRhdGFcblx0XHQgKiBsaXZlIGZyb20gdGhlIERPTSAoZm9yIGV4YW1wbGUgdGhlIGNvbnRlbnRzIG9mIGFuICdpbnB1dCcgZWxlbWVudCkgcmF0aGVyXG5cdFx0ICogdGhhbiBqdXN0IHRoZSBzdGF0aWMgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBrbm93cyBvZi5cblx0XHQgKiBcblx0XHQgKiBUaGUgd2F5IHRoZXNlIHBsdWctaW5zIHdvcmsgaXMgdGhhdCB5b3UgY3JlYXRlIGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgeW91XG5cdFx0ICogd2lzaCB0byBiZSBvcmRlcmluZyBmb3IgdGhlIGNvbHVtbiBpbiBxdWVzdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhhdFxuXHRcdCAqIGFycmF5LiBUaGUgZGF0YSBpbiB0aGUgYXJyYXkgbXVjaCBiZSBpbiB0aGUgaW5kZXggb3JkZXIgb2YgdGhlIHJvd3MgaW5cblx0XHQgKiB0aGUgdGFibGUgKG5vdCB0aGUgY3VycmVudGx5IG9yZGVyaW5nIG9yZGVyISkuIFdoaWNoIG9yZGVyIGRhdGEgZ2F0aGVyaW5nXG5cdFx0ICogZnVuY3Rpb24gaXMgcnVuIGhlcmUgZGVwZW5kcyBvbiB0aGUgYGR0LWluaXQgY29sdW1ucy5vcmRlckRhdGFUeXBlYFxuXHRcdCAqIHBhcmFtZXRlciB0aGF0IGlzIHVzZWQgZm9yIHRoZSBjb2x1bW4gKGlmIGFueSkuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcblx0XHQgKlxuXHRcdCAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxuXHRcdCAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0XHQgKiAyLiBge2ludH1gIFRhcmdldCBjb2x1bW4gaW5kZXhcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5OlxuXHRcdCAqXG5cdFx0ICogKiBge2FycmF5fWAgRGF0YSBmb3IgdGhlIGNvbHVtbiB0byBiZSBvcmRlcmluZyB1cG9uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIE9yZGVyaW5nIHVzaW5nIGBpbnB1dGAgbm9kZSB2YWx1ZXNcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ2RvbS10ZXh0J10gPSBmdW5jdGlvbiAgKCBzZXR0aW5ncywgY29sIClcblx0XHQgKiAgICB7XG5cdFx0ICogICAgICByZXR1cm4gdGhpcy5hcGkoKS5jb2x1bW4oIGNvbCwge29yZGVyOidpbmRleCd9ICkubm9kZXMoKS5tYXAoIGZ1bmN0aW9uICggdGQsIGkgKSB7XG5cdFx0ICogICAgICAgIHJldHVybiAkKCdpbnB1dCcsIHRkKS52YWwoKTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9XG5cdFx0ICovXG5cdFx0b3JkZXI6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVHlwZSBiYXNlZCBwbHVnLWlucy5cblx0XHQgKlxuXHRcdCAqIEVhY2ggY29sdW1uIGluIERhdGFUYWJsZXMgaGFzIGEgdHlwZSBhc3NpZ25lZCB0byBpdCwgZWl0aGVyIGJ5IGF1dG9tYXRpY1xuXHRcdCAqIGRldGVjdGlvbiBvciBieSBkaXJlY3QgYXNzaWdubWVudCB1c2luZyB0aGUgYHR5cGVgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbi5cblx0XHQgKiBUaGUgdHlwZSBvZiBhIGNvbHVtbiB3aWxsIGVmZmVjdCBob3cgaXQgaXMgb3JkZXJpbmcgYW5kIHNlYXJjaCAocGx1Zy1pbnNcblx0XHQgKiBjYW4gYWxzbyBtYWtlIHVzZSBvZiB0aGUgY29sdW1uIHR5cGUgaWYgcmVxdWlyZWQpLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdHR5cGU6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdFxuXHRcdFx0ICogYSBjb2x1bW4ncyB0eXBlLCBtYWtpbmcgaW5pdGlhbGlzYXRpb24gb2YgRGF0YVRhYmxlcyBzdXBlciBlYXN5LCBldmVuXG5cdFx0XHQgKiB3aGVuIGNvbXBsZXggZGF0YSBpcyBpbiB0aGUgdGFibGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBhbmFseXNlZFxuXHRcdCAgICAgKiAgMi4gYHtzZXR0aW5nc31gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5cdFx0ICAgICAqICAgICBwZXJmb3JtIGNvbnRleHQgc3BlY2lmaWMgdHlwZSBkZXRlY3Rpb24gLSBmb3IgZXhhbXBsZSBkZXRlY3Rpb25cblx0XHQgICAgICogICAgIGJhc2VkIG9uIGxhbmd1YWdlIHNldHRpbmdzIHN1Y2ggYXMgdXNpbmcgYSBjb21tYSBmb3IgYSBkZWNpbWFsXG5cdFx0ICAgICAqICAgICBwbGFjZS4gR2VuZXJhbGx5IHNwZWFraW5nIHRoZSBvcHRpb25zIGZyb20gdGhlIHNldHRpbmdzIHdpbGwgbm90XG5cdFx0ICAgICAqICAgICBiZSByZXF1aXJlZFxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHtzdHJpbmd8bnVsbH1gIERhdGEgdHlwZSBkZXRlY3RlZCwgb3IgbnVsbCBpZiB1bmtub3duIChhbmQgdGh1c1xuXHRcdFx0ICogICBwYXNzIGl0IG9uIHRvIHRoZSBvdGhlciB0eXBlIGRldGVjdGlvbiBmdW5jdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBDdXJyZW5jeSB0eXBlIGRldGVjdGlvbiBwbHVnLWluOlxuXHRcdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0LnB1c2goXG5cdFx0XHQgKiAgICAgIGZ1bmN0aW9uICggZGF0YSwgc2V0dGluZ3MgKSB7XG5cdFx0XHQgKiAgICAgICAgLy8gQ2hlY2sgdGhlIG51bWVyaWMgcGFydFxuXHRcdFx0ICogICAgICAgIGlmICggISAkLmlzTnVtZXJpYyggZGF0YS5zdWJzdHJpbmcoMSkgKSApIHtcblx0XHRcdCAqICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgLy8gQ2hlY2sgcHJlZml4ZWQgYnkgY3VycmVuY3lcblx0XHRcdCAqICAgICAgICBpZiAoIGRhdGEuY2hhckF0KDApID09ICckJyB8fCBkYXRhLmNoYXJBdCgwKSA9PSAnJnBvdW5kOycgKSB7XG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4gJ2N1cnJlbmN5Jztcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgICk7XG5cdFx0XHQgKi9cblx0XHRcdGRldGVjdDogW10sXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBiYXNlZCBzZWFyY2ggZm9ybWF0dGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgdHlwZSBiYXNlZCBzZWFyY2hpbmcgZnVuY3Rpb25zIGNhbiBiZSB1c2VkIHRvIHByZS1mb3JtYXQgdGhlXG5cdFx0XHQgKiBkYXRhIHRvIGJlIHNlYXJjaCBvbi4gRm9yIGV4YW1wbGUsIGl0IGNhbiBiZSB1c2VkIHRvIHN0cmlwIEhUTUxcblx0XHRcdCAqIHRhZ3Mgb3IgdG8gZGUtZm9ybWF0IHRlbGVwaG9uZSBudW1iZXJzIGZvciBudW1lcmljIG9ubHkgc2VhcmNoaW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGUgdGhhdCBpcyBhIHNlYXJjaCBpcyBub3QgZGVmaW5lZCBmb3IgYSBjb2x1bW4gb2YgYSBnaXZlbiB0eXBlLFxuXHRcdFx0ICogbm8gc2VhcmNoIGZvcm1hdHRpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG5cdFx0XHQgKiBcblx0XHRcdCAqIFByZS1wcm9jZXNzaW5nIG9mIHNlYXJjaGluZyBkYXRhIHBsdWctaW5zIC0gV2hlbiB5b3UgYXNzaWduIHRoZSBzVHlwZVxuXHRcdFx0ICogZm9yIGEgY29sdW1uIChvciBoYXZlIGl0IGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQgZm9yIHlvdSBieSBEYXRhVGFibGVzXG5cdFx0XHQgKiBvciBhIHR5cGUgZGV0ZWN0aW9uIHBsdWctaW4pLCB5b3Ugd2lsbCB0eXBpY2FsbHkgYmUgdXNpbmcgdGhpcyBmb3Jcblx0XHRcdCAqIGN1c3RvbSBzb3J0aW5nLCBidXQgaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGN1c3RvbSBzZWFyY2hpbmdcblx0XHRcdCAqIGJ5IGFsbG93aW5nIHlvdSB0byBwcmUtcHJvY2Vzc2luZyB0aGUgZGF0YSBhbmQgcmV0dXJuaW5nIHRoZSBkYXRhIGluXG5cdFx0XHQgKiB0aGUgZm9ybWF0IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIHVwb24uIFRoaXMgaXMgZG9uZSBieSBhZGRpbmdcblx0XHRcdCAqIGZ1bmN0aW9ucyB0aGlzIG9iamVjdCB3aXRoIGEgcGFyYW1ldGVyIG5hbWUgd2hpY2ggbWF0Y2hlcyB0aGUgc1R5cGVcblx0XHRcdCAqIGZvciB0aGF0IHRhcmdldCBjb2x1bW4uIFRoaXMgaXMgdGhlIGNvcm9sbGFyeSBvZiA8aT5hZm5Tb3J0RGF0YTwvaT5cblx0XHRcdCAqIGZvciBzZWFyY2hpbmcgZGF0YS5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igc2VhcmNoaW5nXG5cdFx0XHQgKlxuXHRcdFx0ICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBge3N0cmluZ3xudWxsfWAgRm9ybWF0dGVkIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIHNlYXJjaGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0XHQgKiAgQGRlZmF1bHQge31cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaFsndGl0bGUtbnVtZXJpYyddID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0ICogICAgICByZXR1cm4gZC5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSggLzwuKj8+L2csIFwiXCIgKTtcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqL1xuXHRcdFx0c2VhcmNoOiB7fSxcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUeXBlIGJhc2VkIG9yZGVyaW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjb2x1bW4gdHlwZSB0ZWxscyBEYXRhVGFibGVzIHdoYXQgb3JkZXJpbmcgdG8gYXBwbHkgdG8gdGhlIHRhYmxlXG5cdFx0XHQgKiB3aGVuIGEgY29sdW1uIGlzIHNvcnRlZCB1cG9uLiBUaGUgb3JkZXIgZm9yIGVhY2ggdHlwZSB0aGF0IGlzIGRlZmluZWQsXG5cdFx0XHQgKiBpcyBkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbnMgYXZhaWxhYmxlIGluIHRoaXMgb2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggb3JkZXJpbmcgb3B0aW9uIGNhbiBiZSBkZXNjcmliZWQgYnkgdGhyZWUgcHJvcGVydGllcyBhZGRlZCB0b1xuXHRcdFx0ICogdGhpcyBvYmplY3Q6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBge3R5cGV9LXByZWAgLSBQcmUtZm9ybWF0dGluZyBmdW5jdGlvblxuXHRcdFx0ICogKiBge3R5cGV9LWFzY2AgLSBBc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHRcdCAqICogYHt0eXBlfS1kZXNjYCAtIERlc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHRcdCAqXG5cdFx0XHQgKiBBbGwgdGhyZWUgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIG9ubHkgYHt0eXBlfS1wcmVgIG9yIG9ubHlcblx0XHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYCB0b2dldGhlci4gSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkXG5cdFx0XHQgKiB0aGF0IG9ubHkgYHt0eXBlfS1wcmVgIGlzIHVzZWQsIGFzIHRoaXMgcHJvdmlkZXMgdGhlIG9wdGltYWxcblx0XHRcdCAqIGltcGxlbWVudGF0aW9uIGluIHRlcm1zIG9mIHNwZWVkLCBhbHRob3VnaCB0aGUgb3RoZXJzIGFyZSBwcm92aWRlZFxuXHRcdFx0ICogZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBKYXZhc2NyaXB0IHNvcnQgZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIGB7dHlwZX0tcHJlYDogRnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igb3JkZXJpbmdcblx0XHRcdCAqXG5cdFx0XHQgKiBBbmQgcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHsqfWAgRGF0YSB0byBiZSBzb3J0ZWQgdXBvblxuXHRcdFx0ICpcblx0XHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYDogRnVuY3Rpb25zIGFyZSB0eXBpY2FsIEphdmFzY3JpcHQgc29ydFxuXHRcdFx0ICogZnVuY3Rpb25zLCB0YWtpbmcgdHdvIHBhcmFtZXRlcnM6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG5cdFx0ICAgICAqICAyLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0ICpcblx0XHRcdCAqIEFuZCByZXR1cm5pbmc6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBgeyp9YCBPcmRlcmluZyBtYXRjaDogPDAgaWYgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgbG93ZXJcblx0XHRcdCAqICAgdGhhbiB0aGUgc2Vjb25kIHBhcmFtZXRlciwgPT09MCBpZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlIGVxdWFsIGFuZFxuXHRcdFx0ICogICA+MCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgaGVpZ2h0IHRoYW4gdGhlIHNlY29uZFxuXHRcdFx0ICogICBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBcblx0XHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTnVtZXJpYyBvcmRlcmluZyBvZiBmb3JtYXR0ZWQgbnVtYmVycyB3aXRoIGEgcHJlLWZvcm1hdHRlclxuXHRcdFx0ICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLCB7XG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLXByZVwiOiBmdW5jdGlvbih4KSB7XG5cdFx0XHQgKiAgICAgICAgYSA9IChhID09PSBcIi1cIiB8fCBhID09PSBcIlwiKSA/IDAgOiBhLnJlcGxhY2UoIC9bXlxcZFxcLVxcLl0vZywgXCJcIiApO1xuXHRcdFx0ICogICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBhICk7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIENhc2Utc2Vuc2l0aXZlIHN0cmluZyBvcmRlcmluZywgd2l0aCBubyBwcmUtZm9ybWF0dGluZyBtZXRob2Rcblx0XHRcdCAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXIsIHtcblx0XHRcdCAqICAgICAgXCJzdHJpbmctY2FzZS1hc2NcIjogZnVuY3Rpb24oeCx5KSB7XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLWNhc2UtZGVzY1wiOiBmdW5jdGlvbih4LHkpIHtcblx0XHRcdCAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRvcmRlcjoge31cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBVbmlxdWUgRGF0YVRhYmxlcyBpbnN0YW5jZSBjb3VudGVyXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBpbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF91bmlxdWU6IDAsXG5cdFxuXHRcblx0XHQvL1xuXHRcdC8vIERlcHJlY2lhdGVkXG5cdFx0Ly8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGlibGl0eSBvbmx5LlxuXHRcdC8vIFRoZSBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmVcblx0XHQvLyB2ZXJzaW9uXG5cdFx0Ly9cblx0XG5cdFx0LyoqXG5cdFx0ICogVmVyc2lvbiBjaGVjayBmdW5jdGlvbi5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQGRlcHJlY2lhdGVkIFNpbmNlIDEuMTBcblx0XHQgKi9cblx0XHRmblZlcnNpb25DaGVjazogRGF0YVRhYmxlLmZuVmVyc2lvbkNoZWNrLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kZXggZm9yIHdoYXQgJ3RoaXMnIGluZGV4IEFQSSBmdW5jdGlvbnMgc2hvdWxkIHVzZVxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKi9cblx0XHRpQXBpSW5kZXg6IDAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBqUXVlcnkgVUkgY2xhc3MgY29udGFpbmVyXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqL1xuXHRcdG9KVUlDbGFzc2VzOiB7fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNvZnR3YXJlIHZlcnNpb25cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICovXG5cdFx0c1ZlcnNpb246IERhdGFUYWJsZS52ZXJzaW9uXG5cdH07XG5cdFxuXHRcblx0Ly9cblx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEFsaWFzIHRvIHByZSAxLjEwIEh1bmdhcmlhbiBub3RhdGlvbiBjb3VudGVyIHBhcnRzXG5cdC8vXG5cdCQuZXh0ZW5kKCBfZXh0LCB7XG5cdFx0YWZuRmlsdGVyaW5nOiBfZXh0LnNlYXJjaCxcblx0XHRhVHlwZXM6ICAgICAgIF9leHQudHlwZS5kZXRlY3QsXG5cdFx0b2ZuU2VhcmNoOiAgICBfZXh0LnR5cGUuc2VhcmNoLFxuXHRcdG9Tb3J0OiAgICAgICAgX2V4dC50eXBlLm9yZGVyLFxuXHRcdGFmblNvcnREYXRhOiAgX2V4dC5vcmRlcixcblx0XHRhb0ZlYXR1cmVzOiAgIF9leHQuZmVhdHVyZSxcblx0XHRvQXBpOiAgICAgICAgIF9leHQuaW50ZXJuYWwsXG5cdFx0b1N0ZENsYXNzZXM6ICBfZXh0LmNsYXNzZXMsXG5cdFx0b1BhZ2luYXRpb246ICBfZXh0LnBhZ2VyXG5cdH0gKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCB7XG5cdFx0XCJzVGFibGVcIjogXCJkYXRhVGFibGVcIixcblx0XHRcInNOb0Zvb3RlclwiOiBcIm5vLWZvb3RlclwiLFxuXHRcblx0XHQvKiBQYWdpbmcgYnV0dG9ucyAqL1xuXHRcdFwic1BhZ2VCdXR0b25cIjogXCJwYWdpbmF0ZV9idXR0b24gYnRuIHdhdmVzLWVmZmVjdFwiLFxuXHRcdFwic1BhZ2VCdXR0b25BY3RpdmVcIjogXCJjdXJyZW50XCIsXG5cdFx0XCJzUGFnZUJ1dHRvbkRpc2FibGVkXCI6IFwiZGlzYWJsZWRcIixcblx0XG5cdFx0LyogU3RyaXBpbmcgY2xhc3NlcyAqL1xuXHRcdFwic1N0cmlwZU9kZFwiOiBcIm9kZFwiLFxuXHRcdFwic1N0cmlwZUV2ZW5cIjogXCJldmVuXCIsXG5cdFxuXHRcdC8qIEVtcHR5IHJvdyAqL1xuXHRcdFwic1Jvd0VtcHR5XCI6IFwiZGF0YVRhYmxlc19lbXB0eVwiLFxuXHRcblx0XHQvKiBGZWF0dXJlcyAqL1xuXHRcdFwic1dyYXBwZXJcIjogXCJkYXRhVGFibGVzX3dyYXBwZXJcIixcblx0XHRcInNGaWx0ZXJcIjogXCJkYXRhVGFibGVzX2ZpbHRlclwiLFxuXHRcdFwic0luZm9cIjogXCJkYXRhVGFibGVzX2luZm9cIixcblx0XHRcInNQYWdpbmdcIjogXCJkYXRhVGFibGVzX3BhZ2luYXRlIHBhZ2luZ19cIiwgLyogTm90ZSB0aGF0IHRoZSB0eXBlIGlzIHBvc3RmaXhlZCAqL1xuXHRcdFwic0xlbmd0aFwiOiBcImRhdGFUYWJsZXNfbGVuZ3RoXCIsXG5cdFx0XCJzUHJvY2Vzc2luZ1wiOiBcImRhdGFUYWJsZXNfcHJvY2Vzc2luZ1wiLFxuXHRcblx0XHQvKiBTb3J0aW5nICovXG5cdFx0XCJzU29ydEFzY1wiOiBcInNvcnRpbmdfYXNjXCIsXG5cdFx0XCJzU29ydERlc2NcIjogXCJzb3J0aW5nX2Rlc2NcIixcblx0XHRcInNTb3J0YWJsZVwiOiBcInNvcnRpbmdcIiwgLyogU29ydGFibGUgaW4gYm90aCBkaXJlY3Rpb25zICovXG5cdFx0XCJzU29ydGFibGVBc2NcIjogXCJzb3J0aW5nX2FzY19kaXNhYmxlZFwiLFxuXHRcdFwic1NvcnRhYmxlRGVzY1wiOiBcInNvcnRpbmdfZGVzY19kaXNhYmxlZFwiLFxuXHRcdFwic1NvcnRhYmxlTm9uZVwiOiBcInNvcnRpbmdfZGlzYWJsZWRcIixcblx0XHRcInNTb3J0Q29sdW1uXCI6IFwic29ydGluZ19cIiwgLyogTm90ZSB0aGF0IGFuIGludCBpcyBwb3N0Zml4ZWQgZm9yIHRoZSBzb3J0aW5nIG9yZGVyICovXG5cdFxuXHRcdC8qIEZpbHRlcmluZyAqL1xuXHRcdFwic0ZpbHRlcklucHV0XCI6IFwiXCIsXG5cdFxuXHRcdC8qIFBhZ2UgbGVuZ3RoICovXG5cdFx0XCJzTGVuZ3RoU2VsZWN0XCI6IFwiXCIsXG5cdFxuXHRcdC8qIFNjcm9sbGluZyAqL1xuXHRcdFwic1Njcm9sbFdyYXBwZXJcIjogXCJkYXRhVGFibGVzX3Njcm9sbFwiLFxuXHRcdFwic1Njcm9sbEhlYWRcIjogXCJkYXRhVGFibGVzX3Njcm9sbEhlYWRcIixcblx0XHRcInNTY3JvbGxIZWFkSW5uZXJcIjogXCJkYXRhVGFibGVzX3Njcm9sbEhlYWRJbm5lclwiLFxuXHRcdFwic1Njcm9sbEJvZHlcIjogXCJkYXRhVGFibGVzX3Njcm9sbEJvZHlcIixcblx0XHRcInNTY3JvbGxGb290XCI6IFwiZGF0YVRhYmxlc19zY3JvbGxGb290XCIsXG5cdFx0XCJzU2Nyb2xsRm9vdElubmVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxGb290SW5uZXJcIixcblx0XG5cdFx0LyogTWlzYyAqL1xuXHRcdFwic0hlYWRlclRIXCI6IFwiXCIsXG5cdFx0XCJzRm9vdGVyVEhcIjogXCJcIixcblx0XG5cdFx0Ly8gRGVwcmVjYXRlZFxuXHRcdFwic1NvcnRKVUlBc2NcIjogXCJcIixcblx0XHRcInNTb3J0SlVJRGVzY1wiOiBcIlwiLFxuXHRcdFwic1NvcnRKVUlcIjogXCJcIixcblx0XHRcInNTb3J0SlVJQXNjQWxsb3dlZFwiOiBcIlwiLFxuXHRcdFwic1NvcnRKVUlEZXNjQWxsb3dlZFwiOiBcIlwiLFxuXHRcdFwic1NvcnRKVUlXcmFwcGVyXCI6IFwiXCIsXG5cdFx0XCJzU29ydEljb25cIjogXCJcIixcblx0XHRcInNKVUlIZWFkZXJcIjogXCJcIixcblx0XHRcInNKVUlGb290ZXJcIjogXCJcIlxuXHR9ICk7XG5cdFxuXHRcblx0KGZ1bmN0aW9uKCkge1xuXHRcblx0Ly8gUmV1c2VkIHN0cmluZ3MgZm9yIGJldHRlciBjb21wcmVzc2lvbi4gQ2xvc3VyZSBjb21waWxlciBhcHBlYXJzIHRvIGhhdmUgYVxuXHQvLyB3ZWlyZCBlZGdlIGNhc2Ugd2hlcmUgaXQgaXMgdHJ5aW5nIHRvIGV4cGFuZCBzdHJpbmdzIHJhdGhlciB0aGFuIHVzZSB0aGVcblx0Ly8gdmFyaWFibGUgdmVyc2lvbi4gVGhpcyByZXN1bHRzIGluIGFib3V0IDIwMCBieXRlcyBiZWluZyBhZGRlZCwgZm9yIHZlcnlcblx0Ly8gbGl0dGxlIHByZWZlcmVuY2UgYmVuZWZpdCBzaW5jZSBpdCB0aGlzIHJ1biBvbiBzY3JpcHQgbG9hZCBvbmx5LlxuXHR2YXIgX2VtcHR5ID0gJyc7XG5cdF9lbXB0eSA9ICcnO1xuXHRcblx0dmFyIF9zdGF0ZURlZmF1bHQgPSBfZW1wdHkgKyAndWktc3RhdGUtZGVmYXVsdCc7XG5cdHZhciBfc29ydEljb24gICAgID0gX2VtcHR5ICsgJ2Nzc19yaWdodCB1aS1pY29uIHVpLWljb24tJztcblx0dmFyIF9oZWFkZXJGb290ZXIgPSBfZW1wdHkgKyAnZmctdG9vbGJhciB1aS10b29sYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktaGVscGVyLWNsZWFyZml4Jztcblx0XG5cdCQuZXh0ZW5kKCBEYXRhVGFibGUuZXh0Lm9KVUlDbGFzc2VzLCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIHtcblx0XHQvKiBGdWxsIG51bWJlcnMgcGFnaW5nIGJ1dHRvbnMgKi9cblx0XHRcInNQYWdlQnV0dG9uXCI6ICAgICAgICAgXCJmZy1idXR0b24gdWktYnV0dG9uIFwiK19zdGF0ZURlZmF1bHQsXG5cdFx0XCJzUGFnZUJ1dHRvbkFjdGl2ZVwiOiAgIFwidWktc3RhdGUtZGlzYWJsZWRcIixcblx0XHRcInNQYWdlQnV0dG9uRGlzYWJsZWRcIjogXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiLFxuXHRcblx0XHQvKiBGZWF0dXJlcyAqL1xuXHRcdFwic1BhZ2luZ1wiOiBcImRhdGFUYWJsZXNfcGFnaW5hdGUgZmctYnV0dG9uc2V0IHVpLWJ1dHRvbnNldCBmZy1idXR0b25zZXQtbXVsdGkgXCIrXG5cdFx0XHRcInVpLWJ1dHRvbnNldC1tdWx0aSBwYWdpbmdfXCIsIC8qIE5vdGUgdGhhdCB0aGUgdHlwZSBpcyBwb3N0Zml4ZWQgKi9cblx0XG5cdFx0LyogU29ydGluZyAqL1xuXHRcdFwic1NvcnRBc2NcIjogICAgICAgICAgICBfc3RhdGVEZWZhdWx0K1wiIHNvcnRpbmdfYXNjXCIsXG5cdFx0XCJzU29ydERlc2NcIjogICAgICAgICAgIF9zdGF0ZURlZmF1bHQrXCIgc29ydGluZ19kZXNjXCIsXG5cdFx0XCJzU29ydGFibGVcIjogICAgICAgICAgIF9zdGF0ZURlZmF1bHQrXCIgc29ydGluZ1wiLFxuXHRcdFwic1NvcnRhYmxlQXNjXCI6ICAgICAgICBfc3RhdGVEZWZhdWx0K1wiIHNvcnRpbmdfYXNjX2Rpc2FibGVkXCIsXG5cdFx0XCJzU29ydGFibGVEZXNjXCI6ICAgICAgIF9zdGF0ZURlZmF1bHQrXCIgc29ydGluZ19kZXNjX2Rpc2FibGVkXCIsXG5cdFx0XCJzU29ydGFibGVOb25lXCI6ICAgICAgIF9zdGF0ZURlZmF1bHQrXCIgc29ydGluZ19kaXNhYmxlZFwiLFxuXHRcdFwic1NvcnRKVUlBc2NcIjogICAgICAgICBfc29ydEljb24rXCJ0cmlhbmdsZS0xLW5cIixcblx0XHRcInNTb3J0SlVJRGVzY1wiOiAgICAgICAgX3NvcnRJY29uK1widHJpYW5nbGUtMS1zXCIsXG5cdFx0XCJzU29ydEpVSVwiOiAgICAgICAgICAgIF9zb3J0SWNvbitcImNhcmF0LTItbi1zXCIsXG5cdFx0XCJzU29ydEpVSUFzY0FsbG93ZWRcIjogIF9zb3J0SWNvbitcImNhcmF0LTEtblwiLFxuXHRcdFwic1NvcnRKVUlEZXNjQWxsb3dlZFwiOiBfc29ydEljb24rXCJjYXJhdC0xLXNcIixcblx0XHRcInNTb3J0SlVJV3JhcHBlclwiOiAgICAgXCJEYXRhVGFibGVzX3NvcnRfd3JhcHBlclwiLFxuXHRcdFwic1NvcnRJY29uXCI6ICAgICAgICAgICBcIkRhdGFUYWJsZXNfc29ydF9pY29uXCIsXG5cdFxuXHRcdC8qIFNjcm9sbGluZyAqL1xuXHRcdFwic1Njcm9sbEhlYWRcIjogXCJkYXRhVGFibGVzX3Njcm9sbEhlYWQgXCIrX3N0YXRlRGVmYXVsdCxcblx0XHRcInNTY3JvbGxGb290XCI6IFwiZGF0YVRhYmxlc19zY3JvbGxGb290IFwiK19zdGF0ZURlZmF1bHQsXG5cdFxuXHRcdC8qIE1pc2MgKi9cblx0XHRcInNIZWFkZXJUSFwiOiAgX3N0YXRlRGVmYXVsdCxcblx0XHRcInNGb290ZXJUSFwiOiAgX3N0YXRlRGVmYXVsdCxcblx0XHRcInNKVUlIZWFkZXJcIjogX2hlYWRlckZvb3RlcitcIiB1aS1jb3JuZXItdGwgdWktY29ybmVyLXRyXCIsXG5cdFx0XCJzSlVJRm9vdGVyXCI6IF9oZWFkZXJGb290ZXIrXCIgdWktY29ybmVyLWJsIHVpLWNvcm5lci1iclwiXG5cdH0gKTtcblx0XG5cdH0oKSk7XG5cdFxuXHRcblx0XG5cdHZhciBleHRQYWdpbmF0aW9uID0gRGF0YVRhYmxlLmV4dC5wYWdlcjtcblx0XG5cdGZ1bmN0aW9uIF9udW1iZXJzICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0dmFyXG5cdFx0XHRudW1iZXJzID0gW10sXG5cdFx0XHRidXR0b25zID0gZXh0UGFnaW5hdGlvbi5udW1iZXJzX2xlbmd0aCxcblx0XHRcdGhhbGYgPSBNYXRoLmZsb29yKCBidXR0b25zIC8gMiApLFxuXHRcdFx0aSA9IDE7XG5cdFxuXHRcdGlmICggcGFnZXMgPD0gYnV0dG9ucyApIHtcblx0XHRcdG51bWJlcnMgPSBfcmFuZ2UoIDAsIHBhZ2VzICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBwYWdlIDw9IGhhbGYgKSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCAwLCBidXR0b25zLTIgKTtcblx0XHRcdG51bWJlcnMucHVzaCggJ2VsbGlwc2lzJyApO1xuXHRcdFx0bnVtYmVycy5wdXNoKCBwYWdlcy0xICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBwYWdlID49IHBhZ2VzIC0gMSAtIGhhbGYgKSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCBwYWdlcy0oYnV0dG9ucy0yKSwgcGFnZXMgKTtcblx0XHRcdG51bWJlcnMuc3BsaWNlKCAwLCAwLCAnZWxsaXBzaXMnICk7IC8vIG5vIHVuc2hpZnQgaW4gaWU2XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgMCApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG51bWJlcnMgPSBfcmFuZ2UoIHBhZ2UtaGFsZisyLCBwYWdlK2hhbGYtMSApO1xuXHRcdFx0bnVtYmVycy5wdXNoKCAnZWxsaXBzaXMnICk7XG5cdFx0XHRudW1iZXJzLnB1c2goIHBhZ2VzLTEgKTtcblx0XHRcdG51bWJlcnMuc3BsaWNlKCAwLCAwLCAnZWxsaXBzaXMnICk7XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgMCApO1xuXHRcdH1cblx0XG5cdFx0bnVtYmVycy5EVF9lbCA9ICdzcGFuJztcblx0XHRyZXR1cm4gbnVtYmVycztcblx0fVxuXHRcblx0XG5cdCQuZXh0ZW5kKCBleHRQYWdpbmF0aW9uLCB7XG5cdFx0c2ltcGxlOiBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdFx0cmV0dXJuIFsgJ3ByZXZpb3VzJywgJ25leHQnIF07XG5cdFx0fSxcblx0XG5cdFx0ZnVsbDogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICAnZmlyc3QnLCAncHJldmlvdXMnLCAnbmV4dCcsICdsYXN0JyBdO1xuXHRcdH0sXG5cdFxuXHRcdG51bWJlcnM6IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRyZXR1cm4gWyBfbnVtYmVycyhwYWdlLCBwYWdlcykgXTtcblx0XHR9LFxuXHRcblx0XHRzaW1wbGVfbnVtYmVyczogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICdwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnIF07XG5cdFx0fSxcblx0XG5cdFx0ZnVsbF9udW1iZXJzOiBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdFx0cmV0dXJuIFsgJ2ZpcnN0JywgJ3ByZXZpb3VzJywgX251bWJlcnMocGFnZSwgcGFnZXMpLCAnbmV4dCcsICdsYXN0JyBdO1xuXHRcdH0sXG5cdFx0XG5cdFx0Zmlyc3RfbGFzdF9udW1iZXJzOiBmdW5jdGlvbiAocGFnZSwgcGFnZXMpIHtcblx0IFx0XHRyZXR1cm4gWydmaXJzdCcsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ2xhc3QnXTtcblx0IFx0fSxcblx0XG5cdFx0Ly8gRm9yIHRlc3RpbmcgYW5kIHBsdWctaW5zIHRvIHVzZVxuXHRcdF9udW1iZXJzOiBfbnVtYmVycyxcblx0XG5cdFx0Ly8gTnVtYmVyIG9mIG51bWJlciBidXR0b25zIChpbmNsdWRpbmcgZWxsaXBzaXMpIHRvIHNob3cuIF9NdXN0IGJlIG9kZCFfXG5cdFx0bnVtYmVyc19sZW5ndGg6IDdcblx0fSApO1xuXHRcblx0XG5cdCQuZXh0ZW5kKCB0cnVlLCBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLCB7XG5cdFx0cGFnZUJ1dHRvbjoge1xuXHRcdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9zdCwgaWR4LCBidXR0b25zLCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdFx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHRcdFx0dmFyIGxhbmcgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub1BhZ2luYXRlO1xuXHRcdFx0XHR2YXIgYXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYS5wYWdpbmF0ZSB8fCB7fTtcblx0XHRcdFx0dmFyIGJ0bkRpc3BsYXksIGJ0bkNsYXNzLCBjb3VudGVyPTA7XG5cdFxuXHRcdFx0XHR2YXIgYXR0YWNoID0gZnVuY3Rpb24oIGNvbnRhaW5lciwgYnV0dG9ucyApIHtcblx0XHRcdFx0XHR2YXIgaSwgaWVuLCBub2RlLCBidXR0b247XG5cdFx0XHRcdFx0dmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uICggZSApIHtcblx0XHRcdFx0XHRcdF9mblBhZ2VDaGFuZ2UoIHNldHRpbmdzLCBlLmRhdGEuYWN0aW9uLCB0cnVlICk7XG5cdFx0XHRcdFx0fTtcblx0XG5cdFx0XHRcdFx0Zm9yICggaT0wLCBpZW49YnV0dG9ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRcdGJ1dHRvbiA9IGJ1dHRvbnNbaV07XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCAkLmlzQXJyYXkoIGJ1dHRvbiApICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaW5uZXIgPSAkKCAnPCcrKGJ1dHRvbi5EVF9lbCB8fCAnZGl2JykrJy8+JyApXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFRvKCBjb250YWluZXIgKTtcblx0XHRcdFx0XHRcdFx0YXR0YWNoKCBpbm5lciwgYnV0dG9uICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gJyc7XG5cdFxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCBidXR0b24gKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnZWxsaXBzaXMnOlxuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJlbGxpcHNpc1wiPiYjeDIwMjY7PC9zcGFuPicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2ZpcnN0Jzpcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNGaXJzdDtcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPiAwID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0JycgOiAnICcrY2xhc3Nlcy5zUGFnZUJ1dHRvbkRpc2FibGVkKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdwcmV2aW91cyc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zUHJldmlvdXM7XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlID4gMCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCcnIDogJyAnK2NsYXNzZXMuc1BhZ2VCdXR0b25EaXNhYmxlZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbmV4dCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zTmV4dDtcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPCBwYWdlcy0xID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0JycgOiAnICcrY2xhc3Nlcy5zUGFnZUJ1dHRvbkRpc2FibGVkKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdsYXN0Jzpcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNMYXN0O1xuXHRcdFx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBidXR0b24gKyAocGFnZSA8IHBhZ2VzLTEgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQnJyA6ICcgJytjbGFzc2VzLnNQYWdlQnV0dG9uRGlzYWJsZWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gYnV0dG9uICsgMTtcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gcGFnZSA9PT0gYnV0dG9uID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zUGFnZUJ1dHRvbkFjdGl2ZSA6ICcnO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRcdGlmICggYnRuRGlzcGxheSAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gJCgnPGE+Jywge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQnY2xhc3MnOiBjbGFzc2VzLnNQYWdlQnV0dG9uKycgJytidG5DbGFzcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2FyaWEtY29udHJvbHMnOiBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2FyaWEtbGFiZWwnOiBhcmlhWyBidXR0b24gXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2RhdGEtZHQtaWR4JzogY291bnRlcixcblx0XHRcdFx0XHRcdFx0XHRcdFx0J3RhYmluZGV4Jzogc2V0dGluZ3MuaVRhYkluZGV4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnaWQnOiBpZHggPT09IDAgJiYgdHlwZW9mIGJ1dHRvbiA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzLnNUYWJsZUlkICsnXycrIGJ1dHRvbiA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHRcdFx0XHQuaHRtbCggYnRuRGlzcGxheSApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oIGNvbnRhaW5lciApO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRfZm5CaW5kQWN0aW9uKFxuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZSwge2FjdGlvbjogYnV0dG9ufSwgY2xpY2tIYW5kbGVyXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y291bnRlcisrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcblx0XHRcdFx0Ly8gSUU5IHRocm93cyBhbiAndW5rbm93biBlcnJvcicgaWYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpcyB1c2VkXG5cdFx0XHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3IgZnJhbWUuIFRyeSAvIGNhdGNoIHRoZSBlcnJvci4gTm90IGdvb2QgZm9yXG5cdFx0XHRcdC8vIGFjY2Vzc2liaWxpdHksIGJ1dCBuZWl0aGVyIGFyZSBmcmFtZXMuXG5cdFx0XHRcdHZhciBhY3RpdmVFbDtcblx0XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gQmVjYXVzZSB0aGlzIGFwcHJvYWNoIGlzIGRlc3Ryb3lpbmcgYW5kIHJlY3JlYXRpbmcgdGhlIHBhZ2luZ1xuXHRcdFx0XHRcdC8vIGVsZW1lbnRzLCBmb2N1cyBpcyBsb3N0IG9uIHRoZSBzZWxlY3QgYnV0dG9uIHdoaWNoIGlzIGJhZCBmb3Jcblx0XHRcdFx0XHQvLyBhY2Nlc3NpYmlsaXR5LiBTbyB3ZSB3YW50IHRvIHJlc3RvcmUgZm9jdXMgb25jZSB0aGUgZHJhdyBoYXNcblx0XHRcdFx0XHQvLyBjb21wbGV0ZWRcblx0XHRcdFx0XHRhY3RpdmVFbCA9ICQoaG9zdCkuZmluZChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5kYXRhKCdkdC1pZHgnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge31cblx0XG5cdFx0XHRcdGF0dGFjaCggJChob3N0KS5lbXB0eSgpLCBidXR0b25zICk7XG5cdFxuXHRcdFx0XHRpZiAoIGFjdGl2ZUVsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0JChob3N0KS5maW5kKCAnW2RhdGEtZHQtaWR4PScrYWN0aXZlRWwrJ10nICkuZm9jdXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXHRcblx0XG5cdFxuXHQvLyBCdWlsdCBpbiB0eXBlIGRldGVjdGlvbi4gU2VlIG1vZGVsLmV4dC5hVHlwZXMgZm9yIGluZm9ybWF0aW9uIGFib3V0XG5cdC8vIHdoYXQgaXMgcmVxdWlyZWQgZnJvbSB0aGlzIG1ldGhvZHMuXG5cdCQuZXh0ZW5kKCBEYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0LCBbXG5cdFx0Ly8gUGxhaW4gbnVtYmVycyAtIGZpcnN0IHNpbmNlIFY4IGRldGVjdHMgc29tZSBwbGFpbiBudW1iZXJzIGFzIGRhdGVzXG5cdFx0Ly8gZS5nLiBEYXRlLnBhcnNlKCc1NScpIChidXQgbm90IGFsbCwgZS5nLiBEYXRlLnBhcnNlKCcyMicpLi4uKS5cblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaXNOdW1iZXIoIGQsIGRlY2ltYWwgKSA/ICdudW0nK2RlY2ltYWwgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIERhdGVzIChvbmx5IHRob3NlIHJlY29nbmlzZWQgYnkgdGhlIGJyb3dzZXIncyBEYXRlLnBhcnNlKVxuXHRcdGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKVxuXHRcdHtcblx0XHRcdC8vIFY4IHRyaWVzIF92ZXJ5XyBoYXJkIHRvIG1ha2UgYSBzdHJpbmcgcGFzc2VkIGludG8gYERhdGUucGFyc2UoKWBcblx0XHRcdC8vIHZhbGlkLCBzbyB3ZSBuZWVkIHRvIHVzZSBhIHJlZ2V4IHRvIHJlc3RyaWN0IGRhdGUgZm9ybWF0cy4gVXNlIGFcblx0XHRcdC8vIHBsdWctaW4gZm9yIGFueXRoaW5nIG90aGVyIHRoYW4gSVNPODYwMSBzdHlsZSBzdHJpbmdzXG5cdFx0XHRpZiAoIGQgJiYgIShkIGluc3RhbmNlb2YgRGF0ZSkgJiYgISBfcmVfZGF0ZS50ZXN0KGQpICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJzZWQgPSBEYXRlLnBhcnNlKGQpO1xuXHRcdFx0cmV0dXJuIChwYXJzZWQgIT09IG51bGwgJiYgIWlzTmFOKHBhcnNlZCkpIHx8IF9lbXB0eShkKSA/ICdkYXRlJyA6IG51bGw7XG5cdFx0fSxcblx0XG5cdFx0Ly8gRm9ybWF0dGVkIG51bWJlcnNcblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaXNOdW1iZXIoIGQsIGRlY2ltYWwsIHRydWUgKSA/ICdudW0tZm10JytkZWNpbWFsIDogbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvLyBIVE1MIG51bWVyaWNcblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaHRtbE51bWVyaWMoIGQsIGRlY2ltYWwgKSA/ICdodG1sLW51bScrZGVjaW1hbCA6IG51bGw7XG5cdFx0fSxcblx0XG5cdFx0Ly8gSFRNTCBudW1lcmljLCBmb3JtYXR0ZWRcblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaHRtbE51bWVyaWMoIGQsIGRlY2ltYWwsIHRydWUgKSA/ICdodG1sLW51bS1mbXQnK2RlY2ltYWwgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEhUTUwgKHRoaXMgaXMgc3RyaWN0IGNoZWNraW5nIC0gdGhlcmUgbXVzdCBiZSBodG1sKVxuXHRcdGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZW1wdHkoIGQgKSB8fCAodHlwZW9mIGQgPT09ICdzdHJpbmcnICYmIGQuaW5kZXhPZignPCcpICE9PSAtMSkgP1xuXHRcdFx0XHQnaHRtbCcgOiBudWxsO1xuXHRcdH1cblx0XSApO1xuXHRcblx0XG5cdFxuXHQvLyBGaWx0ZXIgZm9ybWF0dGluZyBmdW5jdGlvbnMuIFNlZSBtb2RlbC5leHQub2ZuU2VhcmNoIGZvciBpbmZvcm1hdGlvbiBhYm91dFxuXHQvLyB3aGF0IGlzIHJlcXVpcmVkIGZyb20gdGhlc2UgbWV0aG9kcy5cblx0Ly8gXG5cdC8vIE5vdGUgdGhhdCBhZGRpdGlvbmFsIHNlYXJjaCBtZXRob2RzIGFyZSBhZGRlZCBmb3IgdGhlIGh0bWwgbnVtYmVycyBhbmRcblx0Ly8gaHRtbCBmb3JtYXR0ZWQgbnVtYmVycyBieSBgX2FkZE51bWVyaWNTb3J0KClgIHdoZW4gd2Uga25vdyB3aGF0IHRoZSBkZWNpbWFsXG5cdC8vIHBsYWNlIGlzXG5cdFxuXHRcblx0JC5leHRlbmQoIERhdGFUYWJsZS5leHQudHlwZS5zZWFyY2gsIHtcblx0XHRodG1sOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gX2VtcHR5KGRhdGEpID9cblx0XHRcdFx0ZGF0YSA6XG5cdFx0XHRcdHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdFx0ZGF0YVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoIF9yZV9uZXdfbGluZXMsIFwiIFwiIClcblx0XHRcdFx0XHRcdC5yZXBsYWNlKCBfcmVfaHRtbCwgXCJcIiApIDpcblx0XHRcdFx0XHQnJztcblx0XHR9LFxuXHRcblx0XHRzdHJpbmc6IGZ1bmN0aW9uICggZGF0YSApIHtcblx0XHRcdHJldHVybiBfZW1wdHkoZGF0YSkgP1xuXHRcdFx0XHRkYXRhIDpcblx0XHRcdFx0dHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRkYXRhLnJlcGxhY2UoIF9yZV9uZXdfbGluZXMsIFwiIFwiICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0fVxuXHR9ICk7XG5cdFxuXHRcblx0XG5cdHZhciBfX251bWVyaWNSZXBsYWNlID0gZnVuY3Rpb24gKCBkLCBkZWNpbWFsUGxhY2UsIHJlMSwgcmUyICkge1xuXHRcdGlmICggZCAhPT0gMCAmJiAoIWQgfHwgZCA9PT0gJy0nKSApIHtcblx0XHRcdHJldHVybiAtSW5maW5pdHk7XG5cdFx0fVxuXHRcblx0XHQvLyBJZiBhIGRlY2ltYWwgcGxhY2Ugb3RoZXIgdGhhbiBgLmAgaXMgdXNlZCwgaXQgbmVlZHMgdG8gYmUgZ2l2ZW4gdG8gdGhlXG5cdFx0Ly8gZnVuY3Rpb24gc28gd2UgY2FuIGRldGVjdCBpdCBhbmQgcmVwbGFjZSB3aXRoIGEgYC5gIHdoaWNoIGlzIHRoZSBvbmx5XG5cdFx0Ly8gZGVjaW1hbCBwbGFjZSBKYXZhc2NyaXB0IHJlY29nbmlzZXMgLSBpdCBpcyBub3QgbG9jYWxlIGF3YXJlLlxuXHRcdGlmICggZGVjaW1hbFBsYWNlICkge1xuXHRcdFx0ZCA9IF9udW1Ub0RlY2ltYWwoIGQsIGRlY2ltYWxQbGFjZSApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBkLnJlcGxhY2UgKSB7XG5cdFx0XHRpZiAoIHJlMSApIHtcblx0XHRcdFx0ZCA9IGQucmVwbGFjZSggcmUxLCAnJyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggcmUyICkge1xuXHRcdFx0XHRkID0gZC5yZXBsYWNlKCByZTIsICcnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gZCAqIDE7XG5cdH07XG5cdFxuXHRcblx0Ly8gQWRkIHRoZSBudW1lcmljICdkZWZvcm1hdHRpbmcnIGZ1bmN0aW9ucyBmb3Igc29ydGluZyBhbmQgc2VhcmNoLiBUaGlzIGlzIGRvbmVcblx0Ly8gaW4gYSBmdW5jdGlvbiB0byBwcm92aWRlIGFuIGVhc3kgYWJpbGl0eSBmb3IgdGhlIGxhbmd1YWdlIG9wdGlvbnMgdG8gYWRkXG5cdC8vIGFkZGl0aW9uYWwgbWV0aG9kcyBpZiBhIG5vbi1wZXJpb2QgZGVjaW1hbCBwbGFjZSBpcyB1c2VkLlxuXHRmdW5jdGlvbiBfYWRkTnVtZXJpY1NvcnQgKCBkZWNpbWFsUGxhY2UgKSB7XG5cdFx0JC5lYWNoKFxuXHRcdFx0e1xuXHRcdFx0XHQvLyBQbGFpbiBudW1iZXJzXG5cdFx0XHRcdFwibnVtXCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlICk7XG5cdFx0XHRcdH0sXG5cdFxuXHRcdFx0XHQvLyBGb3JtYXR0ZWQgbnVtYmVyc1xuXHRcdFx0XHRcIm51bS1mbXRcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiBfX251bWVyaWNSZXBsYWNlKCBkLCBkZWNpbWFsUGxhY2UsIF9yZV9mb3JtYXR0ZWRfbnVtZXJpYyApO1xuXHRcdFx0XHR9LFxuXHRcblx0XHRcdFx0Ly8gSFRNTCBudW1lcmljXG5cdFx0XHRcdFwiaHRtbC1udW1cIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiBfX251bWVyaWNSZXBsYWNlKCBkLCBkZWNpbWFsUGxhY2UsIF9yZV9odG1sICk7XG5cdFx0XHRcdH0sXG5cdFxuXHRcdFx0XHQvLyBIVE1MIG51bWVyaWMsIGZvcm1hdHRlZFxuXHRcdFx0XHRcImh0bWwtbnVtLWZtdFwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRlY2ltYWxQbGFjZSwgX3JlX2h0bWwsIF9yZV9mb3JtYXR0ZWRfbnVtZXJpYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZnVuY3Rpb24gKCBrZXksIGZuICkge1xuXHRcdFx0XHQvLyBBZGQgdGhlIG9yZGVyaW5nIG1ldGhvZFxuXHRcdFx0XHRfZXh0LnR5cGUub3JkZXJbIGtleStkZWNpbWFsUGxhY2UrJy1wcmUnIF0gPSBmbjtcblx0XG5cdFx0XHRcdC8vIEZvciBIVE1MIHR5cGVzIGFkZCBhIHNlYXJjaCBmb3JtYXR0ZXIgdGhhdCB3aWxsIHN0cmlwIHRoZSBIVE1MXG5cdFx0XHRcdGlmICgga2V5Lm1hdGNoKC9eaHRtbFxcLS8pICkge1xuXHRcdFx0XHRcdF9leHQudHlwZS5zZWFyY2hbIGtleStkZWNpbWFsUGxhY2UgXSA9IF9leHQudHlwZS5zZWFyY2guaHRtbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblx0XG5cdFxuXHQvLyBEZWZhdWx0IHNvcnQgbWV0aG9kc1xuXHQkLmV4dGVuZCggX2V4dC50eXBlLm9yZGVyLCB7XG5cdFx0Ly8gRGF0ZXNcblx0XHRcImRhdGUtcHJlXCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdHJldHVybiBEYXRlLnBhcnNlKCBkICkgfHwgLUluZmluaXR5O1xuXHRcdH0sXG5cdFxuXHRcdC8vIGh0bWxcblx0XHRcImh0bWwtcHJlXCI6IGZ1bmN0aW9uICggYSApIHtcblx0XHRcdHJldHVybiBfZW1wdHkoYSkgP1xuXHRcdFx0XHQnJyA6XG5cdFx0XHRcdGEucmVwbGFjZSA/XG5cdFx0XHRcdFx0YS5yZXBsYWNlKCAvPC4qPz4vZywgXCJcIiApLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdGErJyc7XG5cdFx0fSxcblx0XG5cdFx0Ly8gc3RyaW5nXG5cdFx0XCJzdHJpbmctcHJlXCI6IGZ1bmN0aW9uICggYSApIHtcblx0XHRcdC8vIFRoaXMgaXMgYSBsaXR0bGUgY29tcGxleCwgYnV0IGZhc3RlciB0aGFuIGFsd2F5cyBjYWxsaW5nIHRvU3RyaW5nLFxuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdG9zdHJpbmctdi1jaGVja1xuXHRcdFx0cmV0dXJuIF9lbXB0eShhKSA/XG5cdFx0XHRcdCcnIDpcblx0XHRcdFx0dHlwZW9mIGEgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRhLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCEgYS50b1N0cmluZyA/XG5cdFx0XHRcdFx0XHQnJyA6XG5cdFx0XHRcdFx0XHRhLnRvU3RyaW5nKCk7XG5cdFx0fSxcblx0XG5cdFx0Ly8gc3RyaW5nLWFzYyBhbmQgLWRlc2MgYXJlIHJldGFpbmVkIG9ubHkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgb2xkXG5cdFx0Ly8gc29ydCBtZXRob2RzXG5cdFx0XCJzdHJpbmctYXNjXCI6IGZ1bmN0aW9uICggeCwgeSApIHtcblx0XHRcdHJldHVybiAoKHggPCB5KSA/IC0xIDogKCh4ID4geSkgPyAxIDogMCkpO1xuXHRcdH0sXG5cdFxuXHRcdFwic3RyaW5nLWRlc2NcIjogZnVuY3Rpb24gKCB4LCB5ICkge1xuXHRcdFx0cmV0dXJuICgoeCA8IHkpID8gMSA6ICgoeCA+IHkpID8gLTEgOiAwKSk7XG5cdFx0fVxuXHR9ICk7XG5cdFxuXHRcblx0Ly8gTnVtZXJpYyBzb3J0aW5nIHR5cGVzIC0gb3JkZXIgZG9lc24ndCBtYXR0ZXIgaGVyZVxuXHRfYWRkTnVtZXJpY1NvcnQoICcnICk7XG5cdFxuXHRcblx0JC5leHRlbmQoIHRydWUsIERhdGFUYWJsZS5leHQucmVuZGVyZXIsIHtcblx0XHRoZWFkZXI6IHtcblx0XHRcdF86IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNlbGwsIGNvbHVtbiwgY2xhc3NlcyApIHtcblx0XHRcdFx0Ly8gTm8gYWRkaXRpb25hbCBtYXJrLXVwIHJlcXVpcmVkXG5cdFx0XHRcdC8vIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gdXBkYXRlIG9uIHNvcnQgLSBub3RlIHRoYXQgdXNpbmcgdGhlXG5cdFx0XHRcdC8vIGBEVGAgbmFtZXNwYWNlIHdpbGwgYWxsb3cgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWQgYXV0b21hdGljYWxseVxuXHRcdFx0XHQvLyBvbiBkZXN0cm95LCB3aGlsZSB0aGUgYGR0YCBuYW1lc3BhY2VkIGV2ZW50IGlzIHRoZSBvbmUgd2UgYXJlXG5cdFx0XHRcdC8vIGxpc3RlbmluZyBmb3Jcblx0XHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnb3JkZXIuZHQuRFQnLCBmdW5jdGlvbiAoIGUsIGN0eCwgc29ydGluZywgY29sdW1ucyApIHtcblx0XHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7IC8vIG5lZWQgdG8gY2hlY2sgdGhpcyB0aGlzIGlzIHRoZSBob3N0XG5cdFx0XHRcdFx0XHRyZXR1cm47ICAgICAgICAgICAgICAgLy8gdGFibGUsIG5vdCBhIG5lc3RlZCBvbmVcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHZhciBjb2xJZHggPSBjb2x1bW4uaWR4O1xuXHRcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdFx0XHRcdGNvbHVtbi5zU29ydGluZ0NsYXNzICsnICcrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRBc2MgKycgJytcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydERlc2Ncblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyggY29sdW1uc1sgY29sSWR4IF0gPT0gJ2FzYycgP1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0QXNjIDogY29sdW1uc1sgY29sSWR4IF0gPT0gJ2Rlc2MnID9cblx0XHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzYyA6XG5cdFx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3Ncblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sXG5cdFxuXHRcdFx0anF1ZXJ5dWk6IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNlbGwsIGNvbHVtbiwgY2xhc3NlcyApIHtcblx0XHRcdFx0JCgnPGRpdi8+Jylcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNsYXNzZXMuc1NvcnRKVUlXcmFwcGVyIClcblx0XHRcdFx0XHQuYXBwZW5kKCBjZWxsLmNvbnRlbnRzKCkgKVxuXHRcdFx0XHRcdC5hcHBlbmQoICQoJzxzcGFuLz4nKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBjbGFzc2VzLnNTb3J0SWNvbisnICcrY29sdW1uLnNTb3J0aW5nQ2xhc3NKVUkgKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYXBwZW5kVG8oIGNlbGwgKTtcblx0XG5cdFx0XHRcdC8vIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gdXBkYXRlIG9uIHNvcnRcblx0XHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnb3JkZXIuZHQuRFQnLCBmdW5jdGlvbiAoIGUsIGN0eCwgc29ydGluZywgY29sdW1ucyApIHtcblx0XHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHR2YXIgY29sSWR4ID0gY29sdW1uLmlkeDtcblx0XG5cdFx0XHRcdFx0Y2VsbFxuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjbGFzc2VzLnNTb3J0QXNjICtcIiBcIitjbGFzc2VzLnNTb3J0RGVzYyApXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNvbHVtbnNbIGNvbElkeCBdID09ICdhc2MnID9cblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEFzYyA6IGNvbHVtbnNbIGNvbElkeCBdID09ICdkZXNjJyA/XG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydERlc2MgOlxuXHRcdFx0XHRcdFx0XHRcdGNvbHVtbi5zU29ydGluZ0NsYXNzXG5cdFx0XHRcdFx0XHQpO1xuXHRcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQuZmluZCggJ3NwYW4uJytjbGFzc2VzLnNTb3J0SWNvbiApXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlBc2MgK1wiIFwiK1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0SlVJRGVzYyArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUkgK1wiIFwiK1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZCArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlEZXNjQWxsb3dlZFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBjb2x1bW5zWyBjb2xJZHggXSA9PSAnYXNjJyA/XG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlBc2MgOiBjb2x1bW5zWyBjb2xJZHggXSA9PSAnZGVzYycgP1xuXHRcdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlEZXNjIDpcblx0XHRcdFx0XHRcdFx0XHRjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXHRcblx0Lypcblx0ICogUHVibGljIGhlbHBlciBmdW5jdGlvbnMuIFRoZXNlIGFyZW4ndCB1c2VkIGludGVybmFsbHkgYnkgRGF0YVRhYmxlcywgb3Jcblx0ICogY2FsbGVkIGJ5IGFueSBvZiB0aGUgb3B0aW9ucyBwYXNzZWQgaW50byBEYXRhVGFibGVzLCBidXQgdGhleSBjYW4gYmUgdXNlZFxuXHQgKiBleHRlcm5hbGx5IGJ5IGRldmVsb3BlcnMgd29ya2luZyB3aXRoIERhdGFUYWJsZXMuIFRoZXkgYXJlIGhlbHBlciBmdW5jdGlvbnNcblx0ICogdG8gbWFrZSB3b3JraW5nIHdpdGggRGF0YVRhYmxlcyBhIGxpdHRsZSBiaXQgZWFzaWVyLlxuXHQgKi9cblx0XG5cdHZhciBfX2h0bWxFc2NhcGVFbnRpdGllcyA9IGZ1bmN0aW9uICggZCApIHtcblx0XHRyZXR1cm4gdHlwZW9mIGQgPT09ICdzdHJpbmcnID9cblx0XHRcdGQucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykgOlxuXHRcdFx0ZDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBIZWxwZXJzIGZvciBgY29sdW1ucy5yZW5kZXJgLlxuXHQgKlxuXHQgKiBUaGUgb3B0aW9ucyBkZWZpbmVkIGhlcmUgY2FuIGJlIHVzZWQgd2l0aCB0aGUgYGNvbHVtbnMucmVuZGVyYCBpbml0aWFsaXNhdGlvblxuXHQgKiBvcHRpb24gdG8gcHJvdmlkZSBhIGRpc3BsYXkgcmVuZGVyZXIuIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSBkZWZpbmVkOlxuXHQgKlxuXHQgKiAqIGBudW1iZXJgIC0gV2lsbCBmb3JtYXQgbnVtZXJpYyBkYXRhIChkZWZpbmVkIGJ5IGBjb2x1bW5zLmRhdGFgKSBmb3Jcblx0ICogICBkaXNwbGF5LCByZXRhaW5pbmcgdGhlIG9yaWdpbmFsIHVuZm9ybWF0dGVkIGRhdGEgZm9yIHNvcnRpbmcgYW5kIGZpbHRlcmluZy5cblx0ICogICBJdCB0YWtlcyA1IHBhcmFtZXRlcnM6XG5cdCAqICAgKiBgc3RyaW5nYCAtIFRob3VzYW5kcyBncm91cGluZyBzZXBhcmF0b3Jcblx0ICogICAqIGBzdHJpbmdgIC0gRGVjaW1hbCBwb2ludCBpbmRpY2F0b3Jcblx0ICogICAqIGBpbnRlZ2VyYCAtIE51bWJlciBvZiBkZWNpbWFsIHBvaW50cyB0byBzaG93XG5cdCAqICAgKiBgc3RyaW5nYCAob3B0aW9uYWwpIC0gUHJlZml4LlxuXHQgKiAgICogYHN0cmluZ2AgKG9wdGlvbmFsKSAtIFBvc3RmaXggKC9zdWZmaXgpLlxuXHQgKiAqIGB0ZXh0YCAtIEVzY2FwZSBIVE1MIHRvIGhlbHAgcHJldmVudCBYU1MgYXR0YWNrcy4gSXQgaGFzIG5vIG9wdGlvbmFsXG5cdCAqICAgcGFyYW1ldGVycy5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICAvLyBDb2x1bW4gZGVmaW5pdGlvbiB1c2luZyB0aGUgbnVtYmVyIHJlbmRlcmVyXG5cdCAqICAge1xuXHQgKiAgICAgZGF0YTogXCJzYWxhcnlcIixcblx0ICogICAgIHJlbmRlcjogJC5mbi5kYXRhVGFibGUucmVuZGVyLm51bWJlciggJ1xcJycsICcuJywgMCwgJyQnIClcblx0ICogICB9XG5cdCAqXG5cdCAqIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5yZW5kZXIgPSB7XG5cdFx0bnVtYmVyOiBmdW5jdGlvbiAoIHRob3VzYW5kcywgZGVjaW1hbCwgcHJlY2lzaW9uLCBwcmVmaXgsIHBvc3RmaXggKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkaXNwbGF5OiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgZCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGQgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHR2YXIgbmVnYXRpdmUgPSBkIDwgMCA/ICctJyA6ICcnO1xuXHRcdFx0XHRcdHZhciBmbG8gPSBwYXJzZUZsb2F0KCBkICk7XG5cdFxuXHRcdFx0XHRcdC8vIElmIE5hTiB0aGVuIHRoZXJlIGlzbid0IG11Y2ggZm9ybWF0dGluZyB0aGF0IHdlIGNhbiBkbyAtIGp1c3Rcblx0XHRcdFx0XHQvLyByZXR1cm4gaW1tZWRpYXRlbHksIGVzY2FwaW5nIGFueSBIVE1MICh0aGlzIHdhcyBzdXBwb3NlZCB0b1xuXHRcdFx0XHRcdC8vIGJlIGEgbnVtYmVyIGFmdGVyIGFsbClcblx0XHRcdFx0XHRpZiAoIGlzTmFOKCBmbG8gKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBfX2h0bWxFc2NhcGVFbnRpdGllcyggZCApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0ZmxvID0gZmxvLnRvRml4ZWQoIHByZWNpc2lvbiApO1xuXHRcdFx0XHRcdGQgPSBNYXRoLmFicyggZmxvICk7XG5cdFxuXHRcdFx0XHRcdHZhciBpbnRQYXJ0ID0gcGFyc2VJbnQoIGQsIDEwICk7XG5cdFx0XHRcdFx0dmFyIGZsb2F0UGFydCA9IHByZWNpc2lvbiA/XG5cdFx0XHRcdFx0XHRkZWNpbWFsKyhkIC0gaW50UGFydCkudG9GaXhlZCggcHJlY2lzaW9uICkuc3Vic3RyaW5nKCAyICk6XG5cdFx0XHRcdFx0XHQnJztcblx0XG5cdFx0XHRcdFx0cmV0dXJuIG5lZ2F0aXZlICsgKHByZWZpeHx8JycpICtcblx0XHRcdFx0XHRcdGludFBhcnQudG9TdHJpbmcoKS5yZXBsYWNlKFxuXHRcdFx0XHRcdFx0XHQvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgdGhvdXNhbmRzXG5cdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0XHRcdGZsb2F0UGFydCArXG5cdFx0XHRcdFx0XHQocG9zdGZpeHx8JycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFxuXHRcdHRleHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRpc3BsYXk6IF9faHRtbEVzY2FwZUVudGl0aWVzXG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvKlxuXHQgKiBUaGlzIGlzIHJlYWxseSBhIGdvb2QgYml0IHJ1YmJpc2ggdGhpcyBtZXRob2Qgb2YgZXhwb3NpbmcgdGhlIGludGVybmFsIG1ldGhvZHNcblx0ICogcHVibGljbHkuLi4gLSBUbyBiZSBmaXhlZCBpbiAyLjAgdXNpbmcgbWV0aG9kcyBvbiB0aGUgcHJvdG90eXBlXG5cdCAqL1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSB3cmFwcGVyIGZ1bmN0aW9uIGZvciBleHBvcnRpbmcgYW4gaW50ZXJuYWwgZnVuY3Rpb25zIHRvIGFuIGV4dGVybmFsIEFQSS5cblx0ICogIEBwYXJhbSB7c3RyaW5nfSBmbiBBUEkgZnVuY3Rpb24gbmFtZVxuXHQgKiAgQHJldHVybnMge2Z1bmN0aW9ufSB3cmFwcGVkIGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI2ludGVybmFsXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5FeHRlcm5BcGlGdW5jIChmbilcblx0e1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gW19mblNldHRpbmdzRnJvbU5vZGUoIHRoaXNbRGF0YVRhYmxlLmV4dC5pQXBpSW5kZXhdICldLmNvbmNhdChcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuXHRcdFx0KTtcblx0XHRcdHJldHVybiBEYXRhVGFibGUuZXh0LmludGVybmFsW2ZuXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdH07XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmVmZXJlbmNlIHRvIGludGVybmFsIGZ1bmN0aW9ucyBmb3IgdXNlIGJ5IHBsdWctaW4gZGV2ZWxvcGVycy4gTm90ZSB0aGF0XG5cdCAqIHRoZXNlIG1ldGhvZHMgYXJlIHJlZmVyZW5jZXMgdG8gaW50ZXJuYWwgZnVuY3Rpb25zIGFuZCBhcmUgY29uc2lkZXJlZCB0byBiZVxuXHQgKiBwcml2YXRlLiBJZiB5b3UgdXNlIHRoZXNlIG1ldGhvZHMsIGJlIGF3YXJlIHRoYXQgdGhleSBhcmUgbGlhYmxlIHRvIGNoYW5nZVxuXHQgKiBiZXR3ZWVuIHZlcnNpb25zLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0JC5leHRlbmQoIERhdGFUYWJsZS5leHQuaW50ZXJuYWwsIHtcblx0XHRfZm5FeHRlcm5BcGlGdW5jOiBfZm5FeHRlcm5BcGlGdW5jLFxuXHRcdF9mbkJ1aWxkQWpheDogX2ZuQnVpbGRBamF4LFxuXHRcdF9mbkFqYXhVcGRhdGU6IF9mbkFqYXhVcGRhdGUsXG5cdFx0X2ZuQWpheFBhcmFtZXRlcnM6IF9mbkFqYXhQYXJhbWV0ZXJzLFxuXHRcdF9mbkFqYXhVcGRhdGVEcmF3OiBfZm5BamF4VXBkYXRlRHJhdyxcblx0XHRfZm5BamF4RGF0YVNyYzogX2ZuQWpheERhdGFTcmMsXG5cdFx0X2ZuQWRkQ29sdW1uOiBfZm5BZGRDb2x1bW4sXG5cdFx0X2ZuQ29sdW1uT3B0aW9uczogX2ZuQ29sdW1uT3B0aW9ucyxcblx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmc6IF9mbkFkanVzdENvbHVtblNpemluZyxcblx0XHRfZm5WaXNpYmxlVG9Db2x1bW5JbmRleDogX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgsXG5cdFx0X2ZuQ29sdW1uSW5kZXhUb1Zpc2libGU6IF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlLFxuXHRcdF9mblZpc2JsZUNvbHVtbnM6IF9mblZpc2JsZUNvbHVtbnMsXG5cdFx0X2ZuR2V0Q29sdW1uczogX2ZuR2V0Q29sdW1ucyxcblx0XHRfZm5Db2x1bW5UeXBlczogX2ZuQ29sdW1uVHlwZXMsXG5cdFx0X2ZuQXBwbHlDb2x1bW5EZWZzOiBfZm5BcHBseUNvbHVtbkRlZnMsXG5cdFx0X2ZuSHVuZ2FyaWFuTWFwOiBfZm5IdW5nYXJpYW5NYXAsXG5cdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbjogX2ZuQ2FtZWxUb0h1bmdhcmlhbixcblx0XHRfZm5MYW5ndWFnZUNvbXBhdDogX2ZuTGFuZ3VhZ2VDb21wYXQsXG5cdFx0X2ZuQnJvd3NlckRldGVjdDogX2ZuQnJvd3NlckRldGVjdCxcblx0XHRfZm5BZGREYXRhOiBfZm5BZGREYXRhLFxuXHRcdF9mbkFkZFRyOiBfZm5BZGRUcixcblx0XHRfZm5Ob2RlVG9EYXRhSW5kZXg6IF9mbk5vZGVUb0RhdGFJbmRleCxcblx0XHRfZm5Ob2RlVG9Db2x1bW5JbmRleDogX2ZuTm9kZVRvQ29sdW1uSW5kZXgsXG5cdFx0X2ZuR2V0Q2VsbERhdGE6IF9mbkdldENlbGxEYXRhLFxuXHRcdF9mblNldENlbGxEYXRhOiBfZm5TZXRDZWxsRGF0YSxcblx0XHRfZm5TcGxpdE9iak5vdGF0aW9uOiBfZm5TcGxpdE9iak5vdGF0aW9uLFxuXHRcdF9mbkdldE9iamVjdERhdGFGbjogX2ZuR2V0T2JqZWN0RGF0YUZuLFxuXHRcdF9mblNldE9iamVjdERhdGFGbjogX2ZuU2V0T2JqZWN0RGF0YUZuLFxuXHRcdF9mbkdldERhdGFNYXN0ZXI6IF9mbkdldERhdGFNYXN0ZXIsXG5cdFx0X2ZuQ2xlYXJUYWJsZTogX2ZuQ2xlYXJUYWJsZSxcblx0XHRfZm5EZWxldGVJbmRleDogX2ZuRGVsZXRlSW5kZXgsXG5cdFx0X2ZuSW52YWxpZGF0ZTogX2ZuSW52YWxpZGF0ZSxcblx0XHRfZm5HZXRSb3dFbGVtZW50czogX2ZuR2V0Um93RWxlbWVudHMsXG5cdFx0X2ZuQ3JlYXRlVHI6IF9mbkNyZWF0ZVRyLFxuXHRcdF9mbkJ1aWxkSGVhZDogX2ZuQnVpbGRIZWFkLFxuXHRcdF9mbkRyYXdIZWFkOiBfZm5EcmF3SGVhZCxcblx0XHRfZm5EcmF3OiBfZm5EcmF3LFxuXHRcdF9mblJlRHJhdzogX2ZuUmVEcmF3LFxuXHRcdF9mbkFkZE9wdGlvbnNIdG1sOiBfZm5BZGRPcHRpb25zSHRtbCxcblx0XHRfZm5EZXRlY3RIZWFkZXI6IF9mbkRldGVjdEhlYWRlcixcblx0XHRfZm5HZXRVbmlxdWVUaHM6IF9mbkdldFVuaXF1ZVRocyxcblx0XHRfZm5GZWF0dXJlSHRtbEZpbHRlcjogX2ZuRmVhdHVyZUh0bWxGaWx0ZXIsXG5cdFx0X2ZuRmlsdGVyQ29tcGxldGU6IF9mbkZpbHRlckNvbXBsZXRlLFxuXHRcdF9mbkZpbHRlckN1c3RvbTogX2ZuRmlsdGVyQ3VzdG9tLFxuXHRcdF9mbkZpbHRlckNvbHVtbjogX2ZuRmlsdGVyQ29sdW1uLFxuXHRcdF9mbkZpbHRlcjogX2ZuRmlsdGVyLFxuXHRcdF9mbkZpbHRlckNyZWF0ZVNlYXJjaDogX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoLFxuXHRcdF9mbkVzY2FwZVJlZ2V4OiBfZm5Fc2NhcGVSZWdleCxcblx0XHRfZm5GaWx0ZXJEYXRhOiBfZm5GaWx0ZXJEYXRhLFxuXHRcdF9mbkZlYXR1cmVIdG1sSW5mbzogX2ZuRmVhdHVyZUh0bWxJbmZvLFxuXHRcdF9mblVwZGF0ZUluZm86IF9mblVwZGF0ZUluZm8sXG5cdFx0X2ZuSW5mb01hY3JvczogX2ZuSW5mb01hY3Jvcyxcblx0XHRfZm5Jbml0aWFsaXNlOiBfZm5Jbml0aWFsaXNlLFxuXHRcdF9mbkluaXRDb21wbGV0ZTogX2ZuSW5pdENvbXBsZXRlLFxuXHRcdF9mbkxlbmd0aENoYW5nZTogX2ZuTGVuZ3RoQ2hhbmdlLFxuXHRcdF9mbkZlYXR1cmVIdG1sTGVuZ3RoOiBfZm5GZWF0dXJlSHRtbExlbmd0aCxcblx0XHRfZm5GZWF0dXJlSHRtbFBhZ2luYXRlOiBfZm5GZWF0dXJlSHRtbFBhZ2luYXRlLFxuXHRcdF9mblBhZ2VDaGFuZ2U6IF9mblBhZ2VDaGFuZ2UsXG5cdFx0X2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nOiBfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmcsXG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXk6IF9mblByb2Nlc3NpbmdEaXNwbGF5LFxuXHRcdF9mbkZlYXR1cmVIdG1sVGFibGU6IF9mbkZlYXR1cmVIdG1sVGFibGUsXG5cdFx0X2ZuU2Nyb2xsRHJhdzogX2ZuU2Nyb2xsRHJhdyxcblx0XHRfZm5BcHBseVRvQ2hpbGRyZW46IF9mbkFwcGx5VG9DaGlsZHJlbixcblx0XHRfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHM6IF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyxcblx0XHRfZm5UaHJvdHRsZTogX2ZuVGhyb3R0bGUsXG5cdFx0X2ZuQ29udmVydFRvV2lkdGg6IF9mbkNvbnZlcnRUb1dpZHRoLFxuXHRcdF9mbkdldFdpZGVzdE5vZGU6IF9mbkdldFdpZGVzdE5vZGUsXG5cdFx0X2ZuR2V0TWF4TGVuU3RyaW5nOiBfZm5HZXRNYXhMZW5TdHJpbmcsXG5cdFx0X2ZuU3RyaW5nVG9Dc3M6IF9mblN0cmluZ1RvQ3NzLFxuXHRcdF9mblNvcnRGbGF0dGVuOiBfZm5Tb3J0RmxhdHRlbixcblx0XHRfZm5Tb3J0OiBfZm5Tb3J0LFxuXHRcdF9mblNvcnRBcmlhOiBfZm5Tb3J0QXJpYSxcblx0XHRfZm5Tb3J0TGlzdGVuZXI6IF9mblNvcnRMaXN0ZW5lcixcblx0XHRfZm5Tb3J0QXR0YWNoTGlzdGVuZXI6IF9mblNvcnRBdHRhY2hMaXN0ZW5lcixcblx0XHRfZm5Tb3J0aW5nQ2xhc3NlczogX2ZuU29ydGluZ0NsYXNzZXMsXG5cdFx0X2ZuU29ydERhdGE6IF9mblNvcnREYXRhLFxuXHRcdF9mblNhdmVTdGF0ZTogX2ZuU2F2ZVN0YXRlLFxuXHRcdF9mbkxvYWRTdGF0ZTogX2ZuTG9hZFN0YXRlLFxuXHRcdF9mblNldHRpbmdzRnJvbU5vZGU6IF9mblNldHRpbmdzRnJvbU5vZGUsXG5cdFx0X2ZuTG9nOiBfZm5Mb2csXG5cdFx0X2ZuTWFwOiBfZm5NYXAsXG5cdFx0X2ZuQmluZEFjdGlvbjogX2ZuQmluZEFjdGlvbixcblx0XHRfZm5DYWxsYmFja1JlZzogX2ZuQ2FsbGJhY2tSZWcsXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlOiBfZm5DYWxsYmFja0ZpcmUsXG5cdFx0X2ZuTGVuZ3RoT3ZlcmZsb3c6IF9mbkxlbmd0aE92ZXJmbG93LFxuXHRcdF9mblJlbmRlcmVyOiBfZm5SZW5kZXJlcixcblx0XHRfZm5EYXRhU291cmNlOiBfZm5EYXRhU291cmNlLFxuXHRcdF9mblJvd0F0dHJpYnV0ZXM6IF9mblJvd0F0dHJpYnV0ZXMsXG5cdFx0X2ZuQ2FsY3VsYXRlRW5kOiBmdW5jdGlvbiAoKSB7fSAvLyBVc2VkIGJ5IGEgbG90IG9mIHBsdWctaW5zLCBidXQgcmVkdW5kYW50XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiAxLjEwLCBzbyB0aGlzIGRlYWQtZW5kIGZ1bmN0aW9uIGlzXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRlZCB0byBwcmV2ZW50IGVycm9yc1xuXHR9ICk7XG5cdFxuXG5cdC8vIGpRdWVyeSBhY2Nlc3Ncblx0JC5mbi5kYXRhVGFibGUgPSBEYXRhVGFibGU7XG5cblx0Ly8gUHJvdmlkZSBhY2Nlc3MgdG8gdGhlIGhvc3QgalF1ZXJ5IG9iamVjdCAoY2lyY3VsYXIgcmVmZXJlbmNlKVxuXHREYXRhVGFibGUuJCA9ICQ7XG5cblx0Ly8gTGVnYWN5IGFsaWFzZXNcblx0JC5mbi5kYXRhVGFibGVTZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcblx0JC5mbi5kYXRhVGFibGVFeHQgPSBEYXRhVGFibGUuZXh0O1xuXG5cdC8vIFdpdGggYSBjYXBpdGFsIGBEYCB3ZSByZXR1cm4gYSBEYXRhVGFibGVzIEFQSSBpbnN0YW5jZSByYXRoZXIgdGhhbiBhXG5cdC8vIGpRdWVyeSBvYmplY3Rcblx0JC5mbi5EYXRhVGFibGUgPSBmdW5jdGlvbiAoIG9wdHMgKSB7XG5cdFx0cmV0dXJuICQodGhpcykuZGF0YVRhYmxlKCBvcHRzICkuYXBpKCk7XG5cdH07XG5cblx0Ly8gQWxsIHByb3BlcnRpZXMgdGhhdCBhcmUgYXZhaWxhYmxlIHRvICQuZm4uZGF0YVRhYmxlIHNob3VsZCBhbHNvIGJlXG5cdC8vIGF2YWlsYWJsZSBvbiAkLmZuLkRhdGFUYWJsZVxuXHQkLmVhY2goIERhdGFUYWJsZSwgZnVuY3Rpb24gKCBwcm9wLCB2YWwgKSB7XG5cdFx0JC5mbi5EYXRhVGFibGVbIHByb3AgXSA9IHZhbDtcblx0fSApO1xuXG5cblx0Ly8gSW5mb3JtYXRpb24gYWJvdXQgZXZlbnRzIGZpcmVkIGJ5IERhdGFUYWJsZXMgLSBmb3IgZG9jdW1lbnRhdGlvbi5cblx0LyoqXG5cdCAqIERyYXcgZXZlbnQsIGZpcmVkIHdoZW5ldmVyIHRoZSB0YWJsZSBpcyByZWRyYXduIG9uIHRoZSBwYWdlLCBhdCB0aGUgc2FtZVxuXHQgKiBwb2ludCBhcyBmbkRyYXdDYWxsYmFjay4gVGhpcyBtYXkgYmUgdXNlZnVsIGZvciBiaW5kaW5nIGV2ZW50cyBvclxuXHQgKiBwZXJmb3JtaW5nIGNhbGN1bGF0aW9ucyB3aGVuIHRoZSB0YWJsZSBpcyBhbHRlcmVkIGF0IGFsbC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNkcmF3LmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKi9cblxuXHQvKipcblx0ICogU2VhcmNoIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBzZWFyY2hpbmcgYXBwbGllZCB0byB0aGUgdGFibGUgKHVzaW5nIHRoZVxuXHQgKiBidWlsdC1pbiBnbG9iYWwgc2VhcmNoLCBvciBjb2x1bW4gZmlsdGVycykgaXMgYWx0ZXJlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNzZWFyY2guZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBQYWdlIGNoYW5nZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgcGFnaW5nIG9mIHRoZSB0YWJsZSBpcyBhbHRlcmVkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3BhZ2UuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBPcmRlciBldmVudCwgZmlyZWQgd2hlbiB0aGUgb3JkZXJpbmcgYXBwbGllZCB0byB0aGUgdGFibGUgaXMgYWx0ZXJlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNvcmRlci5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgaW5pdGlhbGlzYXRpb24gY29tcGxldGUgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHRhYmxlIGlzIGZ1bGx5XG5cdCAqIGRyYXduLCBpbmNsdWRpbmcgQWpheCBkYXRhIGxvYWRlZCwgaWYgQWpheCBkYXRhIGlzIHJlcXVpcmVkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI2luaXQuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgSlNPTiBvYmplY3QgcmVxdWVzdCBmcm9tIHRoZSBzZXJ2ZXIgLSBvbmx5XG5cdCAqICAgIHByZXNlbnQgaWYgY2xpZW50LXNpZGUgQWpheCBzb3VyY2VkIGRhdGEgaXMgdXNlZDwvbGk+PC9vbD5cblx0ICovXG5cblx0LyoqXG5cdCAqIFN0YXRlIHNhdmUgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHRhYmxlIGhhcyBjaGFuZ2VkIHN0YXRlIGEgbmV3IHN0YXRlIHNhdmVcblx0ICogaXMgcmVxdWlyZWQuIFRoaXMgZXZlbnQgYWxsb3dzIG1vZGlmaWNhdGlvbiBvZiB0aGUgc3RhdGUgc2F2aW5nIG9iamVjdFxuXHQgKiBwcmlvciB0byBhY3R1YWxseSBkb2luZyB0aGUgc2F2ZSwgaW5jbHVkaW5nIGFkZGl0aW9uIG9yIG90aGVyIHN0YXRlXG5cdCAqIHByb3BlcnRpZXMgKGZvciBwbHVnLWlucykgb3IgbW9kaWZpY2F0aW9uIG9mIGEgRGF0YVRhYmxlcyBjb3JlIHByb3BlcnR5LlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3N0YXRlU2F2ZVBhcmFtcy5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBzdGF0ZSBpbmZvcm1hdGlvbiB0byBiZSBzYXZlZFxuXHQgKi9cblxuXHQvKipcblx0ICogU3RhdGUgbG9hZCBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaXMgbG9hZGluZyBzdGF0ZSBmcm9tIHRoZSBzdG9yZWRcblx0ICogZGF0YSwgYnV0IHByaW9yIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgYmVpbmcgbW9kaWZpZWQgYnkgdGhlIHNhdmVkIHN0YXRlXG5cdCAqIC0gYWxsb3dpbmcgbW9kaWZpY2F0aW9uIG9mIHRoZSBzYXZlZCBzdGF0ZSBpcyByZXF1aXJlZCBvciBsb2FkaW5nIG9mXG5cdCAqIHN0YXRlIGZvciBhIHBsdWctaW4uXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVMb2FkUGFyYW1zLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIHNhdmVkIHN0YXRlIGluZm9ybWF0aW9uXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTdGF0ZSBsb2FkZWQgZXZlbnQsIGZpcmVkIHdoZW4gc3RhdGUgaGFzIGJlZW4gbG9hZGVkIGZyb20gc3RvcmVkIGRhdGEgYW5kXG5cdCAqIHRoZSBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gbW9kaWZpZWQgYnkgdGhlIGxvYWRlZCBkYXRhLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3N0YXRlTG9hZGVkLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIHNhdmVkIHN0YXRlIGluZm9ybWF0aW9uXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBQcm9jZXNzaW5nIGV2ZW50LCBmaXJlZCB3aGVuIERhdGFUYWJsZXMgaXMgZG9pbmcgc29tZSBraW5kIG9mIHByb2Nlc3Npbmdcblx0ICogKGJlIGl0LCBvcmRlciwgc2VhcmNnIG9yIGFueXRoaW5nIGVsc2UpLiBJdCBjYW4gYmUgdXNlZCB0byBpbmRpY2F0ZSB0b1xuXHQgKiB0aGUgZW5kIHVzZXIgdGhhdCB0aGVyZSBpcyBzb21ldGhpbmcgaGFwcGVuaW5nLCBvciB0aGF0IHNvbWV0aGluZyBoYXNcblx0ICogZmluaXNoZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjcHJvY2Vzc2luZy5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gYlNob3cgRmxhZyBmb3IgaWYgRGF0YVRhYmxlcyBpcyBkb2luZyBwcm9jZXNzaW5nIG9yIG5vdFxuXHQgKi9cblxuXHQvKipcblx0ICogQWpheCAoWEhSKSBldmVudCwgZmlyZWQgd2hlbmV2ZXIgYW4gQWpheCByZXF1ZXN0IGlzIGNvbXBsZXRlZCBmcm9tIGFcblx0ICogcmVxdWVzdCB0byBtYWRlIHRvIHRoZSBzZXJ2ZXIgZm9yIG5ldyBkYXRhLiBUaGlzIGV2ZW50IGlzIGNhbGxlZCBiZWZvcmVcblx0ICogRGF0YVRhYmxlcyBwcm9jZXNzZWQgdGhlIHJldHVybmVkIGRhdGEsIHNvIGl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJlLVxuXHQgKiBwcm9jZXNzIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciwgaWYgbmVlZGVkLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyB0cmlnZ2VyIGlzIGNhbGxlZCBpbiBgZm5TZXJ2ZXJEYXRhYCwgaWYgeW91IG92ZXJyaWRlXG5cdCAqIGBmblNlcnZlckRhdGFgIGFuZCB3aGljaCB0byB1c2UgdGhpcyBldmVudCwgeW91IG5lZWQgdG8gdHJpZ2dlciBpdCBpbiB5b3Vcblx0ICogc3VjY2VzcyBmdW5jdGlvbi5cblx0ICogIEBuYW1lIERhdGFUYWJsZSN4aHIuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgIC8vIFVzZSBhIGN1c3RvbSBwcm9wZXJ0eSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgaW4gYW5vdGhlciBET00gZWxlbWVudFxuXHQgKiAgICAgJCgnI3RhYmxlJykuZGF0YVRhYmxlKCkub24oJ3hoci5kdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywganNvbikge1xuXHQgKiAgICAgICAkKCcjc3RhdHVzJykuaHRtbCgganNvbi5zdGF0dXMgKTtcblx0ICogICAgIH0gKTtcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICAvLyBQcmUtcHJvY2VzcyB0aGUgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXJcblx0ICogICAgICQoJyN0YWJsZScpLmRhdGFUYWJsZSgpLm9uKCd4aHIuZHQnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGpzb24pIHtcblx0ICogICAgICAgZm9yICggdmFyIGk9MCwgaWVuPWpzb24uYWFEYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHQgKiAgICAgICAgIGpzb24uYWFEYXRhW2ldLnN1bSA9IGpzb24uYWFEYXRhW2ldLm9uZSArIGpzb24uYWFEYXRhW2ldLnR3bztcblx0ICogICAgICAgfVxuXHQgKiAgICAgICAvLyBOb3RlIG5vIHJldHVybiAtIG1hbmlwdWxhdGUgdGhlIGRhdGEgZGlyZWN0bHkgaW4gdGhlIEpTT04gb2JqZWN0LlxuXHQgKiAgICAgfSApO1xuXHQgKi9cblxuXHQvKipcblx0ICogRGVzdHJveSBldmVudCwgZmlyZWQgd2hlbiB0aGUgRGF0YVRhYmxlIGlzIGRlc3Ryb3llZCBieSBjYWxsaW5nIGZuRGVzdHJveVxuXHQgKiBvciBwYXNzaW5nIHRoZSBiRGVzdHJveTp0cnVlIHBhcmFtZXRlciBpbiB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0LiBUaGlzXG5cdCAqIGNhbiBiZSB1c2VkIHRvIHJlbW92ZSBib3VuZCBldmVudHMsIGFkZGVkIERPTSBub2RlcywgZXRjLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI2Rlc3Ryb3kuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBQYWdlIGxlbmd0aCBjaGFuZ2UgZXZlbnQsIGZpcmVkIHdoZW4gbnVtYmVyIG9mIHJlY29yZHMgdG8gc2hvdyBvbiBlYWNoXG5cdCAqIHBhZ2UgKHRoZSBsZW5ndGgpIGlzIGNoYW5nZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjbGVuZ3RoLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKiAgQHBhcmFtIHtpbnRlZ2VyfSBsZW4gTmV3IGxlbmd0aFxuXHQgKi9cblxuXHQvKipcblx0ICogQ29sdW1uIHNpemluZyBoYXMgY2hhbmdlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNjb2x1bW4tc2l6aW5nLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKi9cblxuXHQvKipcblx0ICogQ29sdW1uIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjY29sdW1uLXZpc2liaWxpdHkuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqICBAcGFyYW0ge2ludH0gY29sdW1uIENvbHVtbiBpbmRleFxuXHQgKiAgQHBhcmFtIHtib29sfSB2aXMgYGZhbHNlYCBpZiBjb2x1bW4gbm93IGhpZGRlbiwgb3IgYHRydWVgIGlmIHZpc2libGVcblx0ICovXG5cblx0cmV0dXJuICQuZm4uZGF0YVRhYmxlO1xufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9kYXRhdGFibGVzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==