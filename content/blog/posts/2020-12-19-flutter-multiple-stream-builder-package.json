{
  "title": "Flutter Multiple Stream Builder Package",
  "published": true,
  "date": "2020-12-19T00:01:00-06:00",
  "description": "Flutter widgets for avoiding nested StreamBuilder",
  "body": "\nWhen working with Flutter I find myself working with streams quite a bit. They're a great way to allow various parts of your app to be notified when data changes and keep things reactive. \n\nFlutter even provides a built-in widget for working with streams called `StreamBuilder`. This widget allows you to pass in a stream along with a builder method that will get called every time a the stream receives new data. Here's a quick example on how to use a StreamBuilder:\n\n```dart\nvar stream1 = Stream<int>.periodic(Duration(seconds: 1));\n\nWidget build(BuildContext context) {\n  return StreamBuilder<int>(\n    stream: stream,\n    builder: (context, snapshot) {\n      return Text('value: ${snapshot.data}');\n    },\n  );\n}\n```\n\nFor the most part StreamBuilder works really well. That is until you need values from multiple stream in order to build your UI. In that case you have to resort to nesting StreamBuilders. Which, depending on how complicated your build method is can get a bit ugly. \n\n```dart\nvar stream1 = Stream<int>.periodic(Duration(seconds: 1));\nvar stream2 = Stream<int>.periodic(Duration(seconds: 2));\nvar stream3 = Stream<int>.periodic(Duration(seconds: 3));\n\nWidget build(BuildContext context) {\n  return StreamBuilder<int>(\n    stream: stream1,\n    builder: (context, snapshot1) {\n      return StreamBuilder<int>(\n        stream: stream2,\n        builder: (context, snapshot2) {\n          return StreamBuilder<int>(\n            stream: stream3,\n            builder: (context, snapshot3) {\n              return Text(\n                'stream1: ${snapshot1.data} - stream2: ${snapshot2.data} - stream3: ${snapshot3.data}',\n              );\n            },\n          );\n        },\n      );\n    },\n  );\n}\n```\n\nSo how can we clean this up? Let me introduce a package I published called [`multiple_stream_builder`](https://pub.dev/packages/multiple_stream_builder).\nThis package provides new widgets that behave almost the same as a normal StreamBuilder, but it allows you to pass in multiple streams instead of just one.\n\n```dart\nWidget build(BuildContext context) {\n  return StreamBuilder3<int, int, int>(\n    streams: Tuple3(stream1, stream2, stream3),\n    builder: (context, snapshots) {\n      return Text(\n        'stream1: ${snapshots.item1.data} - stream2: ${snapshots.item2.data} - stream3: ${snapshots.item3.data}',\n      );\n    },\n  );\n}\n```\n\nAs you can see this greatly shortens the amount of code we have to add as well as reduces the amount of nesting we need. \n\nDue to some [technical limitations with the Dart language](https://github.com/dart-lang/language/issues/363) you have to use a different StreamBuilder depending on the number of streams you want to pass in. For example, if you need data from 4 streams you'd use `StreamBuilder4` while you'd use `StreamBuilder2` for 2 streams.\n\nAnother thing to note is since Dart doesn't have native support for tuples this package uses a Dart library from Google, called tuple, to pass in your streams. This allows Dart to type check the streams your passing in which will prevent you from accidentally forgetting to pass a stream in or mixing up the order.\n\nIf you want to get started using the package you can see the installation instructions on the [packages pub.dev page](https://pub.dev/packages/multiple_stream_builder). If you run into any issues with the package or would like to suggest a feature feel free to open an issue on the [Github repo](https://github.com/glitchedmob/flutter_multiple_stream_builder)."
}